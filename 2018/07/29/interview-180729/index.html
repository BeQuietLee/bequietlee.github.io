<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>面试知识整理 2018.07.29 | 柘个角落 | IF YOU WANT SOMETHING, GO GET IT. PERIOD.</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="Android,面试">
    <meta name="description" content="有什么手段可以减少APK体积要回答这个问题，首先需要了解APK体积增大的原因，我们从这张经典的APK构建流程图开始分析。                                                                                              apk_build              可以看到最终生成的 APK 里面，主要包含三部">
<meta name="keywords" content="Android,面试">
<meta property="og:type" content="article">
<meta property="og:title" content="面试知识整理 2018.07.29">
<meta property="og:url" content="https://lilei.pro/2018/07/29/interview-180729/index.html">
<meta property="og:site_name" content="柘个角落">
<meta property="og:description" content="有什么手段可以减少APK体积要回答这个问题，首先需要了解APK体积增大的原因，我们从这张经典的APK构建流程图开始分析。                                                                                              apk_build              可以看到最终生成的 APK 里面，主要包含三部">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://lilei.pro/img/190608_interview/apk_build.jpg">
<meta property="og:image" content="https://lilei.pro/img/190608_interview/unused_res.png">
<meta property="og:image" content="https://github.githubassets.com/images/icons/emoji/unicode/1f424.png">
<meta property="og:image" content="https://lilei.pro/img/190608_interview/leakcanary整体流程.jpg">
<meta property="og:image" content="https://lilei.pro/img/190608_interview/类加载过程.jpg">
<meta property="og:updated_time" content="2019-06-12T22:50:27.665Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="面试知识整理 2018.07.29">
<meta name="twitter:description" content="有什么手段可以减少APK体积要回答这个问题，首先需要了解APK体积增大的原因，我们从这张经典的APK构建流程图开始分析。                                                                                              apk_build              可以看到最终生成的 APK 里面，主要包含三部">
<meta name="twitter:image" content="https://lilei.pro/img/190608_interview/apk_build.jpg">
    
        <link rel="alternate" type="application/atom+xml" title="柘个角落" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpeg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Li Lei</h5>
          <a href="mailto:bequietlee#gmail.com" title="bequietlee#gmail.com" class="mail">bequietlee#gmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                文章
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/bequietlee" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/2019/03/10/links"  >
                <i class="icon icon-lg icon-link"></i>
                友情链接
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">面试知识整理 2018.07.29</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">面试知识整理 2018.07.29</h1>
        <h5 class="subtitle">
            
                <time datetime="2018-07-29T04:48:48.000Z" itemprop="datePublished" class="page-time">
  2018-07-29
</time>


            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#有什么手段可以减少APK体积"><span class="post-toc-number">1.</span> <span class="post-toc-text">有什么手段可以减少APK体积</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#dex-文件"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">dex 文件</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#开启-Proguard"><span class="post-toc-number">1.1.1.</span> <span class="post-toc-text">开启 Proguard</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#选择较小的适用于移动平台的第三方类库"><span class="post-toc-number">1.1.2.</span> <span class="post-toc-text">选择较小的适用于移动平台的第三方类库</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#定制第三方库"><span class="post-toc-number">1.1.3.</span> <span class="post-toc-text">定制第三方库</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#资源文件"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">资源文件</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#压缩大小"><span class="post-toc-number">1.2.1.</span> <span class="post-toc-text">压缩大小</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#使用更易扩展的图片格式"><span class="post-toc-number">1.2.2.</span> <span class="post-toc-text">使用更易扩展的图片格式</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#使用-WebP-格式"><span class="post-toc-number">1.2.3.</span> <span class="post-toc-text">使用 WebP 格式</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#用代码代替图片"><span class="post-toc-number">1.2.4.</span> <span class="post-toc-text">用代码代替图片</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#删除不再使用的资源文件"><span class="post-toc-number">1.2.5.</span> <span class="post-toc-text">删除不再使用的资源文件</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#放弃一些图片资源"><span class="post-toc-number">1.2.6.</span> <span class="post-toc-text">放弃一些图片资源</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#so-文件"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">so 文件</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#使用兼容指令集"><span class="post-toc-number">1.3.1.</span> <span class="post-toc-text">使用兼容指令集</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#去除完全用不到的指令集文件"><span class="post-toc-number">1.3.2.</span> <span class="post-toc-text">去除完全用不到的指令集文件</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#其它手段"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">其它手段</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#插件化"><span class="post-toc-number">1.4.1.</span> <span class="post-toc-text">插件化</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#APK-分割"><span class="post-toc-number">1.4.2.</span> <span class="post-toc-text">APK 分割</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#模块化"><span class="post-toc-number">2.</span> <span class="post-toc-text">模块化</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#插件化-1"><span class="post-toc-number">3.</span> <span class="post-toc-text">插件化</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#GET-和-POST-区别"><span class="post-toc-number">4.</span> <span class="post-toc-text">GET 和 POST 区别</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#本质上无区别"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">本质上无区别</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#是否可以互换"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">是否可以互换</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#其它一些补充"><span class="post-toc-number">4.3.</span> <span class="post-toc-text">其它一些补充</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#LeakCanary-检查内存泄漏的原理"><span class="post-toc-number">5.</span> <span class="post-toc-text">LeakCanary 检查内存泄漏的原理</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#背景知识"><span class="post-toc-number">5.1.</span> <span class="post-toc-text">背景知识</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#基本原理"><span class="post-toc-number">5.2.</span> <span class="post-toc-text">基本原理</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#源码分析"><span class="post-toc-number">5.3.</span> <span class="post-toc-text">源码分析</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#整体流程"><span class="post-toc-number">5.3.1.</span> <span class="post-toc-text">整体流程</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#入口"><span class="post-toc-number">5.3.2.</span> <span class="post-toc-text">入口</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#监听"><span class="post-toc-number">5.3.3.</span> <span class="post-toc-text">监听</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#监测-Fragment-泄漏"><span class="post-toc-number">5.3.3.1.</span> <span class="post-toc-text">监测 Fragment 泄漏</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#ensureGone"><span class="post-toc-number">5.3.4.</span> <span class="post-toc-text">ensureGone</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#分析"><span class="post-toc-number">5.3.5.</span> <span class="post-toc-text">分析</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#HeapAnalyzerService"><span class="post-toc-number">5.3.5.1.</span> <span class="post-toc-text">HeapAnalyzerService</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#参考"><span class="post-toc-number">5.4.</span> <span class="post-toc-text">参考</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#创建一个对象时内部流程"><span class="post-toc-number">6.</span> <span class="post-toc-text">创建一个对象时内部流程</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#类的加载过程"><span class="post-toc-number">6.1.</span> <span class="post-toc-text">类的加载过程</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-加载"><span class="post-toc-number">6.1.1.</span> <span class="post-toc-text">1. 加载</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-验证"><span class="post-toc-number">6.1.2.</span> <span class="post-toc-text">2. 验证</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-准备"><span class="post-toc-number">6.1.3.</span> <span class="post-toc-text">3. 准备</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-解析"><span class="post-toc-number">6.1.4.</span> <span class="post-toc-text">4. 解析</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-初始化（父父子子）"><span class="post-toc-number">6.1.5.</span> <span class="post-toc-text">5. 初始化（父父子子）</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#对象创建过程"><span class="post-toc-number">6.2.</span> <span class="post-toc-text">对象创建过程</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-在堆区分配对象需要的内存"><span class="post-toc-number">6.2.1.</span> <span class="post-toc-text">1. 在堆区分配对象需要的内存</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-为实例变量赋默认值"><span class="post-toc-number">6.2.2.</span> <span class="post-toc-text">2. 为实例变量赋默认值</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-执行实例初始化代码"><span class="post-toc-number">6.2.3.</span> <span class="post-toc-text">3. 执行实例初始化代码</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#虚方法表"><span class="post-toc-number">6.3.</span> <span class="post-toc-text">虚方法表</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Demo"><span class="post-toc-number">6.4.</span> <span class="post-toc-text">Demo</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#实例初始化不一定要在类初始化结束之后才开始初始化"><span class="post-toc-number">6.4.1.</span> <span class="post-toc-text">实例初始化不一定要在类初始化结束之后才开始初始化</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#一道测验题"><span class="post-toc-number">6.4.2.</span> <span class="post-toc-text">一道测验题</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#另一道测验题"><span class="post-toc-number">6.4.3.</span> <span class="post-toc-text">另一道测验题</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#参考-1"><span class="post-toc-number">6.5.</span> <span class="post-toc-text">参考</span></a></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-interview-180729"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">面试知识整理 2018.07.29</h1>
        <div class="post-meta">
            <time class="post-time" title="2018-07-29 12:48:48" datetime="2018-07-29T04:48:48.000Z"  itemprop="datePublished">2018-07-29</time>

            


            

        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h1 id="有什么手段可以减少APK体积"><a href="#有什么手段可以减少APK体积" class="headerlink" title="有什么手段可以减少APK体积"></a>有什么手段可以减少APK体积</h1><p>要回答这个问题，首先需要了解APK体积增大的原因，我们从这张经典的APK构建流程图开始分析。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/190608_interview/apk_build.jpg" alt="apk_build" title="">
                </div>
                <div class="image-caption">apk_build</div>
            </figure>
<p>可以看到最终生成的 APK 里面，主要包含三部分内容：Java 源码编译出来的<code>.dex</code>文件，编译后的资源文件 &amp; 未经编译的<code>assets</code>目录，以及一些经 NDK 编译后生成的<code>.so</code>文件。下面针对这三方面给出优化的建议。</p>
<h2 id="dex-文件"><a href="#dex-文件" class="headerlink" title="dex 文件"></a>dex 文件</h2><p>dex 文件包含了所有 Java 类编译出来类文件。从“数量”与“质量”两方面入手，我们可以削减类的数目，还可以减少类文件的大小。</p>
<h3 id="开启-Proguard"><a href="#开启-Proguard" class="headerlink" title="开启 Proguard"></a>开启 Proguard</h3><p>这样可以在打包时去除没有使用到的类，以及缩短类和字段、方法的命名，从而减少 class 文件大小。需要注意的是，把要保留命名（比如反射）的类 keep 住。对于混淆后打包出来的 APK 应当进行充分的回归测试。</p>
<h3 id="选择较小的适用于移动平台的第三方类库"><a href="#选择较小的适用于移动平台的第三方类库" class="headerlink" title="选择较小的适用于移动平台的第三方类库"></a>选择较小的适用于移动平台的第三方类库</h3><p>既可以减少了包体 size，也能减少方法数，从而避免 65535 问题。比如在接入 JSON 解析库时，比较常见的几种类库有：Gson（2.8.5，235Kb）、Jackson（2.9.5，三个 Jar，共 1.7Mb）、Fastjson（1.2.47，533Kb），在满足需求的前提下选择包体最小的 Gson。</p>
<h3 id="定制第三方库"><a href="#定制第三方库" class="headerlink" title="定制第三方库"></a>定制第三方库</h3><p>对于开源的第三方库，如果项目里只用到其中 10% 甚至更少的功能，不妨仅将用到的源码拷贝至自己项目里，而不是通过 gradle 完整引入。</p>
<h2 id="资源文件"><a href="#资源文件" class="headerlink" title="资源文件"></a>资源文件</h2><p>主要是图片、音视频等，处理不当的话一张图片可能就会增加 1Mb 的体积，因此必须谨慎对待资源文件，不要不加考虑地全盘接受设计师给出的切图。</p>
<h3 id="压缩大小"><a href="#压缩大小" class="headerlink" title="压缩大小"></a>压缩大小</h3><p>大部分 png 图片是可以压缩的，你可以使用<a href="https://compresspng.com/" target="_blank" rel="noopener">https://compresspng.com/</a>在线进行压缩。对于音视频，也要在保证效果的前提下，尽量缩减体积。</p>
<h3 id="使用更易扩展的图片格式"><a href="#使用更易扩展的图片格式" class="headerlink" title="使用更易扩展的图片格式"></a>使用更易扩展的图片格式</h3><p>使用矢量图、.9 图代替高清切图，尤其是规则形状的背景、边框图片等。</p>
<h3 id="使用-WebP-格式"><a href="#使用-WebP-格式" class="headerlink" title="使用 WebP 格式"></a>使用 WebP 格式</h3><p>WebP格式是有损压缩（像JPEG）且有透明通道（像PNG），且压缩率高于JPEG或PNG。在Android Studio中，能将BMP，JPG，PNG或者静态GIF图片转换成WebP格式。</p>
<p>使用WebP文件格式也有一些缺点。第一，低于Android 3.2的版本不支持WebP，第二，WebP的解码时间比PNG长。</p>
<h3 id="用代码代替图片"><a href="#用代码代替图片" class="headerlink" title="用代码代替图片"></a>用代码代替图片</h3><p>使用属性动画，而非帧动画。帧动画通常需要多张图片组合才能进行播放，此时通过代码实现缩放、旋转等动画是更好的选择；用 RotateDrawable 代替仅仅是方向不同的“内容相同”的图片；用 layer-list 来制作多层图片从而达到复用。</p>
<h3 id="删除不再使用的资源文件"><a href="#删除不再使用的资源文件" class="headerlink" title="删除不再使用的资源文件"></a>删除不再使用的资源文件</h3><p>随着版本迭代，一些旧日需求引入的资源文件将不再使用，此时应当将它们删除。Android Studio 自带的 Lint 工具可以帮我们完成这件事。在 AS 的菜单中选择 Analyze -&gt; Inspect Code。分析需要一定时间，待分析完成后会在窗口展示结果。其中 Unused resources 即是未使用到的资源文件。</p>
<p>不要忘了清理 assets 文件夹下不再使用的文件。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/190608_interview/unused_res.png" alt="unused_res" title="">
                </div>
                <div class="image-caption">unused_res</div>
            </figure>
<p>删除资源是根治的方法，如果你想偷点懒，可以通过 shrinkResources 属性让编译器打包时自动剔除不再使用的资源，该属性需要与 proguard 同时开启。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">buildTypes &#123;</span><br><span class="line">     release &#123;</span><br><span class="line">          minifyEnabled <span class="keyword">true</span></span><br><span class="line">          shrinkResources <span class="keyword">true</span></span><br><span class="line">          proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果想看看在激活自动缩减资源后 APK 缩减了多少，可以运行 shrinkReleaseResources 任务，这个任务会打印出包的大小缩减了多少。</p>
<p>自动缩减资源有一个问题：它可能移除了过多的资源，特别是那些动态使用的资源肯定会被删除。为了防止这种情况，可以在 res/raw/ 下的 keep.xml 文件中定义这些例外。</p>
<h3 id="放弃一些图片资源"><a href="#放弃一些图片资源" class="headerlink" title="放弃一些图片资源"></a>放弃一些图片资源</h3><p>Android 有 ldpi、mdhi、hdpi、xhdpi、xxhdpi、xxxhdpi 等多种分辨率格式，谨慎的人也许会针对分辨率提供一份切图，但我在这里像你建议，千万别这么做。</p>
<ul>
<li>一方面，Android 系统提供了兼容的处理方案，比如会把 hdpi 的图片缩放到 ldpi 使用。</li>
<li>另一方面，在添加资源文件时应当考虑它所对应机型的占有率。比如绝大部分情况下不需要准备 ldpi 和 xxxhdpi 的图片，前者的手机早已过时，后者则是给 2K 屏幕使用的，目前市面上并不常见，也可以选择忽略。</li>
</ul>
<p>对于第三方 aar 引入的资源文件，也可以指定引入特定分辨率的，通过 gradle 配置实现这一点。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">defaultConfig &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    resConfigs <span class="string">"en"</span>, <span class="string">"de"</span>, <span class="string">"fr"</span>, <span class="string">"it"</span> <span class="comment">// 指定语言</span></span><br><span class="line">    resConfigs <span class="string">"hdpi"</span>, <span class="string">"xhdpi"</span>, <span class="string">"xxhdpi"</span> <span class="comment">// 指定显示密度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="so-文件"><a href="#so-文件" class="headerlink" title="so 文件"></a>so 文件</h2><p>当我们项目里需要使用 NDK 时，会将编译生成的 .so 文件置于项目里面，当你解压一个 APK 时会发现它们的身影。有以下方法可以缩减它们所占的体积。</p>
<h3 id="使用兼容指令集"><a href="#使用兼容指令集" class="headerlink" title="使用兼容指令集"></a>使用兼容指令集</h3><p>处理器的指令集通常是向下兼容的，比如[TODO]的指令集就可以兼容[TODO]，意味着你可以只提供一份[TODO]的 so（但我不建议这么做，因为更高版本的指令集可以提供更高的运行效率）。</p>
<h3 id="去除完全用不到的指令集文件"><a href="#去除完全用不到的指令集文件" class="headerlink" title="去除完全用不到的指令集文件"></a>去除完全用不到的指令集文件</h3><p>比如 x86、x86_64，现在极少手机是使用 x86 的 CPU 架构了，你自然可以去除它们。需要注意的是，如果你想让 APP 在模拟器上运行，仍需要保留它们。</p>
<p>在 gradle 文件的 defaultConfig 域下配置需要的 so：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">defaultConfig &#123;</span><br><span class="line">        <span class="comment">// ... ...</span></span><br><span class="line">        ndk &#123;</span><br><span class="line">            <span class="comment">//设置支持的SO库架构</span></span><br><span class="line">            abiFilters <span class="string">'arm64-v8a'</span>, <span class="string">'armeabi'</span> <span class="comment">//, 'x86', ,'x86_64', 'armeabi-v7a</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="其它手段"><a href="#其它手段" class="headerlink" title="其它手段"></a>其它手段</h2><h3 id="插件化"><a href="#插件化" class="headerlink" title="插件化"></a>插件化</h3><p>插件化技术自 2015 年井喷后，一直是 Android 面试中长盛不衰的面试题。发布 APP 时只发布包含必要功能的宿主，子模块功能以插件的形式下发。也是一个有效降低 APK 体积的方法。但提高了项目的开发难度和维护成本，同时还需要一个成熟的发布后台。</p>
<h3 id="APK-分割"><a href="#APK-分割" class="headerlink" title="APK 分割"></a>APK 分割</h3><p>可以通过在 gradle 配置中定义一个 splits 代码块来配置分割，目前支持 density 分割和 ABI 分割。比如你可以通过配置，在一次打包中生成以下 APK，进而将它们分别发布给不同机型。</p>
<p>density 分割</p>
<ul>
<li>app-hdpi-release.apk</li>
<li>app-universal-release.apk</li>
<li>app-xhdpi-release.apk</li>
<li>app-xxhdpi-release.apk</li>
<li>app-xxxhdpi-release.apk</li>
</ul>
<p>ABI 分割</p>
<ul>
<li>app-armeabi-v7a-debug.apk</li>
<li>app-mips-debug.apk</li>
<li>app-x86-debug.apk</li>
</ul>
<h1 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h1><p>这个 Title 太大，我会单独撰文加以讲解。</p>
<h1 id="插件化-1"><a href="#插件化-1" class="headerlink" title="插件化"></a>插件化</h1><p>这个 Title 太大，我同样会单独撰文加以讲解。上个月刚读完包建强所著的《Android 插件话开发指南》一书，所获颇丰。后面我会将书中的重点内容总结成文字笔记分享在博客里面。</p>
<h1 id="GET-和-POST-区别"><a href="#GET-和-POST-区别" class="headerlink" title="GET 和 POST 区别"></a>GET 和 POST 区别</h1><h2 id="本质上无区别"><a href="#本质上无区别" class="headerlink" title="本质上无区别"></a>本质上无区别</h2><p>首先，GET 和 POST 都是HTTP 协议中发送请求的方法，这两者底层的协议也都是 TCP/IP，这两者并没有本质上的区别。</p>
<p>从底层原理上，<strong>GET 产生了一个 TCP 数据包，POST 产生了两个 TCP 数据包。</strong></p>
<p>对于 GET 请求，浏览器把 HTTP Header 和 Data 一同发送出去，服务器相应 200。</p>
<p>对于 POST 请求，浏览器 先发送 HTTP Header，服务器响应 100（continue），浏览器再发送 Data，服务器响应 200（返回数据）。</p>
<h2 id="是否可以互换"><a href="#是否可以互换" class="headerlink" title="是否可以互换"></a>是否可以互换</h2><p>那么是否可以把所有的 POST 请求都改成 GET，以提高网站相应效率呢？答案是不行。</p>
<ol>
<li>两者具有不同的语义。</li>
<li>在网络环境好的情况下，两次请求与一次请求在响应时间上相差微乎其微；在网络情况差的情况下，两次请求更有助于进行数据完整性校验。</li>
<li>并非所有浏览器在 POST 时都发送两个包，Firefox 就只发送一次。</li>
</ol>
<h2 id="其它一些补充"><a href="#其它一些补充" class="headerlink" title="其它一些补充"></a>其它一些补充</h2><ul>
<li>浏览器回退：GET在浏览器回退时是无害的（幂等性），而POST会再次提交请求。</li>
<li>Bookmark：GET产生的URL地址可以被Bookmark，而POST不可以。</li>
<li>Cache：GET请求会被浏览器主动cache，而POST不会，除非手动设置。</li>
<li>编码：GET请求只能进行url编码，而POST支持多种编码方式。</li>
<li>参数保存：GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li>
<li>参数长度：GET请求在URL中传送的参数是有长度限制的，而POST没有。</li>
<li>参数类型：对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</li>
<li>参数安全：GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li>
<li>参数传递：GET参数通过URL传递，POST放在Request body中。</li>
</ul>
<h1 id="LeakCanary-检查内存泄漏的原理"><a href="#LeakCanary-检查内存泄漏的原理" class="headerlink" title="LeakCanary 检查内存泄漏的原理"></a>LeakCanary 检查内存泄漏的原理</h1><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p>JVM 运行时内存分区，内存模型，垃圾回收算法，GC Roots，强软弱虚引用。</p>
<blockquote>
<p>A small leak will sink a great ship.<br>– Benjamin Franklin</p>
</blockquote>
<p><a href="https://github.com/square/leakcanary" target="_blank" rel="noopener">LeakCanary</a> 是由Square公司开源的内存泄漏检测工具。Logo 是一只小黄鸡。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://github.githubassets.com/images/icons/emoji/unicode/1f424.png" alt="LeakCanaryLogo" title="">
                </div>
                <div class="image-caption">LeakCanaryLogo</div>
            </figure>
<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><ol>
<li>在 Activity.onDestroy 方法里手动触发 GC。</li>
<li>利用 ReferenceQueue + WeakReference 判断是否有未释放的引用。</li>
<li>结合  dump memory 得到的 hprof 文件，利用 <a href="https://github.com/square/haha" target="_blank" rel="noopener">HaHa(Headless Android Heap Analyzer)</a> 分析出泄漏位置。</li>
</ol>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/190608_interview/leakcanary整体流程.jpg" alt="leakcanary整体流程" title="">
                </div>
                <div class="image-caption">leakcanary整体流程</div>
            </figure>
<h3 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h3><p>需要在 Application 类中启用 LeakCanary。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 安装</span></span><br><span class="line"><span class="keyword">if</span> (!LeakCanary.isInAnalyzerProcess(WeiboApplication.<span class="keyword">this</span>)) &#123;</span><br><span class="line">  LeakCanary.install(WeiboApplication.<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// install</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RefWatcher <span class="title">install</span><span class="params">(Application application)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ((AndroidRefWatcherBuilder) refWatcher(application)</span><br><span class="line"> .listenerServiceClass(DisplayLeakService.class).excludedRefs(AndroidExcludedRefs.createAppDefaults().build())) <span class="comment">//配置监听器及分析数据格式</span></span><br><span class="line">  .buildAndInstall();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LeakCanary 会运行在两个进程：App进程中运行监听任务，工作进程中运行分析任务。</p>
<h3 id="监听"><a href="#监听" class="headerlink" title="监听"></a>监听</h3><p>在<code>install</code>方法里，创建了一个<code>RefWatcher</code>对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RefWatcher <span class="title">buildAndInstall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RefWatcher refWatcher = <span class="keyword">this</span>.build();</span><br><span class="line">    <span class="keyword">if</span>(refWatcher != RefWatcher.DISABLED) &#123;</span><br><span class="line">        LeakCanary.enableDisplayLeakActivity(<span class="keyword">this</span>.context);</span><br><span class="line">        ActivityRefWatcher.install((Application)<span class="keyword">this</span>.context, refWatcher);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> refWatcher;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">install</span><span class="params">(Application application, RefWatcher refWatcher)</span> </span>&#123;</span><br><span class="line">    (<span class="keyword">new</span> ActivityRefWatcher(application, refWatcher)).watchActivities();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ActivityLifecycleCallbacks lifecycleCallbacks = <span class="keyword">new</span> ActivityLifecycleCallbacks() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityCreated</span><span class="params">(Activity activity, Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityStarted</span><span class="params">(Activity activity)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityResumed</span><span class="params">(Activity activity)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityPaused</span><span class="params">(Activity activity)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityStopped</span><span class="params">(Activity activity)</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivitySaveInstanceState</span><span class="params">(Activity activity, Bundle outState)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityDestroyed</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">        ActivityRefWatcher.<span class="keyword">this</span>.onActivityDestroyed(activity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onActivityDestroyed</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.refWatcher.watch(activity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LeakCanary 通过<code>Application.registerActivityLifecycleCallbacks</code>方法，注册了 Activity 生命周期的监听，在监测到<code>onDestroyed</code>调用时，触发<code>RefWatcher.watch</code>方法。下面是该方法的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watch</span><span class="params">(Object watchedReference, String referenceName)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> != DISABLED) &#123;</span><br><span class="line">      Preconditions.checkNotNull(watchedReference, <span class="string">"watchedReference"</span>);</span><br><span class="line">      Preconditions.checkNotNull(referenceName, <span class="string">"referenceName"</span>);</span><br><span class="line">      <span class="keyword">long</span> watchStartNanoTime = System.nanoTime();</span><br><span class="line">      String key = UUID.randomUUID().toString();<span class="comment">//保证key的唯一性</span></span><br><span class="line">      <span class="keyword">this</span>.retainedKeys.add(key);</span><br><span class="line">      KeyedWeakReference reference = <span class="keyword">new</span> KeyedWeakReference(watchedReference, key, referenceName, <span class="keyword">this</span>.queue);</span><br><span class="line">      <span class="keyword">this</span>.ensureGoneAsync(watchStartNanoTime, reference);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyedWeakReference</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> String key;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> String name;</span><br><span class="line">  </span><br><span class="line">  KeyedWeakReference(Object referent, String key, String name, ReferenceQueue&lt;Object&gt; referenceQueue) &#123; <span class="comment">//ReferenceQueue类监听回收情况</span></span><br><span class="line">    <span class="keyword">super</span>(Preconditions.checkNotNull(referent, <span class="string">"referent"</span>), (ReferenceQueue)Preconditions.checkNotNull(referenceQueue, <span class="string">"referenceQueue"</span>));</span><br><span class="line">    <span class="keyword">this</span>.key = (String)Preconditions.checkNotNull(key, <span class="string">"key"</span>);</span><br><span class="line">    <span class="keyword">this</span>.name = (String)Preconditions.checkNotNull(name, <span class="string">"name"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureGoneAsync</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> watchStartNanoTime, <span class="keyword">final</span> KeyedWeakReference reference)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.watchExecutor.execute(<span class="keyword">new</span> Retryable() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> RefWatcher.<span class="keyword">this</span>.ensureGone(reference, watchStartNanoTime);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类<code>KeyedWeakReference</code>是<code>WeakReference</code>，这里利用了<code>ReferenceQueue</code>来监听 GC 后的回收情况。<code>ReferenceQueue</code>的原理是，当 GC 检测到对象生命周期结束时，会将其添加到 ReferenceQueue 中。当 GC 过后对象一直不被加入 ReferenceQueue，说明它可能存在内存泄漏。</p>
<p>正是利用 ReferenceQueue 这一特性，LeakCanary 实现了对对象是否被释放的监控。</p>
<h4 id="监测-Fragment-泄漏"><a href="#监测-Fragment-泄漏" class="headerlink" title="监测 Fragment 泄漏"></a>监测 Fragment 泄漏</h4><p>上文中看到只在 Activity.onDestroy 中进行检测，如果需要检测 Fragment 时，应当手动在 Fragment.onDestroy 中创建一个 RefWatcher 对象，并调用 watch 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    RefWatcher refWatcher = ExampleApplication.getRefWatcher(getActivity());</span><br><span class="line">    refWatcher.watch(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ensureGone"><a href="#ensureGone" class="headerlink" title="ensureGone"></a>ensureGone</h3><p>是检测回收的核心代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Result <span class="title">ensureGone</span><span class="params">(KeyedWeakReference reference, <span class="keyword">long</span> watchStartNanoTime)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> gcStartNanoTime = System.nanoTime();</span><br><span class="line">  <span class="keyword">long</span> watchDurationMs = TimeUnit.NANOSECONDS.toMillis(gcStartNanoTime - watchStartNanoTime);</span><br><span class="line">  <span class="keyword">this</span>.removeWeaklyReachableReferences(); <span class="comment">//先将引用尝试从队列中poll出来</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>.debuggerControl.isDebuggerAttached()) &#123; <span class="comment">//规避调试模式</span></span><br><span class="line">    <span class="keyword">return</span> Result.RETRY;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.gone(reference)) &#123; <span class="comment">//检测是否已经回收</span></span><br><span class="line">    <span class="keyword">return</span> Result.DONE;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">//如果没有被回收，则手动GC</span></span><br><span class="line">    <span class="keyword">this</span>.gcTrigger.runGc();<span class="comment">//手动GC方法</span></span><br><span class="line">    <span class="keyword">this</span>.removeWeaklyReachableReferences();<span class="comment">//再次尝试poll，检测是否被回收</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">this</span>.gone(reference)) &#123; <span class="comment">// 还没有被回收，则dump堆信息，调起分析进程进行分析</span></span><br><span class="line">      <span class="keyword">long</span> startDumpHeap = System.nanoTime();</span><br><span class="line">      <span class="keyword">long</span> gcDurationMs = TimeUnit.NANOSECONDS.toMillis(startDumpHeap - gcStartNanoTime);</span><br><span class="line">      File heapDumpFile = <span class="keyword">this</span>.heapDumper.dumpHeap();</span><br><span class="line">      <span class="keyword">if</span>(heapDumpFile == HeapDumper.RETRY_LATER) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.RETRY;<span class="comment">//需要重试</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">long</span> heapDumpDurationMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startDumpHeap);</span><br><span class="line">      <span class="keyword">this</span>.heapdumpListener.analyze(<span class="keyword">new</span> HeapDump(heapDumpFile, reference.key, reference.name, <span class="keyword">this</span>.excludedRefs, watchDurationMs, gcDurationMs, heapDumpDurationMs));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> Result.DONE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">gone</span><span class="params">(KeyedWeakReference reference)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !<span class="keyword">this</span>.retainedKeys.contains(reference.key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeWeaklyReachableReferences</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  KeyedWeakReference ref;</span><br><span class="line">  <span class="keyword">while</span>((ref = (KeyedWeakReference)<span class="keyword">this</span>.queue.poll()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.retainedKeys.remove(ref.key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ensureGone</code>方法通过检测<code>referenceQueue</code>队列的引用情况，来判断回收情况，通过手动 GC 来进一步确认回收情况。这是一个耗时过程，运行在<code>WatchExecutor</code>中。</p>
<p>LeakCanary 在主线程空闲时候执行检测任务，代码位于<code>AndroidWatchExecutor</code>中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AndroidWatchExecutor</span> <span class="keyword">implements</span> <span class="title">WatchExecutor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String LEAK_CANARY_THREAD_NAME = <span class="string">"LeakCanary-Heap-Dump"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Handler mainHandler = <span class="keyword">new</span> Handler(Looper.getMainLooper());</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Handler backgroundHandler;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> initialDelayMillis;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> maxBackoffFactor;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AndroidWatchExecutor</span><span class="params">(<span class="keyword">long</span> initialDelayMillis)</span> </span>&#123;</span><br><span class="line">        HandlerThread handlerThread = <span class="keyword">new</span> HandlerThread(<span class="string">"LeakCanary-Heap-Dump"</span>);</span><br><span class="line">        handlerThread.start();</span><br><span class="line">        <span class="keyword">this</span>.backgroundHandler = <span class="keyword">new</span> Handler(handlerThread.getLooper());</span><br><span class="line">        <span class="keyword">this</span>.initialDelayMillis = initialDelayMillis;</span><br><span class="line">        <span class="keyword">this</span>.maxBackoffFactor = <span class="number">9223372036854775807L</span> / initialDelayMillis;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Retryable retryable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(Looper.getMainLooper().getThread() == Thread.currentThread()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.waitForIdle(retryable, <span class="number">0</span>);<span class="comment">//需要在主线程中检测</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.postWaitForIdle(retryable, <span class="number">0</span>);<span class="comment">//post到主线程</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postWaitForIdle</span><span class="params">(<span class="keyword">final</span> Retryable retryable, <span class="keyword">final</span> <span class="keyword">int</span> failedAttempts)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mainHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                AndroidWatchExecutor.<span class="keyword">this</span>.waitForIdle(retryable, failedAttempts);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">waitForIdle</span><span class="params">(<span class="keyword">final</span> Retryable retryable, <span class="keyword">final</span> <span class="keyword">int</span> failedAttempts)</span> </span>&#123;</span><br><span class="line">        Looper.myQueue().addIdleHandler(<span class="keyword">new</span> IdleHandler() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">queueIdle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                AndroidWatchExecutor.<span class="keyword">this</span>.postToBackgroundWithDelay(retryable, failedAttempts);<span class="comment">//切换到子线程</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postToBackgroundWithDelay</span><span class="params">(<span class="keyword">final</span> Retryable retryable, <span class="keyword">final</span> <span class="keyword">int</span> failedAttempts)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> exponentialBackoffFactor = (<span class="keyword">long</span>)Math.min(Math.pow(<span class="number">2.0</span>D, (<span class="keyword">double</span>)failedAttempts), (<span class="keyword">double</span>)<span class="keyword">this</span>.maxBackoffFactor); <span class="comment">// 二进制退让算法</span></span><br><span class="line">        <span class="keyword">long</span> delayMillis = <span class="keyword">this</span>.initialDelayMillis * exponentialBackoffFactor;</span><br><span class="line">        <span class="keyword">this</span>.backgroundHandler.postDelayed(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Result result = retryable.run();<span class="comment">//RefWatcher.this.ensureGone(reference, watchStartNanoTime)执行</span></span><br><span class="line">                <span class="keyword">if</span>(result == Result.RETRY) &#123;</span><br><span class="line">                    AndroidWatchExecutor.<span class="keyword">this</span>.postWaitForIdle(retryable, failedAttempts + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, delayMillis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中调用了<code>MessageQueue.addIdleHandler</code>方法，Looper 中的 MessageQueue 有个<code>mIdleHandlers</code>队列，在获取下个要执行的 Message 时，如果没有发现可执行的 Message，就会回调<code>queueIdle()</code>方法，如果<code>queueIdle()</code>返回<code>false</code>，则移除该 IdleHandler。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">    <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">       		···</span><br><span class="line">       		···<span class="comment">//省略部分消息查找代码</span></span><br><span class="line">       		</span><br><span class="line">       		<span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                    <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">                    nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ···</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">return</span> msg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// No more messages.</span></span><br><span class="line">                nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">       		</span><br><span class="line">            <span class="comment">// If first time idle, then get the number of idlers to run.</span></span><br><span class="line">            <span class="comment">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class="line">            <span class="comment">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">                    &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">                pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class="line">                mBlocked = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">            &#125;</span><br><span class="line">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Run the idle handlers.</span></span><br><span class="line">        <span class="comment">// We only ever reach this code block during the first iteration.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">            mPendingIdleHandlers[i] = <span class="keyword">null</span>; <span class="comment">// release the reference to the handler</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                keep = idler.queueIdle();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">"IdleHandler threw exception"</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!keep) &#123;<span class="comment">//返回false，则从队列移除，下次空闲不会调用。</span></span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    mIdleHandlers.remove(idler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reset the idle handler count to 0 so we do not run them again.</span></span><br><span class="line">        pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// While calling an idle handler, a new message could have been delivered</span></span><br><span class="line">        <span class="comment">// so go back and look again for a pending message without waiting.</span></span><br><span class="line">        nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>利用 VMDebug+HaHa 完成分析任务。</p>
<ol>
<li>在后台线程检查引用是否被清除，如果没有，调用 GC。</li>
<li>如果引用还是未被清除，把 heap 内存 dump 到 APP 对应的文件系统中的一个 <code>.hprof</code> 文件中。</li>
<li>在另外一个进程中的 <code>HeapAnalyzerService</code> 有一个 <code>HeapAnalyzer</code> 使用<a href="https://github.com/square/haha" target="_blank" rel="noopener">HAHA</a> 解析这个文件。</li>
<li>得益于唯一的 reference key, <code>HeapAnalyzer</code> 找到 <code>KeyedWeakReference</code>，定位内存泄漏。</li>
<li><code>HeapAnalyzer</code> 计算 <em>到 GC roots 的最短强引用路径</em>，并确定是否是泄漏。如果是的话，建立导致泄漏的引用链。</li>
<li>引用链传递到 APP 进程中的 <code>DisplayLeakService</code>， 并以通知的形式展示出来。</li>
</ol>
<h4 id="HeapAnalyzerService"><a href="#HeapAnalyzerService" class="headerlink" title="HeapAnalyzerService"></a>HeapAnalyzerService</h4><p>是一个 IntentService，调用 HAHA 中的<code>HeapAnalyzer</code>对 hprof 文件进行分析，找出泄露点。由于运行在不同进程，通过 Intent 传递数据。最终将结果发回给监听器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onHandleIntent</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (intent == <span class="keyword">null</span>) &#123;<span class="comment">// intent 为空直接返回</span></span><br><span class="line">    CanaryLog.d(<span class="string">"HeapAnalyzerService received a null intent, ignoring."</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  String listenerClassName = intent.getStringExtra(LISTENER_CLASS_EXTRA);<span class="comment">//获取回调类的类名</span></span><br><span class="line">  HeapDump heapDump = (HeapDump) intent.getSerializableExtra(HEAPDUMP_EXTRA);<span class="comment">//获取 HeapDump </span></span><br><span class="line">  HeapAnalyzer heapAnalyzer = <span class="keyword">new</span> HeapAnalyzer(heapDump.excludedRefs);<span class="comment">//创建 HeapAnalyzer</span></span><br><span class="line">  AnalysisResult result = heapAnalyzer.checkForLeak(heapDump.heapDumpFile, heapDump.referenceKey);<span class="comment">//检查泄漏（通过 HAHA 来完成），并获取结果</span></span><br><span class="line">  AbstractAnalysisResultService.sendResultToListener(<span class="keyword">this</span>, listenerClassName, heapDump, result);<span class="comment">//将分析结果发送给监听器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.im/post/5ab8d3d46fb9a028ca52f813" target="_blank" rel="noopener">掘金：Java 内存问题及 LeakCanary 原理分析</a><br><a href="https://ivanljt.github.io/blog/2017/12/15/%E6%8B%86%E8%BD%AE%E5%AD%90%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94LeakCanary%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/" target="_blank" rel="noopener">拆轮子系列——LeakCanary工作原理</a></p>
<h1 id="创建一个对象时内部流程"><a href="#创建一个对象时内部流程" class="headerlink" title="创建一个对象时内部流程"></a>创建一个对象时内部流程</h1><p>Java 在 new 一个对象的时候，会先检查对象所属的类是否已经加载到内存。如果没有加载，则会先执行<strong>类的加载过程</strong>；如果已经加载，则直接执行<strong>对象的创建过程</strong>。</p>
<h2 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h2><p>Java 使用<strong>双亲委派模型</strong>来进行类的加载。</p>
<p>如果一个类加载器（ClassLoader）收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委托给父类加载器去完成，每一个层次的类加载器都是如此。因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需要加载的类）时，子加载器才会尝试自己去加载。</p>
<p>这样做的好处是能够确保一个类的全局唯一性。因为类的唯一性由加载器+类名共同决定。使用<strong>双亲委派模型</strong>保证了同一个类始终由同一加载器进行加载。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/190608_interview/类加载过程.jpg" alt="类加载过程" title="">
                </div>
                <div class="image-caption">类加载过程</div>
            </figure>
<h3 id="1-加载"><a href="#1-加载" class="headerlink" title="1. 加载"></a>1. 加载</h3><p>由类加载器负责根据一个类的全限定名来读取此类的二进制字节流到 JVM 内部，并存储在运行时内存区的方法区，然后将其转换为一个与目标类型对应的 java.lang.Class 对象实例。</p>
<h3 id="2-验证"><a href="#2-验证" class="headerlink" title="2. 验证"></a>2. 验证</h3><ul>
<li>格式验证：验证是否符合class文件规范。</li>
<li>语义验证：检查一个被标记为final的类型是否包含子类；检查一个类中的final方法是否被子类进行重写；确保父类和子类之间没有不兼容的一些方法声明（比如方法签名相同，但方法的返回值不同）。</li>
<li>操作验证：在操作数栈中的数据必须进行正确的操作，对常量池中的各种符号引用执行验证（通常在解析阶段执行，检查是否可以通过符号引用中描述的全限定名定位到指定类型上，以及类成员信息的访问修饰符是否允许访问等）。</li>
</ul>
<h3 id="3-准备"><a href="#3-准备" class="headerlink" title="3. 准备"></a>3. 准备</h3><p>为类中的所有静态变量分配内存空间，并为其设置一个初始值；被final修饰的static变量（常量），会直接赋值。</p>
<h3 id="4-解析"><a href="#4-解析" class="headerlink" title="4. 解析"></a>4. 解析</h3><p>将常量池中的符号引用转为直接引用（得到类或者字段、方法在内存中的指针或者偏移量，以便直接调用该方法），这个可以在初始化之后再执行。</p>
<p>解析需要静态绑定的内容。（所有不会被重写的方法和域都会被静态绑定）</p>
<p>以上 2、3、4 三个阶段又合称为<strong>链接阶段</strong>，链接阶段要做的是将加载到 JVM 中的二进制字节流的类数据信息合并到 JVM 的运行时状态中。</p>
<h3 id="5-初始化（父父子子）"><a href="#5-初始化（父父子子）" class="headerlink" title="5. 初始化（父父子子）"></a>5. 初始化（父父子子）</h3><p>5.1 赋值静态变量。</p>
<p>5.2 执行静态代码块。</p>
<p>因为子类存在对父类的依赖，所以<strong>类的加载顺序是先加载父类后加载子类，初始化也一样</strong>。</p>
<p>最终，方法区会存储当前类类信息，包括类的<strong>静态变量</strong>、<strong>类初始化代码</strong>（<strong>定义静态变量时的赋值语句 </strong>和 <strong>静态初始化代码块</strong>）、<strong>实例变量定义</strong>、<strong>实例初始化代码</strong>（<strong>定义实例变量时的赋值语句实例代码块</strong>和<strong>构造方法</strong>）和<strong>实例方法</strong>，还有<strong>父类的类信息引用</strong>。</p>
<h2 id="对象创建过程"><a href="#对象创建过程" class="headerlink" title="对象创建过程"></a>对象创建过程</h2><h3 id="1-在堆区分配对象需要的内存"><a href="#1-在堆区分配对象需要的内存" class="headerlink" title="1. 在堆区分配对象需要的内存"></a>1. 在堆区分配对象需要的内存</h3><p>包括本类与父类所有实例变量，不包括静态变量。</p>
<h3 id="2-为实例变量赋默认值"><a href="#2-为实例变量赋默认值" class="headerlink" title="2. 为实例变量赋默认值"></a>2. 为实例变量赋默认值</h3><p>将方法区内对实例变量的定义拷贝一份到堆区，然后赋默认值。</p>
<h3 id="3-执行实例初始化代码"><a href="#3-执行实例初始化代码" class="headerlink" title="3. 执行实例初始化代码"></a>3. 执行实例初始化代码</h3><p>初始化顺序是先初始化父类再初始化子类，初始化时先执行<strong>实例代码块</strong>然后是<strong>构造方法</strong>。</p>
<p>如果我们对实例变量直接赋值或者使用实例代码块赋值，那么编译器会将其中的代码放到类的构造函数中去，并且这些代码会被放在对超类构造函数的调用语句<strong>之后</strong>(Java要求构造函数的第一条语句必须是超类构造函数的调用语句)，构造函数本身的代码<strong>之前</strong>。</p>
<p> 如果有类似于Child c = new Child()形式的c引用的话，在栈区定义Child类型引用变量c，然后将堆区对象的地址赋值给它。</p>
<p>需要注意的是，<strong>每个子类对象持有父类对象的引用</strong>，可在内部通过 super 关键字来调用父类方法，但在外部不可访问。并且子类对象创建时只是<strong>调用父类构造函数</strong>，并非<strong>创建父类对象</strong>。</p>
<p>Java 要求在实例化类之前，必须先实例化其超类，以保证所创建实例的完整性。如果我们既没有调用其他的构造函数，也没有显式调用超类的构造函数，那么编译器会为我们自动生成一个对超类构造函数的调用。</p>
<h2 id="虚方法表"><a href="#虚方法表" class="headerlink" title="虚方法表"></a>虚方法表</h2><p>通过实例引用调用实例方法的时候，先从方法区中对象的实际类型信息找，找不到的话再去父类类型信息中找。</p>
<p>如果继承的层次比较深，要调用的方法位于比较上层的父类，则调用的效率是比较低的，因为每次调用都要经过很多次查找。这时候大多系统会采用一种称为<strong>虚方法表</strong>的方法来优化调用的效率。</p>
<p>所谓虚方法表，就是在类加载的时候，为每个类创建一个表，这个表包括该类的对象所有动态绑定的方法及其地址，包括父类的方法，但一个方法只有一条记录，子类重写了父类方法后只会保留子类的。当通过对象动态绑定方法的时候，只需要查找这个表就可以了，而不需要挨个查找每个父类。</p>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><h3 id="实例初始化不一定要在类初始化结束之后才开始初始化"><a href="#实例初始化不一定要在类初始化结束之后才开始初始化" class="headerlink" title="实例初始化不一定要在类初始化结束之后才开始初始化"></a>实例初始化不一定要在类初始化结束之后才开始初始化</h3><ul>
<li>类初始化<code>&lt;clinit&gt;()</code></li>
<li>实例初始化<code>&lt;init&gt;()</code></li>
</ul>
<p>在Java中， 创建一个对象常常需要经历如下几个过程：</p>
<ol>
<li>父类的类构造器<code>&lt;clinit&gt;()</code></li>
<li>子类的类构造器<code>&lt;clinit&gt;()</code></li>
<li>父类的成员变量和实例代码块</li>
<li>父类的构造函数</li>
<li>子类的成员变量和实例代码块</li>
<li>子类的构造函数。</li>
</ol>
<p>你可以使用 <a href="https://www.tutorialspoint.com/compile_java_online.php" target="_blank" rel="noopener">https://www.tutorialspoint.com/compile_java_online.php</a> 进行在线验证。</p>
<h3 id="一道测验题"><a href="#一道测验题" class="headerlink" title="一道测验题"></a>一道测验题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        staticFunction();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> StaticTest st = <span class="keyword">new</span> StaticTest();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;   <span class="comment">//静态代码块</span></span><br><span class="line">        System.out.println(<span class="string">"1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;       <span class="comment">// 实例代码块</span></span><br><span class="line">        System.out.println(<span class="string">"2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    StaticTest() &#123;    <span class="comment">// 实例构造器</span></span><br><span class="line">        System.out.println(<span class="string">"3"</span>);</span><br><span class="line">        System.out.println(<span class="string">"a="</span> + a + <span class="string">",b="</span> + b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticFunction</span><span class="params">()</span> </span>&#123;   <span class="comment">// 静态方法</span></span><br><span class="line">        System.out.println(<span class="string">"4"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">110</span>;    <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">112</span>;     <span class="comment">// 静态变量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output: </span></span><br><span class="line"><span class="comment">        2</span></span><br><span class="line"><span class="comment">        3</span></span><br><span class="line"><span class="comment">        a=110,b=0</span></span><br><span class="line"><span class="comment">        1</span></span><br><span class="line"><span class="comment">        4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="另一道测验题"><a href="#另一道测验题" class="headerlink" title="另一道测验题"></a>另一道测验题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    Foo() &#123;</span><br><span class="line">        System.out.println(i);             </span><br><span class="line">        <span class="keyword">int</span> x = getValue();</span><br><span class="line">        System.out.println(x);            </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        i = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    Bar() &#123;</span><br><span class="line">        j = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        j = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstructorExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        Bar bar = <span class="keyword">new</span> Bar();</span><br><span class="line">        System.out.println(bar.getValue());        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.cnblogs.com/JackPn/p/9386182.html" target="_blank" rel="noopener">博客园 - java new 一个对象的过程中发生了什么</a></li>
<li><a href="https://blog.csdn.net/justloveyou_/article/details/72466105" target="_blank" rel="noopener">CSDN - JVM类生命周期概述：加载时机与加载过程</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-clobj-init/index.html" target="_blank" rel="noopener">IBM - 解析 Java 类和对象的初始化过程</a></li>
</ul>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2019-06-12T22:50:27.665Z" itemprop="dateUpdated">2019-06-13 06:50:27</time>
</span><br>


        
        这里可以写作者留言，标签和 hexo 中所有变量及辅助函数等均可调用，示例：<a href="/2018/07/29/interview-180729/" target="_blank" rel="external">https://lilei.pro/2018/07/29/interview-180729/</a>
        
    </div>
    
    <footer>
        <a href="https://lilei.pro">
            <img src="/img/avatar.jpeg" alt="Li Lei">
            Li Lei
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/面试/">面试</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://lilei.pro/2018/07/29/interview-180729/&title=《面试知识整理 2018.07.29》 — 柘个角落&pic=https://lilei.pro/img/avatar.jpeg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://lilei.pro/2018/07/29/interview-180729/&title=《面试知识整理 2018.07.29》 — 柘个角落&source=技术与生活上的点滴积累" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://lilei.pro/2018/07/29/interview-180729/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《面试知识整理 2018.07.29》 — 柘个角落&url=https://lilei.pro/2018/07/29/interview-180729/&via=https://lilei.pro" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://lilei.pro/2018/07/29/interview-180729/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2018/07/30/weekly-20180723-20180729/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">本周总结 20180723 ~ 20180729</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2018/07/28/hello-mr-billionaire/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">西虹市首富</h4>
      </a>
    </div>
  
</nav>



    











    <!-- Valine Comments -->
    <div class="comments vcomment" id="comments"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
    <!-- Valine Comments script -->
    <script>
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail,link'.split(',').filter(function(item){
          return GUEST_INFO.indexOf(item) > -1
        });
        new Valine({
            el: '#comments',
            notify: 'false' == 'true',
            verify: 'true' == 'true',
            appId: "khG3rBt0nWda7lxDUHpS3Sq0-gzGzoHsz",
            appKey: "btFkQfcBgJeCRm55mYmUgA5d",
            avatar: "mm",
            placeholder: "欢迎讨论",
            guest_info: guest_info.length == 0 ? GUEST_INFO : guest_info,
            pageSize: "10"
        })
    </script>
    <!-- Valine Comments end -->







</article>



</div>

        <footer class="footer">
    <div class="top">
        

        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>Li Lei &copy; 2015 - 2019</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://lilei.pro/2018/07/29/interview-180729/&title=《面试知识整理 2018.07.29》 — 柘个角落&pic=https://lilei.pro/img/avatar.jpeg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://lilei.pro/2018/07/29/interview-180729/&title=《面试知识整理 2018.07.29》 — 柘个角落&source=技术与生活上的点滴积累" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://lilei.pro/2018/07/29/interview-180729/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《面试知识整理 2018.07.29》 — 柘个角落&url=https://lilei.pro/2018/07/29/interview-180729/&via=https://lilei.pro" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://lilei.pro/2018/07/29/interview-180729/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACJ0lEQVR42u3aQW7EIAwF0N7/0tNtpYrMN2aqAo/VKE0Dj4VljL++4vH6MUZPkue/33l+c/HAwMDYlvF6HM8Tj5aSbMTz7PnaMDAw7mGMJh69M/rrMywPx/naMDAwMPLEbu795AkGBgZGh1ENl0mSh4GBgdE5xHaOqZ3fi8/iGBgYGzLyqvvf//7I/QYGBsZWjFdxdIr++TG1vCoMDIyjGZ20L/+vTuAubBwGBsbRjGqYS4JpUlCbaylbliZiYGBswshL/Mnn8nJb3l4WrQcDA+MaRvUg2rmwnDvuDlNPDAyMoxlzk3VSw05C+WbjMDAwDmUkRa7yrjQSx3JxrdVHhoGBsQejmgJWD6hzjV/VEI+BgXE2I0/j5paVhMv8GDx8joGBcTSjWrhPyl55Gjd3CfGmzQIDA+NQRue6sdqcsarZAgMD4zZGP2n7xBG3jMHAwLiMkU85V8qvBujo+xgYGBcw+qEzX3SyuHwlGBgYNzDWJoXVS4JyYI2DPgYGxkmMamjLS2ydNotykoqBgXEBo1Mm6wfcfMbCxQAGBsZxjLmjZrUN4hncKeFhYGCcyphrm6gWyzpBOaJiYGAczchHjpkr3s0F5fJ6MDAwtmX0Wx+SpedfyMtwizs4MDAw/j2jGiifw/Fc60Z1gzAwMDDylovkO/02izeBGAMDA6NRbuuU2PJNxMDAuIGRN1XkpGryNxfEMTAwbmCsLe6vakv9yKUmBgbGfoxvbjzRP9QI7hwAAAAASUVORK5CYII=" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>










</body>
</html>
