<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>面试知识整理 2018.07.26 | 柘个角落 | IF YOU WANT SOMETHING, GO GET IT. PERIOD.</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="Android,面试">
    <meta name="description" content="谈谈 SparseArray用法使用 Key-Value 保存对象的集合，类似 HashMap，但只允许使用 int 型的 Key 特点 （优点）内存效率高，避免自动装箱，避免了使用 Entry 来构建数据结构，int 4 bytes，Integer 16 bytes （缺点）使用二分法查找对象，在数据体量大（more than hundreds of items）的场景下查找/插入/删除效率不如">
<meta name="keywords" content="Android,面试">
<meta property="og:type" content="article">
<meta property="og:title" content="面试知识整理 2018.07.26">
<meta property="og:url" content="https://lilei.pro/2018/07/26/interview-180726/index.html">
<meta property="og:site_name" content="柘个角落">
<meta property="og:description" content="谈谈 SparseArray用法使用 Key-Value 保存对象的集合，类似 HashMap，但只允许使用 int 型的 Key 特点 （优点）内存效率高，避免自动装箱，避免了使用 Entry 来构建数据结构，int 4 bytes，Integer 16 bytes （缺点）使用二分法查找对象，在数据体量大（more than hundreds of items）的场景下查找/插入/删除效率不如">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://lilei.pro/img/180726_interview/window.png">
<meta property="og:image" content="https://lilei.pro/img/180726_interview/perform_traversals.png">
<meta property="og:image" content="https://lilei.pro/img/180726_interview/measure.png">
<meta property="og:image" content="https://lilei.pro/img/180726_interview/layout.png">
<meta property="og:image" content="https://lilei.pro/img/180726_interview/draw.png">
<meta property="og:image" content="https://lilei.pro/img/180726_interview/overdraw.png">
<meta property="og:image" content="https://lilei.pro/img/180726_interview/呈现模式分析.png">
<meta property="og:updated_time" content="2018-08-08T02:18:21.188Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="面试知识整理 2018.07.26">
<meta name="twitter:description" content="谈谈 SparseArray用法使用 Key-Value 保存对象的集合，类似 HashMap，但只允许使用 int 型的 Key 特点 （优点）内存效率高，避免自动装箱，避免了使用 Entry 来构建数据结构，int 4 bytes，Integer 16 bytes （缺点）使用二分法查找对象，在数据体量大（more than hundreds of items）的场景下查找/插入/删除效率不如">
<meta name="twitter:image" content="https://lilei.pro/img/180726_interview/window.png">
    
        <link rel="alternate" type="application/atom+xml" title="柘个角落" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpeg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Li Lei</h5>
          <a href="mailto:bequietlee#gmail.com" title="bequietlee#gmail.com" class="mail">bequietlee#gmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                文章
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/bequietlee" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/2019/03/10/links"  >
                <i class="icon icon-lg icon-link"></i>
                友情链接
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">面试知识整理 2018.07.26</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">面试知识整理 2018.07.26</h1>
        <h5 class="subtitle">
            
                <time datetime="2018-07-26T04:51:20.000Z" itemprop="datePublished" class="page-time">
  2018-07-26
</time>


            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#谈谈-SparseArray"><span class="post-toc-number">1.</span> <span class="post-toc-text">谈谈 SparseArray</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#用法"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">用法</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#特点"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">特点</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#操作"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">操作</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#源码阅读"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">源码阅读</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Handler-内部原理，HandlerThread-与普通-Thread-区别"><span class="post-toc-number">2.</span> <span class="post-toc-text">Handler 内部原理，HandlerThread 与普通 Thread 区别</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Handler-的两个用途"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">Handler 的两个用途</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#主要概念"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">主要概念</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#原理流程概述"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">原理流程概述</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#UI-线程创建-Looper"><span class="post-toc-number">2.4.</span> <span class="post-toc-text">UI 线程创建 Looper</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Handler-发送消息的流程"><span class="post-toc-number">2.5.</span> <span class="post-toc-text">Handler 发送消息的流程</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#HandlerThread"><span class="post-toc-number">2.6.</span> <span class="post-toc-text">HandlerThread</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Picasso-VS-Glide"><span class="post-toc-number">3.</span> <span class="post-toc-text">Picasso VS Glide</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#View-的绘制过程"><span class="post-toc-number">4.</span> <span class="post-toc-text">View 的绘制过程</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#measure-过程分析"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">measure 过程分析</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#layout-过程分析"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">layout 过程分析</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#draw-过程分析"><span class="post-toc-number">4.3.</span> <span class="post-toc-text">draw 过程分析</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#参考：Android应用层View绘制流程与源码分析"><span class="post-toc-number">4.3.1.</span> <span class="post-toc-text">参考：Android应用层View绘制流程与源码分析</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#类加载过程-ClassLoader机制"><span class="post-toc-number">5.</span> <span class="post-toc-text">类加载过程/ClassLoader机制</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Apk-打包过程"><span class="post-toc-number">6.</span> <span class="post-toc-text">Apk 打包过程</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#ListView-和-RecyclerView-原理"><span class="post-toc-number">7.</span> <span class="post-toc-text">ListView 和 RecyclerView 原理</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#性能优化"><span class="post-toc-number">8.</span> <span class="post-toc-text">性能优化</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#内存优化"><span class="post-toc-number">8.1.</span> <span class="post-toc-text">内存优化</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#参考：Android中五种常见内存泄漏原因"><span class="post-toc-number">8.1.1.</span> <span class="post-toc-text">参考：Android中五种常见内存泄漏原因</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#UI优化（布局、绘制）"><span class="post-toc-number">8.2.</span> <span class="post-toc-text">UI优化（布局、绘制）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#布局优化"><span class="post-toc-number">8.2.1.</span> <span class="post-toc-text">布局优化</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#绘制优化"><span class="post-toc-number">8.2.2.</span> <span class="post-toc-text">绘制优化</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#速度优化（线程、网络）"><span class="post-toc-number">8.3.</span> <span class="post-toc-text">速度优化（线程、网络）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#线程优化"><span class="post-toc-number">8.3.1.</span> <span class="post-toc-text">线程优化</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#网络优化"><span class="post-toc-number">8.3.2.</span> <span class="post-toc-text">网络优化</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#电量优化"><span class="post-toc-number">8.4.</span> <span class="post-toc-text">电量优化</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#启动优化"><span class="post-toc-number">8.5.</span> <span class="post-toc-text">启动优化</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#AsyncTask-知识点"><span class="post-toc-number">9.</span> <span class="post-toc-text">AsyncTask 知识点</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#是什么"><span class="post-toc-number">9.1.</span> <span class="post-toc-text">是什么</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#变更历史"><span class="post-toc-number">9.2.</span> <span class="post-toc-text">变更历史</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#内部原理（API-26）"><span class="post-toc-number">9.3.</span> <span class="post-toc-text">内部原理（API 26）</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#一个关于类的静态变量归属的问题"><span class="post-toc-number">10.</span> <span class="post-toc-text">一个关于类的静态变量归属的问题</span></a></li></ol>
        </nav>
    </aside>


<article id="post-interview-180726"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">面试知识整理 2018.07.26</h1>
        <div class="post-meta">
            <time class="post-time" title="2018-07-26 12:51:20" datetime="2018-07-26T04:51:20.000Z"  itemprop="datePublished">2018-07-26</time>

            


            

        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h1 id="谈谈-SparseArray"><a href="#谈谈-SparseArray" class="headerlink" title="谈谈 SparseArray"></a>谈谈 SparseArray</h1><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>使用 Key-Value 保存对象的集合，类似 HashMap，但只允许使用 int 型的 Key</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>（优点）内存效率高，避免自动装箱，避免了使用 Entry 来构建数据结构，int 4 bytes，Integer 16 bytes</li>
<li>（缺点）使用二分法查找对象，在数据体量大（more than hundreds of items）的场景下查找/插入/删除效率不如 HashMap</li>
<li>删除过程优化：先标记 item，待 GC 时真正删除</li>
</ul>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><ul>
<li>随机插入：put(int, x)，会替换掉已有的对象</li>
<li>顺序插入：append(int, x)，当 Key 比目前所有的都要大时执行效率更高，否则同 put</li>
<li>随机删除：delete(int)，删除 Key 对应的对象</li>
<li>顺序删除：removeAt(int)，删除第 N 项</li>
<li>范围删除：removeAtRange(int, int)</li>
<li>随机访问：get(int)，根据 Key 获取 Value，如果没有则返回 null</li>
<li>顺序访问：valueAt(int)</li>
<li>遍历：keyAt(int)，获取第 n 位的 key；valueAt(int)，获取第 n 位 key 对应的 value；indexOfKey(int)，获取 key 的 index；indexOfValue(int)，获取 value 的 index</li>
</ul>
<h2 id="源码阅读"><a href="#源码阅读" class="headerlink" title="源码阅读"></a>源码阅读</h2><p>成员变量部分</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object DELETED = <span class="keyword">new</span> Object(); <span class="comment">// 删除对象时，并非真正删除，而是将 Value 替换成 DELETE 对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> mGarbage = <span class="keyword">false</span>; <span class="comment">// 标示是否需要进行 gc</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] mKeys;</span><br><span class="line"><span class="keyword">private</span> Object[] mValues;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mSize;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SparseArray</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">10</span>); <span class="comment">// 默认长度是10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在调用 append, put, size 等方法时会触发 GC，是一个逐项复制的过程，代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = mSize;</span><br><span class="line">    <span class="keyword">int</span> o = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] keys = mKeys;</span><br><span class="line">    Object[] values = mValues;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        Object val = values[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (val != DELETED) &#123; <span class="comment">// 判断是否已经标记</span></span><br><span class="line">            <span class="keyword">if</span> (i != o) &#123;</span><br><span class="line">                keys[o] = keys[i];</span><br><span class="line">                values[o] = val;</span><br><span class="line">                values[i] = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            o++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mGarbage = <span class="keyword">false</span>;</span><br><span class="line">    mSize = o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>put 过程，核心是先判断有没有同一个 key 存在，有则替换，没有的话，再判断是否目标位置刚好被 DELETED 标记，最后才进行加项操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, E value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = ContainerHelpers.binarySearch(mKeys, mSize, key); <span class="comment">// 二分查找 key 的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123; <span class="comment">// 如果已经有同一个 key</span></span><br><span class="line">        mValues[i] = value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        i = ~i; <span class="comment">// 求异或</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &lt; mSize &amp;&amp; mValues[i] == DELETED) &#123; <span class="comment">// 目标位置项目已经标记 DELETE，可以直接替换</span></span><br><span class="line">            mKeys[i] = key;</span><br><span class="line">            mValues[i] = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mGarbage &amp;&amp; mSize &gt;= mKeys.length) &#123; <span class="comment">// 需要寻找新的位置，此时先 gc</span></span><br><span class="line">            gc();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Search again because indices may have changed.</span></span><br><span class="line">            i = ~ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key); <span class="comment">// 运用 System.arraycopy 进行添加（有必要则扩容）</span></span><br><span class="line">        mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);</span><br><span class="line">        mSize++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>delete 过程，先二分查找到目标位置，标记 DELETED，不直接删除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mValues[i] != DELETED) &#123;</span><br><span class="line">            mValues[i] = DELETED;</span><br><span class="line">            mGarbage = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Handler-内部原理，HandlerThread-与普通-Thread-区别"><a href="#Handler-内部原理，HandlerThread-与普通-Thread-区别" class="headerlink" title="Handler 内部原理，HandlerThread 与普通 Thread 区别"></a>Handler 内部原理，HandlerThread 与普通 Thread 区别</h1><h2 id="Handler-的两个用途"><a href="#Handler-的两个用途" class="headerlink" title="Handler 的两个用途"></a>Handler 的两个用途</h2><ol>
<li>管理消息/任务队列，可以控制立即执行或者延迟执行</li>
<li>调度任务在不同线程运行f</li>
</ol>
<h2 id="主要概念"><a href="#主要概念" class="headerlink" title="主要概念"></a>主要概念</h2><ul>
<li>Handler：消息分发器，一个 Handler 里面会关联一个 MessageQueue，这个 MessageQueue 来自当前线程的 Looper</li>
<li>Looper：消息循环器，从 MQ 里面不断取出消息运行。非 UI 线程是没有默认创建 Looper 的，需要人工调用 prepare 和 loop 来启动 Looper。被声明为 ThreadLocal，每一个线程独立拥有</li>
<li>Message：消息单元，内部用消息池管理，默认 capacity = 50</li>
<li>MessageQueue：消息队列，单链表，每个消息入队时会带上一个运行时间 when，根据这个 when 将其放入队列中相应的位置（早执行的放在队首），整个队列是按照运行时间排序的</li>
</ul>
<h2 id="原理流程概述"><a href="#原理流程概述" class="headerlink" title="原理流程概述"></a>原理流程概述</h2><p>创建 Handler 时会关联当前线程 Looper 中的 MQ，当用 Handler 对象发送消息时，消息会进入 MQ，经 Looper 轮询取出后进行处理，处理时会调用所实现的 handleMessage 方法。</p>
<h2 id="UI-线程创建-Looper"><a href="#UI-线程创建-Looper" class="headerlink" title="UI 线程创建 Looper"></a>UI 线程创建 Looper</h2><ol>
<li>ActivityThread 在 main 方法里通过 Looper.prepareMainLooper() 创建主 Looper，并将其存入 ThreadLocal 变量中。同时将它另存一份作为主线程 Looper，供其他线程访问。</li>
<li>在 main 方法最后通过 looper.loop() 启动轮询</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line">        ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">        thread.attach(<span class="keyword">false</span>);</span><br><span class="line">        Looper.loop();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Handler-发送消息的流程"><a href="#Handler-发送消息的流程" class="headerlink" title="Handler 发送消息的流程"></a>Handler 发送消息的流程</h2><p>构造过程中取出当前线程持有的 Looper，并保存其 MQ 对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">        mLooper = Looper.myLooper();</span><br><span class="line">        mQueue = mLooper.mQueue;</span><br><span class="line">        mCallback = callback;</span><br><span class="line">        mAsynchronous = async;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>handler通过sendMessage(msg) 将消息发出，消息最终走向 queue.enqueueMessage(msg, uptimeMillis) 进入队列，同时将当前 Handler 以 target 保存在消息对象中，当 Looper 轮询时，会取出 target 用于处理消息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">        msg.target = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">        <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Message msg = queue.next(); <span class="comment">// 取出消息，无消息则阻塞</span></span><br><span class="line">          <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;  <span class="keyword">return</span>;   &#125;</span><br><span class="line">        msg.target.dispatchMessage(msg);<span class="comment">//发送消息 其中target就是Handler</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>dispatchMessage 最终会调到 Handler 中实现的 handleMessage</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            handleCallback(msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            handleMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="HandlerThread"><a href="#HandlerThread" class="headerlink" title="HandlerThread"></a>HandlerThread</h2><p>构造函数里创建了自己的 Looper 并且开启轮询，普通 Thread 不含 Looper</p>
<h1 id="Picasso-VS-Glide"><a href="#Picasso-VS-Glide" class="headerlink" title="Picasso VS Glide"></a>Picasso VS Glide</h1><table>
<thead>
<tr>
<th>项目</th>
<th>Picasso</th>
<th>Glide</th>
</tr>
</thead>
<tbody>
<tr>
<td>图片格式</td>
<td>ARGB8888</td>
<td>RGB_565</td>
</tr>
<tr>
<td>缓存</td>
<td>原图尺寸</td>
<td>显示尺寸</td>
</tr>
<tr>
<td>GIF</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>video</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>Library size</td>
<td>100K</td>
<td>500K</td>
</tr>
<tr>
<td>Methods count</td>
<td>500</td>
<td>2500</td>
</tr>
</tbody>
</table>
<h1 id="View-的绘制过程"><a href="#View-的绘制过程" class="headerlink" title="View 的绘制过程"></a>View 的绘制过程</h1><p>一个 Activity 的窗口页面，可以分为PhoneWindow、DecorView、TitleBar &amp; ContentView 几个层级</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/180726_interview/window.png" alt="window.png" title="">
                </div>
                <div class="image-caption">window.png</div>
            </figure>
<p>整个 View 树的绘图流程在 ViewRootImpl.performTraversals() 方法中，它主要做的事情是根据之前设置的状态，判断是否需要重新计算视图大小（measure）、是否需要重新放置视图位置（layout）以及是否需要重新绘制（draw），代码如下</p>
<ul>
<li>measure：测量，指测量 View 的宽高</li>
<li>layout：布局，指确定在父容器中的位置坐标</li>
<li>draw：绘制并显示</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//最外层的根视图的widthMeasureSpec和heightMeasureSpec由来</span></span><br><span class="line">        <span class="comment">//lp.width和lp.height在创建ViewGroup实例时等于MATCH_PARENT</span></span><br><span class="line">        <span class="keyword">int</span> childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);</span><br><span class="line">        <span class="keyword">int</span> childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);</span><br><span class="line">        ......</span><br><span class="line">        mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">        ......</span><br><span class="line">        mView.layout(<span class="number">0</span>, <span class="number">0</span>, mView.getMeasuredWidth(), mView.getMeasuredHeight());</span><br><span class="line">        ......</span><br><span class="line">        mView.draw(canvas);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/180726_interview/perform_traversals.png" alt="perform_traversals" title="">
                </div>
                <div class="image-caption">perform_traversals</div>
            </figure>
<h2 id="measure-过程分析"><a href="#measure-过程分析" class="headerlink" title="measure 过程分析"></a>measure 过程分析</h2><p>整个 View 树从根 View 开始，递归进行 measure</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/180726_interview/measure.png" alt="measure.png" title="">
                </div>
                <div class="image-caption">measure.png</div>
            </figure>
<p>View.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * This is called to find out how big a view should be. The parent</span></span><br><span class="line"><span class="comment"> * supplies constraint information in the width and height parameters.</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * The actual measurement work of a view is performed in</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #onMeasure(int, int)&#125;, called by this method. Therefore, only</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #onMeasure(int, int)&#125; can and must be overridden by subclasses.</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> widthMeasureSpec Horizontal space requirements as imposed by the</span></span><br><span class="line"><span class="comment"> *        parent</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> heightMeasureSpec Vertical space requirements as imposed by the</span></span><br><span class="line"><span class="comment"> *        parent</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #onMeasure(int, int)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//final方法，子类不可重写</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//回调onMeasure()方法</span></span><br><span class="line">    onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//View的onMeasure默认实现方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</span><br><span class="line">            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MeasureSpec 的语义是父 View 对子 View 在长宽上的约束，有三种取值</p>
<ul>
<li>EXACTLY：不管子 View 想多大，它只能这么大</li>
<li>AT_MOST：最大只能这么大</li>
<li>UNSPECIFIED：不加约束，子 View 想多大就多大</li>
</ul>
<p>measure 过程主要就是从顶层父 View 向子 View 递归调用 view.measure 方法（measure中 又回调 onMeasure 方法）的过程。具体 measure 核心主要有如下几点</p>
<ul>
<li>View的measure方法是final的，不允许重载，View子类只能重载onMeasure来完成自己的测量逻辑。</li>
<li>最顶层DecorView测量时的MeasureSpec是由ViewRootImpl中getRootMeasureSpec方法确定的（LayoutParams宽高参数均为MATCH_PARENT，specMode是EXACTLY，specSize为物理屏幕大小）。</li>
<li>ViewGroup类提供了measureChild，measureChild和measureChildWithMargins方法，简化了父子View的尺寸计算。</li>
<li>只要是ViewGroup的子类就必须要求LayoutParams继承子MarginLayoutParams，否则无法使用layout_margin参数。</li>
<li>View的布局大小由父View和子View共同决定。</li>
<li>使用View的getMeasuredWidth()和getMeasuredHeight()方法来获取View测量的宽高，必须保证这两个方法在onMeasure流程之后被调用才能返回有效值。</li>
</ul>
<h2 id="layout-过程分析"><a href="#layout-过程分析" class="headerlink" title="layout 过程分析"></a>layout 过程分析</h2><p>View.performTraversals 在 measure 之后，会执行 layout 过程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    mView.layout(<span class="number">0</span>, <span class="number">0</span>, mView.getMeasuredWidth(), mView.getMeasuredHeight());</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>layout() 方法有四个参数，分别是 left、top、right、bottom，表示当前 View 相对 Parent 的四个坐标。layout 过程也是一个递归的过程：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/180726_interview/layout.png" alt="layout.png" title="">
                </div>
                <div class="image-caption">layout.png</div>
            </figure>
<p>View.layout 方法实际上会调用到 onLayout 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//实质都是调用setFrame方法把参数分别赋值给mLeft、mTop、mRight和mBottom这几个变量</span></span><br><span class="line">    <span class="comment">//判断View的位置是否发生过变化，以确定有没有必要对当前的View进行重新layout</span></span><br><span class="line">    <span class="keyword">boolean</span> changed = isLayoutModeOptical(mParent) ?</span><br><span class="line">            setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</span><br><span class="line">    <span class="comment">//需要重新layout</span></span><br><span class="line">    <span class="keyword">if</span> (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</span><br><span class="line">        <span class="comment">//回调onLayout</span></span><br><span class="line">        onLayout(changed, l, t, r, b);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>layout 也是从顶层父 View 向子 View 的递归调用 layout 方法的过程，即父 View 根据上一步 measure 子 View 所得到的布局大小和布局参数，将子 View 放在合适的位置上。具体 layout 核心主要有以下几点：</p>
<ul>
<li>View.layout方法可被重载，ViewGroup.layout为final的不可重载，ViewGroup.onLayout为abstract的，子类必须重载实现自己的位置逻辑</li>
<li>measure操作完成后得到的是对每个View经测量过的measuredWidth和measuredHeight，layout操作完成之后得到的是对每个View进行位置分配后的mLeft、mTop、mRight、mBottom，这些值都是相对于父View来说的</li>
<li>凡是layout_XXX的布局属性基本都针对的是包含子View的ViewGroup的，当对一个没有父容器的View设置相关layout_XXX属性是没有任何意义的</li>
<li>使用View的getWidth()和getHeight()方法来获取View测量的宽高，必须保证这两个方法在onLayout流程之后被调用才能返回有效值</li>
</ul>
<h2 id="draw-过程分析"><a href="#draw-过程分析" class="headerlink" title="draw 过程分析"></a>draw 过程分析</h2><p>performTraverls 在 layout 后会进行 draw 的操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">final</span> Rect dirty = mDirty;</span><br><span class="line">    ......</span><br><span class="line">    canvas = mSurface.lockCanvas(dirty);</span><br><span class="line">    ......</span><br><span class="line">    mView.draw(canvas);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>draw 也是一个递归的过程</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/180726_interview/draw.png" alt="draw.png" title="">
                </div>
                <div class="image-caption">draw.png</div>
            </figure>
<ul>
<li>如果该View是一个ViewGroup，则需要递归绘制其所包含的所有子View。</li>
<li>View默认不会绘制任何内容，真正的绘制都需要自己在子类中实现。</li>
<li>View的绘制是借助onDraw方法传入的Canvas类来进行的。</li>
<li>区分View动画和ViewGroup布局动画，前者指的是View自身的动画，可以通过setAnimation添加，后者是专门针对ViewGroup显示内部子视图时设置的动画，可以在xml布局文件中对ViewGroup设置layoutAnimation属性（譬如对LinearLayout设置子View在显示时出现逐行、随机、下等显示等不同动画效果）。</li>
<li>在获取画布剪切区（每个View的draw中传入的Canvas）时会自动处理掉padding，子View获取Canvas不用关注这些逻辑，只用关心如何绘制即可。</li>
<li>默认情况下子View的ViewGroup.drawChild绘制顺序和子View被添加的顺序一致，但是你也可以重载ViewGroup.getChildDrawingOrder()方法提供不同顺序。</li>
</ul>
<h3 id="参考：Android应用层View绘制流程与源码分析"><a href="#参考：Android应用层View绘制流程与源码分析" class="headerlink" title="参考：Android应用层View绘制流程与源码分析"></a>参考：<a href="https://blog.csdn.net/yanbober/article/details/46128379" target="_blank" rel="noopener">Android应用层View绘制流程与源码分析</a></h3><h1 id="类加载过程-ClassLoader机制"><a href="#类加载过程-ClassLoader机制" class="headerlink" title="类加载过程/ClassLoader机制"></a>类加载过程/ClassLoader机制</h1><h1 id="Apk-打包过程"><a href="#Apk-打包过程" class="headerlink" title="Apk 打包过程"></a>Apk 打包过程</h1><h1 id="ListView-和-RecyclerView-原理"><a href="#ListView-和-RecyclerView-原理" class="headerlink" title="ListView 和 RecyclerView 原理"></a>ListView 和 RecyclerView 原理</h1><h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><p>考虑性能时一般从以下几个角度</p>
<ul>
<li>内存优化</li>
<li>UI优化（布局、绘制）</li>
<li>速度优化（线程、网络）</li>
<li>电量优化</li>
<li>启动优化</li>
</ul>
<h2 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h2><p>内存优化是为了解决内存溢出（OOM）的问题，内存溢出通常有两个原因</p>
<ul>
<li>使用不当造成的内存泄漏，内存无法释放</li>
<li>虽然不属于泄漏，但一些代码逻辑不当，导致消耗大量内存，难以及时释放</li>
</ul>
<p>内存泄漏</p>
<p>常见原因与处理方法</p>
<ol>
<li>单例模式里使用了 Activity 的 Context，导致其生命周期延长至整个应用使用周期，应该使用 ApplicationContext</li>
<li>非静态内部类持有 Activity 对象引用，应该改成静态内部类，同时使用 ApplicationContext；以上两步说明尽量不要使用 Activity 的 Context，而是应当用 ApplicationContext</li>
<li>Handler 持有 Activity 对象引用，同样应该改成静态，并使用弱引用，并在 Activity 的 onDestroy 方法里清空 Handler 消息，<code>mHandler.removeCallbacksAndMessages(null);</code></li>
<li>线程进行耗时操作，导致 Activity 没释放，应当使用弱引用，并且在 Activity 的 onDestroy 方法里 cancel 掉线程</li>
<li>占有系统资源后没有关闭，在使用完 BraodcastReceiver,ContentObserver,File,Cursor,Stream,Bitmap,Animation 等资源时，一定要在 Activity 中的 onDestry 中及时的关闭、注销或者释放内存。</li>
</ol>
<h3 id="参考：Android中五种常见内存泄漏原因"><a href="#参考：Android中五种常见内存泄漏原因" class="headerlink" title="参考：Android中五种常见内存泄漏原因"></a>参考：<a href="https://blog.csdn.net/qq_35373333/article/details/74909811" target="_blank" rel="noopener">Android中五种常见内存泄漏原因</a></h3><p>常用工具</p>
<ul>
<li>Heap SnapShot</li>
<li>Heap Viewer</li>
<li>LeakCanary</li>
<li>MAT</li>
<li>TraceView（Device Monitor）</li>
</ul>
<p>消耗大量内存：通常加载 Bitmap 时会发生这种情况，解决思路是</p>
<ul>
<li>加载单张图片时候进行压缩，或者使用缩略图</li>
<li>控制每次加载的数量</li>
<li>加载多张图片时，滑动过程中不进行加载，仅在滑动完成后加载</li>
</ul>
<h2 id="UI优化（布局、绘制）"><a href="#UI优化（布局、绘制）" class="headerlink" title="UI优化（布局、绘制）"></a>UI优化（布局、绘制）</h2><p>Android 屏幕刷新的频率是 60fps，意味着每一帧的绘制必须要在 16ms 内完成，如果 UI 绘制超过了 16ms，在体验上就会出现卡顿。</p>
<p>以下罗列造成 App 卡顿的一些原因</p>
<ol>
<li>在 UI 线程里进行轻微耗时操作</li>
<li>布局 Layout 过于复杂，无法在 16ms 内完成渲染</li>
<li>动画执行次数过多，导致 CPU 或 GPU 负载过高</li>
<li>View 过度绘制，屏幕某些像素在一帧时间内绘制多次，CPU 或 GPU 负载过高</li>
<li>View 频繁触发 measure 和 layout，累计耗时过多，频繁渲染造成负载过高</li>
<li>内存频繁 GC，导致阻塞渲染操作</li>
<li>冗余资源和逻辑导致运行缓慢</li>
<li>ANR</li>
</ol>
<p>UI优化，通常是指布局优化和 View 绘制优化</p>
<h3 id="布局优化"><a href="#布局优化" class="headerlink" title="布局优化"></a>布局优化</h3><p>在“开发者选项”里可以打开“过度绘制开关”，从而查看当前页面 View 是否存在过绘，红色表示层级最多（4+），浅紫色表示层级最低（1），如下所示。找到那些过绘的部分，在布局文件里减少它们的背景，比如把底层 View 的背景设置成透明。同时，尽量减少 ViewGroup 嵌套的情况，通常 LinearLayout 会比 RelativeLayout 的层级要少。还有一点就是要使用设备对应分辨率的资源文件，并不是图片越清晰就越好。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/180726_interview/overdraw.png" alt="Overdraw" title="">
                </div>
                <div class="image-caption">Overdraw</div>
            </figure>
<p>在“开发者模式”里面还有另一项相关的设置，叫做“GPU呈现模式分析”，可以将渲染时间以条形图📊的方式显示在屏幕底部，同时 16ms 的基准线也会以绿色绘制在屏幕中央。条形图中同一个条形的不同颜色表示绘制不同阶段</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/180726_interview/呈现模式分析.png" alt="呈现模式分析" title="">
                </div>
                <div class="image-caption">呈现模式分析</div>
            </figure>
<h3 id="绘制优化"><a href="#绘制优化" class="headerlink" title="绘制优化"></a>绘制优化</h3><p>主要是针对自定义 View 里面的代码编写，在 onDraw 这一步要尽量减少开销，因为 onDraw 方法是实时执行的，在一帧内会执行多次。因此，在 onDraw 中要避免出现以下两种情况</p>
<ul>
<li>创建局部对象，这会导致占用大量内存，频繁 GC</li>
<li>执行耗时操作，出现循环，这会占用 CPU 时间</li>
</ul>
<p>过度绘制优化，使用对应分辨率的资源文件</p>
<h2 id="速度优化（线程、网络）"><a href="#速度优化（线程、网络）" class="headerlink" title="速度优化（线程、网络）"></a>速度优化（线程、网络）</h2><h3 id="线程优化"><a href="#线程优化" class="headerlink" title="线程优化"></a>线程优化</h3><p>需要在子线程进行耗时操作，避免阻塞主线程</p>
<ul>
<li>HandlerThread：拥有自己 Looper 的线程类，可以在这个线程里进行耗时操作，然后通知主线程</li>
<li>AsyncTask：见下面一节“AsyncTask 知识点”</li>
<li>IntentService：运行在独立线程的 Service，原理是创建一个 HandlerThread，然后在 onStart 时把消息丢给 Handler 处理</li>
<li>ThreadPool：用 Executor、ThreadPoolExecutor 来管理线程</li>
</ul>
<h3 id="网络优化"><a href="#网络优化" class="headerlink" title="网络优化"></a>网络优化</h3><p>网络优化主要是从时间、速度、成功率几个角度来进行，对于提高速度，比较典型的是请求图片的场景</p>
<ul>
<li>使用WebP格式，能比 JPG 节约25%～35%的流量，比 PNG 节约80%流量</li>
<li>使用缩略图</li>
</ul>
<p>另外一些网络优化的知识点</p>
<ul>
<li>对网络请求进行缓存，若请求数据仍在有效期内则直接使用缓存，不走网络</li>
<li>减少 GPS 定位使用，条件允许则多用网络定位</li>
<li>下载过程中使用断点续传</li>
<li>刷新数据时采用局部刷新，少用全局刷新</li>
</ul>
<h2 id="电量优化"><a href="#电量优化" class="headerlink" title="电量优化"></a>电量优化</h2><ul>
<li>需要进行网络请求时，先判断网络当前状态</li>
<li>批量处理网络请求</li>
<li>在同时有wifi和移动数据的情况下，我们应该直接屏蔽移动数据的网络请求</li>
<li>减少后台任务</li>
</ul>
<h2 id="启动优化"><a href="#启动优化" class="headerlink" title="启动优化"></a>启动优化</h2><p>根据应用启动时候的状态，可以分为冷启动、热启动、暖启动三种，其中冷启动的耗时最长，对用户体验影响最大，因此谈启动优化主要是从冷启动的角度给出优化建议。</p>
<p>冷启动初始时，系统完成三个任务</p>
<ol>
<li>启动和加载应用</li>
<li>创建应用进程</li>
<li>显示启动视图（白屏）</li>
</ol>
<p>当应用进程创建完毕后，开始创建应用</p>
<ol>
<li>创建应用对象</li>
<li>启动主线程 (MainThread)</li>
<li>创建 Main Activity</li>
<li>加载视图 (Inflating views)</li>
<li>渲染布局 (Laying out)</li>
<li>执行初始绘制</li>
</ol>
<p>冷启动优化</p>
<ul>
<li>减少首页使用的资源，懒加载</li>
<li>优化首页布局，减少层级，不绘制不可见的 UI，而是使用 ViewStub 对象在适当的时间布局绘制</li>
<li>在闪屏页（Fragment）预先加载</li>
</ul>
<h1 id="AsyncTask-知识点"><a href="#AsyncTask-知识点" class="headerlink" title="AsyncTask 知识点"></a>AsyncTask 知识点</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>是为了解决 UI 线程无法进行耗时操作的问题而应用的一种 API，通常处理短时耗时任务（长时任务建议使用 Executor、ThreadPoolExecutor、FutureTask），有四个方法需要覆盖</p>
<ul>
<li>onPreExecute()，在 UI 线程调用，进行任务运行前的准备工作</li>
<li>doInBackground(Params…)，在后台线程运行，读取 execute 传来的参数，运行过程中可以通过 publishProgress(Progress…) 来发布进度信息，进度信息会以 onProgressUpdate(Progress…) 回调的方式通知 UI 线程</li>
<li>onProgressUpdate(Progress…)，在 UI 线程调用，接收进度信息</li>
<li>onPostExecute(Result)，在 UI 线程调用，接受任务运行结果</li>
</ul>
<h2 id="变更历史"><a href="#变更历史" class="headerlink" title="变更历史"></a>变更历史</h2><ul>
<li>最初问世，采用单线程模型，所有任务串行执行</li>
<li>DONUT（1.6），采用线程池模型，并发运行</li>
<li>HONEYCOMB（3.0），又改回单线程模型，为了简化使用，避免并发带来的同步问题</li>
</ul>
<h2 id="内部原理（API-26）"><a href="#内部原理（API-26）" class="headerlink" title="内部原理（API 26）"></a>内部原理（API 26）</h2><ol>
<li>AsyncTask 无参构造函数里会创建一个任务对象 mWorker（在其中执行 doInBackground），一个任务完成回调对象 mFuture，同时获取到 UI 线程的 Looper，用来在任务完成后通知 UI 线程</li>
<li>维护单例 SERIAL_EXECUTOR，用来串行执行任务</li>
<li>调用 AsyncTask.execute 时，会进入 executeOnExecutor 方法，在其内部先调用 onPreExecute，然后通过 executor 运行 mWorker，由 SERIAL_EXECUTOR 保证了串行运行，真正运行任务的是 THREAD_POOL_EXECUTOR</li>
<li>在任务完成后，通过 UI 线程的 Looper 通知 UI 线程</li>
</ol>
<h1 id="一个关于类的静态变量归属的问题"><a href="#一个关于类的静态变量归属的问题" class="headerlink" title="一个关于类的静态变量归属的问题"></a>一个关于类的静态变量归属的问题</h1><p>父类有一个 protected 的静态变量 foo，基于父类 A 创建两个子类 B1 和 B2</p>
<ul>
<li>如果 B1 和 B2 不声明变量 foo，那么它们使用的 foo 是同一个，来自父类 A</li>
<li>如果 B1 和 B2 都声明变量 foo，那么它们使用各自的变量</li>
</ul>
<p>简单概括就是说静态变量与类绑定，demo 如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// case 1</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">int</span> foo = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B1</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B2</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	A b1 = <span class="keyword">new</span> B1();</span><br><span class="line">	A b2 = <span class="keyword">new</span> B2();</span><br><span class="line">	System.out.println(<span class="string">"b1.foo = "</span> + b1.foo + <span class="string">"&amp; b2.foo = "</span> + b2.foo); <span class="comment">// b1.foo = 0 &amp; b2.foo = 0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// case 2</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">int</span> foo = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B1</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> foo = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B2</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> foo = <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	A b1 = <span class="keyword">new</span> B1();</span><br><span class="line">	A b2 = <span class="keyword">new</span> B2();</span><br><span class="line">	System.out.println(<span class="string">"b1.foo = "</span> + b1.foo + <span class="string">"&amp; b2.foo = "</span> + b2.foo); <span class="comment">// b1.foo = 100 &amp; b2.foo = 200</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2018-08-08T02:18:21.188Z" itemprop="dateUpdated">2018-08-08 10:18:21</time>
</span><br>


        
        这里可以写作者留言，标签和 hexo 中所有变量及辅助函数等均可调用，示例：<a href="/2018/07/26/interview-180726/" target="_blank" rel="external">https://lilei.pro/2018/07/26/interview-180726/</a>
        
    </div>
    
    <footer>
        <a href="https://lilei.pro">
            <img src="/img/avatar.jpeg" alt="Li Lei">
            Li Lei
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/面试/">面试</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://lilei.pro/2018/07/26/interview-180726/&title=《面试知识整理 2018.07.26》 — 柘个角落&pic=https://lilei.pro/img/avatar.jpeg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://lilei.pro/2018/07/26/interview-180726/&title=《面试知识整理 2018.07.26》 — 柘个角落&source=技术与生活上的点滴积累" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://lilei.pro/2018/07/26/interview-180726/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《面试知识整理 2018.07.26》 — 柘个角落&url=https://lilei.pro/2018/07/26/interview-180726/&via=https://lilei.pro" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://lilei.pro/2018/07/26/interview-180726/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2018/07/27/city-of-rock/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">缝纫机乐队</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2018/07/21/dianping-meituan-mobile-share-0721/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">美团技术沙龙第39期：新思路打造移动端高效研发体系 小记</h4>
      </a>
    </div>
  
</nav>



    











    <!-- Valine Comments -->
    <div class="comments vcomment" id="comments"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
    <!-- Valine Comments script -->
    <script>
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail,link'.split(',').filter(function(item){
          return GUEST_INFO.indexOf(item) > -1
        });
        new Valine({
            el: '#comments',
            notify: 'false' == 'true',
            verify: 'true' == 'true',
            appId: "khG3rBt0nWda7lxDUHpS3Sq0-gzGzoHsz",
            appKey: "btFkQfcBgJeCRm55mYmUgA5d",
            avatar: "mm",
            placeholder: "欢迎讨论",
            guest_info: guest_info.length == 0 ? GUEST_INFO : guest_info,
            pageSize: "10"
        })
    </script>
    <!-- Valine Comments end -->







</article>



</div>

        <footer class="footer">
    <div class="top">
        

        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>Li Lei &copy; 2015 - 2019</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://lilei.pro/2018/07/26/interview-180726/&title=《面试知识整理 2018.07.26》 — 柘个角落&pic=https://lilei.pro/img/avatar.jpeg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://lilei.pro/2018/07/26/interview-180726/&title=《面试知识整理 2018.07.26》 — 柘个角落&source=技术与生活上的点滴积累" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://lilei.pro/2018/07/26/interview-180726/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《面试知识整理 2018.07.26》 — 柘个角落&url=https://lilei.pro/2018/07/26/interview-180726/&via=https://lilei.pro" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://lilei.pro/2018/07/26/interview-180726/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACKElEQVR42u3aW7KCQAxFUeY/aRyABeyTtFaR3v1l4VVYfuTmdRz4nF+H/OX39fvXV1eWHRkyZLyWcd6elMF55PvJs8mQIWMfxtWN729J3iUYHo4vr8uQIUNGicqDKSHJkCFDRo2RfookeTJkyJDRKWJJQ63WaOPBekEtLkOGjBcyOmH0169/Mt+QIUPGqxhneO5hJASTMjV+KhkyZIxm8ABHUkZSaq4KuDJkyNiTUQtztYKzUwYvSxBlyJDxEgYPo2lrjFzhyeXDU8mQIWM0gxSlZMGrFojTcjeex8qQIWMEoz+kJJg0BJOfT4YMGfswOoVlWit36uxgwUKGDBnjGHxImbbvSbKYPsPld8qQIWM0o7YQVmuT1VK9zr8BGTJkzGCkobZfgraa/mTNQoYMGeMYnYHlqlFBrdCVIUPGPozOMgS/shb5sDMiQ4aMoYxaAC0mcDihDNp5MmTIGM3oLIHxcWb62XRUIEOGjN0YfDCQLo3VxpBBoJchQ8YGjAOftBlXW7NIS18ZMmTsxuADy/5yBh+LFucbMmTIGMRI075OqpcOR0kKK0OGjKmMMzxpm6w2sIxHBTJkyBjNSAvXdD2CBFbe+ucDVBkyZMxj1EJkra2W/mTkXjJkyNiHkQbKNDXkLTk+lpAhQ4aMTpDlY4Y0GX1ousmQIUMGDperWmxkyCpDhox9GKSI5QODWvLHg7IMGTJ2Y6SlIx838mTxT0NNGTJkvI/xAT8yQc8Zl+1gAAAAAElFTkSuQmCC" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>










</body>
</html>
