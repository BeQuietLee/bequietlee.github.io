[{"title":"《Java 并发编程实战》勘误表 2019-08-27","date":"2019-08-27T15:53:23.000Z","path":"2019/08/27/jcip-errata/","text":"Java Concurrency in Practice 是一本讲解 JVM 下并发编程知识的经典作品，建议有志于资深的 Java 工程师将其纳入自己的读书计划中，相信一定会大有裨益。 在阅读这本书的过程中，我发现中文版本有很多显而易见的错误，尤其是代码里条件判断有时根本是反着来的（本应是&gt;=的条件，书里面却是&lt;）。Google 搜索之后发现在 http://jcip.net/errata.html 有英文原版的勘误表，由于中文版本没有勘误表，故翻译在此，希望可以有所帮助。 使用之前请确认自己手中的书籍版本是否相符。 本文适用的中文版本 书名：《Java 并发编程实战》，Java Concurrency in Practice 作者：Brain Goetz, Tim Peierls 等 译者：童云兰 等 ISBN：978-7-111-37004-8 出版社：机械工业出版社 出版时间：2012.2 第一版，2018.9 重印 定价：69 元 豆瓣链接：https://book.douban.com/subject/10484692/ 勘误数据来源官方勘误表 中文版勘误表 页码 勘误 p.5 程序清单 1-1 下面的第一段，someVariable++应为value++ p.6 程序清单 1-2，Value应为value p.53 4.3 节上面的最后一段，getLocation应为getLocations p.58 程序清单 4-11，SafePoint(int x, int y)构造函数的函数体可以精简为set(x, y) p.62 程序清单 4-16，if(contains)应为if(!contains) p.75 5.3.1 第一段，DiskCrawler应为FileCrawler p.100 程序清单 6-7 下面第二段，在 ExcutorService 关闭后提交的任务将由“拒绝执行处理器（Rejected Execution Handler）来处理表述有误，Rejected Execution Handler是仅在ThreadPoolExecutor实现中提供的，并非所有的ExecutorService实现都具备此功能 p.122 第二行，那么调用 close 或 wakeup 方法会使线程抛出 ClosedSelectorException，只有close方法会抛出该异常，wakeup方法不会 p.163 程序清单 9-6，第一个if(runningTask != null)判断条件应为(runningTask == null) p.214 程序清单 12-9，Executors.newFixedThreadPool(MAX_SIZE)方法调用应该增加第二个参数threadFactory p.229 程序清单 13-3，代码倒数第三行if (System.nanoTime() &lt; stopTime)判断条件里的&lt;应为&gt;= 以上就是中文版《Java 并发编程实战》的勘误表，如有遗漏，欢迎通过文末留言联系我进行补充。","tags":[{"name":"Java","slug":"Java","permalink":"https://lilei.pro/tags/Java/"}]},{"title":"架构学习之 mvp-clean","date":"2019-08-20T16:11:55.000Z","path":"2019/08/21/architecture-todo-mvp-clean/","text":"I am the STORM!!! 上一篇文章介绍了 MVP 模式，作为 Android 最朴实的架构，MVP 足以应对复杂度较低的业务场景，回想 2014~2015 年在 DP 做预订闪惠的日子，用的便是 MVP。 然而随着业务复杂度增加，Presenter 层的逻辑会随之变重，导致的结果便是 Presenter 类过大，动辄一两千行代码，实在是丑陋。在这种场景下，Clean 架构是一个很好的选择。 关于 Clean什么是 Clean CleanArchitecture Clean 架构最初并不是为了针对 Android 平台的问题而提出，而是作为软件系统的通用架构被设计出来，如上面的同心圆所示，它的核心思想是The Dependency Rule（单向依赖原则），即只能从外层向内层依赖，内层对外层一无所知，外层的变动不应当影响到内层。 另一个重要概念是Use Case（用例），用例是业务逻辑的最小抽象单元，它调用数据模块的接口，向上（Presenter）提供业务逻辑操作入口。 Android Clean mvp-clean Android 平台在 Presenter 和 Model 之间定义了Domain Layer（域层），用于承载Use Case，如上图所示，Use Case 的背后是业务逻辑。Domain Layer 脱胎于 MVP 的 Presenter，这样可以避免相同的业务逻辑代码出现在两个 Presenter 中的问题。 Use Cases 异步性鉴于 Domain Layer 是 UI 无关的，这里可以统一将 Use Case 放入工作线程运行，通过异步回调进行通信。至于更底层的数据库/网络操作，出于简化的目的，可以直接使用同步接口。 不同 Layer 是否需要定义各自的 Model标准的做法是在视图层（View Layer）、域层（Domain Layer）和数据层（Data/Model Layer）分别使用不同的对象，如 VO、BO、DO 等。这样带来的问题是重复性增加。如果对象是不可变的，在各层之间具有相同的属性和方法，则可以只定义一个对象，共通使用。 如果视图层对象包含 Android 相关的方法或属性，则应当为其单独定义一个类，然后使用Mapper在不同层之间进行对象转换。 如何抽象业务场景这里我们将 Clean 模式应用在 todo-app 上，想想还有点小激动。 Use Cases &amp; Domain Layer把 Use Case 的声明和运行机制拆开，是不是跟 Runnable + Executor 的机制很像？没错，这就是设计模式中的命令模式。设计模式不是彼此孤立的，一个项目里可以整体采用 Clean 架构，不同的子模块，应用不同的设计模式。设计模式是死的，人是活的。 抽象类UseCase即是命令，包含入参、出参、回调通知对象、运行的抽象过程（这里又出现了模版模式）。 12345678910111213141516171819public abstract class UseCase&lt;Q extends UseCase.RequestValues, P extends UseCase.ResponseValue&gt; &#123; private Q mRequestValues; private UseCaseCallback&lt;P&gt; mUseCaseCallback; // 任务完成后（成功or失败）的回调 // ... // set and get //.. void run() &#123; // Executor 运行入口 executeUseCase(mRequestValues); &#125; protected abstract voi8d executeUseCase(Q requestValues); // 子类必需实体化这个方法 public interface RequestValues &#123;&#125; public interface ResponseValues &#123;&#125; // 接口约束 public interface UseCaseCallback&lt;R&gt; &#123; // 任务完成后的回调 void onSuccess(R response); void onError(); &#125;&#125; 然后选取一个“加载全部任务”的场景为例，看它是如何实现抽象类的，以下是GetTask.java的部分代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class GetTasks extends UseCase&lt;GetTasks.RequestValues, GetTasks.ResponseValues&gt; &#123; private final TasksRepository mTasksRepository; // 更底层的数据源对象 private final FilterFactory mFilterFactory; // 过滤器工厂类 public GetTasks(@NonNull TaskRepository tasksRepository, @NonNull FilterFactory filterFactory) &#123; // 构造时传入数据源对象和过滤器工厂 mTasksRepository = checkNotNull(tasksRepository, \"tasksRepository cannot be null!\"); mFilterFactory = checkNotNull(filterFactory, \"filterFactory cannot be null!\"); &#125; @Override protected void executeUseCase(final RequestValues values) &#123; // 利用泛型约束，在不同UseCase实现类里使用不同参数 if (values.isForceUpdate()) &#123; mTasksRepository.refreshTasks(); &#125; mTasksRepository.getTasks(new TasksDataSource.LoadTasksCallback() &#123; // 调用数据源异步方法 @Override public void onTasksLoaded(List&lt;Task&gt; tasks) &#123; TasksFilterType currentFiltering = values.getCurrentFiltering(); TaskFilter taskfilter = mFilterFactory.create(currentFiltering); List&lt;Task&gt; tasksFiltered = taskFilter.filter(tasks); ResponseValue responseValue = new ResponseValue(tasksFiltered); getUseCaseCallback().onSuccess(responseValue); &#125; @Override public void onDataNotAvailable() &#123; getUseCallback().onError(); &#125; &#125;); &#125; public static final class RequestValues implements UseCase.RequestValues &#123; private final TasksFilterType mCurrentFiltering; private final boolean mForceUpdate; // ... // constructor, get and set // ... &#125; public static final class ResponseValues implements UseCase.ResponseValues &#123; private final List&lt;Task&gt; mTasks; // ... &#125;&#125; 我在上述代码的注释里增加了一些说明，此外，有几处需要额外的注意： Use Case 构造函数里需要传入底层数据源对象，这意味着不可以在 Presenter 层直接构造 Use Case，因为 Presenter 不应当跨过 Domain Layer 直接访问数据源。—— 想想如何实现？IOC，DI，Bingo！ 在 Use Case 的类内部，以静态类的方式声明RequestValues和ResponseValues，代码集中，易于管理。UseCase.java基类中提供的空接口也利于不同的子类声明各自不同的参数类型。在模版方法executeUseCase里分别进行调用，化元归一。 Executor：任务执行机制命令模式由命令与执行机制两部分组成，Java 中的Executor框架就是一种典型应用。虽然Executor只是一个简单的接口，但它却为灵活而强大的异步任务执行框架提供了基础，该框架能支持多种不同类型的任务执行策略。它提供了一种标准的方法将任务的提交过程和执行过程解耦开来。 1234// Java 中的 Executor，不负责运行结果通知public interface Executor &#123; void execute(Runnable command);&#125; 项目里使用同样的机制作为UseCase的运行框架。 UseCaseScheduler.java 1234567public interface UseCaseScheduler &#123; // todo-mvp-clean 中的 Executor void execute(Runnable runnable); // 增加结果通知回调 &lt;V extends UseCase.ResponseValue&gt; void notifyResponse(final V response, final UseCase.UseCaseCallback&lt;V&gt; useCaseCallback); &lt;V extends UseCase.ResponseValue&gt; void onError(final UseCase.UseCaseCallback&lt;V&gt; useCaseCallback);&#125; 它的实现类采用线程池方式实现： UseCaseThreadPoolScheduler.java 1234567891011121314151617181920212223242526272829303132333435public class UseCaseThreadPoolScheduler implements UseCaseScheduler &#123; private final Handler mHandler = new Handler(); // 将运算结果通知主线程 public static final int POOL_SIZE = 2; public static final int MAX_POOL_SIZE = 4; public static final int TIMEOUT = 30; ThreadPoolExecutor mThreadPoolExecutor; // 使用线程池提供复用 public UseCaseThreadPoolScheduler() &#123; mThreadPoolExecutor = new ThreadPoolExecutor(POOL_SIZE, MAX_POOL_SIZE, TIMEOUT, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(POOL_SIZE)); &#125; @Override public void execute(Runnable runnable) &#123; mThreadPoolExecutor.execute(runnable); // 任务提交给线程池处理 &#125; @Override public &lt;V extends UseCase.ResponseValue&gt; void notifyResponse(final V response, final UseCase.UseCaseCallback&lt;V&gt; useCaseCallback) &#123; mHandler.post(new Runnable() &#123; @Override public void run() &#123; useCaseCallback.onSuccess(response); // 主线程处理结果 &#125; &#125;); &#125; @Override public &lt;V extends UseCase.ResponseValue&gt; void onError(final UseCase.UseCaseCallback&lt;V&gt; useCaseCallback) &#123; mHandler.post(new Runnable() &#123; @Override public void run() &#123; useCaseCallback.onError(); // 主线程处理结果 &#125; &#125;); &#125;&#125; UseCaseHandler：任务执行机制包装上文介绍了项目里采用Executor作为命令的运行框架，Executor接收的是Runnable类型的任务，我们还需要一层UseCase处理器，用于将UseCase封装成Runnable，并且处理任务的返回值。UseCaseHandler就是负责处理UseCase的组件。 UseCaseHandler.java，省略部分代码。 12345678910111213141516171819202122232425262728293031public class UseCaseHandler &#123; private static UseCaseHandler INSTANCE; // 单例模式，饿汉 public &lt;T extends UseCase.RequestValues, R extends UseCase.ResponseValue&gt; void execute(final UseCase&lt;T, R&gt; useCase, T values, UseCase.UseCaseCallback&lt;R&gt; callback) &#123; useCase.setRequestValues(values); useCase.setUseCaseCallback(new UiCallbackWrapper(callback, this)); mUseCaseScheduler.execute(new Runnable() &#123; @Override public void run() &#123; useCase.run(); &#125;); &#125; // UI回调包装器类，将成功/失败事件交给UI线程处理 private static final class UiCallbackWrapper&lt;V extends UseCase.ResponseValue&gt; implements UseCase.UseCaseCallback&lt;V&gt; &#123; private final UseCase.UseCaseCallback&lt;V&gt; mCallback; private final UseCaseHandler mUseCaseHandler; public UiCallbackWrapper(UseCase.UseCaseCallback&lt;V&gt; callback, UseCaseHandler useCaseHandler) &#123; mCallback = callback; mUseCaseHandler = useCaseHandler; &#125; @Override public void onSuccess(V response) &#123; mUseCaseHandler.notifyResponse(response, mCallback); &#125; @Override public void onError() &#123; mUseCaseHandler.notifyError(mCallback); &#125; &#125; UseCaseHandler隐藏了任务的执行机制，对外暴露出通过UseCase提交命令的接口，此时 Presenter 就可以借助UseCaseHandler来提交各项异步任务，并且获取回调。注意到回调是在 UI 线程发生的，意味着 Presenter 可以在回调中直接操作 UI 元素。 Activity：穿针引线的组织者与 MVP 架构一样，在 MVP clean 架构中，Activity 同样担任初始化 Fragment、Presenter 的职责。Activity 类是十分简单的，80% 的逻辑都写在onCreate当中。 TaskActivity.java 12345678910111213141516171819202122232425262728293031@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.tasks_act); // Set up the toolbar. // 初始化 ActionBar // ... // 初始化 DrawerLayout // ... // FragmentManager与Activity是一一对应的，所以这里通过R.id.contentFrame获取Fragment，在Activity B中也可以用R.id.contentFrame获取B当中的Fragment，不用担心重复 TasksFragment tasksFragment = (TasksFragment) getSupportFragmentManager().findFragmentById(R.id.contentFrame); if (tasksFragment == null) &#123; // Create the fragment tasksFragment = TasksFragment.newInstance(); ActivityUtils.addFragmentToActivity(getSupportFragmentManager(), tasksFragment, R.id.contentFrame); &#125; // 将使用到的Task用作构造参数，创建Presenter mTasksPresenter = new TasksPresenter( Injection.provideUseCaseHandler(), tasksFragment, Injection.provideGetTasks(getApplicationContext()), Injection.provideCompleteTasks(getApplicationContext()), Injection.provideActivateTask(getApplicationContext()), Injection.provideClearCompleteTasks(getApplicationContext()) ); // Load previously saved state, if available. if (savedInstanceState != null) &#123; TasksFilterType currentFiltering = (TasksFilterType) savedInstanceState.getSerializable(CURRENT_FILTERING_KEY); mTasksPresenter.setFiltering(currentFiltering); &#125;&#125; 随后在View.onResume中会调用Presenter.start来首次加载数据。 12345@Overridepublic void onResume() &#123; super.onResume(); mPresenter.start();&#125; 至此，MVP-clean 架构的设计思路就被我们分析透彻了，可以看出，相比于 MVP，clean 架构抽象出来 Domain 层，使具体的业务操作独立可复用，且减轻了 Presenter 类的负担。 还有一个好处是每一个 Use Case 都是可测试的，单元测试粒度被细化，更容易定位问题，从而针对性解决。关于测试我讲的不多，可以直接参考源码进行理解。 任务列表功能类图最后，我们将 todo app 的任务列表功能绘制成类图，加深理解。 mvp-clean-类图","tags":[{"name":"架构","slug":"架构","permalink":"https://lilei.pro/tags/架构/"}]},{"title":"架构学习之 mvp","date":"2019-08-20T16:04:52.000Z","path":"2019/08/21/architecture-todo-mvp/","text":"Life doesn’t give you what your want, it gives you what you DESERVE! 0x00 序言 Android Architecture Blueprints Google 官方在 GitHub 推出的Android 架构 Demo项目非常值得学习，通过 TODO app 的例子，讲解各种应用架构模式如何在实现需求的基础上，达到可维护性、扩展性、可测试性的优秀设计。 本系列博客文章聚焦于以下几点： 简明扼要介绍各个架构的思想与基础模型 在该架构模式下如何对 TODO App 的各个模块进行划分，以及划分的依据 取一个页面为例，作出类图，解析代码 Talk is cheap, show me the code. 0x01 业务逻辑建议 clone 代码后真机运行体验，用一张图概括如下。 页面流程图 Google 也给出了一个wiki 页面说明 TODO app 的特性。至于为什么选择这样一个应用作为 demo，官方给出的解释如下： 它必须足够简单，便于你很快地理解其功能；同时也要足够复杂，这样才能展现不同设计的决策以及提供测试场景。 0x02 todo-mvp关于 MVPMVP 脱胎于大名鼎鼎的 MVC（Model-View-Controller）。 mvc 但凡做软件开发的人应该对 MVC 都不感到陌生，它的基本思想是将数据、视图、控制逻辑拆分。这三部分可以自由进行替换，比如在不改变数据接口的情况下，替换数据来源；或者是调整 UI 显示，而无需改动业务逻辑。 MVC 是一个具有历史意义的架构模式，它对天马行空、一团乱麻的软件设计进行规约，使后续对程序的修改和扩展简化，并且使重用成为可能。但是，它并不是最适合 Android 开发的架构模式。 MVC 为什么不适合 Android 开发MVC 的核心思想是解耦，单一职责。在 Android 开发中，不使用 MVC 的主要原因是 Activity 的职责太重，往往要同时承担 View 和 Controller 的工作，这会造成 Activity 类非常庞大，UI 代码和逻辑代码交织，耦合严重。 MVP 为什么适合 Android 开发MVP 的架构如下图。 MVP 它单独抽出了 Presenter 对象，实现了业务逻辑，用于控制 View 的显示变化，以及与 Model 进行数据交互。Presenter 和 View 互相持有，Model 仅被 Presenter 持有。 在理想状态下，Presenter 和 Model 仅包含 Java 代码，不含 Android SDK 内容。MVP 架构解决了 MVC 中 Activity 职责过多的问题，将 UI 功能分配给 View 单独管理，View 的接口仅向 Presenter 开放，相比 MVC，更好地实现了职责单一、解耦的需求。 如何抽象业务场景Model设计从数据层开始，数据层要承担什么职责呢？其实就是CRUD： 保存新建的任务 查询已创建任务 更新任务状态（未完成 -&gt; 已完成） 删除任务 数据的持久化方式，数据操作结果采用同步还是异步，这些问题也是设计过程中要考虑的。 基本的任务对象：Task首先设计一个Task.java类，表示任务对象，它是一个典型的 Java Bean。在这里我们将 Task 设计成一个不可变的对象。在一个任务从“未完成”变为“完成”状态时，并不是修改原对象，而是丢弃掉原对象，再以相同id重新创建一个完成状态的对象。这样做的好处是逻辑简单，不可变对象线程绝对安全。缺点是当对象创建、销毁成本高的时候，会产生性能损失。在实际业务中应当酌情选择重用或者舍弃。 1234567public final class Task &#123; private final String mId; private final String mTitle; private final String mDescription; private final boolean mCompleted; ...&#125; Model 层对外暴露的接口：TasksDataSource本着面向接口编程的原则，隐藏数据操作具体实现代码，暴露出管理任务的接口（包含回调）。 123456789101112131415161718192021public interface TasksDataSource &#123; interface LoadTasksCallback &#123; // 加载复数任务回调 void onTasksLoaded(List&lt;Task&gt; tasks); void onDataNotAvailable(); &#125; interface GetTaskCallback &#123; // 加载单条任务回调 void onTaskLoaded(Task task); void onDataNotAvailable(); &#125; void getTasks(@NonNull LoadTasksCallback callback); void getTask(@NonNull String taskId, @NonNull GetTaskCallback callback); void saveTask(@NonNull Task task); void completeTask(@NonNull Task task); void completeTask(@NonNull String taskId); void activateTask(@NonNull Task task); void activateTask(@NonNull String taskId); void clearCompletedTasks(); void refreshTasks(); void deleteAllTasks(); void deleteTask(@NonNull String taskId);&#125; 这个接口里有两处与我的编程思路有出入。首先是加载任务回调，我认为可以仅保留复数任务的接口，对于加载单条任务的需求，返回一个长度为 1 的列表就可以了。其次，在命名上，我习惯于将同步接口以getXXX，异步接口以loadXXX来声明。 有了这个接口，就可以提供给任务详情、任务列表等页面使用。接下来创建一个接口实现类，这个类对外的职责是实现数据操作接口，对内的职责是隐藏两种具体的数据操作实现（内存缓存、数据库、网络）。 数据源共有三级缓存： In-memory cache - Fast Disk (SQLiteDb) - Slow Network - Very slow 12345public class TasksRepository implements TasksDataSource &#123; private final TasksDatasource mTasksRemoteDataSource; // 网络数据源 private final TasksDatasource mTasksLocalDataSource; // 本地数据源 ...&#125; 读写数据策略可以概括为“依次读，全部写”，括号里是我补充的内容： In every getoperation: Return cache if available, or return local copy if it exists (and update cache) , or return remote copy ( and update local copy &amp; cache) Every write/deleteoperation will simply: Update cache Update local Update remote 具体的网络数据源、本地数据库设计为常见写法，不赘述。 Fragment 即是 View处理所有 UI 变化事件，比如显示 loading、显示任务列表、显示任务详情、显示任务状态变更 SnackBar 等，值得注意的是页面跳转操作也属于 UI 变化，是在 Fragment 里面实现的。不妨思考一下为什么“跳转”不放在 Presenter 中进行？一个原因是 Presenter 与 Android SDK 无关，而跳转需要 Context 对象，违背了这一原则。比如从“任务列表”跳转到“任务详情”时： 123456// TasksFragment.java@Overridepublic void showAddTask() &#123; Intent intent = new Intent(getContext(), AddEditTaskActivity.class); startActivityForResult(intent, AddEditTaskActivity.REQUEST_ADD_TASK);&#125; View 里面没有任何业务逻辑，主要处理以下事件： 加载中、加载成功、失败页面展示 展现 Toast、SnackBar 等提示 处理按钮、菜单点击事件（通常是将其甩给 Presenter 处理） 处理页面跳转 声明 Adapter 在onResume时调用 Presenter 的start方法，启动页面 提供isActive方法，供 Presenter 在异步回调返回时判断页面是否存活 最后一点是容易漏掉的，如果异步请求回调时页面被销毁，会导致各种难以预料的问题。 123@Override public boolean isActive() &#123; return isAdded();&#125; Presenter - 业务逻辑载体承担了业务逻辑实现的职责，有时业务逻辑过于复杂会导致 Presenter 类太大，此时要考虑拆分业务逻辑到单独的类中，就变成了mvp-clean架构，clean 架构中使用Use Case（用例）处理细分的业务逻辑。 Presenter 由 Activity 构造，并且提供方法给 Activity 以及 View（Fragment）使用。 Activity - 将一切粘合到一起现在我们有了 Model、View、Presenter 各个部分，而 Android 应用的页面入口是 Activity 类，我们在 Activity 中创建 Fragment（View）及 Presenter，在这两者之间建立关联。同时还要处理一些必须放在 Activity 中进行的操作，比如onSaveInstanceState、onOptionsItemSelected 等等。 任务列表功能实现用类图来表示 MVP 模式下的任务列表功能相关类： mvp","tags":[{"name":"架构","slug":"架构","permalink":"https://lilei.pro/tags/架构/"}]},{"title":"ACE-PTM 第 II 部分 领导和实施","date":"2019-07-14T10:16:42.000Z","path":"2019/07/14/ace-cpt-part-2/","text":"第 2 章 - 激励和坚持原则只有约20%的美国成人同时符合有氧活动和肌肉强化指南要求。健身专业人员面临着两大挑战：让人们积极开始以及之后坚持运动计划。本章重点是提高人们在开始之后坚持计划的可能性。 激励人开始锻炼的因素不一定是使他们长期参与运动计划的因素。健康和健身行业的真正挑战是创造出适宜的计划和运动环境，使人们尽可能提高坚持计划并选择积极生活方式的可能性。 了解激励用于评估激励的两种最常讨论方法是内在与外在激励和自我效能。 内在和外在激励在运动背景下，要实现内在激励，意味着一个人是因为参与本身所带来的内在愉悦和体验而从事运动活动。 与其认为需要让自己的客户受到更多的内在激励，私人教练应更努力增加参与计划所带来的愉悦感和成就感。私人教练通过鼓励客户拥有并参与计划以及教授自足性和自主性，可以帮助促进内在激励的形成。 自我效能在运动背景下，自我效能定义为个体对自身成功参与体力活动计划的能力和信念。自我效能与激励呈正相关。 许多健身专业人员所犯的一个重大错误是安排整堂课进行评估，不要让客户感觉像在做测试，在某些情况下，甚至不要让客户知道你在收集评估信息。 用于保持客户激励的策略私人教练应当告知客户可能会出现回复原态并使其提前做好准备，以便他们能够在回复原态后立即重新坚持活动计划。第一步是宣教，第二步是支持。 社会支持开发和维护运动的社会支持网络。教练应当尽量多利用团体参与和社交互动的机会，让客户感觉自己属于该计划，并且是具有共同兴趣和目标的成员所组成团队的一部分。 自我肯定教导客户进行自我肯定。 自我调节教导客户成为有效的自律者，自我监督行为、日程、时间和优先事项。 高风险情况时间管理技能不佳、缺乏社会支持或日程繁忙的个人最有可能回复圆台。私人教练必须不断了解并观察客户是否出现受打击、沮丧或疲惫的迹象。 影响运动参与和坚持度的因素体力活动的潜在决定因素可分为三类： 个人特质 环境因素 体力活动因素 个人特质人口统计变量健康状况过往的运动经验心理特质认识、态度和信念环境因素设施便利性时间社会支持体力活动因素强度损伤反馈 外部反馈：私人教练为客户提供的强化、纠错和鼓励。 内部反馈：客户根据自己的感觉系统（感受到、看到或听到的内容）为自己提供的相应信息。长期计划坚持度取决于客户提供自我反馈的能力。 领导特质对客户的进展表现出持续不断地关心和兴趣是贯穿私教职业生涯的一部分。私人教练使用系统性目标设定以及教授回复原态预防技巧的目的是，告诉客户他们对客户的关心远远超出这一小时课程的范围。 私人教练爱建立坚持度中的作用计划设计私人教练必须能够针对每个客户的偏好、时间表、经验、顾虑和约束条件（例如，钱、便利性和时间）设计计划。 角色清晰度在一段关系中分歧和冲突产生的常见原因是角色模糊。 目标设定目标设定应当遵循SMART原则。 避免设定过多目标 避免设定负向目标 设定短期和长期目标以及过程目标和成绩目标 定期重审目标 合同/协议使用行为合约和书面协议。 第 2 章 - 习题集1. 对于刚开始参加运动方案的个体而言，最重要的因素是什么？ 家庭和朋友的大力支持 运动设施的便利性 与运动有关的行为改变意愿度 与私人教练联络 错误选项（1），正确答案（3）。真正的动机都来源于内心。 4. 为了确保客户坚持参加训练，私人教练最好采用下列哪种策略？ 为客户设计运动方案，这样客户就只训练，而不会对运动本身想太多 通过内在动机因素对客户进行激励，以提升其自我效能 鼓励客户独立安排运动方案，从而促进客户提升内在动机 主要通过指引（而非教育）建立自己的运动教学风格 错误选项（2），正确答案（3）。教练不是通过“内在动机”对客户进行激励的。教练的目的是提升内在动机。 9. 在监督式环境中运动，最可能与运动坚持水平无关的因素是？ 教育 年龄 收入 性别 错误选项（3），正确答案（2）。其余几个选项都有相关。 11. 坚持的定义为：一种将行为赋予方向和目的的心理驱动力。 正确 错误 错误选项（1），正确答案（2）。坚持是积极主动地参加运动方案；激励则是心理驱动力。 13. 身体活动的三种主要潜在决定因素不包括哪一项？ 个人特质 身体特质 环境因素 体育活动因素 错误选项（1），正确答案（2）。其中1、3、4是体育活动的潜在决定因素。 18. 下列术语种，哪一项的定义为：相信自己有能力成功开始并坚持某种行为？ 内在激励 自我效能 外在激励 心里控制源 错误选项（1），正确答案（2）。注意这是“效能”的定义。 第 3 章 - 沟通和教学技巧第 4 章 - 行为改变与健康心理学基础","tags":[{"name":"健身","slug":"健身","permalink":"https://lilei.pro/tags/健身/"},{"name":"ACE-CPT","slug":"ACE-CPT","permalink":"https://lilei.pro/tags/ACE-CPT/"}]},{"title":"ACE-PTM 第 I 部分 简介","date":"2019-07-14T09:32:41.000Z","path":"2019/07/14/ace-cpt-part-1/","text":"笔记前言 作为学习 ACE-CPT 的读书笔记，这一系列将按章节分为七个部分。 第 I 部分 - 简介介绍私人教练的角色定位与执业范围，哪些事情应该做，哪些事情可以做，哪些事情不能做。 第 II 部分 - 领导和实施从沟通、激励会员角度给出指导意见，是贯彻执教过程始终的中心思想，帮助教练与会员建立相互信赖的关系。 第 III 部分 - ACE 整合式健身训练模式即 ACE-IFT 训练模式，是 ACE 独家的训练计划与模式，先评估，然后在稳定性、抗阻、心肺等多方面分别给出指导。 第 IV 部分 - 特殊运动计划制定主题讲解身心运动以及特殊人群的运动方法。 第 V 部分 - 损伤预防和急救常见损伤对运动过程的影响，以及遭遇损伤时候的紧急程序。 第 VI 部分 - 职业和法律责任以及业务策略私人教练职业的法律指南。 第 VII 部分 - 补充涵盖不属于上述章节的内容。 第 1 章 - 私人教练的角色和执业范围健康照护联盟健康照护联盟由医疗保健专业人员组成，他们通过执照、注册和/或许可证获得认可，并提供相关服务以识别、预防和治疗疾病和病症。 团队成员构成如下： 针灸师 脊椎按摩师 营养师 自然疗法医生 护士 医生 行为医师 物理治疗师 职业物理治疗师 运动教练 ACE 私人教练认证专业能力门槛被称为从事某种行业所需的“最低能力”。对于专业人员而言，执照可以将其与未证明自己处于同一能力水平的人区分开。通过获得 ACE 私人教练认证，专业人员证明了其在以下方面的能力：应用相关知识在各种实际情况下做出安全有效的运动计划决策，同时最大限度地减少客户风险和伤害。 “执业范围”的定义ACE 认证的私人教练的执业范围根据 IDEA 私人健身教练的执业范围 表格，私人教练不可以做以下事情： 进行诊断 开处方 为客户规定饮食或推荐具体的补充剂 治疗伤害或疾病 监督医疗转介绍客户的进展 提供康复服务 提供咨询 与患者合作 ACE 认证的私人教练的知识、技能和能力ACE 私人教练考试包括以下领域 客户面谈和评估 - 31% 计划设计和执行 - 33% 进阶和调整 - 19% 专业行为、安全性和风险管理 - 17% 教育和经验建议应试者流出平均三至四个月的学习时间来充分准备私人教练认证考试。 执业责任和道德规范ACE 制定了ACE 道德准则，所有 ACE 认证的专业人员和应试者都必须熟悉并遵守道德准则和专业时间和纪律程序。 ACE 专业实践和纪律程序执照期和续期ACE 认证有效期为两年，从获得认证之日起开始计算，于当月最后一天到期。续期则需要完成至少 20 小时的持续教育学分（2.0 CEC），并持有当前的心肺复苏（CPR）证书。如果持证人生活在北美，则必须能够正确使用自动外部除颤器（AED）。 ACE 为超过截止期限的专业人员的续期留出六个月的延长期限。 客户隐私转介绍补充剂和其他营养相关问题补充剂不受美国食品和药物管理局（FDA）管制，因此无法保证起强度、纯度、安全性和效果。私人教练仅仅有资格向客户推荐补充剂，而没有资格推荐药物或开具药物。 所提供服务超出执业范围的后果由 NCCA 进行的健康照护联盟资格证书认证健身与健康行业的认可教育界的认可ACE 教育伙伴计划提供四门独立的大学课程： 私教 团体运动 健康教练 特殊人群运动课程 劳工部的认可职业发展持续教育高级知识专业化学位额外的健身执照健康照护联盟的新专业领域 第 1 章 - 习题集6. 下列哪一项属于 ACE 认证私人教练的执业范围？ 帮助客户更好地了解食物分量与健康食品，从而帮助他们做出更明智的选择 为客户提供 4 周食谱与购物清单，帮助他们走上健康饮食的正轨 回顾过去 24 小时的饮食情况，帮助客户了解自己缺少哪些微量元素 就惊喜代谢率（RMR）以及热量摄入要小于 RMR 等知识对客户进行教育，帮助客户减轻体重 错误选项（4），正确答案（1）。关键点在于选择权由客户持有，而非私人教练做出选择 or 决定。 9. 关于私人教练向客户推荐营养补充剂，下列叙述最恰当的一项是 只能向客户推荐自己已投职业责任险的补充剂 如果私人教练未持有注册营养师或医学博士学位等其他帧数，则不具有向他人推荐补充剂的合法资质 私人教练应接受专门的知识培训后才能向客户推荐营养补充剂 由于服用补充剂与其他药物可能会引起并发症，私人教练只能向客户推荐植物性补充剂 错误选项（3），正确答案（2）。“专门的知识培训”不够精确。 15. “执业范围”的定义不包括哪一项？ 专业健身人员在特定领域可提供的合法服务范围 在工作场所必须遵守的职业道德准则 可以供私教服务的场所 必须遵守的指南或参数标准 错误选项（3），正确答案（2）。道德是道德，业务是业务。 20. 如果客户提到自己参加周末网球比赛后肌肉酸痛，教练给予的最恰当的回应是？ 推荐客户服用抗炎类非处方药 建议客户在下次比赛前服用肌酸补充剂 对深层组织进行按摩处理，帮助缓解肌肉酸痛 与客户探讨对患处进行冷敷的正确方法 错误选项（3），正确答案（4）。其余选项超出执业范围。","tags":[{"name":"健身","slug":"健身","permalink":"https://lilei.pro/tags/健身/"},{"name":"ACE-CPT","slug":"ACE-CPT","permalink":"https://lilei.pro/tags/ACE-CPT/"}]},{"title":"ACE-CPT 考试信息汇总","date":"2019-07-14T09:27:29.000Z","path":"2019/07/14/ace-cpt-qualification/","text":"国内自考ACE-CPT心得（一）考试流程 国内自考ACE-CPT心得（二）读者问答 教材哪里买 四大认证 ACSM NSCA ACE NASM 教材1000页教材，需要100h学习时间。 官网英文版 官网翻译版 培训机构翻译版 教材 Personal Trainer Manual —— 主要教材，80%考题来源于此 Essential of Exercise Science —— 辅助材料，解剖、营养、生理等 Study Companion —— 课后习题 宣传手册 —— 没用 官网有在线模拟题。 考题分布。 考题分布 考试携带身份证、驾照、护照、CPR证。 3小时，150道单选题，125题计入总分。每道题都有英文原文和中文翻译。开考前会提供纸笔。 电脑上有工具： 题目标记 未答题数量 计算器 考试提交后立马出分数。总分800分，超过500分及格。 报名官网报名。399刀。 提前一个月申请考场。 急救培训：CPR or AED，在当地红十字会报名，一周末拿证。 继续教育两年内 2.0 学分 + CPR","tags":[{"name":"健身","slug":"健身","permalink":"https://lilei.pro/tags/健身/"},{"name":"ACE-CPT","slug":"ACE-CPT","permalink":"https://lilei.pro/tags/ACE-CPT/"}]},{"title":"《高效能人士的七个习惯》第四部分 再论由内而外造就自己","date":"2019-04-07T03:00:29.000Z","path":"2019/04/07/Seven-Habbits-11/","text":"利用刺激与回应之间的距离上帝行事由内而外，尘世行事由外而内；尘世让世人摆脱贫穷，耶稣则先让世人摆脱内心的贫穷，然后由他们自己摆脱贫穷；尘世通过改变环境来造就人，耶稣则通过改变人来造就环境：尘世塑造人的行为，而耶稣改变人的本质。 刺激与回应之间存在一段距离，成长和幸福的关键就在于我们如何利用这段距离。 我们用新颖而有趣的方式利用刺激与回应之间的那段距离，思考自己如何变成了今天的自己以及这些过程如何决定了我们的世界观。 从一开始，我们就极力互相支持、鼓励和体谅，这让我们能够更进一步地探索彼此的内心世界，而我们之间的关系也得到滋养。 我们逐渐有了两项心照不宣的基本规则。一是“不要刨根问底”：无论哪个人露出了内心最脆弱的一面，另一人都不得追根究底，而是要尽力体谅对方，否则就显得太过咄咄逼人、霸道和刻板。二是在话题过于尖锐或痛苦的时候，我们就要及时打住，晚些时候或者等到第二天再说，直到当事人愿意再次开口。 我们发现，看似琐碎的小事，往往也源自铭心刻骨的情感经历，如果只看表面，而没有挖掘深层的敏感问题，无异于在践踏对方心中的圣土。 爱情保鲜的秘诀就是交谈，特别是讨论彼此的感受。 代际传承我们的行为模式会对子女的生活产生难以置信的影响，就好像我们的父母影响了我们一样。他们不仅让我们了解了自己是什么样子的人，而且让我们知道自己通过努力可以成为什么样的人。 一个关系紧密、几代同堂的大家庭往往有一种超常的力量，能帮人们确认自我。让孩子们在这样的“部落”中找到自己的位置，时时感到被关怀。几代同堂的和睦家庭可能蕴含着最富有成效，回报最高，最令人满意的相互依赖关系，许多人都能感觉到这种关系的重要性。 成为转型者在你的家族中已经延续数代的趋势可以在你这里画一个句号。你是一个转型者，连接着过去和未来，你自身的变化可以影响到后世的许多人。 真正的变革是由内向外实现的，只是利用性格魅力的技巧，在态度和行为方面做些表面功夫根本不行，一定要从根本上改变那些决定了我们的人格和世界观的思想构造和行为模式才行。 再次引用艾默生（Emerson）的名言：“在我们的不懈努力下，事情变得可以迎刃而解，这并不是因为任务的性质发生了变化，而是因为我们的能力增强了。”","tags":[{"name":"高效能人士的七个习惯","slug":"高效能人士的七个习惯","permalink":"https://lilei.pro/tags/高效能人士的七个习惯/"}]},{"title":"《高效能人士的七个习惯》第四部分 自我提升和完善","date":"2019-04-07T03:00:29.000Z","path":"2019/04/07/Seven-Habbits-9/","text":"习惯七：不断更新","tags":[{"name":"高效能人士的七个习惯","slug":"高效能人士的七个习惯","permalink":"https://lilei.pro/tags/高效能人士的七个习惯/"}]},{"title":"《高效能人士的七个习惯》第三部分 习惯六 统合综效——创造性合作的原则","date":"2019-04-07T03:00:29.000Z","path":"2019/04/07/Seven-Habbits-8/","text":"统合综效的基本态度是如果以为具有相当聪明才智的人跟我意见不同，那么对方的主张必定有我尚未体会的奥妙，值得加以了解。 与人合作最重要的是，重视不同个体的不同心理、情绪与智能，以及个人眼中所见到的不同世界。假如两人意见相同，其中一人必属多余。与所见略同的人沟通，毫无益处，要有分歧才有收获。 统合综效的精髓是判断和尊重差异，取长补短。 敞开胸怀，博采众议所谓统合综效的沟通，是指敞开胸怀、接纳一切奇怪的想法，同时也贡献自己的浅见。 凡是创新就得承担，不怕失败，不断尝试错误。只愿稳扎稳打的人，经不起此种煎熬。 沟通三层次低层次的沟通源自低度信任，其特点是人与人之间互相提防，步步为营，经常借助法律说话，为情况恶化作打算，其结果只能是赢/输或者输/赢，而且毫无效率可言，即产出/产能不平衡，结果只能是让人们更有理由进行自我防御和保护。 中间一层是彼此尊重的交流方式，唯有相当成熟的人才办得到。但是为了避免冲突，双方都保持礼貌，却不一定为对方设想。在相互依赖的环境中，最常用的态度是妥协。 统合综效意味着1+1等于8或者16，甚至1600。源自高度信任沟通的层次。 寻求第三条道路高余额的情感账户、双赢模式、先理解别人的原则，所有这些加在一起，就是实现创造性统合综效的理想环境。 消极协作减效人际关系最可贵的地方就是能接触到不同的模式。相同不是统一，一致也不等于团结，统一和团结意味着互补，而不是相同。相同毫无创造性可言，而且沉闷乏味。统合综效的精髓就是尊重差异。 尊重差异自以为是的人总以为自己最可观，别人都有所偏颇，其实这才是画地为牢。反之，虚怀若谷的人承认自己有不足之处，而乐于在与人交往之中汲取丰富的知识见解，重视不同的意见，因而增广见闻。 化阻力为动力在互赖关系中，统合综效是对付阻挠成长与改变的最有力途径。 动力通常是积极、合理、自觉、符合经济效益的力量；相反地，阻力多半消极、负面、不合逻辑、情绪化、不自觉，具社会性与心理性因素。这两组作用力都是真实存在的，在应变时都要考虑周全。 不涉法削减阻力，只一味增加推力，就仿佛施力于弹簧上，终有一天引起反弹。 这并不意味着拒绝采取法律手段，有些时候法律手段时绝对必要的，但是我认为它只应该在最后关头发挥作用，而不是问题刚一出现的时候，过早使用只会让恐惧心理和法律模式制约了统合综效的可能性。 自然界是统合综效的最佳典范你应该尊重自己善于分析的一面和富有创造力的一面，尊重它们的差异会催生你的创造力。 即使处于不利境地，也不应该放弃追求统合综效。不要在意别人的无礼行径，避开那些消极力量，发现并利用别人的优势，提高自己的认识，扩展自己的视野。你应该在相互依赖的环境中勇敢而坦率地表达自己的观点、情感和经历，借此鼓励他人同样地坦诚相待。 尊重人与人之间的差异，当有人不同意你的观点的时候，你应该说：“你跟我有不一样的看法，这很好。” 付诸行动 想一想谁总是跟你的看法不一样，用什么方法可以把这些差异变成通往第三条道路的阶梯。可以就当前的某个项目或者某个问题请教这个人的意见，珍惜这些不同的见解。 列一张名单，写上让你觉得不快的人的名字。如果你内心有更充足的安全感，能够做到尊重差异，你是否会觉得这些人代表了不同意见，而你可借此实现与他们的统合综效？ 想一想在什么情况下你更需要统合综效？统合综效需要哪些条件来支持？怎样才能创造出这些条件？ 下一次当你同某人意见相左或者发生冲突的时候，尽量理解他的立场和顾虑，以创造性的、互惠互利的方式解决问题。","tags":[{"name":"高效能人士的七个习惯","slug":"高效能人士的七个习惯","permalink":"https://lilei.pro/tags/高效能人士的七个习惯/"}]},{"title":"《高效能人士的七个习惯》第四部分 习惯七 不断更新——平衡的自我更新的原则","date":"2019-04-07T03:00:29.000Z","path":"2019/04/07/Seven-Habbits-10/","text":"人生最值得的投资就是锻炼自己，因为生活与服务人群都得靠自己，这是最真贵的工具。 工作本身并不能带来经济上的安全感，具备良好的思考、学习、创造与适应能力，才能立于不败之地。拥有财富，并不代表经济独立，拥有创造财富的能力才真正可靠。 自我提升和完善的四个层面习惯七就是个人产能。它保护并优化你所拥有的最重要的资产——你自己。它从四个层面更新你的天性，那就是：身体、精神、智力、社会/情感。 身体层面身体层面指有效呵护我们的身体——健康饮食，充足休息以及定期锻炼。 锻炼属于第二类事务，但是由于不具紧迫性，所以很少人能坚持不懈，结果终有一天我们会发现自己陷入了第一类事务，不得不面对健康问题和危机，而原因正是之前对锻炼的忽视。 锻炼的所有好处几乎都产生于最后阶段。我想增强力量，就必须等到肌肉纤维撕裂，神经纤维感到疼痛才行，因为这时候自然机制才会予以过度补偿，纤维在 48 小时后会变得更加坚韧。 情感“肌肉”（比如耐心）也是一样。当对耐心的磨练超越过去的记录时，情感纤维就会断裂，自然机制就会予以过度补偿，下一次纤维就会更加坚韧。 刚开始时也许你并不喜欢锻炼，甚至还很厌恶，但是一定要积极一点，坚持下去。在你执行慢跑计划期间，即使清晨有雨，也不能放弃。而是要想太好了！下雨了！我可以在锻炼身体的同时磨练意志。 精神层面精神层面的更新为你指引人生的方向，与习惯二密切相关。 有些人是通过欣赏优秀的文学或音乐作品来实现精神层面的更新，还有些人是通过与自然交流来达到同样目的。我的做法是每天认真阅读和思考《圣经》。 大自然会赐福给哪些沉浸在自然中的人。当你远离城市的喧嚣与混乱，尽情享受过大自然的和谐与韵律，再回到城市时会感到耳目一新，在一段时间内，没有什么能够干扰你或让你惊慌失措，直到外界的喧嚣混乱再次侵蚀到你内心的静谧和安详。 个人的使命宣言至关重要。一旦深刻理解了生活的中心和目标，我们就可以不断反思，持之以恒，在更新精神层面的过程中，就可以抱着坚定的信念，构想并实践每一天的活动。 仔细聆听，设法回头，检讨动机，把忧愁埋进沙子里。 智力层面我们大多数人的智力发育和学习习惯都源自正规教育。但是，一旦脱离了学校的训导，许多人的头脑就会退化：不再认真读书，不再探索身外的新世界，不再用心思考，也不再写作，至少是不再重视写作，不再把它当作考验我们准确、扼要表达自己的能力的方式。相反，我们把时间花在了看电视（或者是网上冲浪）中。 电视的确让生活变得丰富多彩，但是，还有很多电视节目完全是在浪费我们的时间和头脑。 养成定期阅读优秀文学作品的习惯是拓展思维的最佳方式。可以从每个月读一本书开始，然后每两周读一本书，接着是每周读一本书。 磨砺心志的另一种有效方式是写作。如果能够在写信的时候与他人深入交流思想、感受和理念，而不是肤浅地停留在事物表面，也有助于我们提高思考、推理和获取他人理解的能力。 社会/情感层面社会/情感层面的更新并不像其它层面的更新那样需要花费大量的时间，我们可以在与他人的日常交往中完成这项工作，但练习还是必要的。习惯四、五、六是你在练习当中需要时时关注的地方，这些习惯成功的关键不是智力问题，而是情感问题，与我们个人的安全感密切相关。 改变他人后来，当她又要恢复到旧有的行为模式时，生命垂危的骑士把她叫到病床前，唱起了那曲动人的《无法实现的梦》（The Impossible Dream）。他凝视她的双眼，轻声说：“永远不要忘记，你是杜尔西内娅”。 我们可以选择清晰而真实地反映出他人的形象，肯定他们的积极性和责任心，帮助他们改变行为模式，成为讲原则，懂判断，独立自主，有价值的个体。知足心态让我们意识到，反映他人的正面形象并不会贬低我们自己，而会使我们更强大，因为它增加了我们与其他积极主动者有效交往的机会。 歌德（Goethe）说：“以一个人的现有表现期许之，他不会有所长进。以他的潜能和应有成就期许之，他定能不负所望。” 平衡更新自我提升和完善的过程必须包括天性中的所有四个层面：身体、精神、智力、社会/情感。 企业力争上游的道理也是这样。谋利固然是企业经营的基本目的，但并非企业存在的唯一目的。犹如生命少不了食物，但人绝非为吃而活。 更新中的统合综效人生的四个层面休戚相关：身体健全有助于心智发展，精神提升有益于人际关系的圆满。因此，平衡才能产生最佳的整体效果。 身体层面的自我更新等同于强化个人愿景（习惯一）。它帮助我们增强积极性、自我意识和独立意志，让我们知道自己是自由的，不需要被动地承受他人的行为后果，这也许是锻炼身体的最大好处。 精神层面的更新等同于强化自我领导（习惯二）。它帮助我们更好地按照想象和良知（而不只是回忆）行事，深入理解个人思维和价值观，确定核心的正确原则，明确自己在生活中的独特使命，改变思维和行为模式，以及坚持正确原则并利用个人的资源优势。 精神层面的更新让个人的生活变得更加丰富。 智力层面的更新等同于强化自我管理（习惯三）。它帮助你在做计划的时候确定第二类事务的重要活动，优先能够有效利用时间和精力的目标与活动，然后围绕这些组织并展开活动。不断接受教育帮助你巩固知识基础，增加选择范围。稳定的经济基础并非来自于工作，而是来自于个人的产能（思考、学习、创造、调整）。真正的经济独立指的不是家财万贯，而是拥有创造财富的能力，这是内在的。 “每天的个人领域的成功”（每天至少用一个小时实现身体、精神和智力层面的更新）是培养七个习惯的关键，完全在个人的影响圈范围内。 螺旋式上升良知是人类独特的天赋，帮助我们判断自己是否背离了正确的原则，然后引导我们向这些原则靠拢。 垃圾食品和缺乏锻炼会毁掉运动员的健康。同样，淫秽、粗俗或色情的东西会使我们的灵魂陷入黑暗之中，削弱我们的判断能力，不再关心是非对错（自然而神圣的良知），只在乎自己是否会被揭发“社会良知”。 哈马舍尔德（Dag Hammarskjold，前联合国秘书长）说过：把玩内心兽性的人，早晚会变成真正的野兽；整天弄虚作假的人，终将失去获得真理的权利；暴虐成性的人，头脑的判断力会日益减退。如果真的要保持花园整洁，就不能让杂草有立足之地。 要实现这个良性循环，就必须学习、坚持、实践，并沿着螺旋式上升的路线不断提高实践的层次。如果以为做到一项就已足够，完全是在自欺欺人。 付诸行动 写出有助于保持良好的身体状态，符合你的生活方式，能让你从中得到乐趣的活动清单。 挑选其中一项活动，把它列为你下周的个人活动的目标。 到一周结束时，评估自己的表现，如果没有实现目标，就思考一下原因，是因为你更看重一种更高尚的价值观，还是因为你未能遵循自己的价值观行事。 列出在精神和智力层面自我提升和完善的活动清单，在社会、情感层面希望改善的人际关系以及能依靠公众成功来提高效能的具体领域。在每个层面中挑选一项活动，列为本周目标，付诸实施并加以评估。 坚持每周写下所有四个层面的具体“磨刀”行动，付诸实施并评估自己的表现和效果。","tags":[{"name":"高效能人士的七个习惯","slug":"高效能人士的七个习惯","permalink":"https://lilei.pro/tags/高效能人士的七个习惯/"}]},{"title":"《高效能人士的七个习惯 第三部分 习惯五 知彼解己——移情沟通的原则","date":"2019-04-07T03:00:29.000Z","path":"2019/04/07/Seven-Habbits-7/","text":"你真的听懂了吗如果你要和我交往，想对我有影响力，你首先要了解我，而做到这一点不能只靠技巧。如果我觉察到你在使用某种技巧，就会有受骗和被操纵的感觉。我不知道你为什么这样做，有什么动机。 你的影响力在于你的榜样作用和引导能力，前者源于你的品德，是你的真我，别人的评论或者你希望别人如何看你都没有意义，我在同你的交往中已经清楚了解了你。 你的品德时刻发挥着影响力，并起着沟通的作用。久而久之，我就会本能地信任或者不信任你这个人以及你对我所做的事情。 移情聆听“知彼”是交往模式的一大转变，因为我们通常把让别人理解自己放在首位。大部分人在聆听时并不是想理解对方，而是为了做出回应。这种人要么说话，要么准备说话，不断地用自己的模式过滤一切，用自己的经历理解别人的生活。 事实上，大部分人都是这么自以为是。我们的聆听通常有层次之分。一是充耳不闻，压根就不听别人说话；二是装模作样，“是的！嗯！没错！”三是选择接受，只听一部分，通常学龄前儿童喋喋不休会让我们采取这种方式；四是聚精会神，努力听到每一个字，但是，很少有人会达到第五个层次，即最高层次——移情聆听。 移情聆听是指以理解为目的的聆听，要求听者站在说话者的角度理解他们的思维模式和感受。 移情（Empathy）不是同情（Sympathy）。后者是一种认同和判断形式，更适合用来表达感情和做出回应，却容易养成对方的依赖性。移情聆听的本质不是你要赞同对方，而是要在情感和理智上充分而深入地理解对方。 据专家估计，人际沟通仅有10%通过语言来进行，30%取决于语调与声音，其余60%则得靠肢体语言。所以在移情聆听的过程中，不仅要耳到，还要眼到、心到；用眼睛去观察，用心灵去体会。 心理空气除了物质，人类最大的生存需求源自心理，即被人理解、肯定、认可和欣赏。 移情聆听是有风险的。只有当你做好了被对方影响的准备，才能深入到移情聆听的阶段，而这是需要足够的安全感的，因为这时候的你会变得很脆弱。从某种意义上说，这很矛盾，因为在影响对方之前，你必须先被影响，即真正理解对方。 先诊断后开方平庸的业务员推销产品，杰出的业务员销售解决问题、满足需求之道。万一产品不符合客户需要，也要勇于承认。 四种自传式回应我们在听别人讲话时总是会联系我们自己的经理，因此自以为是的人往往会有四种“自传式回应”（Autobiographical Response）的倾向： 价值判断——对旁人的意见只有接受或不接受。 追根究底——依自己的价值观探查别人的隐私。 好为人师——以自己的经验提供忠告。 自以为是——根据自己的行为与动机衡量别人的行为与动机。 表达也要讲技巧古希腊人有一种很经典的哲学观点，即品德第一，感情第二，理性第三。我认为这三个词集中体现了让他人理解自己以及有效表达自己的精髓。 品德指的是你个人的可信度，是人们对你的诚信和能力的认可，是人们对你的信任，是你的情感账户。感情指的是你的移情能力，是感性的，说明你能通过交流迅速理解他人的情感。理性是你的逻辑能力，即合理表达自己的能力。 一对一沟通你现在就可以练习习惯五。下次同别人交流的时候，你可以试着抛开自己的经验，尽力真正了解对方。你应该睿智、敏感而又头脑清楚。不论在办公室或者家中，敞开胸怀，凝神倾听。不要急功近利，即使短期内未获回馈也绝不气馁。 如果你真正爱一个人，那么花时间了解对方将有益于今后的坦诚相待，这样一来，很多困扰家庭和婚姻的问题都将被扼杀在萌芽状态，没有发展壮大的机会，即便有这样的机会，充足的情感账户储蓄也会让问题迎刃而解。 先理解别人。在问题出现之前，在评估和判断之前，在你表达个人观点之前，先理解别人，这是有效的相互依赖关系中最有用的习惯。 付诸行动 选择一个情感账户出现赤字的人际关系，试着从对方的角度理解并记下他的处境。下一次见面时，通过聆听来理解对方，将现在听到的和以前记下的做一个比较。看看你的想法是否准确？——你真的理解对方的立场和观点么？ 与一个亲近的人分享移情这个概念，告诉他你想要做到真正的移情聆听，并让他在一个星期之后提供反馈意见。——你做的怎么样？那个人有什么感觉？ 下次有机会旁观他人交流的时候，捂住自己的耳朵，只用眼睛观察。哪些情感不是用语言表达出来的？ 下次发现你表现出不恰当的自传式回应的时候，立即承认错误，尽力扭转局面，将情感账户的支出变成存入。（“对不起，我刚才并不是真的努力去理解你，我们可以再来一次吗？”） 下次表达自己观点的时候，首先做到移情。要能够和对方的同伴一样（甚至更好地）描述对方的观点，然后站在对方的立场上，争取让自己的观点得到理解。","tags":[{"name":"高效能人士的七个习惯","slug":"高效能人士的七个习惯","permalink":"https://lilei.pro/tags/高效能人士的七个习惯/"}]},{"title":"《高效能人士的七个习惯》第三部分 习惯四 双赢思维——人际领导的原则","date":"2019-04-07T03:00:29.000Z","path":"2019/04/07/Seven-Habbits-6/","text":"人际交往的六个模式 利人利己（双赢） 损人利己（赢/输） 舍己为人（输/赢） 两败俱伤（输/输） 独善其身（赢） 好聚好散（无交易） 利人利己（双赢）双赢者把生活看作合作的舞台，而不是竞技场。但是大多数人都用两分法看问题，非强即弱，不胜则败。实际上这种想法是站不住脚的，它以力量和地位，而非原则为准绳。 损人利己（赢/输）大多数人从小就被这种模式浸染。学校、赛场、法律把人分为敌对双方，不是你死，就是我活。诚然，在竞争激烈和信任薄弱的环境里，我们需要赢/输模式。但是竞争在生活中只居少数，我们不需要每天都和配偶、孩子、同事、邻居、朋友竞争。现实生活需要互相依赖，而不是单枪匹马，你的很多梦想都需要通过与其他人合作才能实现，而赢/输模式是这种合作最大的障碍。 舍己为人（输/赢）有些人则正好相反，他们信奉输/赢模式。 “我认输，你赢了。” “就这样吧，我听你的。” “我是个和事佬，只要能息事宁人，我做什么都行。” 这种人没有标准，没有要求，没有期望，也没有将来。他们通常喜欢取悦他人，喜欢满足他人的希望。别人的认同和接受能够给他们力量，他们没有勇气表达自己的感受和信念，总是服从别人的意志。 在谈判时，他们常常不是放弃就是退让，如果成为领导，也对下属嫉妒纵容。赢/输模式意味着做好人，然而好人不长命。 可是被压抑的情感并不会消失，累积到一定程度后，反而以更丑恶的方式爆发出来，有些精神疾病就是这样形成的。 赢/输模式和输/赢模式都存在人格缺陷。短期来看，赢/输模式的人较有效率，因为他们通常在能力和智力方面高人一筹，而输/赢模式自始至终都居于劣势。 两败俱伤（输/输）为了报复，不惜牺牲自身的利益，却不问是否值得；只有不够成熟、掌握不了人生方向的人，才会这样。 独善其身（赢）当竞争和对抗意义不大的时候，独善其身的模式是多数人的处事方法，他们只在意自己的利益无损，别人的就留给他们自己去保护吧。 哪一种最好长远来看，不是双赢，就一定是两败俱伤。 如果真的抱着双赢的态度，就会多与业主交流，听取意见，并有勇气表达自己的观点，直到结果让双方都满意。 不能双赢就好聚好散如果实在无法达成共识，实现双赢，就不如好聚好散（放弃交易）。 在相互依赖的环境里，任何非双赢的解决方案都不是最好的，因为他们终将对长远关系产生这样那样的不利影响，你必须慎重对待这些影响的代价。如果你无法同对方达成双赢的协议，那么最好选择放弃。 双赢思维的五个要领双赢的原则是所有人际交往的基础，包括五个独立的方面：双赢品德是基础，接着建立起双赢关系，由此衍生出双赢协议，需要双赢体系（结构）作为培育环境，通过双赢的双赢过程来完成。 双赢品德双赢品德有三个基本特征。 诚信。有明确的价值观，信守承诺。 成熟。成熟就是在表达自己的情感和信念的同时又能体谅他人的想法和感受的能力。 知足。即相信资源充足，人人有份。公众领域的成功的意思不是压倒旁人，而是通过成功的有效交往让所有的参与者获利，大家一起工作，一起探讨，一起实现单枪匹马无法完成的理想，这种成功要以知足心态为基础。 双赢关系双赢的精髓就是信用，即情感账户。如果情感账户储蓄充足，信用就不再是问题，已有的投入让我们相知相敬，我们可以全神贯注于问题本身，而不是性格或者立场。 你对双赢的态度越坚持，越真诚，越积极，越投入，你对他人的影响力就越大。 双赢协议关系确立之后，就需要有协议来说明双赢的定义和方向，这种协议有时被称为“绩效协议”或“合作协议”，它让纵向交往转为水平交往，从属关系转为合作关系，上级监督转为自我监督。 在双赢协议中，对以下五个要素应该有明确的规定： 预期结果：确认目标和时限，方法不计。 指导方针：确认实现目标的原则、方针和行为限度。 可用资源：包括人力、财力、技术或者组织资源。 任务考核：建立业绩评估标准和时间。 奖惩制度：根据任务考核确定奖惩的意义。 双赢的管理培训……培训之前，向受训者语言这次培训不会一帆风顺，阻力一定会存在。 双赢绩效协议管理哲学家兼顾问彼得·德鲁克（Peter Drucker）建议，经理和员工之间可以用“给经理的信”这种形式来表述绩效协议的要点。首先就预期结果、指导方针和可用资源深入探讨，保证其与组织的总目标一致，然后写在“给经理的信”中，并提议下一次绩效计划和讨论的时间。 有四种管理者或家长都可以掌控的奖惩方法：金钱、精神、机会以及责任。 双赢体系双赢必须有相应体系支撑，包括培训、规划、交流、预算、信息、薪酬等，而且所有体系都要建立在双赢原则的基础上。 通常情况下，问题都源于体系，而不是人。再好的人置身于一个糟糕的体系中，也不会有好结果。 双赢过程我建议不同的人和机构采用以下四个步骤完成双赢过程： 首先，从对方的角度看问题。真正理解对方的想法、需要和顾虑，有时甚至比对方理解的更为透彻。 其次，认清主要问题和顾虑（而非立场）。 第三，确定大家都能接受的结果。 第四，实现这种结果的各种可能途径。 付诸行动 认真想一下你最近需要打交道的人或者想要解决的问题，在敢作敢为和善解人意间找到平衡点。 列出最能妨碍双赢模式的因素，设法清除在个人影响圈内的那一部分。 选择一个你想签订双赢协议的人际关系；尽量设身处地为对方着想，记下你认为对方会接受的结果；从自己的角度出发，列出对自己有利的结果；询问对方是否愿意就这个问题进行交流；一起商讨两全其美的对策。 列出你生活中最重要的三个人际关系，估算一下与这些人的情感账户余额，记下有助于增加存款的感情投资。 反省自己的交往模式，是赢/输式的吗？这种模式对你于他人的交往有什么影响？形成这种模式的主要原因是什么？这种模式对你有何助益？ 找到一个双赢模式的榜样，也就是即使身处困境也不忘双赢的人，仔细观察并向他学习。","tags":[{"name":"高效能人士的七个习惯","slug":"高效能人士的七个习惯","permalink":"https://lilei.pro/tags/高效能人士的七个习惯/"}]},{"title":"《高效能人士的七个习惯》第三部分 公众领域的成功","date":"2019-04-07T03:00:29.000Z","path":"2019/04/07/Seven-Habbits-5/","text":"习惯一：积极主动 习惯二：以终为始 习惯三：要事第一","tags":[{"name":"高效能人士的七个习惯","slug":"高效能人士的七个习惯","permalink":"https://lilei.pro/tags/高效能人士的七个习惯/"}]},{"title":"《高效能人士的七个习惯》第二部分 习惯三 要事第一","date":"2019-04-07T03:00:29.000Z","path":"2019/04/07/Seven-Habbits-4/","text":"回答两个问题 在你目前的生活中，有哪些事情能够彻底改观你的个人生活，但是你一直没有去做？ 在你目前的生活中，有哪些事情能够彻底改观你的工作局面，但是你一直没有去做？ 习惯三是习惯一、二的具体实践。习惯一告诉你，你是创造者，你掌控自己的人生，其基础是人类特有的四大天赋：想象力、良知、独立意志、自我意识。 习惯二是关于第一次的创造或者智力上的创造的习惯，其原则基础是想象力和良知这两大天赋。 习惯三是关于第二次的创造或者体力上的创造的习惯，是对前面两个习惯的实施、执行和自然表现。 左脑进行管理，右脑进行领导。 有效的管理指的就是要事第一，先做最重要的事情。领导者首先要决定的，就是哪些事情是重要的；而作为管理者，就是要将这些重要的事务优先安排。自我管理的实质就是自律和条理，是对计划的实施。 《成功的普遍共性》一文的作者格雷（E.M.Gray）说：“成功者能为失败者所不能为，纵使并非心甘情愿，但为了理想与目标，仍可以凭毅力克服心理障碍。” 四代时间管理理论的演进如何分辨轻重缓急与培养组织能力，是时间管理的精髓。 第一代理论着重利用便条与备忘录，在忙碌中调配时间与精力 第二代理论强调行事历与日程表，反映出时间管理已经注意到规划未来的重要。 第三代是讲求优先顺序的概念，依据轻重缓急设定短中长期目标。 第四代理论从根本否定“时间管理”，主张关键在于“个人管理”，重心应当放在维持产出与产能平衡上。 别让琐务牵着鼻子走第四代时间管理理论从重要性和紧急程度两个维度对事务进行划分。重要性与目标有关，凡有价值、有利于实现个人目标的就是要事。紧急程度与时间紧迫性有关，紧迫之事通常都显而易见，推诿不得。 第一类事务，重要且紧急在矩阵中，第一类事务通常既紧迫又重要，需要立即处理，通常被称为“危机”或者“问题”。如果你过分注重第一类事务，它们的范围会变得越来越大，最终占据你全部的时间和精力。 大部分时间精力都用于处理危机的人（第一类事务） 压力大 精疲力尽 被危机牵着鼻子走 忙于收拾残局 第三类事务，紧急不重要这些人将时间致力于紧急不重要的第三类事务，却自以为在处理第一类事务。殊不知紧迫之事往往是别人的优先，对别人很重要，对自己却不然。 急功近利 被危机牵着鼻子走 被视为巧言令色 轻视目标和计划 认为自己是受害者，缺乏自制力 人际关系肤浅，甚至破裂 第四类事务，既不重要也不紧急有些不负责任的人，将时间都花在第三和第四类事务上 完全不负责任 被炒鱿鱼 基本生活都需要依赖他人或社会机构 第二类事务，重要不紧急包括建立人际关系、撰写使命宣言、规划长期目标、防患于未然等等。高效能人士避免陷入第三和第四类事务，通过花费更多时间在第二类事务来减少第一类事务的数量。 愿景，远见 平衡 自律 自制 很少发生危机 勇敢说“不”若要集中精力于当急的要务，就得排除次要事务的牵绊，此时需要有说“不”的勇气。 我曾聘用一位极有才华又独立自主的专员，有一天有件急事想拜托他。他说：“你要我做什么都可以，不过请先了解目前的状况。”他指着墙壁上的工作计划表，显示超过 20 个计划正在进行，这是我俩早已谈妥的。然后他说：“这件急事至少占去几天时间，你希望我放下或取消哪个计划来空出时间？” 很多人坦陈自己“缺乏自制力”，实际上，这是“确认目标”的功夫还不到家，而且不能由衷接收“事有轻重缓急”的观念，自然容易半途而废。 集大成的时间管理理论第一代的时间管理理论丝毫没有“优先”的概念。固然做完备忘录上的一件事，会带给人成就感，可是这种成就不一定符合人生大目标。因此，所完成的只是必要而非重要的事。 然而好此道者不在少数，因为阻力最小，痛苦与压力也最少。 更何况，根据外在要求与规律行事，容易推卸责任。这类人缺乏效率，缺乏自制力与自尊。 第四代理论强调以原则为重心，配合个人对使命的认知，兼顾重要性与急迫性；强调产出与产能齐头并进，着重第二类事务的完成。 管理方法六标准 和谐一致。 平衡功能。 围绕中心理想的管理方法。 以人为本。 灵活变通。 便于携带的管理工具。 个人管理四步骤第一步 确认角色写出你自己的关键角色，在家庭中、工作中乃至教会和社区事务中的角色。列举自己想要持续投入时间和精力去做的一些事情。 第二步 选定周目标思考下一个周计划中每一个任务栏下你最想做的一两件要事，作为你选定的目标。这些目标中一定要有几个第二类事务，根据自己的感觉判断每个角色中哪些事情是比较重要的，并为每个角色确立一个或两个目标。 第三步 安排进度为每一项目标安排具体的实施时间。有些目标需要在工作日完成，有些目标需要在周末完成。确保自己有充分的自由和灵活性以应付突发事件，让你享受到自发的乐趣。你会感觉很踏实，因为你知道自己已经安排好了一周的要务，照顾到了工作生活中的每一个重要领域。 第四部 每日调整根据突发事件、人际关系的意外发展及崭新机会对每天的要务安排进行适当调整。 在每天早晨审视自己一天的日程安排。 付诸实践诚心正意，对人不可讲效率，效率是对事而言的，对人应当讲效用。第四代个人管理理论的特点在于承认人比事更重要。 第四代时间管理方法的优点第四代时间管理方法比前三代更加先进，这种先进体现在五个方面 以原则为基础，切实地创造出一个核心模式，让你能够在一个更大的范围内分配自己的时间，看清楚什么是真正重要和有效的。 接受你内心良知的指导，让你有机会更好地安排自己的生活，并且最大限度地同你的价值观保持一致。同时给你自由和变通，让你在牺牲既定日程安排，服从更重要的价值观的时候心平气和，毫不内疚。 这种方法确认了你的个人使命，包括价值观和长期目标。 这种方法帮助你明确自己的角色，平衡自己生活中的各个方面。每个星期为每个关键角色确立要达到的目标，并作出具体的日程安排。 以一个星期为单位计划生活，不必局限于短暂的一天时间。通过审视自己的主要角色而让自己保持清醒，经常想到自己内心深处的价值观。 有一条主线贯穿这五个方面，那就是将人际关系和效果放在第一位，将时间放在第二位。 高效能的秘诀——授权把责任分配给其他成熟老练的员工，才有余力从事更高层次的活动。授权是事必躬亲与管理之间的最大分野，事必躬亲者凡事不假外求。反之，管理者注重建立制度，然后汇集群力共同完成工作。 授权可以划分为两种类型：指令型授权和责任型授权。 指令型授权指令型授权关注重点是方法，管理者自己为最后的结果负责。 责任型授权责任型授权的关注重点是最终结果，它给人们自由，允许自行选择做事的具体方法，并为最终的结果负责。起初，这种授权方式费时费力，但却十分值得。通过责任型授权，可以将杠杆的支点向右移动，提高杠杆的作用。 责任型授权要求双方就以下五个方面达成清晰、坦诚的共识，并作出承诺。 预期结果。双方都要明确并且完全理解最终想要的结果。要以“结果”而不是以“方法”为中心。要有具体的日程，明确截止期限。 指导方针。确认适用的评估标准，避免成为指令型授权。但是一定要有明确的限制性规定。 可用资源。告诉他们可以使用哪些人力、财务、技术或者组织资源来取得缩预期的成果。 责任归属。制定业绩标准，并用这些标准来评估他们的成果。制定具体的时间表，说明何时提交业绩报告，何时进行评估。 明确奖惩。明确地告诉他们评估可能导致的结果，好的和不好的后果都要告诉他们。 信任是促使人进步的最大动力，因为信任能够让人表现出自己最好的一面。 授权的大原则不变，权限却因人而异。对不够成熟的人，目标不必订得太高，指示要详尽，并且充分提供资源；监督考核则较频繁，奖惩也更直接。对成熟的人，可分配挑战性高的任务，精简指示，减少监督考核的次数，考评标准则较为抽象。 付诸行动 找出一项平时被你忽略的第二类事务。 画出一个时间管理矩阵，按照百分比将你的时间分配给每一类事务。然后以十五分钟为计时单位连续记录自己三天的活动状况。对照一下自己的计划，看是否有很大的出入。 将你认为可以授权给他人作的事情列在一张纸上，然后列出你认为可以做这些工作的人选或者通过培训可以胜任的工作人选。思考一下应该如何开始授权程序或者开展培训工作。 计划你的下周活动，你的计划应当能够体现你的人生目标和主导价值观。并在星期结束的时候进行总结。 承诺以后每周都制定一个周计划，并规定一个具体的时间专门做这件事情。 将目前使用的时间管理工具升级为第四代时间管理工具。 阅读附录二——高效能人士的一天。","tags":[{"name":"高效能人士的七个习惯","slug":"高效能人士的七个习惯","permalink":"https://lilei.pro/tags/高效能人士的七个习惯/"}]},{"title":"《高效能人士的七个习惯》第二部分 习惯二 以终为始","date":"2019-04-07T02:58:21.000Z","path":"2019/04/07/Seven-Habbits-3/","text":"第四章 习惯二 以终为始——自我领导的原则设想一段悼词请找个僻静的角落，抛开一切杂念，敞开心扉，跟着我走过这段心灵之旅。 假设你正在前往殡仪馆的路上，要去参加一位至亲的葬礼。抵达之后，居然发现亲朋好友齐聚一堂，是为了向你告别。姑且假定这时亲族代表、友人、同事或社团伙伴，即将上台追述你的生平。请你认真想一想 你希望人们对你以及你的生活有什么样的评价？ 你希望他们怎样评价你的人格？ 你希望他们回忆起你的哪些成就和贡献？ 你希望对周围人的生活施加过什么样的影响？ 以终为始的定义以你的人生目标作为衡量一切的标准，你的一言一行、一举一动，无论发生在何时，都必须遵循这一原则，即由个人最忠实的期许或价值观来决定一切。 你希望在盖棺定论时获得的评价，才是你心目中真正渴望的成功。 任何事物都需要两次创造第一次创造在头脑中构思，即智力上的第一次创造（Mental/First Creation） 第二次创造付诸实践，体力上的第二次创造（Physical/Second Creation） 主动设计还是被动接受“任何事物都是两次创造而成”是个客观原则，但“第一次的创造”未必都是有意的设计。有些人自我意识薄弱，不愿主动设计自己的生活，结果就让影响圈外的人或事控制了自己。这种人的人生方向大多源自个人喜好，不符合客观原则，之所以会被接收，是因为某些人内心脆弱，依赖心理过重，渴望被接纳和获得归属感，向往他人的关怀和爱护，而且一定要别人来肯定自己价值和重要性。 领导与管理：两次创造“以终为始”的另一个原则基础是自我领导，但领导（Leadershi）不同于管理（Management）。领导是第一次的创造，必需先于管理；管理是第二次的创造。 领导与管理就好比思想与行为。管理关注基层，思考的是“怎样才能有效地把事情做好”；领导关注高层，思考的是“我想成就的是什么事业”。领导是“做正确的事”，管理是“正确地做事”。管理是有效地顺着成功的梯子往上爬，领导则判断这个梯子是否搭在正确的墙上。 个人生活中的领导意识更为匮乏，很多人连自己的价值观都没有搞清楚，就忙于提高效率，制定目标或完成任务。 改写人生剧本：成为自己的第一次创造者 自我意识 想象力：在心里演练哪些尚未释放的潜能 良知：遵循自然法则或原则 个人使命宣言以终为始的最有效方法，就是撰写一份个人使命宣言，即人生哲学或基本信念。 想成为怎样的人（品德） 想成就什么样的事业（贡献和成就） 为此奠基的价值观和原则 对于个人来说，基于正确原则的个人使命宣言也同样是评价一切的标准，成为我们以不变应万变的力量源泉。 核心区制定个人使命宣言必须从影响圈的核心开始，基本的思维定式就在这里，即我们用来观察世界的“透镜”。当我们专注于这个核心并取得丰硕成果时，影响圈就会被扩大，这是最高水平的产能，会提升我们在各生活领域的效能。 安全感：代表价值观、认同、情感的归属、自尊自重与是否拥有个人的基本能力。 人生方向：时“地图”的和内心的准绳，人类一次为解释外界事物的理据以及决策与行为的原则和内在标准。 智慧：是人类对生命的认知、对平衡的感知和对事物间联系的理解，包括判断力、洞察力和理解力，是这些能力的统一体。 力量：采取行动、达成目标的能力，是做出选择的关键性力量，也包括培育出更有效的习惯以替代旧习惯的能力。 以原则为中心以原则为中心的人会保持冷静和客观，不受情绪或其它因素的干扰，纵观全局——工作需要、家庭需要、其他相关因素以及不同决定的可能后果，深思熟虑后才做出正确选择。 善用整个大脑左脑负责逻辑思考与语言能力，右脑执掌创造力与直觉。左脑处理文字，右脑擅长图像；左脑重局部与分析，右脑重整体与整合。 拓宽思路和心灵演练是开发右脑的两个途径。 拓宽思路有时，人会因为意外打击而在瞬间从左脑思维变成右脑思维，比如亲人离世、罹患重病、经济危机或陷入困境的时候，我们会扪心自问：什么才是最重要的？我们究竟在追求什么？ 积极主动者不需要这种刺激，就能拓宽思路、自觉转换思维定式。比如设想自己的葬礼，或者银婚及金婚纪念日的情景，邀请你的配偶与你一起来畅想，两人共同的理想婚姻关系应当怎样，怎样通过日常活动来付诸实施？ 你也可以设想自己退休后的情形，那时自己有怎样的贡献和成就，退休后又有什么计划，是否想二次创业？ 心灵演练心灵演练与确认施行自我领导不是只要撰写一个使命宣言就完成了，他是一个确立愿景和价值观，并让自己的生活遵从这些重要原则的过程。右脑会在这个过程中帮助你进行心灵演练（Visualization），并对正确行为加以确认（Affirmation）。这会让你的生活更符合使命宣言。 确认应该包括五个基本要素：个人、积极、果断、可视、情感。例如“发现子女行为不当时，我（个人）能以智慧、爱心、坚定的立场与自制力（积极）及时应对（果断），结果让我深感欣慰（情感）。” 确定角色和目标在撰写使命宣言时，不妨分开不同的角色领域，一一订立目标。事业、生活、政治、信仰等。 家庭的使命宣言每个家庭都有共同的价值观及理念，作为生活的重心，撰写家庭使命宣言正可以凸显这个生活中心，时全家人团结在共同的目标下。 组织的使命宣言一个真正反映每隔成员的共同愿景和价值观的使命宣言，能调动他们的创造力和奉献精神，使他们不再需要旁人的指导、监督和批评，因为他们已经接受了不变的核心原则，接受了企业为之奋斗的共同目标。 付诸行动 把你参加葬礼心灵演练时的心得列表整理。 根据目前理解，写下自己的人生角色。检讨你对目前扮演的角色和自己的生活是否满意。 每天抽空撰写个人使命宣言。 阅读各种生活中心，看你的行为符合其中哪种类型？他们是否让你的日常行为有了一定依据？你是否满意？ 为编写使命宣言而手机笔记、引言、想法以及可能有用的各种资料。 设想近期内可能会从事的某个项目，用心灵演练的原则，写下你希望获得的结果与应采取的步骤。 向家人呢或同事讲述本章的精华，并建议大家共同拟定家庭或团队的使命宣言。","tags":[{"name":"高效能人士的七个习惯","slug":"高效能人士的七个习惯","permalink":"https://lilei.pro/tags/高效能人士的七个习惯/"}]},{"title":"《高效能人士的七个习惯》第二部分 习惯一 积极主动","date":"2019-04-07T02:56:26.000Z","path":"2019/04/07/Seven-Habbits-2/","text":"第三章 习惯一 积极主动——个人愿景的原则自我思维（Self-paradigm） 行有不得，反求诸己 试着跳出自我的框框，把意识转移到屋子的某个角落，然后用心客观地审视自己，站在旁观泽的角度观察自己，描述现在的心情与精神状态，思考你头脑的工作方式，它是否反应灵敏。 社会之镜（Social Mirro）社会观点认为，环境与条件对我们起着决定性的作用。我们不否认条件作用的影响巨大，但并不等于承认它凌驾于一切之上，甚至可以决定我们的命运。根据这种看法绘制的社会地图可以分为三种，也被称作揭示人性的三种“决定论”： 基因决定论（Genetic Determinism）：人的本性由DNA决定，自先祖遗传下来。 心理决定论（Psychic Determinism）：人的本性由父母的言行决定，即原生家庭论。 环境决定论（Environmental Determinism）：环境决定人的本性，如周遭的人与事，例如老板、配偶、子女乃至自然环境和经济环境。 这三种社会地图都已“刺激-回应”理论为基础，来源于巴甫洛夫所做的关于狗的实验，基本观点认为我们会受条件左右，以某一特定方式回应某一特定刺激。 选择的自由人类的自我意识是独立的，能够超脱肉体的束缚，以旁观者的身份审视自己的遭遇。他可以决定外界刺激对自己的影响程度，或者说，在遭遇（刺激）与对遭遇的回应之间，他有选择回应方式的自由和能力。 即，在刺激与回应之间，人类有选择的自由。这便是“积极主动”的价值。 责任感（Responsibility）从构词法来说是能够回应（Response-able）的意思，即选择回应的能力，人类应当有营造有利的外在环境的积极性和责任感。积极主动是人的天性，即使生活受到了外界条件的制约，那也是因为我们有意或无意地选择了被外界条件控制，这种选择成为消极被动（Reactive）。 除非你愿意，否则没人能伤害你伤害我们的并非悲惨遭遇本身，而是我们对于悲惨遭遇的回应。尽管这些事的确会让人身心受创或者经济受损，但是品德和本性完全可以不受影响。事实上月痛苦的经历，越能磨练意志，开发潜能，提升自如应对困境的能力，甚至还可能感召他人争取同样的自由。 聆听自己的语言消极被动的人，言语中往往会暴露出推卸责任的意图，例如： “我就是这样做事的。”天生如此，爱看不看。 “他把我气疯了！”责任不在我，是外界因素控制了我的情绪。 “我根本没时间做。”外界因素——时间扼住了我的咽喉。 “我只能这样做。”迫于环境（外界因素） 推卸责任的言语往往会强化宿命论。说者一遍遍被自己洗脑，变得更加自怨自艾，怪罪别人和环境，甚至把星座也扯了进去。 关注圈与影响圈积极主动的人专注于“影响圈”，他们专心做自己力所能及的事，他们的能量是积极的，能够使影响圈不断扩大、扩张和成长。只要我们的焦点在关注权，就等于是允许自己受制于外界条件，自然就不会主动采取必要措施来推动积极变化。 一个人的关注圈可能会小于影响圈，这说明此人由于自己的缘故，在情感方面缺乏远见和判断力，消极而又自私，全部精力都放在关注圈内。 三种问题可直接控制/可间接控制/无法控制 上帝啊，请赐我勇气，改变那些我能改变的；请赐我胸襟，接收那些我无法改变的；请赐我慧眼，能够分辨这两者。 “如果”和“我可以”与关注圈相关的语句多半带有假设性质，“如果”；与影响圈相关的语句多半体现了这个人的品德修养，“我可以”。 对待错误的态度马上承认， 改正并从中吸取教训，这样才能反败为胜。如果不肯承认而后改正，也不丛中吸取教训，等于错上加错，自欺欺人。 两种直接掌控人生的途径一、作出承诺，信守诺言二、确立目标，付诸实践 付诸行动 用一整天的时间，听自己和周围的人说话，注意看是否常有“但愿”、“我办不到”、“我不得不”等消极语言出现 想一想近期是否会发生一些按照以前的习惯拟会消极对待的事情？他是否在你的影响圈之内？你应如何以积极主动的原则应对？在心里演练一下积极的应对方式；提醒自己刺激与回应之间存在空间；想自己承诺，要抓住选择回应的自由 找出一个工作或生活中令你备感挫折的问题，判断它属于直接控制、间接控制还是无法控制的问题，然后在影响圈内找出解决问题的第一个步骤，并付诸行动 实行积极主动的原则30天，观察自己的影响圈有何变化","tags":[{"name":"高效能人士的七个习惯","slug":"高效能人士的七个习惯","permalink":"https://lilei.pro/tags/高效能人士的七个习惯/"}]},{"title":"《高效能人士的七个习惯》第一部分 重新探索自我","date":"2019-04-07T02:54:17.000Z","path":"2019/04/07/Seven-Habbits-1/","text":"第一章 由内而外全面造就自己本书要阐述的内容以原则为中心，以品德为基础，要求“由内而外”地实现个人效能和人际效能。 由内而外的观点认为个人领域的成功必需先于公众领域的成功；只有先信守对自己的承诺，才能信守对他人的承诺。由内而外是一个持续的更新过程，以主宰人类成长和进步的自然法则为基础，是螺旋向上的，它让我们不断进步，直到实现独立自强与有效的互赖。 第二章 七个习惯概论习惯的引力宇宙飞船必须先摆脱强大的地球引力，为此在刚发射的几分钟，即刚升空时的几公里消耗的能量比之后几天几十万公里旅程消耗的能量还要多。习惯也一样有极大的引力，只是许多人不加注意或不肯承认罢了。要根除根深蒂固的不良习惯，仅有一点点毅力，只作一点点改变是不够的。 习惯的定义习惯是知识、技巧、意愿相互交织的结果。 知识：理论范畴，指点“做什么”及“为何做” 技巧：告诉“如何做” 意愿：促使“想要做” 成熟模式图 依赖：以“你”为核心 独立：以“我”为核心 互赖：以“我们”为核心 只重独立并不适于互赖的现实生活。只知独立却不懂互赖的人只能称为独个的“生产标兵”，却与“优秀领导”或“最佳合作者”之类的称呼无缘，也不会拥有美满的家庭、婚姻或集体生活。 互赖是一个更为成熟和高级的概念。生理上互赖的人，可以自力更生，但也明白合作会比单干更有成效；情感上互赖的人，能充分认识自己的价值，但也知道爱心、关怀以及付出的必要性；智力上互赖的人懂得取人之长，补己之短。 七个习惯依赖 -&gt; 独立，个人领域的成功 积极主动 以终为始 要事第一 独立 -&gt; 互赖，公众领域的成功 双赢思维 知彼解己 统合综效 螺旋上升 不断更新 什么是高效能产出与产能平衡的原则是效能的精髓，放之四海而皆准，不管你是否遵从，它都会存在。它是指导人生的灯塔，是效能的定义和模式，是本书中七个习惯的基础。","tags":[{"name":"高效能人士的七个习惯","slug":"高效能人士的七个习惯","permalink":"https://lilei.pro/tags/高效能人士的七个习惯/"}]},{"title":"友情链接","date":"2019-03-09T23:52:36.000Z","path":"2019/03/10/links/","text":"Title Content hexo-theme-indigo 本博客使用的 Hexo 主题","tags":[{"name":"工具","slug":"工具","permalink":"https://lilei.pro/tags/工具/"}]},{"title":"Java SE 8 Lambda 快速入门","date":"2018-11-01T09:25:07.000Z","path":"2018/11/01/java8-lambda/","text":"本文是对Java SE 8: Lambda Quick Start的翻译，供个人学习Lambda表达式之用。成文日期：2018-11-01，所有以引文出现的文字为笔者阅读过程中添加，非原文内容。强烈建议CET4以上的读者阅读原文。 概述目标本文旨在介绍在 Java SE 8 中引进的 Lambda 表达式。 阅读时间大约 1 小时 简介Lambda 表达式是 Java SE 8 新引入的重要特性。它提供了通过一个表达式表示指代接口的简洁方法。Lambda 表达式也在遍历、过滤、以及读取数据方面优化了Collection类的使用。此外，新的并发特性提升了多核环境下的程序性能。 总结一下就是三个优点：1.更简洁的匿名类写法，2.更便利的集合类处理，3.多核环境性能优化。 本文首先提供了对 Lambda 表达式的介绍说明，然后介绍匿名内部函数，接着对函数借口和新的 Lambda 语法进行讨论。然后列举出一些常用使用方法模版。 下节通过对一个搜索场景的讨论，引申出 Lambda 表达式如何优化这种功能实现。然后介绍了一些java.util.function包里面常用的函数接口，如Predicate和Function，并举了一些栗子。 文末介绍如何通过 Lambda 优化集合类使用。 提供所有样例源码。 硬件和软件需求以下是硬件和软件需求列表 JDK 8 NetBeans 7.4 可以用IDEA代替NetBeans （运行样例的）先决条件要运行样例，你的电脑上必须安装有JDK 8和NetBeans 7.4或更高版本。你可以在the main Lambda site找到下载链接。或者可以直接使用下面的链接。 Java Development Kit 8 (JDK8) Early Access NetBeans 7.4 or later 注意： 安装包适用于所有主流操作系统。本文基于 Linux Mint 13（Ubuntu/Debian）完成。 安装完成JDK8和NetBeans后。将它们的bin文件夹添加到你的环境变量PATH中。 注意： 本文最后更新于 2013 年十二月。 竟然是5年以前的文章了… 背景知识匿名内部类（Anonymous Inner Class）在 Java 中，匿名内部类提供一种实现仅使用一次的类的途径。例如，在标准的 Swing 或者 JavaFX 应用中，需要用一系列的 handler 来处理键盘和鼠标事件。除了为每一个事件单独写一个事件处理类（该类需要实现 ActionListener 接口）这种方式，你可以用以下代码来实现类似需求 123456JButton testButton = new JButton(\"Test Button\");testButton.addActionListener(new ActionListener()&#123; @Override public void actionPerformed(ActionEvent ae)&#123; System.out.println(\"Click Detected by Anon Class\"); &#125;&#125;); 除此之外，你需要为每一个事件都写下类似的代码，它们都需要实现ActionListener接口。通过上述匿名内部类的写法，代码似乎变得容易阅读一些。然而这种写法很不优雅，因为有太多无用的模版代码，我们需要的其实只是“在函数里我要做什么事”这个信息。 函数接口（Functional Interfaces）定义ActionListener的类代码如下 12345678package java.awt.event;import java.util.EventListener;public interface ActionListener extends EventListener &#123; public void actionPerformed(ActionEvent e);&#125; ActionListener的梨子是一个只含有一个函数声明的接口。在 Java SE 8 中，这种模式的接口被称为“函数接口”。 注意： 这种接口之前被称为“Single Abstrace Method type”（单一抽象方法类型） 在 Java 中使用匿名类实现函数接口是一种常见写法。除了EventListener类以外，像Runnable和Comparator这样的接口也有一样的模式。因此，函数式接口是我们使用 Lambda 表达式的一个重要原因。 Lambda 表达式语法Lambda 可以把匿名内部类的代码从 5 行精简到 1 行，极大的缩减了代码的冗余。如下这种“水平的”解决方案解决了匿名内部类带来的“垂直的”问题。 这里“水平”和“垂直”是指代码块在页面中呈现的形式 一个 Lambda 表达式由三部分构成 Argument List Arrow Token Body (int x, int y) -&gt; x + y 这三个部分可以翻译为“参数列表”、“箭头标志”、“函数体”，不过下文仍然以英文称呼，为了加深记忆。 Body 部分可以是一个简单的表达式（expression）或者代码块（statement block）。在上面的模版中，body 中进行了简单的计算和返回。在代码块格式中，body 呈现形式与普通函数写法一样，同样需要一个 return 语句来返回结果给匿名函数的调用者。break和continue关键字在最外层是禁止使用的，不过如果代码里存在循环（loops），则可以使用。如果 body 需要返回一个结果值，每一条控制路径都必需有值返回，或者抛出异常。 看一下这些栗子： 12345(int x, int y) -&gt; x + y() -&gt; 42(String s) -&gt; &#123; System.out.println(s); &#125; 第一个表达式读取两个整型参数，x和y，然后返回x+y的结果。第二个表达式不需要参数，使用“表达式”格式的返回结果，值为42。第三个表达式读取字符串参数，然后将它打印在控制台，不返回任何结果。 有了上面的基础知识，我们再来看一些样例。 Lambda 样例（Lambda Examples）这里是一些使用到上面提到的栗子的常见用法。 Runnable Lambda你可以用 Lambda 来写一个实现了 Runnable 接口的对象 123456789101112131415161718192021public class RunnableTest &#123; public static void main(String[] args) &#123; System.out.println(\"=== RunnableTest ===\"); // Anonymous Runnable Runnable r1 = new Runnable()&#123; @Override public void run()&#123; System.out.println(\"Hello world one!\"); &#125; &#125;; // Lambda Runnable Runnable r2 = () -&gt; System.out.println(\"Hello world two!\"); // Run em! r1.run(); r2.run(); &#125;&#125; 在两种场景里，请注意到接口不需要读取参数，也没有返回值。Runnable的 Lambda 表达式使用了代码块模式，将 5 行代码浓缩为 1 行。 “代码块”应为原作者笔误，实际上是“表达式”格式。 Comparator LambdaComparator类在 Java 中用于给集合排序。在以下的例子中，一个由Person对象构成的ArrayList被按照surName进行排序。以下是Person类的成员变量 12345678public class Person &#123; private String givenName; private String surName; private int age; private Gender gender; private String eMail; private String phone; private String address; 以下代码分别使用了匿名内部类和 Lambda 表达式两种方式生成Comparator进行排序。 1234567891011121314151617181920212223242526272829303132333435363738public class ComparatorTest &#123; public static void main(String[] args) &#123; List&lt;Person&gt; personList = Person.createShortList(); // Sort with Inner Class Collections.sort(personList, new Comparator&lt;Person&gt;()&#123; public int compare(Person p1, Person p2)&#123; return p1.getSurName().compareTo(p2.getSurName()); &#125; &#125;); System.out.println(\"=== Sorted Asc SurName ===\"); for(Person p:personList)&#123; p.printName(); &#125; // Use Lambda instead // Print Asc System.out.println(\"=== Sorted Asc SurName ===\"); Collections.sort(personList, (Person p1, Person p2) -&gt; p1.getSurName().compareTo(p2.getSurName())); for(Person p:personList)&#123; p.printName(); &#125; // Print Desc System.out.println(\"=== Sorted Desc SurName ===\"); Collections.sort(personList, (p1, p2) -&gt; p2.getSurName().compareTo(p1.getSurName())); for(Person p:personList)&#123; p.printName(); &#125; &#125;&#125; 由于 Markdown 不支持代码行数表示，这里的行数请自行体会。 17 - 21 行的排序语句可以被 32 行的 Lambda 表达式精简。注意到第一个 Lambda 表达式声明了传进来的参数类型。第二个 Lambda 表达式则省略了类型声明。Lambda 支持“target typing”（类型自动匹配？），意味着它可以自动从上下文中获取到对象类型信息。因为我们将Comparator应用于泛型集合类（personList），编译器能够自动判断参数类型为Person。 Listener Lambda最后我们来看一下ActionListener的例子 1234567891011121314151617181920public class ListenerTest &#123; public static void main(String[] args) &#123; JButton testButton = new JButton(\"Test Button\"); testButton.addActionListener(new ActionListener()&#123; @Override public void actionPerformed(ActionEvent ae)&#123; System.out.println(\"Click Detected by Anon Class\"); &#125; &#125;); testButton.addActionListener(e -&gt; System.out.println(\"Click Detected by Lambda Listner\")); // Swing stuff JFrame frame = new JFrame(\"Listener Test\"); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.add(testButton, BorderLayout.CENTER); frame.pack(); frame.setVisible(true); &#125;&#125; 注意 Lambda 表达式作为参数被传入。类型自动匹配可以应用在很多场景中，以下举例说明： Variable declarations（变量声明） Assignments（赋值） Return statements（返回语句） Array initializers（数组初始化） Method or constructor arguments（方法或构造器参数） Lambda expression bodies（Lambda 表达式体） Conditional expressions?:（三元运算符?:） Cast expressions（类型转换语句） 简单说就是所有为expression的地方，都可以使用 Lambda 表达式，它本身就是一个 expression/statement。 资源下载本小节中的 NetBeans 工程样例代码可以在下面下载到 LambdaExamples01.zip 通过 Lambda 表达式优化代码在你掌握了前面展示的例子后，本节将介绍如何借助 Lambda 改进你的代码。Lambda 表达式将帮助你轻松实现“Don’t Repeat Yourself(DRY)”原则，并且使你的代码更加简洁易于阅读。 一个查询的 Case一个常见的应用程序场景是，从一个集合中遍历，找出那些符合某种过滤条件的成员。在 2012 年的 JavaOne 大会上，Stuart Marks 和 Mike Duigou 通过格外出色的Jump-Starting Lambda展示了这种应用场景。给你一个名单列表以及一系列筛选条件，需要找出那些符合条件的人并且自动呼叫他们。这个指南在有一些轻微变更的情况下实现了上述需求。 在这个例子中，我们需要从以下三个美国群体中提取出消息： 司机： 年龄大于 16 岁 入伍人员： 男性，18 ~ 25 岁 飞行员（特指商业飞行员）： 23 ~ 65 岁 我们将要实现上述需求，不过不是通过打电话或者发邮件，而是在控制台输出信息。信息内容包括姓名、年龄和联系方式（例如邮件地址或者电话号码） Person 类属性定义如下： 12345678910public class Person &#123; private String givenName; private String surName; private int age; private Gender gender; private String eMail; private String phone; private String address; &#125; Person类通过Builder来创建新对象，使用createShortList来创建人员列表。如下方代码片段所示。注意： 以下所有样例代码都可以在本节末尾给出的 NetBeans 工程里找到。 1234567891011121314151617181920212223242526272829303132333435363738public static List&lt;Person&gt; createShortList()&#123; List&lt;Person&gt; people = new ArrayList&lt;&gt;(); people.add( new Person.Builder() .givenName(\"Bob\") .surName(\"Baker\") .age(21) .gender(Gender.MALE) .email(\"bob.baker@example.com\") .phoneNumber(\"201-121-4678\") .address(\"44 4th St, Smallville, KS 12333\") .build() ); people.add( new Person.Builder() .givenName(\"Jane\") .surName(\"Doe\") .age(25) .gender(Gender.FEMALE) .email(\"jane.doe@example.com\") .phoneNumber(\"202-123-4678\") .address(\"33 3rd St, Smallville, KS 12333\") .build() ); people.add( new Person.Builder() .givenName(\"John\") .surName(\"Doe\") .age(25) .gender(Gender.MALE) .email(\"john.doe@example.com\") .phoneNumber(\"202-123-4678\") .address(\"33 3rd St, Smallville, KS 12333\") .build() ); 第一次尝试有了上面的Person类，加上定义好的检索条件，你可以写一个RoboContact类。一个可以参考的写法中定义了每种使用场景里的方法： RoboContactMethods.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.example.lambda;import java.util.List;/** * * @author MikeW */public class RoboContactMethods &#123; public void callDrivers(List&lt;Person&gt; pl)&#123; for(Person p:pl)&#123; if (p.getAge() &gt;= 16)&#123; roboCall(p); &#125; &#125; &#125; public void emailDraftees(List&lt;Person&gt; pl)&#123; for(Person p:pl)&#123; if (p.getAge() &gt;= 18 &amp;&amp; p.getAge() &lt;= 25 &amp;&amp; p.getGender() == Gender.MALE)&#123; roboEmail(p); &#125; &#125; &#125; public void mailPilots(List&lt;Person&gt; pl)&#123; for(Person p:pl)&#123; if (p.getAge() &gt;= 23 &amp;&amp; p.getAge() &lt;= 65)&#123; roboMail(p); &#125; &#125; &#125; public void roboCall(Person p)&#123; System.out.println(\"Calling \" + p.getGivenName() + \" \" + p.getSurName() + \" age \" + p.getAge() + \" at \" + p.getPhone()); &#125; public void roboEmail(Person p)&#123; System.out.println(\"EMailing \" + p.getGivenName() + \" \" + p.getSurName() + \" age \" + p.getAge() + \" at \" + p.getEmail()); &#125; public void roboMail(Person p)&#123; System.out.println(\"Mailing \" + p.getGivenName() + \" \" + p.getSurName() + \" age \" + p.getAge() + \" at \" + p.getAddress()); &#125;&#125; 如上所示，上面列出的方法说明了对不同对象采取的行为（打电话、发电子邮件、发实体邮件）。可以清楚地看出过滤条件和采取的行为。然而，这种设计存在一些缺陷： 没有践行 DRY 原则 每一个方法都是重复的模版 必须为每个方法重写过滤条件 每个用户场景都需要实现大量的方法（比如今天是打电话给入伍人员，发邮件给飞行员；明天可能就是打电话给飞行员，发邮件给入伍人员） 代码呆板。如果过滤条件发生改变，不得不改动大量代码。因此，这段代码是难以维护的。 重构这些方法如何修复这个类？可以从过滤条件入手。如果可以把过滤调价提取出一个独立的方法，将会有一些提升。 RoboContactMethods2.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.example.lambda;import java.util.List;/** * * @author MikeW */public class RoboContactMethods2 &#123; public void callDrivers(List&lt;Person&gt; pl)&#123; for(Person p:pl)&#123; if (isDriver(p))&#123; roboCall(p); &#125; &#125; &#125; public void emailDraftees(List&lt;Person&gt; pl)&#123; for(Person p:pl)&#123; if (isDraftee(p))&#123; roboEmail(p); &#125; &#125; &#125; public void mailPilots(List&lt;Person&gt; pl)&#123; for(Person p:pl)&#123; if (isPilot(p))&#123; roboMail(p); &#125; &#125; &#125; public boolean isDriver(Person p)&#123; return p.getAge() &gt;= 16; &#125; public boolean isDraftee(Person p)&#123; return p.getAge() &gt;= 18 &amp;&amp; p.getAge() &lt;= 25 &amp;&amp; p.getGender() == Gender.MALE; &#125; public boolean isPilot(Person p)&#123; return p.getAge() &gt;= 23 &amp;&amp; p.getAge() &lt;= 65; &#125; public void roboCall(Person p)&#123; System.out.println(\"Calling \" + p.getGivenName() + \" \" + p.getSurName() + \" age \" + p.getAge() + \" at \" + p.getPhone()); &#125; public void roboEmail(Person p)&#123; System.out.println(\"EMailing \" + p.getGivenName() + \" \" + p.getSurName() + \" age \" + p.getAge() + \" at \" + p.getEmail()); &#125; public void roboMail(Person p)&#123; System.out.println(\"Mailing \" + p.getGivenName() + \" \" + p.getSurName() + \" age \" + p.getAge() + \" at \" + p.getAddress()); &#125;&#125; 比起上一个例子，这次的过滤条件被封装在单独的方法里。这些判断用的代码可以复用，需求变更时也避免了在类里面进行大范围的修改。然而，仍然存在着大量重复代码，以及必需为每种联系方法（打电话、发电子邮件、发邮件）单独写一个方法。是否有更好的将过滤条件传递给这些联系方法的方式？ 匿名内部类在 Lambda 表达式问世之前，可采用匿名内部类的方案。例如，一个解决方法是声明一个具有返回布尔值的test方法的MyTest.java类。把过滤条件在这个方法里，如下： 123public interface MyTest&lt;T&gt; &#123; public boolean test(T t);&#125; 更新后的模拟联系方式类如下： RobocontactAnon.java 123456789101112131415161718192021222324252627282930313233343536373839public class RoboContactAnon &#123; public void phoneContacts(List&lt;Person&gt; pl, MyTest&lt;Person&gt; aTest)&#123; for(Person p:pl)&#123; if (aTest.test(p))&#123; roboCall(p); &#125; &#125; &#125; public void emailContacts(List&lt;Person&gt; pl, MyTest&lt;Person&gt; aTest)&#123; for(Person p:pl)&#123; if (aTest.test(p))&#123; roboEmail(p); &#125; &#125; &#125; public void mailContacts(List&lt;Person&gt; pl, MyTest&lt;Person&gt; aTest)&#123; for(Person p:pl)&#123; if (aTest.test(p))&#123; roboMail(p); &#125; &#125; &#125; public void roboCall(Person p)&#123; System.out.println(\"Calling \" + p.getGivenName() + \" \" + p.getSurName() + \" age \" + p.getAge() + \" at \" + p.getPhone()); &#125; public void roboEmail(Person p)&#123; System.out.println(\"EMailing \" + p.getGivenName() + \" \" + p.getSurName() + \" age \" + p.getAge() + \" at \" + p.getEmail()); &#125; public void roboMail(Person p)&#123; System.out.println(\"Mailing \" + p.getGivenName() + \" \" + p.getSurName() + \" age \" + p.getAge() + \" at \" + p.getAddress()); &#125; &#125; 这里无疑是有了一些优化，因为只需要 3 个用于进行联系的方法。然而，在实际进行调用时，代码会有一些丑陋。看下面的测试代码： RoboCallTest03.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.example.lambda;import java.util.List;/** * @author MikeW */public class RoboCallTest03 &#123; public static void main(String[] args) &#123; List&lt;Person&gt; pl = Person.createShortList(); RoboContactAnon robo = new RoboContactAnon(); System.out.println(\"\\n==== Test 03 ====\"); System.out.println(\"\\n=== Calling all Drivers ===\"); robo.phoneContacts(pl, new MyTest&lt;Person&gt;()&#123; @Override public boolean test(Person p)&#123; return p.getAge() &gt;=16; &#125; &#125; ); System.out.println(\"\\n=== Emailing all Draftees ===\"); robo.emailContacts(pl, new MyTest&lt;Person&gt;()&#123; @Override public boolean test(Person p)&#123; return p.getAge() &gt;= 18 &amp;&amp; p.getAge() &lt;= 25 &amp;&amp; p.getGender() == Gender.MALE; &#125; &#125; ); System.out.println(\"\\n=== Mail all Pilots ===\"); robo.mailContacts(pl, new MyTest&lt;Person&gt;()&#123; @Override public boolean test(Person p)&#123; return p.getAge() &gt;= 23 &amp;&amp; p.getAge() &lt;= 65; &#125; &#125; ); &#125;&#125; 这是“垂直”代码的一个典型案例。这样的代码难以阅读。此外，我们必须为每一种使用场景单独写自定义的过滤条件。 Lambda 表达式解千愁Lambda 表达式可以解决目前为止我们遇到的一切问题。不过，让我们先了解一点别的。 java.uitl.function 在上一个例子中，MyTest函数接口将匿名内部类传递给方法调用。然而，写一个接口并不是必需的。Java SE 8 提供了java.util.function包，其中有一系列标准的函数借口。在这种场景下，Predicate接口符合我们的需求。 Predict意为“谓语，断言”，即判断条件的意思 123public interface Predicate&lt;T&gt; &#123; public boolean test(T t);&#125; test方法接收一个泛型类，返回一个布尔值。这正是我们所需要的过滤场景。下面是模拟联系方式类的最终版本。 RobocontactsLambda.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.example.lambda;import java.util.List;import java.util.function.Predicate;/** * * @author MikeW */public class RoboContactLambda &#123; public void phoneContacts(List&lt;Person&gt; pl, Predicate&lt;Person&gt; pred)&#123; for(Person p:pl)&#123; if (pred.test(p))&#123; roboCall(p); &#125; &#125; &#125; public void emailContacts(List&lt;Person&gt; pl, Predicate&lt;Person&gt; pred)&#123; for(Person p:pl)&#123; if (pred.test(p))&#123; roboEmail(p); &#125; &#125; &#125; public void mailContacts(List&lt;Person&gt; pl, Predicate&lt;Person&gt; pred)&#123; for(Person p:pl)&#123; if (pred.test(p))&#123; roboMail(p); &#125; &#125; &#125; public void roboCall(Person p)&#123; System.out.println(\"Calling \" + p.getGivenName() + \" \" + p.getSurName() + \" age \" + p.getAge() + \" at \" + p.getPhone()); &#125; public void roboEmail(Person p)&#123; System.out.println(\"EMailing \" + p.getGivenName() + \" \" + p.getSurName() + \" age \" + p.getAge() + \" at \" + p.getEmail()); &#125; public void roboMail(Person p)&#123; System.out.println(\"Mailing \" + p.getGivenName() + \" \" + p.getSurName() + \" age \" + p.getAge() + \" at \" + p.getAddress()); &#125;&#125; 在这种写法里，只需要三个方法用来模拟联系候选人。Lambda 表达式作为参数被传递给方法，用来过滤需要联系的人员。 垂直问题迎刃而解Lambda 表达式解决了垂直代码的问题，并且更容易重用。来看看新的使用了 Lambda 表达式的测试类。 RoboCallTest04.java 12345678910111213141516171819202122232425262728293031323334353637383940package com.example.lambda;import java.util.List;import java.util.function.Predicate;/** * * @author MikeW */public class RoboCallTest04 &#123; public static void main(String[] args)&#123; List&lt;Person&gt; pl = Person.createShortList(); RoboContactLambda robo = new RoboContactLambda(); // Predicates Predicate&lt;Person&gt; allDrivers = p -&gt; p.getAge() &gt;= 16; Predicate&lt;Person&gt; allDraftees = p -&gt; p.getAge() &gt;= 18 &amp;&amp; p.getAge() &lt;= 25 &amp;&amp; p.getGender() == Gender.MALE; Predicate&lt;Person&gt; allPilots = p -&gt; p.getAge() &gt;= 23 &amp;&amp; p.getAge() &lt;= 65; System.out.println(\"\\n==== Test 04 ====\"); System.out.println(\"\\n=== Calling all Drivers ===\"); robo.phoneContacts(pl, allDrivers); System.out.println(\"\\n=== Emailing all Draftees ===\"); robo.emailContacts(pl, allDraftees); System.out.println(\"\\n=== Mail all Pilots ===\"); robo.mailContacts(pl, allPilots); // Mix and match becomes easy System.out.println(\"\\n=== Mail all Draftees ===\"); robo.mailContacts(pl, allDraftees); System.out.println(\"\\n=== Call all Pilots ===\"); robo.phoneContacts(pl, allPilots); &#125;&#125; 注意到，我们为每组联系人（allDrivers, allDraftees, allPilots）声明了一个断言（Predicate）。你可以将任何一个断言传给模拟联系的方法。代码简洁易于阅读，并且减少了重复代码。 资源下载本小节中的 NetBeans 工程样例代码可以在下面下载到 RoboCallExample.zip java.util.function包上节介绍的Predicate并不是 Java SE 8 所提供的唯一函数接口。开发者可以使用一系列的标准接口帮助开发。 像我这么吊的 Predicate：参数对象的某个属性 Consumer：对参数对象执行的某种操作 Function：把 T 转换为 U Supplieer：提供一个 T 的实例（例如工厂） UnaryOperator：一个单元运算符，T -&gt; T BinaryOperator：一个双元运算符，(T, T) -&gt; T 此外，很多接口都有原始形式（类似上文中的Predicate和人工过滤器这种比较），可以帮助你更好地理解 Lambda 表达式。 东方取名法以及方法调用在写上面一个例子时，我认为Person类应当具备一个灵活的输出系统。一个需求是以西方和东方两种命名方式打印出名字。在西方，名在前，姓在后。在东方则恰好相反。 老式写法的例子这是在未使用 Lambda 表达式时的写法 Person.java 12345678910111213141516171819public void printWesternName()&#123; System.out.println(\"\\nName: \" + this.getGivenName() + \" \" + this.getSurName() + \"\\n\" + \"Age: \" + this.getAge() + \" \" + \"Gender: \" + this.getGender() + \"\\n\" + \"EMail: \" + this.getEmail() + \"\\n\" + \"Phone: \" + this.getPhone() + \"\\n\" + \"Address: \" + this.getAddress());&#125; public void printEasternName()&#123; System.out.println(\"\\nName: \" + this.getSurName() + \" \" + this.getGivenName() + \"\\n\" + \"Age: \" + this.getAge() + \" \" + \"Gender: \" + this.getGender() + \"\\n\" + \"EMail: \" + this.getEmail() + \"\\n\" + \"Phone: \" + this.getPhone() + \"\\n\" + \"Address: \" + this.getAddress());&#125; 你需要两个方法，分别打印西方命名、东方命名 Function接口Function接口适用于这个问题。它只有一个名为apply的方法，方法签名如下： 1public R apply(T t)&#123; &#125; 它接收一个泛型 T 的参数，然后返回一个 R 的对象。对于这个例子，传入Person类型，返回String类型。一个更加灵活的打印方法如下所示： Person.java 123public String printCuston(Function &lt;Person, String&gt; f) &#123; return f.apply(this);&#125; 这可真简单。方法接收一个Function参数，返回一个字符串。apply方法通过一个 Lambda 表达式返回Person对象的信息。 Function是如何定义的？如下是测试的样例代码。 NameTestNew.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class NameTestNew &#123; public static void main(String[] args) &#123; System.out.println(\"\\n==== NameTestNew02 ===\"); List&lt;Person&gt; list1 = Person.createShortList(); // Print Custom First Name and e-mail System.out.println(\"===Custom List===\"); for (Person person:list1)&#123; System.out.println( person.printCustom(p -&gt; \"Name: \" + p.getGivenName() + \" EMail: \" + p.getEmail()) ); &#125; // Define Western and Eastern Lambdas Function&lt;Person, String&gt; westernStyle = p -&gt; &#123; return \"\\nName: \" + p.getGivenName() + \" \" + p.getSurName() + \"\\n\" + \"Age: \" + p.getAge() + \" \" + \"Gender: \" + p.getGender() + \"\\n\" + \"EMail: \" + p.getEmail() + \"\\n\" + \"Phone: \" + p.getPhone() + \"\\n\" + \"Address: \" + p.getAddress(); &#125;; Function&lt;Person, String&gt; easternStyle = p -&gt; \"\\nName: \" + p.getSurName() + \" \" + p.getGivenName() + \"\\n\" + \"Age: \" + p.getAge() + \" \" + \"Gender: \" + p.getGender() + \"\\n\" + \"EMail: \" + p.getEmail() + \"\\n\" + \"Phone: \" + p.getPhone() + \"\\n\" + \"Address: \" + p.getAddress(); // Print Western List System.out.println(\"\\n===Western List===\"); for (Person person:list1)&#123; System.out.println( person.printCustom(westernStyle) ); &#125; // Print Eastern List System.out.println(\"\\n===Eastern List===\"); for (Person person:list1)&#123; System.out.println( person.printCustom(easternStyle) ); &#125; &#125;&#125; 第一个循环只是打印出名字和电子邮件地址。不过可以把任何的表达式传给printCuston方法。东方命名法和西方命名法使用 Lambda 表达式定义，并且保存在变量中。这些变量接下来被传入最后的两个循环。可以很容易地将 Lambda表达式合并成为Map，用起来更加方便。Lambda 表达式提供了显著的灵活性。 样例输出下面是程序的样例输出。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697==== NameTestNew02 ======Custom List===Name: Bob EMail: bob.baker@example.comName: Jane EMail: jane.doe@example.comName: John EMail: john.doe@example.comName: James EMail: james.johnson@example.comName: Joe EMail: joebob.bailey@example.comName: Phil EMail: phil.smith@examp;e.comName: Betty EMail: betty.jones@example.com===Western List===Name: Bob BakerAge: 21 Gender: MALEEMail: bob.baker@example.comPhone: 201-121-4678Address: 44 4th St, Smallville, KS 12333Name: Jane DoeAge: 25 Gender: FEMALEEMail: jane.doe@example.comPhone: 202-123-4678Address: 33 3rd St, Smallville, KS 12333Name: John DoeAge: 25 Gender: MALEEMail: john.doe@example.comPhone: 202-123-4678Address: 33 3rd St, Smallville, KS 12333Name: James JohnsonAge: 45 Gender: MALEEMail: james.johnson@example.comPhone: 333-456-1233Address: 201 2nd St, New York, NY 12111Name: Joe BaileyAge: 67 Gender: MALEEMail: joebob.bailey@example.comPhone: 112-111-1111Address: 111 1st St, Town, CA 11111Name: Phil SmithAge: 55 Gender: MALEEMail: phil.smith@examp;e.comPhone: 222-33-1234Address: 22 2nd St, New Park, CO 222333Name: Betty JonesAge: 85 Gender: FEMALEEMail: betty.jones@example.comPhone: 211-33-1234Address: 22 4th St, New Park, CO 222333===Eastern List===Name: Baker BobAge: 21 Gender: MALEEMail: bob.baker@example.comPhone: 201-121-4678Address: 44 4th St, Smallville, KS 12333Name: Doe JaneAge: 25 Gender: FEMALEEMail: jane.doe@example.comPhone: 202-123-4678Address: 33 3rd St, Smallville, KS 12333Name: Doe JohnAge: 25 Gender: MALEEMail: john.doe@example.comPhone: 202-123-4678Address: 33 3rd St, Smallville, KS 12333Name: Johnson JamesAge: 45 Gender: MALEEMail: james.johnson@example.comPhone: 333-456-1233Address: 201 2nd St, New York, NY 12111Name: Bailey JoeAge: 67 Gender: MALEEMail: joebob.bailey@example.comPhone: 112-111-1111Address: 111 1st St, Town, CA 11111Name: Smith PhilAge: 55 Gender: MALEEMail: phil.smith@examp;e.comPhone: 222-33-1234Address: 22 2nd St, New Park, CO 222333Name: Jones BettyAge: 85 Gender: FEMALEEMail: betty.jones@example.comPhone: 211-33-1234Address: 22 4th St, New Park, CO 222333 资源下载本小节中的 NetBeans 工程样例代码可以在下面下载到 LambdaFunctionExamples.zip Lambda 表达式和集合上节介绍了Function接口和示例语法。本节我们将看到 Lambda 表达式如何提升Collections类。 Lambda 表达式和集合到目前为止的例子中，集合类出现的很少。然而，相当一部分 Lambda 表达式的特征改变了我们使用集合类的方式。本节介绍其中的一部分。 类增强司机、飞行员、入伍人员的过滤条件被包装进了SearchCriteria类。 SearchCriteria.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.example.lambda;import java.util.HashMap;import java.util.Map;import java.util.function.Predicate;/** * * @author MikeW */public class SearchCriteria &#123; private final Map&lt;String, Predicate&lt;Person&gt;&gt; searchMap = new HashMap&lt;&gt;(); private SearchCriteria() &#123; super(); initSearchMap(); &#125; private void initSearchMap() &#123; Predicate&lt;Person&gt; allDrivers = p -&gt; p.getAge() &gt;= 16; Predicate&lt;Person&gt; allDraftees = p -&gt; p.getAge() &gt;= 18 &amp;&amp; p.getAge() &lt;= 25 &amp;&amp; p.getGender() == Gender.MALE; Predicate&lt;Person&gt; allPilots = p -&gt; p.getAge() &gt;= 23 &amp;&amp; p.getAge() &lt;= 65; searchMap.put(\"allDrivers\", allDrivers); searchMap.put(\"allDraftees\", allDraftees); searchMap.put(\"allPilots\", allPilots); &#125; public Predicate&lt;Person&gt; getCriteria(String PredicateName) &#123; Predicate&lt;Person&gt; target; target = searchMap.get(PredicateName); if (target == null) &#123; System.out.println(\"Search Criteria not found... \"); System.exit(1); &#125; return target; &#125; public static SearchCriteria getInstance() &#123; return new SearchCriteria(); &#125;&#125; 本例的编码不是很规范，作为参数的PredicateName应该写为predicateName更严谨。 这个类保存了基于Predicate的搜索过滤条件，你可以在测试用例中使用它们。 循环首先登场的是任何集合类都可以使用的forEach方法。这里是一些打印出Person列表的例子。 Test01ForEach.java 123456789101112131415161718public class Test01ForEach &#123; public static void main(String[] args) &#123; List&lt;Person&gt; pl = Person.createShortList(); System.out.println(\"\\n=== Western Phone List ===\"); pl.forEach( p -&gt; p.printWesternName() ); System.out.println(\"\\n=== Eastern Phone List ===\"); pl.forEach(Person::printEasternName); System.out.println(\"\\n=== Custom Phone List ===\"); pl.forEach(p -&gt; &#123; System.out.println(p.printCustom(r -&gt; \"Name: \" + r.getGivenName() + \" EMail: \" + r.getEmail())); &#125;); &#125;&#125; 例 1 展示了一个 Lambda 表达式，它调用printWesternName方法打印出列表里每个人的名字。例 2 展示了一个 方法调用。当已经存在对类对象操作的方法时，这种写法可以代替通用 Lambda 表达式的写法。最后，例 3 展示了printCustom方法也可以在这种场景下使用。注意 Lambda 表达式嵌套时，变量名的细小差别。 你可以用这种方式遍历任何集合。基础结构与增强型for训话类似。然而，一些增强型机制能带来很多好处。 链式调用与过滤器除了遍历集合内元素，你还可以将方法组装成链式。第一个要讲解的方法是filter，它接收一个Predicate类型的参数。 下面例子在过滤元素后，遍历列表。 Test02Filter.java 123456789101112131415161718192021public class Test02Filter &#123; public static void main(String[] args) &#123; List&lt;Person&gt; pl = Person.createShortList(); SearchCriteria search = SearchCriteria.getInstance(); System.out.println(\"\\n=== Western Pilot Phone List ===\"); pl.stream().filter(search.getCriteria(\"allPilots\")) .forEach(Person::printWesternName); System.out.println(\"\\n=== Eastern Draftee Phone List ===\"); pl.stream().filter(search.getCriteria(\"allDraftees\")) .forEach(Person::printEasternName); &#125;&#125; 第一个和最后一个循环展示了List如何基于过滤条件被过滤。控制台输出如下所示： 12345678910111213=== Eastern Draftee Phone List ===Name: Baker BobAge: 21 Gender: MALEEMail: bob.baker@example.comPhone: 201-121-4678Address: 44 4th St, Smallville, KS 12333Name: Doe JohnAge: 25 Gender: MALEEMail: john.doe@example.comPhone: 202-123-4678Address: 33 3rd St, Smallville, KS 12333 偷点儿懒这些特征虽然有价值，但是在已经有了一个完美的for循环语法的情况下，把它们引入集合类的意义何在？通过将集合操作归纳成库，Java 开发者可以在代码上进行更多的优化。首先看一对名词解释。 懒惰：在编程领域，懒惰意味着只处理你需要处理的对象。在先前的例子中，最后一个循环是“懒惰”的，因为它只遍历了List被过滤出来的两个Person对象。这样的代码效率更高，因为最后只处理了两个对象，（而非整个列表）。 主动性：处理列表中每个元素的代码被称为“主动性强”的。例如，一个增强型for循环遍历整个列表，只为处理 2 个元素，这种方式被认为“主动性”很强。 stream方法在先前的代码样例中，你会发现在对列表进行过滤和遍历之前，我们调用了stream方法。这个方法接收Collection类型的参数，返回java.util.stream.Stream类型的结果。一个Stream对象意味着一个元素序列，你可以在上面进行链式操作。默认地，一旦元素被消费了，他们就不再处于 Stream 中。此外，随着调用方法不同，Stream可以用在串行（默认）或者并行的场景中。本节末尾将介绍一个并行的场景。 变更与运算结果如刚才所提到的，Stream在使用完成后就会被丢弃。因此，我们无法通过Stream来对列表中的元素进行修改。然而，如果你想要保存链式处理后的元素呢？你可以将它们存入一个新的集合。如下代码所示： Test03toList.java 1234567891011121314151617181920public class Test03toList &#123; public static void main(String[] args) &#123; List&lt;Person&gt; pl = Person.createShortList(); SearchCriteria search = SearchCriteria.getInstance(); // Make a new list after filtering. List&lt;Person&gt; pilotList = pl .stream() .filter(search.getCriteria(\"allPilots\")) .collect(Collectors.toList()); System.out.println(\"\\n=== Western Pilot Phone List ===\"); pilotList.forEach(Person::printWesternName); &#125;&#125; collect方法只有一个参数，是Collector类。Collector类用于从处理流的结果中生成一个List或者Set。上例介绍了如何将列表过滤后的结果存成List。 使用map进行计算map方法通常和filter搭配使用。这个方法去除类里面的某个属性，然后对它进行操作。如下代码基于年龄字段进行了一系列计算。 Test04Map.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Test04Map &#123; public static void main(String[] args) &#123; List&lt;Person&gt; pl = Person.createShortList(); SearchCriteria search = SearchCriteria.getInstance(); // Calc average age of pilots old style System.out.println(\"== Calc Old Style ==\"); int sum = 0; int count = 0; for (Person p:pl)&#123; if (p.getAge() &gt;= 23 &amp;&amp; p.getAge() &lt;= 65 )&#123; sum = sum + p.getAge(); count++; &#125; &#125; long average = sum / count; System.out.println(\"Total Ages: \" + sum); System.out.println(\"Average Age: \" + average); // Get sum of ages System.out.println(\"\\n== Calc New Style ==\"); long totalAge = pl .stream() .filter(search.getCriteria(\"allPilots\")) .mapToInt(p -&gt; p.getAge()) .sum(); // Get average of ages OptionalDouble averageAge = pl .parallelStream() .filter(search.getCriteria(\"allPilots\")) .mapToDouble(p -&gt; p.getAge()) .average(); System.out.println(\"Total Ages: \" + totalAge); System.out.println(\"Average Age: \" + averageAge.getAsDouble()); &#125; &#125; 输出如下： 1234567== Calc Old Style ==Total Ages: 150Average Age: 37== Calc New Style ==Total Ages: 150Average Age: 37.5 这段代码计算列表中所有飞行员的平均年龄。第一个循环展示了老式用for循环的写法。第二个循环使用了map方法获取串流中的每个人的年龄。注意totalAge是一个long类型对象。map方法返回一个IntStream对象，可以对其调用sum方法，这会返回一个long值。 注意： 第二次计算平均年龄时，再对所有值求和是多余的。然而，上例中这样写是为了展示sum函数的调用方法。 最后一个循环基于串流计算平均年龄。注意parallelStream方法，它是 Java 8 中流式计算的并行版本，返回结果也不是简单的double，而是OptionalDouble。 parallelStream提供了一种并发处理集合元素的方法，以上文的列表求平均值为例，如果一共有 100 个元素，parallelStream会将任务分为 n 份（n 是线程池的大小，默认为 CPU 核数），每份任务交由单独一个线程处理，最终再汇总这些任务的结果，得出平均值 资源下载本小节中的NetBeans工程样例代码可以在下面下载到 LambdaCollectionExamples.zip 总结在本篇指南中，你学会了使用以下技能： Java 匿名内部类 使用 Java SE 8 的 Lambda 表达式代替匿名内部类 Lambda 表达式的语法 通过Predicate接口在列表中查找 通过Function接口处理对象，并得到一个新类型的对象 Java SE 8 中新增的支持 Lambda 表达式的集合特性 更多资源如果你想要了解更多关于 Lambda 表达式和 Java SE 8 的信息，参考以下链接： Java 8 Project Lambda State of the Lambda State of the Lambda Collections Jump-Starting Lambda JavaOne 2012(You Tube) 若想要学习更多关于 Java 的内容，请点击Oracle Learning Library 著者 课程组长：Michael Williams QA：Juan Quesada Nunez 翻译：李磊","tags":[{"name":"Java","slug":"Java","permalink":"https://lilei.pro/tags/Java/"}]},{"title":"香帅的北大金融学课（二）金融机构","date":"2018-09-23T00:37:54.000Z","path":"2018/09/23/finance-Xiangshuai-week02/","text":"货币与信用银行体系在整个社会经济中，处于枢纽地位。国家通过银行体系进行信用创造，调控经济，这是现代经济运行的一个最重要特征。 银行货币信用扩张机制 货币的背后是国家信用货币的真名叫做“法定货币”，也就是国家赋予某个银行（比如中央银行）的一种特许权力而发行的，它背后的关键是国家信用。布雷顿森林会议上确立了美元在国际货币体系中“锚”的地位，美元成为了国际计价结算的储备货币，变成了国际货币体系的中心。现代的货币是信用货币，货币价值的浮动完全取决于一个国家的实力和其他国家对于这个国家的信心。 所以说没有国家信用加持的货币，即使可以完成计价、储藏、交换的功能，它也不能够成为通用的货币——比特币最根本的缺陷来源于此，像比特币这样去中心化的货币，要取代各国央行发行的法定货币，还是路漫漫其修远兮。 存款准备金率和“降准”前面讲到银行与国家强强联合，共同铸造了当代信用社会。国家通过银行体系，调控整个社会的信用规模和经济冷热。我们经常在电视新闻里听到“降息”、“降准”这样的词汇，“息”指的是基础利率，“准”指的是存款准备金率。 什么是存款准备金率储户要把钱存到银行里，银行再放贷出去，然后形成企业、个人的各种贷款，支持消费生产。但是，每天都有不同的储户有提现的要求，所以银行必须留存一小部分钱出来应付储户提现的需求，这部分钱就叫做存款准备金，这个留存的比例就叫存款准备金率。 存款准备金率如何生效的呢？假如小明有 100 块钱，他可以把这 100 块钱存到银行里，当时的存款准备金率是 10%，意味着银行必须预留出 100 块钱的 10%，也就是 10 块钱的现金，来预备应付小明的提现需求。去掉这 10% 后，银行可以把剩下的 90 块钱通过贷款的方式发放给小红。那么市面上一共有多少货币流通的，是 100（小明）+ 90（小红）= 190 元。小红同样可以选择把这 90 块钱存进银行，银行则在保留了 90 * 10% = 9 元的存款准备金后，将剩余 81 元发放出去……最终计算下来，小明持有的 100 元钱，经过层层转化，流动到社会中的钱可以达到 1000 元，整整扩张了 10 倍。这就是存款准备金的威力。 平时新闻里总是听到，基础货币（M0），广义货币（M2）这种词。在这个例子里，100 元就是基础货币，1000 元就是广义货币，央行发行的这个货币就叫基础货币，在 10% 的存款准备金率下，通过商业银行体系的循环之后，社会上的货币供应量扩张了整整 10 倍。这个倍数其实你算一下，就是存款准备金率的倒数 10，所以也叫货币乘数。 存款准备金制度是国家宏观上把控货币扩张的手段，银行放贷的意愿，我们个人、企业的现金持有量，都会影响到货币扩张的机制。 基准利率和“加息”现代经济运行最重要的逻辑，就是国家通过银行体系，来调控整个社会的信用规模和经济冷热。其中，存款准备金制度 和 基准利率 是两个最重要的调控手段。它们为什么重要呢？存款准备金制度主要是控制了资金的量，而基准利率调整的是资金的价格。 什么是基准利率基准利率就是一个市场上利率水平的风向标。各个金融机构，都根据这个标准来确定自己的贷款和存款利率。政府如果担心经济过热的话，就会加息，也就是提高利率进行收缩。如果想要刺激经济，就会采取降息的措施。 加息和降息的尺度其实非常难把握，过猛的加息可能会导致经济的突然崩盘，而过度的降息可能会导致经济泡沫。 学金融为什么要先了解宏观背景 世界上从来就不存在独立的微观金融现象，它的背后一定有某种宏观层面的逻辑或者推动力。 我们中国市场是一个强政府指导下的逐步开放的金融市场，所以政府在这个市场的影响力是很深的。 从宏观视角来理解微观金融现象，最后才能做出适合自己的金融决策。 学习金融的三个阶段 概念、术语通关，也就是说在这个阶段，你会接触到大量的金融术语，然后理解这些词语——降准、降息、影子银行、IPO、PE、VC，你得把握这些词的概念，然后建立一个自己对金融市场的体感，这是第一个阶段。 框架通关。这就是说，要求你建立一个金融思考的框架。我们现在面临的是一个信息爆炸的时代，市场上其实错误的信息是很多的，比如说你经常会听到什么“货币超发”、“货币战争”这些词语，这里面有很多的逻辑硬伤。在概念通关的基础上，你要学着建立一个自己的金融思维的框架，辨别这些信息。 实操通关，这就是要求你运用金融框架来解决问题，在这个阶段，我会给你一些模拟的宏观环境，让你置身在一个具体的场景里面，这个时候你要开始运用自己在前面学到的很多知识进行判断，进行操作、投资、商业决策、金融运作等等。 银行与理财银行躺着赚钱的秘密 2017年全球最赚钱的5家公司，中国占了其中4家，分别是工农中建四大行。去年招行平均薪水46万，上海银行45万。 从2003年到2012年这十年，被称为“中国银行业的黄金十年”。 银行利润来源 3/4，存贷差 1/4，银行投资，通道费用 银行解决了资金匹配上的规模、期限和风险问题，所以它会产生大量收益。 为什么在中国会发生“黄金十年”？ 金融准入门槛高，牌照控制严格，而且国家在2000年以后对存款利率实行严格管制，在2012年利率市场化之前，利率一直维持在3%左右 国家经济高速增长的十年，投资机会多、利润高，产生大量的贷款需求 银行业贫富分化的新业态由于准入门槛降低（银行个数从2000年的40家发展到4000家）、利率市场化，在马太效应下，银行业两极分化，四大行依旧是巨头，股份制银行各辟蹊径，城商行状态欠佳。所有银行都赚钱的好日子过去了。 货币基金和银行银行间货币市场银行间货币市场：银行会有资金短缺和盈余的时候，所以会互相借钱，称为银行间的货币拆借，形成银行间市场。它是一个大额的、短期的资金拆借市场。 货币基金 就是美国70年代利率管制下的金融创新、投资银行通过募集资金、投入银行间货币市场来获取利润。货币基金的出现是美国金融自由化的一个标志性事件。 对老百姓来说，货币基金提供了一个加入高收益的银行间货币市场的途径，让一小部分利润从银行流回老百姓手中。对银行来说，货币基金为其敲响了警钟，促使银行推出更多的货币基金产品。 货币基金收益率货币基金利率的上下浮动，主要是跟随银行间市场波动。市面上的钱越紧张（钱荒），货币市场越火热，货币基金收益率越高。反之，市面上钱越多，货币基金利率越低。 银行非保本理财产品影子银行银行收到严格的监管，它有绕开监管的冲动。在中国的银行金融体系中，银行占据着绝对主导地位，因为只有银行能吸收存款，募资也比其他机构容易得多。中国240万亿的金融总资产里面，银行占了90%以上。 银行受到监管多，募资能力强。 其他金融机构钱少，受到监管宽松。 信托、基金这些机构通过银行募集资金，把这些钱投到当时利润最高的行业和市场中去，绕开监管，大家一起赚钱，这些业务就是影子银行。最典型的就是银行和信托联手的“银信合作”业务，2010年的房地产市场，2014年的股票证券市场，都有银行和信托、券商合作的因素。 中国的影子银行就是一个金融机构和金融监管之间猫捉老鼠的游戏。 在这些业务中，银行充当通道作用，但是如果项目失败，银行不负有保本责任。 判别非保本理财产品是否靠谱的四个基本原则 在产品说明书上要特别注意产品的投向，如果它偷网的是现金贷、小额贷、消费贷这类的产品，在当前的大背景下要非常谨慎 如果是银行代销，意味着银行充当的只是中间人角色，你不会知道产品最后投到哪里，信息不对称太大，难以把握，不建议投资 注意募资方信息，不要被名头唬到，要对产品本身做一些研究和了解 如果利率过高就要小心，但是怎样判断利率过高？可以根据基准利率做判断，比如当前半年期基准贷款利率是4.35%，五年期以上的是4.9%，在这以上上浮10%、20%都是正常的范畴。5%的银行理财产品收益并不算太高 什么样的货币基金值得买中国市场上有5万多亿的资金都在货币基金上，一共300多种产品，怎样挑选安全、收益率更高的？ 挑选货币基金的两大原则安全性与流动性原则——挑选散户比例高的货币基金 机构型的货基，申购赎回都非常频繁，散户经常反应过慢，会受到资金量大的机构影响。这种基金由于机构频繁购买赎回产生的流动性风险，成为“基金挤兑”（Fund Run），这会导致基金波动很大，不够稳健。 如果一个货基的散户利率达到70%以上，就可以认为是散户型基金，流动性风险就非常低了。出于收益率考虑，这个标准可以放宽到60%。 收益率原则——挑选规模适中的货币基金 货基的收益率和它的货基规模，呈现一个倒U型的关系，基金规模太小（&lt;50亿）或者太大（&gt;1000亿）都会导致收益率过低。挑选货基时应当挑选100亿到400亿这样中等规模的基金。 以下是香帅团队在2018年初根据以上原则挑选出的几支基金。 货币基金申购赎回的三个小窍门 避开T+2、T+3的基金，因为这会对基金流动性造成一定损失 基金交易按照工作日来计算，周五不买入，周四不赎回。如果在周五买入，T+1型基金应当在周六赎回，而周六非工作日，就只能在下周一赎回，变成了T+3型基金。“周四不赎回”是因为你如果在周四赎回了，就会变成“周五买入” 货币基金的投资方向应该是一个短期的货币工具，市场上资金的紧张与否是货基收益率的关键，资金越紧张，收益率越高。一般来说月末、季末、年中、年底时，市场上货币最紧张，在这些时候购买货基也是收益率相对比较高的。 一些在线购买货币基金的渠道 天天基金 好买基金 数米基金","tags":[{"name":"金融学","slug":"金融学","permalink":"https://lilei.pro/tags/金融学/"}]},{"title":"香帅的北大金融学课（一）金融世界观","date":"2018-09-09T03:59:01.000Z","path":"2018/09/09/finance-Xiangshuai-week01/","text":"学习“得到App”中《香帅的北大金融学课》笔记 第一周：金融的本质 金融的本质 金融并不是高高在上、只存在于银行家和证券分析师口中的神秘事物，它与每一个普通人息息相关，不论是菜贩、打工者、服务员，只要你活在时间的河流中，就一定会与金融发生这样那样的关系。 金融的第一定理——时间的价值 时间就是金钱 时间是可以被换算成金钱的，我们每个人拥有的时间数量是相同的，上帝给每个人的时间一个基础定价（质量），我们再利用各自选择的金融工具，放大/缩小各自拥有的时间价值。这在金融学里被称作“货币的时间价值”（time value of money）。 金融为时间定价，我们这些购买金融产品、做出金融决策的人，就是购买了不同的未来价值。 金融的第二定理——资金的集聚人类面临两个约束：时间和资金，经济学上将资金的约束称为“稀缺”。越是伟大的事物，越需要资金的快速集聚和有效配置，这种功能只有金融可以实现。金融帮助我们突破时间和地域的限制，进行快速有效的资金集聚。 金融的第三定理——分散风险金融使人类对风险的承受能力突破地域和时间限制，拓展人类经济活动范围 保险将个体承受的风险分散到社会群体之间 股票起到的作用是利益共享、风险共担。 风投、创投让社会分担创业创新的风险 辩证看待金融世界观金融赋能人类，帮助我们扩大时间价值、进行资金的集聚，分散风险。金融同样也有负面的作用，比如马太效应和道德风险。 金融的基础知识可以分为以下六个板块 金融机构：银行、投行、基金的起源、功能、运作模式，以及背后的金融学逻辑 金融工具：股票、债券、金融衍生品的本质和特征，金融机构如何开拓市场，金融交易制度 投资者决策：资产配置、证券选择、非理性决策 公司决策：筹资的时机和方法，上市时机，分红策略，股权激励 金融的监管、创新和危机：“监管、创新、危机”的金融周期 科技金融：金融行业未来的发展，互联网，区块链，比特币 金融学带来金融思维，它让我们学会权衡风险和收益，不仅投资金钱，更是投资人生。 第二周 金融市场的历史演化过程 金融市场的历史演化 中国金融市场的制度根源——中央货币财政体系所有的金融市场都不是凭空出现的，它的形成背后都有一个强大的历史制度根源。 中国的金融市场是从一个中央集权的帝国内部演化来的，早期的金融发达也来源于这样的封建专制制度，国家垄断了金融行业，经济生活国有化，可以集中力量办大事。 这种经济制度的缺点是民间信用极其脆弱，民众的融资需求得不到满足，造成中国金融市场很多乱象。 欧美金融市场的演化——以银行为中心，分权制衡下的信用体系欧美的金融市场也不是一开始就像现在这样成熟，而是从11世纪以后慢慢发展起来的 圣殿骑士团奠定欧洲银行业基础 -&gt; 意大利银行业、荷兰股票证券、英法银行业逐渐形成分权制衡信用体系 -&gt; 美国的金融立国，称为世界上最发达的金融市场。我们现在所看到的欧美信用社会，是由于欧洲分权制衡的形态所决定的。 历史不能依靠简单的拿来主义，它是一个路径相依的过程。 金融机构用于消除金融市场上的信息不对称金融市场上交易的是“信用”、“未来”，是看不见摸不到的抽象物品，存在巨大的信息不对称，金融中介的存在就是为了消除信息不对称。各种审计机构、会计师事务所、券商银行都属于金融中介。 没有金融中介机构，金融市场是无法运行的，金融市场的高度中介化是必然的结果。 延展话题：个人资产配置的生命周期 青年时期：最大的优势是时间，加大实物资产配置，以时间换空间，增大年轻时期资本积累 壮年时期：现金收入高，风险承受能力强。应该加大风险资产配置；身份角色的转换，需要资产的多元化配置 老年时期：未来时间变少，风险承受能力减弱，加大安全资产配置，同时加大流动性资产配置，保障现金流","tags":[{"name":"金融学","slug":"金融学","permalink":"https://lilei.pro/tags/金融学/"}]},{"title":"深入理解 Java 虚拟机（三）垃圾收集器与内存分配策略","date":"2018-08-15T09:26:32.000Z","path":"2018/08/15/JVM-Note-03/","text":"本章介绍垃圾收集器的设计思路、算法以及常见实现，同时介绍为对象分配空间时采取的策略。 垃圾收集（Garbage Collection）GC 的历史比 Java 久远，1960 年诞生于 MIT 的 Lisp 是第一门真正使用内存动态分配和垃圾回收技术的语言。不论是什么语言，在设计 GC 时都必须要解决以下三个问题： 哪些内存需要回收（Who） 什么时候回收（When） 如何回收（How） 也许你要问，虚拟机已经为我们完成了内存回收的工作，目前内存的动态分配与回收技术已经相当成熟，一切都进入了“自动化”时代，我们为什么还要去了解 GC 和内存分配呢？答案很简单，当我们需要排查各种内存溢出、泄漏问题时，当垃圾收集称为系统达到更高并发量的瓶颈时，就必须要对这些“自动化”的技术进行必要的监控和调节。 在上一章的学习中，我们了解到 JVM 的内存可以划分为线程私有部分（虚拟机栈、本地方法栈、程序计数器）和公有部分（堆、方法区），其中线程私有部分所申请的内存，随着线程运行结束而销毁，在这个区域的内存分配和回收具备确定性。公有部分的方法区，其分配多少内存在编译期间也可以确认，因此，需要考虑内存回收的区域主要是 Java 堆，堆中的对象是运行时创建的，它们的创建和回收都是动态的，这是垃圾收集器关注的区域。 对象已死吗？引用计数器法引用计数器法（Reference Counting）是一种实现起来很简单的判断对象是否存活的方法。原理是当出现一个对对象的引用时，计数器 +1；当引用失效时，计数器 -1，计数器值为 0 则表示对象已死。它的优点是实现简单，判定效率高，在大部分情况下都是不错的算法，也有很多著名的应用案例： M$ 的 COM（Component Object Model）技术 试用 AS3 的 FlashPlayer Python Squirrel 引用计数器发存在循环引用的问题，因此主流 Java 虚拟机没有选用这种方法来管理内存。 可达性分析法主流商用程序语言（Java、C#、Lisp）使用可达性分析（Reachability Analysis）方法来判定对象是否存活： 从一系列 GC Roots 节点开始向下搜索，搜索走过的路径称为引用链（Reference Chain） 当一个对象到 GC Roots 没有任何引用链相连（不可达）时，证明此对象是不可用的 在 Java 中的 GC Roots 有以下几种 虚拟机栈（栈帧中的本地变量表）引用的对象 本地方法栈中 JNI 引用的对象 方法区中类静态属性引用的对象 方法区中常量引用的对象 可见 GC Roots 节点主要有全局性引用和执行上下文这两个来源。 JDK 1.2 后的几种引用在 Java 1.2 之前，对“引用”的定义很传统：如果 reference 类型的数据中存储的数值代表的是另一块内存的起始地址，就称为这块内存代表着一个引用。这种定义很纯粹但是太过狭隘，一个对象在这种定义下只有被引用或者没有被引用两种状态。我们希望描述这样一类对象：当内存空间还足够时，则能保存在内存之中；如果内存空间在进行 GC 后还是非常紧张，则可以抛弃这些对象。在 JDK 1.2 之后，Java 对引用的概念进行了扩充，将引用分为“强软弱虚”四种： 强引用（Strong Reference）：指在程序代码之中普遍存在的，类似“Object obj = new Object()”这类的引用，只要强引用还存在，垃圾收集器 永远不会 回收掉被引用的对象 软引用（Soft Reference）：用来描述一些 还有用但非必需 的对象，对于软引用关联的对象，在系统将要发生内存溢出异常之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收还没有足够的内存，则会抛出 内存溢出异常 弱引用（Weak Reference）：用来描述 非必需 对象，被弱引用关联的对象只能生存到下一次垃圾回收发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象 虚引用（Phantom Reference）：也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用获取对象实例。为一个对象设置虚引用关联的唯一目的就是能在它被收集器回收时收到一个系统通知 两次标记宣告对象死亡对于在可达性分析中被判断为“不可达”的对象，有一次进行自救的机会，要真正宣告一个对象死亡，需要经历两次标记过程： 第一次标记：对象在可达性分析中被标记为“不可达” 第二次筛选：判断此对象是否有必要执行 finalize() 方法，以下两个条件满足其一时，可认为是“有必要”，a. 对象覆盖了 finalize() 方法；b. 对象的 finalize() 方法未被调用过 对象被判断为“有必要执行 finalize()”时，是其最后一次自救机会，它会被放置在一个名为F-Queue的队列之中，并在稍后由一个虚拟机自动建立的、低优先级的 Finalizer 线程去执行 finalize() 方法，对象进行自救的唯一手段是在 finalize() 方法中建立与 GC Roots 的连接，譬如把自己（this 关键字）赋值给某个类变量或者对象的成员变量，这样会使得对象被移除出“即将回收”集合；换言之，如果这时候对象仍然未能自救，则会迎来死亡的命运。 需要注意的是，任何一个对象的 finalize() 方法只会被系统自动调用一次。在编码中我们应当尽量避免使用finalize()方法，因为它的运行代价高昂，不确定性大，并且无法保证各个对象的调用顺序。 回收方法区方法区（在 HotSpot 虚拟机中被称为“永久代”）也可以进行垃圾收集（虽然 Java 虚拟机规范中明确表示可以不要求在方法区实现垃圾收集）。不过在方法区中进行收集的“性价比”通常很低，在堆中常规应用进行一次垃圾收集一般可以回收 70%～95% 的空间，而永久代的垃圾收集效率远低于此。 永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。 废弃常量 的回收与 Java 堆中对象回收十分类似，以字面量回收为例，假如一个字符串“abc”已经进入了常量池中，但是当前系统没有任何一个 String 对象是叫做“abc”的，也没有在其他任何地方引用了这个字面量，如果这时发生内存回收，在必要的情况下，“abc”常量会被清除出常量池。 无用的类 的判断则要稍微复杂一些，需要同时满足以下三个条件，才“可以”被回收，注意不是“一定”而是“可以” 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例 加载该类的 ClassLoader 已经被回收 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法 HotSpot 虚拟机提供了-Xnoclassgc参数进行控制无用的类回收。 垃圾收集算法标记-清除算法最基本的收集算法是标记-清除（Mark-Sweep）算法，分为两个阶段： 标记出所有需要回收的对象 统一回收所有被标记的对象 标记-清除算法的示意图如下 标记清除 标记-清除算法主要不足有两个 效率问题，标记和清除的效率都不高 空间问题，清楚之后会产生大量不连续的内存碎片 复制算法复制（Copying）算法主要目的是解决效率问题，它将可用内存平均分为两个半区，每次只使用其中一个半区，在进行垃圾回收时，将仍存活的对象复制到另半区上，然后清空刚刚使用的半区。复制算法的实现简单运行高效，不足是空间利用率太低，只使用了一半的内存。 复制 现在的商业虚拟机都采用复制算法来回收新生代，IBM 研究表明新生代中的对象多达 98% 是朝生夕死的，所以不需要按照 1:1 的比例来划分内存。而是将内存分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中一块 Survivor 空间（称为 From Survivor），在回收时将存活对象复制到另一块 Survivor 空间（称为 To Survivor），并清理掉 Eden 以及 From Survivor 空间。HotSpot 虚拟机默认对 Eden 和 Survivor 空间分配比例为 8:1。 当 GC 过程中发现 To Survivor 空间不够用时，需要依赖其他内存（老年代）进行分配担保（Handle Promotion）。 标记-整理算法复制算法对于对象存活率高的场景并不适用，因为需要频繁进行复制操作；并且它还需要额外空间进行分配担保。因此，在老年代中通常不使用复制算法进行内存回收，而是使用的标记-整理（Mark-Compact）算法： 标记过程与“标记-清除”算法相同，先是标记出仍然存活的对象 把所有存活对象向一端移动 清理掉端边界以外的内存 标记整理 分代收集算法当代商业虚拟机采用的都是分代收集算法（Generational Collection），将 Java 堆分为新生代和老年代，根据各个年代的特点采用最合适的收集算法。 新生代：对象存活周期短，每次垃圾收集时有大量对象死去，只有少量存活，使用复制算法 老年代：对象存活周期长，存活率高，没有额外空间对它进行分配担保，采用标记-清除或者标记-整理算法 HotSpot 的算法实现在虚拟机上实现之前所述的算法时，必需对算法的执行效率有严格考量，才能保证虚拟机高效运行。 枚举根节点之前讲到作为 GC Roots 的区域主要是全局性引用（常量、类静态属性）和执行上下文（栈帧中的本地变量），很多应用仅仅方法区就有数百兆，如果逐个检查引用，必然会消耗很多时间。 此外，可达性分析对执行时间的敏感还体现在 GC 停顿 上，因为可达性分析必须在一个能确保一致性的快照中进行（分析过程中对象引用关系不可以发生变化），GC 时必须停顿所有的 Java 执行线程（称为 Stop The World）。 目前所有主流虚拟机采用的都是准确式 GC，当执行系统停顿下来时，虚拟机有办法知道，哪些地方存放着对象引用。在 HotSpot 实现中，使用一组称为 OopMap 的数据结构达成这个目的。在类加载完成时，HotSpot 把对象内什么偏移量上是什么类型的数据计算出来，在 JIT 编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。 安全点在 OopMap 协助下，HotSpot 可以快速且准确地完成 GC Roots 的枚举，然而存在一个很现实的问题：可能导致引用关系变化，或者说 OopMap 内容变化的指令非常多，如果为每一条指令都生成对应的 OopMap，将需要大量的额外空间，导致 GC 的空间成本非常高。 HotSpot 处理的方法是，并没有为每一条指令都生成 OopMap，只是在“特定的位置”记录这些信息，这些位置称为安全点（Safepoint），即程序执行时并非在所有地方都能停顿下来开始 GC，只有在到达安全点时才暂停。安全点的选定基本上是以程序“是否具有让程序长时间执行的特征”为标准进行选定的——因为每条指令执行的时间都非常短暂，程序不太可能因为指令流长度太长这个原因而过长时间运行。（这部分不理解） 对于 Safepoint 另一个需要考虑的点是如何在 GC 时让所有线程都运行到安全点上停顿下来，这里有两种方案： 抢先式中断（Preemptive Suspension）：GC 发生时中断所有线程，如果有线程中断地方不处于安全点，则让该线程运行至安全点。现在几乎没有虚拟机采用抢先式中断来暂停线程从而响应 GC 事件。 主动式中断（Voluntary Suspension）：当 GC 需要中断时，设置一个标志位。各个线程执行时主动轮询这个标志，发现中断标志为真时就自己中断挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。 安全区域Safepoint 机制保证程序执行时进入 GC 的可行性，但是，当程序不执行的时候（即没有分配 CPU 事件，例如线程处于 Sleep 状态或者 Blocked 状态），线程无法响应 JVM 的中断请求，无法轮询自然无法运行至安全点再中断挂起，安全区域 （Safe Region）就是用来解决这种问题的。 安全区域是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始 GC 都是安全的。可以把 Safe Region 看作是扩展了的 Safepoint。 当线程执行到 Safe Region 中的代码时，首先标识自己已经进入了 Safe Region 当这段时间里 JVM 需要发起 GC 时，对于标识自己为 Safe Region 状态的线程认为它是安全状态 当线程需要离开 Safe Region 时，检查系统是否已经完成了根节点枚举，如果完成则线程继续执行，否则等待直至收到可以安全离开 Safe Region 的信号为止 垃圾收集器如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。下图展示了 7 种作用于不同分代的垃圾收集器，存在连线的垃圾收集器可以搭配使用。 HotSpot垃圾收集器 Serial 收集器 最基本、发展历史最悠久的收集器 单线程，进行垃圾收集时必须暂停其他所有工作线程（Stop The World） 是虚拟机运行在 Client 模式下默认的 新生代收集器，在用户的桌面场景应用中，分配给虚拟机的内存一半不会很大，收集几十兆乃至一两百兆的新生代，停顿时间可以控制在 100 毫秒之内，可以接受 对于单个 CPU 的情况，没有线程交互的开销，可以获得最高的单线程收集效率 ParNew 收集器 Serial 收集器的多线程版本 许多运行在 Server 模式下的虚拟机首选的新生代收集器 只有它可以与 CMS（Concurrent Mark Sweep）收集器配合工作 在单 CPU 环境中，效率不如 Serial 收集器；默认开启的收集线程数与 CPU 数量相同 Parallel Scavenge 收集器 新生代收集器，采用复制算法 关注点在于 达到可控制的吞吐量（Throughput），吞吐量 = 运行用户代码时间/(运行用户代码时间 + 垃圾收集时间)，是一个百分数 停顿时间短的收集器（例如 CMS）适合与用户交互的程序；吞吐量高的收集器（例如 Parallel）适合后台运算而不需要太多交互的程序 自适应调节策略：虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整参数以提供最合适的停顿时间或者最大的吞吐量 Serail Old 收集器 Serial 收集器的老年代版本，单线程，“标记-整理”算法 主要意义在于给 Client 模式下的虚拟机使用 Parallel Old 收集器 Parallel Scanvenge 收集器的老年代版本，多线程，“标记-整理”算法 吞吐量优先：Parallel Scanvenge + Parallel Old CMS（Concurrent Mark Sweep）收集器 以获取最短回收停顿时间为目标，应用于网站以及 B/S 系统的服务端，注重服务响应速度，希望停顿时间最短 基于“标记-清除”算法，收集过程分为四步 初始标记（CMS initial mark），标记 GC Roots 能直接关联到的对象 并发标记（CMS concurrent mark），进行 GC Roots Tracing 重新标记（CMS remark），修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录 并发清除（CMS concurrent sweep） 初始标记、重新标记这两个过程需要 Stop The World 有三个明显缺点 对 CPU 资源非常敏感，并发阶段会占用一部分线程（或者说 CPU 资源）导致用户程序变慢，吞吐量降低。CMS 默认启动的回收线程数是（CPU数量 + 3）/4，当 CPU 不足 4 个时，对用户程序影响可能变得很大 无法处理浮动垃圾（Floating Garbage），可能出现“Concurrent Mode Failute”而导致另一次 Full GC 发生。“浮动垃圾”是指并发清理阶段所产生的垃圾，必须为这部分垃圾提前预留空间，以供并发收集时程序运作使用 因为采用的是“标记-清理”算法，当空间碎片过多时，无法分配大对象，CMS 收集器提供-XX:+UseCMSCompactAtFullCollection参数，用来在 FullGC 时开启压缩 G1（Garbage-First） 收集器 JDK 1.7 正式推出（7u4），面向服务端应用 特点：并行与并发，分代收集，空间整合，可预测的停顿 过程：将 Java 堆划分为多个大小相等的独立区域（Region），避免在整个 Java 堆中进行全区域的垃圾收集，而是追踪哥哥 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小及回收所需时间的经验值），在后台维护一个悠闲列表，每次根据允许的收集时间，优先回收价值最大的 Region（也是 Garbage-First 名字由来） 分为 4 个步骤 初始标记 并发标记 最终标记 筛选回收","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://lilei.pro/tags/读书笔记/"},{"name":"JVM","slug":"JVM","permalink":"https://lilei.pro/tags/JVM/"}]},{"title":"深入理解 Java 虚拟机（二）JVM 内存区域与内存溢出异常","date":"2018-08-09T07:30:23.000Z","path":"2018/08/09/JVM-Note-02/","text":"本章从概念上介绍 Java 虚拟机内存的各个区域，从作用、服务对象、可能产生的问题几个方面进行讲解。 运行时数据区域根据《Java 虚拟机运行规范》的规定，Java 虚拟机所管理的内存将会包括以下几个运行时区域： 虚拟机数据分区 线程私有：程序计数器，虚拟机栈，本地方法栈 线程共享：堆，方法区 程序计数器（Program Counter Register）程序计数器是一块较小的内存空间，可以看作是当前线程执行的字节码行号指示器，JVM 通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能。 程序计数器空间是私有的，原因在于 Java 虚拟机是通过线程轮流切换并分配处理器时间来实现的多线程，为了线程切换后能恢复到正确的执行位置，每个线程都需要一个独立的程序计数器。 如果线程正在执行 Java 方法，则程序计数器记录的是虚拟机字节码指令地址 如果线程正在执行 Native 方法，则程序计数器值为空（Undefined） 程序计数器是唯一一个在 Java 虚拟机规范中不会发生 OutOfMemoryError 的区域。 Java 虚拟机栈（Java Virtual Machine Stacks）描述 Java 方法执行的内存模型：每个方法在执行时都会创建一个栈帧（Stack Frame），用于存储局部变量表、操作数栈、动态链接、方法出口等信息。方法运行从开始到结束，对应的是栈帧在虚拟机栈中入栈及出栈的过程。以下着重介绍局部变量表。 局部变量表存放以下类型的变量，其中 64 位长度的 long 和 double 类型数据会占用 2 个局部变量空间（Slot），其余数据类型只占据 1 个。 编译期已知的各种基本数据类型：boolean、byte、char、short、int、float、long、double 对象引用：reference 类型，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置 returnAddress 类型：指向字节码指令地址 局部变量表所需的内促农建在编译期间完成分配，在方法运行期间不会更改局部变量表的大小。 在 Java 虚拟机规范中，对这个区域规定了两种异常情况： StackOverflowError: 线程请求的栈深度大于虚拟机所允许的深度 OutOfMemoryError: 虚拟机栈进行动态扩展时无法申请到足够的内存 本地方法栈（Native Method Stack）类似于虚拟机栈，只不过本地方法栈是为本地方法服务。同样会抛出 StackOverflowError 和 OutOfMemoryError。 Java 堆（Heap）是 Java 虚拟机所管理的内存中最大的一块区域，被所有线程共享。堆存在的唯一意义是存放对象实例，在 Java 虚拟机规范中的表述是“所有的对象和数组都要在堆上分配”。但是随着 JIT 编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致这一规则不再那么绝对。GC 就是对堆上的对象进行回收。堆区域空间不足会导致 OOM。 方法区（Method Area）也是线程共享的区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。别名 Non-Heap。HotSpot 虚拟机设计团队选择把 GC 分代收集扩展至方法区，导致也有人称呼方法区为“永久代”（Permanent Generation），但这并不是一个好的实践，会导致内存溢出问题，而且极少数的方法会因为这个原因而在不同虚拟机上产生不同表现。 垃圾收集行为在方法区是较少出现的，而且回收率不高，回收目标主要是针对常量池的回收和对类型的卸载。 运行时常量池（Runtime Constant Pool） 是方法区的一部分，Class 文件除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期间生成的各种字面量和符号引用。可能会抛出 OOM 异常。 直接内存（Direct Memory）直接内存不是 JVM 运行时数据区的一部分，JDK 1.4 中新加入了 NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的 I/O 方式，可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆的 DirectByteBuffer 对象作为这块内存的引用进行操作。从而避免在 Java 堆和 Native 堆中来回复制护具，在一些场景中显著提高性能。使用不当会有 OOM 异常。 HotSpot 虚拟机对象探秘基于实用优先原则，以 HotSpot 虚拟机为例，学习在它在 Java 堆中对象分配、布局和访问的全过程。 对象创建在语言层面上，对象创建只需要new关键字即可完成。但是在虚拟机中，这一过程背后实际上并不那么简单。 并不简单 类加载虚拟机收到一条new指令时，首先去检查指令参数能否在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有，则会进行相应的类加载过程。 分配内存对象所需内存大小在类加载完成后即可完全确定，为对象分配内存的操作相当于从堆中划分出一块可使用的区域。有两种分配方式： 指针碰撞 (Bump the Pointer）：当 Java 堆中的内存是绝对规整的，用过的内存和空闲的内存分两边存放，并且有指针指向明确的界限，此时分配内存只需要将指针移动与对象大小相同距离即可。Serial、ParNew 等带 Compact 过程的收集器采用这种方法。 空闲列表（Free List）：当内存不规整、用过的内存和空闲的内存交叉排列时，需要由虚拟机维护一个列表记录哪些内存块是可用的，分配时为对象寻找一块足够大的区域并更新列表。CMS 这种基于 Mark-Sweep 算法的收集器采用这种方法。 除了划分可用空间外，还需要考虑移动指针带来的并发问题。解决并发问题有两个方案： 对分配内存空间的动作进行同步处理，虚拟机采用 CAS 配上失败重试的方法保证更新操作的原子性 把内存分配的动作按照线程划分在不同空间进行，每个线程在 Java 堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）。线程在各自的 TLAB 上为对象分配内存，只有当 TLAB 用尽并分配新的 TLAB 时，才需要同步锁定。 内存分配完成后，虚拟机会讲所分配到的内存空间都初始化为零值。 对象设置虚拟机会设置对象信息（对象是哪个类的实例、如何找到类的元数据信息、哈希码、GC 分代年龄），这些信息保存在对象头（Object Header）中。 init在以上步骤都完成后，开始对象创建，即执行&lt;init&gt;方法，将对象按照构造函数进行初始化，这样一个真正可用的对象才算完全产生出来。 对象内存布局在 HotSpot 虚拟机中，对象在内存中存储的布局分为三块：对象头（Header）、实例数据（Instance Data）、对齐填充（Padding）。 对象头 包括两部分信息 对象自身运行时数据，如哈希码（HashCode）、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等。这部分数据长度在 32 位和 64 位虚拟机中分别是 32bit 和 64bit，官方称它为“Mark Word”。是一个非固定的数据结构。 类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。如果对象是 Java 数组，还需要一块用于记录数组长度的数据。 实例数据 是对象真正存储的有效信息，也就是各种类型字段内容。存储顺序受虚拟机分配策略参数（FieldsAllocationStyle）和字段在 Java 代码中定义顺序影响。 HotSpot 虚拟机默认分配策略是 longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers），相同宽度的字段总被分配到一起 在满足上一条件的前提下，在父类中定义的变量会出现在子类之前。如果 CompactFields 参数值为 true，则子类中较窄的变量也可能会插入到父类变量空隙之中。 对齐填充 不是必须存在的，因为 HotSpot 虚拟机内存管理系统要求对象起始地址必须是 8 字节的整数倍，因此当 实例数据 部分没有对齐时，就要通过对齐填充来补齐。 对象访问定位JVM 栈中保存的是 reference 数据，指向存放在堆中的对象，对象的访问（定位）方式取决于虚拟机具体实现，主流的有句柄和直接指针两种，它们各有优劣。 句柄Java 堆中划分出一块内存来作为句柄池，reference 中保存的是句柄地址，句柄中包含对象实例数据与类型数据各自的具体地址信息。 句柄 优点 reference 中保存的是稳定的句柄地址，在对象被移动（比如 GC）时只会改变句柄中实例数据指针的地址， reference 本身不变。在对象频繁异动的场景里性能更好。 直接指针Java 堆对象头重保存类型数据信息，reference 直接指向对象地址。 直接指针 优点 速度更快，节省了一次指针定位开销，在对象频繁访问的场景里性能更好。HotSpot VM 使用的是直接指针方式。","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://lilei.pro/tags/读书笔记/"},{"name":"JVM","slug":"JVM","permalink":"https://lilei.pro/tags/JVM/"}]},{"title":"深入理解 Java 虚拟机（一）走近 Java","date":"2018-08-09T00:45:15.000Z","path":"2018/08/09/JVM-Note-01/","text":"最近阅读周志明的《深入理解 Java 虚拟机 JVM 高级特性与最佳实践》，以读书笔记的形式记录下所学所得，先给自己定个小目标，完成10篇笔记。 世界上并没有完美的程序，但我们并不因此而沮丧，因为写程序本来就是一个不断追求完美的过程。 概述Java 不仅仅是一门编程语言，更是一个由一系列计算机软件和规范形成的技术体系，这个技术体系提供了完整的用于软件开发和跨平台部署的支持环境。它有一系列优点： 拥有一门结构严谨、面向对象的编程语言 摆脱硬件平台束缚，实现“一次编写，处处运行” 提供相对安全的内存管理和访问机制，避免了绝大部分内存泄露和指针越界 实现热点代码检测和运行时编译及优化，使得 Java 应用能随着运行时间的增加而获取更高的性能 有一套完善的应用程序接口，还有无数第三方类库实现各种功能 Java 技术体系按照组成部分来分，Sun 官方定义的 Java 技术体系包括以下几个方面内容 Java 程序设计语言 各种硬件平台上的 Java 虚拟机 Class 文件格式 Java API 类库 来自商业机构和开源社区的第三方 Java 类库 JDK（Java Development Kit）：Java 程序设计语言 + Java 虚拟机 + Java API 类库，是支持 Java 程序开发的最小环境 JRE（Java Runtime Environment）：Java 虚拟机 + Java SE API，支持Java 程序运行的最小环境 Java技术体系所包含的内容 按照所服务的领域来分，Java 技术体系可以分为4个平台 Java Card：支持一些 Java 小程序（Applets）运行在小内存设备上的平台 Java ME（Micro Edition）：支持 Java 程序运行在移动终端（手机、PDA）平台，对 Java API 有所精简，并加入了针对移动终端的支持，旧称 J2ME Java SE（Standard Edition）：支持面向桌面级应用（如 Windows 下的应用程序）的 Java 平台，提供完整的 Java 核心 API，旧称 J2SE Java EE（Enterprise Edition）：支持面向多层架构的企业应用（如 ERP、CRM）的 Java 平台，除了提供 Java SE API 外，还对其做了大量补充以及部署支持，旧称 J2EE Java 发展史 1991 年 4 月，Oak（橡树）出现，目的在于开发一种能够在各种消费型电子产品（机顶盒、冰箱、收音机）上运行的程序架构，是为 Java 前身 1995 年，Oak 正式更名为 Java，并且在 SunWorld 大会上正式发布 1.0 版本，同时提出“Write Once，Run Everywhere”口号 1998 年，发布里程碑式的 1.2 版本，Sun 在这个版本中将 Java 按照服务领域拆分为三个方向：J2SE, J2ME, J2EE，并且第一次内置了 JIT 编译器，以及内置 Classic、HotSpot、Exact 三种 VM 2002 年，发布第一个真正成熟的版本 1.4，同年出现 .NET 2009 年，发布 1.7，代号 Dolphin 海豚 实践：编译 JDK时间原因没有进行进行编译，只是把源码下载下来，日后有需要会补上","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://lilei.pro/tags/读书笔记/"},{"name":"JVM","slug":"JVM","permalink":"https://lilei.pro/tags/JVM/"}]},{"title":"本周总结 20180723 ~ 20180729","date":"2018-07-30T11:02:20.000Z","path":"2018/07/30/weekly-20180723-20180729/","text":"你的痛苦是因为，包裹你心智的外壳，正在破裂毁伤。你必须经历痛苦，正如果壳必须破裂，果仁才见阳光。 刚刚度过七月的最后一周，这一周自己往返跑了两次杭州，一共面了5家公司，其中两家现场，三家电面。七月的杭州气温达到三十七度，比上海平均高出四五度，顶着烈日奔波在城东城西，这样的经历，还真是难得啊。","tags":[{"name":"周报","slug":"周报","permalink":"https://lilei.pro/tags/周报/"}]},{"title":"面试知识整理 2018.07.29","date":"2018-07-29T04:48:48.000Z","path":"2018/07/29/interview-180729/","text":"有什么手段可以减少APK体积要回答这个问题，首先需要了解APK体积增大的原因，我们从这张经典的APK构建流程图开始分析。 apk_build 可以看到最终生成的 APK 里面，主要包含三部分内容：Java 源码编译出来的.dex文件，编译后的资源文件 &amp; 未经编译的assets目录，以及一些经 NDK 编译后生成的.so文件。下面针对这三方面给出优化的建议。 dex 文件dex 文件包含了所有 Java 类编译出来类文件。从“数量”与“质量”两方面入手，我们可以削减类的数目，还可以减少类文件的大小。 开启 Proguard这样可以在打包时去除没有使用到的类，以及缩短类和字段、方法的命名，从而减少 class 文件大小。需要注意的是，把要保留命名（比如反射）的类 keep 住。对于混淆后打包出来的 APK 应当进行充分的回归测试。 选择较小的适用于移动平台的第三方类库既可以减少了包体 size，也能减少方法数，从而避免 65535 问题。比如在接入 JSON 解析库时，比较常见的几种类库有：Gson（2.8.5，235Kb）、Jackson（2.9.5，三个 Jar，共 1.7Mb）、Fastjson（1.2.47，533Kb），在满足需求的前提下选择包体最小的 Gson。 定制第三方库对于开源的第三方库，如果项目里只用到其中 10% 甚至更少的功能，不妨仅将用到的源码拷贝至自己项目里，而不是通过 gradle 完整引入。 资源文件主要是图片、音视频等，处理不当的话一张图片可能就会增加 1Mb 的体积，因此必须谨慎对待资源文件，不要不加考虑地全盘接受设计师给出的切图。 压缩大小大部分 png 图片是可以压缩的，你可以使用https://compresspng.com/在线进行压缩。对于音视频，也要在保证效果的前提下，尽量缩减体积。 使用更易扩展的图片格式使用矢量图、.9 图代替高清切图，尤其是规则形状的背景、边框图片等。 使用 WebP 格式WebP格式是有损压缩（像JPEG）且有透明通道（像PNG），且压缩率高于JPEG或PNG。在Android Studio中，能将BMP，JPG，PNG或者静态GIF图片转换成WebP格式。 使用WebP文件格式也有一些缺点。第一，低于Android 3.2的版本不支持WebP，第二，WebP的解码时间比PNG长。 用代码代替图片使用属性动画，而非帧动画。帧动画通常需要多张图片组合才能进行播放，此时通过代码实现缩放、旋转等动画是更好的选择；用 RotateDrawable 代替仅仅是方向不同的“内容相同”的图片；用 layer-list 来制作多层图片从而达到复用。 删除不再使用的资源文件随着版本迭代，一些旧日需求引入的资源文件将不再使用，此时应当将它们删除。Android Studio 自带的 Lint 工具可以帮我们完成这件事。在 AS 的菜单中选择 Analyze -&gt; Inspect Code。分析需要一定时间，待分析完成后会在窗口展示结果。其中 Unused resources 即是未使用到的资源文件。 不要忘了清理 assets 文件夹下不再使用的文件。 unused_res 删除资源是根治的方法，如果你想偷点懒，可以通过 shrinkResources 属性让编译器打包时自动剔除不再使用的资源，该属性需要与 proguard 同时开启。 1234567buildTypes &#123; release &#123; minifyEnabled true shrinkResources true proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125;&#125; 如果想看看在激活自动缩减资源后 APK 缩减了多少，可以运行 shrinkReleaseResources 任务，这个任务会打印出包的大小缩减了多少。 自动缩减资源有一个问题：它可能移除了过多的资源，特别是那些动态使用的资源肯定会被删除。为了防止这种情况，可以在 res/raw/ 下的 keep.xml 文件中定义这些例外。 放弃一些图片资源Android 有 ldpi、mdhi、hdpi、xhdpi、xxhdpi、xxxhdpi 等多种分辨率格式，谨慎的人也许会针对分辨率提供一份切图，但我在这里像你建议，千万别这么做。 一方面，Android 系统提供了兼容的处理方案，比如会把 hdpi 的图片缩放到 ldpi 使用。 另一方面，在添加资源文件时应当考虑它所对应机型的占有率。比如绝大部分情况下不需要准备 ldpi 和 xxxhdpi 的图片，前者的手机早已过时，后者则是给 2K 屏幕使用的，目前市面上并不常见，也可以选择忽略。 对于第三方 aar 引入的资源文件，也可以指定引入特定分辨率的，通过 gradle 配置实现这一点。 123456defaultConfig &#123; // ... resConfigs \"en\", \"de\", \"fr\", \"it\" // 指定语言 resConfigs \"hdpi\", \"xhdpi\", \"xxhdpi\" // 指定显示密度&#125; so 文件当我们项目里需要使用 NDK 时，会将编译生成的 .so 文件置于项目里面，当你解压一个 APK 时会发现它们的身影。有以下方法可以缩减它们所占的体积。 使用兼容指令集处理器的指令集通常是向下兼容的，比如[TODO]的指令集就可以兼容[TODO]，意味着你可以只提供一份[TODO]的 so（但我不建议这么做，因为更高版本的指令集可以提供更高的运行效率）。 去除完全用不到的指令集文件比如 x86、x86_64，现在极少手机是使用 x86 的 CPU 架构了，你自然可以去除它们。需要注意的是，如果你想让 APP 在模拟器上运行，仍需要保留它们。 在 gradle 文件的 defaultConfig 域下配置需要的 so： 1234567defaultConfig &#123; // ... ... ndk &#123; //设置支持的SO库架构 abiFilters 'arm64-v8a', 'armeabi' //, 'x86', ,'x86_64', 'armeabi-v7a &#125; &#125; 其它手段插件化插件化技术自 2015 年井喷后，一直是 Android 面试中长盛不衰的面试题。发布 APP 时只发布包含必要功能的宿主，子模块功能以插件的形式下发。也是一个有效降低 APK 体积的方法。但提高了项目的开发难度和维护成本，同时还需要一个成熟的发布后台。 APK 分割可以通过在 gradle 配置中定义一个 splits 代码块来配置分割，目前支持 density 分割和 ABI 分割。比如你可以通过配置，在一次打包中生成以下 APK，进而将它们分别发布给不同机型。 density 分割 app-hdpi-release.apk app-universal-release.apk app-xhdpi-release.apk app-xxhdpi-release.apk app-xxxhdpi-release.apk ABI 分割 app-armeabi-v7a-debug.apk app-mips-debug.apk app-x86-debug.apk 模块化这个 Title 太大，我会单独撰文加以讲解。 插件化这个 Title 太大，我同样会单独撰文加以讲解。上个月刚读完包建强所著的《Android 插件话开发指南》一书，所获颇丰。后面我会将书中的重点内容总结成文字笔记分享在博客里面。 GET 和 POST 区别本质上无区别首先，GET 和 POST 都是HTTP 协议中发送请求的方法，这两者底层的协议也都是 TCP/IP，这两者并没有本质上的区别。 从底层原理上，GET 产生了一个 TCP 数据包，POST 产生了两个 TCP 数据包。 对于 GET 请求，浏览器把 HTTP Header 和 Data 一同发送出去，服务器相应 200。 对于 POST 请求，浏览器 先发送 HTTP Header，服务器响应 100（continue），浏览器再发送 Data，服务器响应 200（返回数据）。 是否可以互换那么是否可以把所有的 POST 请求都改成 GET，以提高网站相应效率呢？答案是不行。 两者具有不同的语义。 在网络环境好的情况下，两次请求与一次请求在响应时间上相差微乎其微；在网络情况差的情况下，两次请求更有助于进行数据完整性校验。 并非所有浏览器在 POST 时都发送两个包，Firefox 就只发送一次。 其它一些补充 浏览器回退：GET在浏览器回退时是无害的（幂等性），而POST会再次提交请求。 Bookmark：GET产生的URL地址可以被Bookmark，而POST不可以。 Cache：GET请求会被浏览器主动cache，而POST不会，除非手动设置。 编码：GET请求只能进行url编码，而POST支持多种编码方式。 参数保存：GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。 参数长度：GET请求在URL中传送的参数是有长度限制的，而POST没有。 参数类型：对参数的数据类型，GET只接受ASCII字符，而POST没有限制。 参数安全：GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。 参数传递：GET参数通过URL传递，POST放在Request body中。 LeakCanary 检查内存泄漏的原理背景知识JVM 运行时内存分区，内存模型，垃圾回收算法，GC Roots，强软弱虚引用。 A small leak will sink a great ship.– Benjamin Franklin LeakCanary 是由Square公司开源的内存泄漏检测工具。Logo 是一只小黄鸡。 LeakCanaryLogo 基本原理 在 Activity.onDestroy 方法里手动触发 GC。 利用 ReferenceQueue + WeakReference 判断是否有未释放的引用。 结合 dump memory 得到的 hprof 文件，利用 HaHa(Headless Android Heap Analyzer) 分析出泄漏位置。 源码分析整体流程 leakcanary整体流程 入口需要在 Application 类中启用 LeakCanary。 1234567891011// 安装if (!LeakCanary.isInAnalyzerProcess(WeiboApplication.this)) &#123; LeakCanary.install(WeiboApplication.this);&#125;// installpublic static RefWatcher install(Application application) &#123; return ((AndroidRefWatcherBuilder) refWatcher(application) .listenerServiceClass(DisplayLeakService.class).excludedRefs(AndroidExcludedRefs.createAppDefaults().build())) //配置监听器及分析数据格式 .buildAndInstall();&#125; LeakCanary 会运行在两个进程：App进程中运行监听任务，工作进程中运行分析任务。 监听在install方法里，创建了一个RefWatcher对象。 12345678910111213141516171819202122232425262728293031public RefWatcher buildAndInstall() &#123; RefWatcher refWatcher = this.build(); if(refWatcher != RefWatcher.DISABLED) &#123; LeakCanary.enableDisplayLeakActivity(this.context); ActivityRefWatcher.install((Application)this.context, refWatcher); &#125; return refWatcher;&#125;public static void install(Application application, RefWatcher refWatcher) &#123; (new ActivityRefWatcher(application, refWatcher)).watchActivities();&#125;private final ActivityLifecycleCallbacks lifecycleCallbacks = new ActivityLifecycleCallbacks() &#123; public void onActivityCreated(Activity activity, Bundle savedInstanceState) &#123; &#125; public void onActivityStarted(Activity activity) &#123;&#125; public void onActivityResumed(Activity activity) &#123;&#125; public void onActivityPaused(Activity activity) &#123;&#125; public void onActivityStopped(Activity activity) &#123; &#125; public void onActivitySaveInstanceState(Activity activity, Bundle outState) &#123;&#125; public void onActivityDestroyed(Activity activity) &#123; ActivityRefWatcher.this.onActivityDestroyed(activity); &#125;&#125;;void onActivityDestroyed(Activity activity) &#123; this.refWatcher.watch(activity);&#125; LeakCanary 通过Application.registerActivityLifecycleCallbacks方法，注册了 Activity 生命周期的监听，在监测到onDestroyed调用时，触发RefWatcher.watch方法。下面是该方法的实现。 12345678910111213141516171819202122232425262728293031public void watch(Object watchedReference, String referenceName) &#123; if (this != DISABLED) &#123; Preconditions.checkNotNull(watchedReference, \"watchedReference\"); Preconditions.checkNotNull(referenceName, \"referenceName\"); long watchStartNanoTime = System.nanoTime(); String key = UUID.randomUUID().toString();//保证key的唯一性 this.retainedKeys.add(key); KeyedWeakReference reference = new KeyedWeakReference(watchedReference, key, referenceName, this.queue); this.ensureGoneAsync(watchStartNanoTime, reference); &#125;&#125; final class KeyedWeakReference extends WeakReference&lt;Object&gt; &#123; public final String key; public final String name; KeyedWeakReference(Object referent, String key, String name, ReferenceQueue&lt;Object&gt; referenceQueue) &#123; //ReferenceQueue类监听回收情况 super(Preconditions.checkNotNull(referent, \"referent\"), (ReferenceQueue)Preconditions.checkNotNull(referenceQueue, \"referenceQueue\")); this.key = (String)Preconditions.checkNotNull(key, \"key\"); this.name = (String)Preconditions.checkNotNull(name, \"name\"); &#125;&#125;private void ensureGoneAsync(final long watchStartNanoTime, final KeyedWeakReference reference) &#123; this.watchExecutor.execute(new Retryable() &#123; public Result run() &#123; return RefWatcher.this.ensureGone(reference, watchStartNanoTime); &#125; &#125;);&#125; 类KeyedWeakReference是WeakReference，这里利用了ReferenceQueue来监听 GC 后的回收情况。ReferenceQueue的原理是，当 GC 检测到对象生命周期结束时，会将其添加到 ReferenceQueue 中。当 GC 过后对象一直不被加入 ReferenceQueue，说明它可能存在内存泄漏。 正是利用 ReferenceQueue 这一特性，LeakCanary 实现了对对象是否被释放的监控。 监测 Fragment 泄漏上文中看到只在 Activity.onDestroy 中进行检测，如果需要检测 Fragment 时，应当手动在 Fragment.onDestroy 中创建一个 RefWatcher 对象，并调用 watch 方法。 1234567public abstract class BaseFragment extends Fragment &#123; @Override public void onDestroy() &#123; super.onDestroy(); RefWatcher refWatcher = ExampleApplication.getRefWatcher(getActivity()); refWatcher.watch(this); &#125;&#125; ensureGone是检测回收的核心代码。 12345678910111213141516171819202122232425262728293031323334353637Result ensureGone(KeyedWeakReference reference, long watchStartNanoTime) &#123; long gcStartNanoTime = System.nanoTime(); long watchDurationMs = TimeUnit.NANOSECONDS.toMillis(gcStartNanoTime - watchStartNanoTime); this.removeWeaklyReachableReferences(); //先将引用尝试从队列中poll出来 if(this.debuggerControl.isDebuggerAttached()) &#123; //规避调试模式 return Result.RETRY; &#125; else if(this.gone(reference)) &#123; //检测是否已经回收 return Result.DONE; &#125; else &#123; //如果没有被回收，则手动GC this.gcTrigger.runGc();//手动GC方法 this.removeWeaklyReachableReferences();//再次尝试poll，检测是否被回收 if(!this.gone(reference)) &#123; // 还没有被回收，则dump堆信息，调起分析进程进行分析 long startDumpHeap = System.nanoTime(); long gcDurationMs = TimeUnit.NANOSECONDS.toMillis(startDumpHeap - gcStartNanoTime); File heapDumpFile = this.heapDumper.dumpHeap(); if(heapDumpFile == HeapDumper.RETRY_LATER) &#123; return Result.RETRY;//需要重试 &#125; long heapDumpDurationMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startDumpHeap); this.heapdumpListener.analyze(new HeapDump(heapDumpFile, reference.key, reference.name, this.excludedRefs, watchDurationMs, gcDurationMs, heapDumpDurationMs)); &#125; return Result.DONE; &#125;&#125;private boolean gone(KeyedWeakReference reference) &#123; return !this.retainedKeys.contains(reference.key);&#125;private void removeWeaklyReachableReferences() &#123; KeyedWeakReference ref; while((ref = (KeyedWeakReference)this.queue.poll()) != null) &#123; this.retainedKeys.remove(ref.key); &#125;&#125; ensureGone方法通过检测referenceQueue队列的引用情况，来判断回收情况，通过手动 GC 来进一步确认回收情况。这是一个耗时过程，运行在WatchExecutor中。 LeakCanary 在主线程空闲时候执行检测任务，代码位于AndroidWatchExecutor中。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public final class AndroidWatchExecutor implements WatchExecutor &#123; static final String LEAK_CANARY_THREAD_NAME = \"LeakCanary-Heap-Dump\"; private final Handler mainHandler = new Handler(Looper.getMainLooper()); private final Handler backgroundHandler; private final long initialDelayMillis; private final long maxBackoffFactor; public AndroidWatchExecutor(long initialDelayMillis) &#123; HandlerThread handlerThread = new HandlerThread(\"LeakCanary-Heap-Dump\"); handlerThread.start(); this.backgroundHandler = new Handler(handlerThread.getLooper()); this.initialDelayMillis = initialDelayMillis; this.maxBackoffFactor = 9223372036854775807L / initialDelayMillis; &#125; public void execute(Retryable retryable) &#123; if(Looper.getMainLooper().getThread() == Thread.currentThread()) &#123; this.waitForIdle(retryable, 0);//需要在主线程中检测 &#125; else &#123; this.postWaitForIdle(retryable, 0);//post到主线程 &#125; &#125; void postWaitForIdle(final Retryable retryable, final int failedAttempts) &#123; this.mainHandler.post(new Runnable() &#123; public void run() &#123; AndroidWatchExecutor.this.waitForIdle(retryable, failedAttempts); &#125; &#125;); &#125; void waitForIdle(final Retryable retryable, final int failedAttempts) &#123; Looper.myQueue().addIdleHandler(new IdleHandler() &#123; public boolean queueIdle() &#123; AndroidWatchExecutor.this.postToBackgroundWithDelay(retryable, failedAttempts);//切换到子线程 return false; &#125; &#125;); &#125; void postToBackgroundWithDelay(final Retryable retryable, final int failedAttempts) &#123; long exponentialBackoffFactor = (long)Math.min(Math.pow(2.0D, (double)failedAttempts), (double)this.maxBackoffFactor); // 二进制退让算法 long delayMillis = this.initialDelayMillis * exponentialBackoffFactor; this.backgroundHandler.postDelayed(new Runnable() &#123; public void run() &#123; Result result = retryable.run();//RefWatcher.this.ensureGone(reference, watchStartNanoTime)执行 if(result == Result.RETRY) &#123; AndroidWatchExecutor.this.postWaitForIdle(retryable, failedAttempts + 1); &#125; &#125; &#125;, delayMillis); &#125;&#125; 其中调用了MessageQueue.addIdleHandler方法，Looper 中的 MessageQueue 有个mIdleHandlers队列，在获取下个要执行的 Message 时，如果没有发现可执行的 Message，就会回调queueIdle()方法，如果queueIdle()返回false，则移除该 IdleHandler。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869Message next() &#123; int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) &#123; ··· ···//省略部分消息查找代码 if (msg != null) &#123; if (now &lt; msg.when) &#123; // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; ··· return msg; &#125; &#125; else &#123; // No more messages. nextPollTimeoutMillis = -1; &#125; // If first time idle, then get the number of idlers to run. // Idle handles only run if the queue is empty or if the first message // in the queue (possibly a barrier) is due to be handled in the future. if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123; pendingIdleHandlerCount = mIdleHandlers.size(); &#125; if (pendingIdleHandlerCount &lt;= 0) &#123; // No idle handlers to run. Loop and wait some more. mBlocked = true; continue; &#125; if (mPendingIdleHandlers == null) &#123; mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; &#125; mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); &#125; // Run the idle handlers. // We only ever reach this code block during the first iteration. for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123; final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handler boolean keep = false; try &#123; keep = idler.queueIdle(); &#125; catch (Throwable t) &#123; Log.wtf(TAG, \"IdleHandler threw exception\", t); &#125; if (!keep) &#123;//返回false，则从队列移除，下次空闲不会调用。 synchronized (this) &#123; mIdleHandlers.remove(idler); &#125; &#125; &#125; // Reset the idle handler count to 0 so we do not run them again. pendingIdleHandlerCount = 0; // While calling an idle handler, a new message could have been delivered // so go back and look again for a pending message without waiting. nextPollTimeoutMillis = 0; &#125;&#125; 分析利用 VMDebug+HaHa 完成分析任务。 在后台线程检查引用是否被清除，如果没有，调用 GC。 如果引用还是未被清除，把 heap 内存 dump 到 APP 对应的文件系统中的一个 .hprof 文件中。 在另外一个进程中的 HeapAnalyzerService 有一个 HeapAnalyzer 使用HAHA 解析这个文件。 得益于唯一的 reference key, HeapAnalyzer 找到 KeyedWeakReference，定位内存泄漏。 HeapAnalyzer 计算 到 GC roots 的最短强引用路径，并确定是否是泄漏。如果是的话，建立导致泄漏的引用链。 引用链传递到 APP 进程中的 DisplayLeakService， 并以通知的形式展示出来。 HeapAnalyzerService是一个 IntentService，调用 HAHA 中的HeapAnalyzer对 hprof 文件进行分析，找出泄露点。由于运行在不同进程，通过 Intent 传递数据。最终将结果发回给监听器。 1234567891011@Override protected void onHandleIntent(Intent intent) &#123; if (intent == null) &#123;// intent 为空直接返回 CanaryLog.d(\"HeapAnalyzerService received a null intent, ignoring.\"); return; &#125; String listenerClassName = intent.getStringExtra(LISTENER_CLASS_EXTRA);//获取回调类的类名 HeapDump heapDump = (HeapDump) intent.getSerializableExtra(HEAPDUMP_EXTRA);//获取 HeapDump HeapAnalyzer heapAnalyzer = new HeapAnalyzer(heapDump.excludedRefs);//创建 HeapAnalyzer AnalysisResult result = heapAnalyzer.checkForLeak(heapDump.heapDumpFile, heapDump.referenceKey);//检查泄漏（通过 HAHA 来完成），并获取结果 AbstractAnalysisResultService.sendResultToListener(this, listenerClassName, heapDump, result);//将分析结果发送给监听器&#125; 参考掘金：Java 内存问题及 LeakCanary 原理分析拆轮子系列——LeakCanary工作原理 创建一个对象时内部流程Java 在 new 一个对象的时候，会先检查对象所属的类是否已经加载到内存。如果没有加载，则会先执行类的加载过程；如果已经加载，则直接执行对象的创建过程。 类的加载过程Java 使用双亲委派模型来进行类的加载。 如果一个类加载器（ClassLoader）收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委托给父类加载器去完成，每一个层次的类加载器都是如此。因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需要加载的类）时，子加载器才会尝试自己去加载。 这样做的好处是能够确保一个类的全局唯一性。因为类的唯一性由加载器+类名共同决定。使用双亲委派模型保证了同一个类始终由同一加载器进行加载。 类加载过程 1. 加载由类加载器负责根据一个类的全限定名来读取此类的二进制字节流到 JVM 内部，并存储在运行时内存区的方法区，然后将其转换为一个与目标类型对应的 java.lang.Class 对象实例。 2. 验证 格式验证：验证是否符合class文件规范。 语义验证：检查一个被标记为final的类型是否包含子类；检查一个类中的final方法是否被子类进行重写；确保父类和子类之间没有不兼容的一些方法声明（比如方法签名相同，但方法的返回值不同）。 操作验证：在操作数栈中的数据必须进行正确的操作，对常量池中的各种符号引用执行验证（通常在解析阶段执行，检查是否可以通过符号引用中描述的全限定名定位到指定类型上，以及类成员信息的访问修饰符是否允许访问等）。 3. 准备为类中的所有静态变量分配内存空间，并为其设置一个初始值；被final修饰的static变量（常量），会直接赋值。 4. 解析将常量池中的符号引用转为直接引用（得到类或者字段、方法在内存中的指针或者偏移量，以便直接调用该方法），这个可以在初始化之后再执行。 解析需要静态绑定的内容。（所有不会被重写的方法和域都会被静态绑定） 以上 2、3、4 三个阶段又合称为链接阶段，链接阶段要做的是将加载到 JVM 中的二进制字节流的类数据信息合并到 JVM 的运行时状态中。 5. 初始化（父父子子）5.1 赋值静态变量。 5.2 执行静态代码块。 因为子类存在对父类的依赖，所以类的加载顺序是先加载父类后加载子类，初始化也一样。 最终，方法区会存储当前类类信息，包括类的静态变量、类初始化代码（定义静态变量时的赋值语句 和 静态初始化代码块）、实例变量定义、实例初始化代码（定义实例变量时的赋值语句实例代码块和构造方法）和实例方法，还有父类的类信息引用。 对象创建过程1. 在堆区分配对象需要的内存包括本类与父类所有实例变量，不包括静态变量。 2. 为实例变量赋默认值将方法区内对实例变量的定义拷贝一份到堆区，然后赋默认值。 3. 执行实例初始化代码初始化顺序是先初始化父类再初始化子类，初始化时先执行实例代码块然后是构造方法。 如果我们对实例变量直接赋值或者使用实例代码块赋值，那么编译器会将其中的代码放到类的构造函数中去，并且这些代码会被放在对超类构造函数的调用语句之后(Java要求构造函数的第一条语句必须是超类构造函数的调用语句)，构造函数本身的代码之前。 如果有类似于Child c = new Child()形式的c引用的话，在栈区定义Child类型引用变量c，然后将堆区对象的地址赋值给它。 需要注意的是，每个子类对象持有父类对象的引用，可在内部通过 super 关键字来调用父类方法，但在外部不可访问。并且子类对象创建时只是调用父类构造函数，并非创建父类对象。 Java 要求在实例化类之前，必须先实例化其超类，以保证所创建实例的完整性。如果我们既没有调用其他的构造函数，也没有显式调用超类的构造函数，那么编译器会为我们自动生成一个对超类构造函数的调用。 虚方法表通过实例引用调用实例方法的时候，先从方法区中对象的实际类型信息找，找不到的话再去父类类型信息中找。 如果继承的层次比较深，要调用的方法位于比较上层的父类，则调用的效率是比较低的，因为每次调用都要经过很多次查找。这时候大多系统会采用一种称为虚方法表的方法来优化调用的效率。 所谓虚方法表，就是在类加载的时候，为每个类创建一个表，这个表包括该类的对象所有动态绑定的方法及其地址，包括父类的方法，但一个方法只有一条记录，子类重写了父类方法后只会保留子类的。当通过对象动态绑定方法的时候，只需要查找这个表就可以了，而不需要挨个查找每个父类。 Demo实例初始化不一定要在类初始化结束之后才开始初始化 类初始化&lt;clinit&gt;() 实例初始化&lt;init&gt;() 在Java中， 创建一个对象常常需要经历如下几个过程： 父类的类构造器&lt;clinit&gt;() 子类的类构造器&lt;clinit&gt;() 父类的成员变量和实例代码块 父类的构造函数 子类的成员变量和实例代码块 子类的构造函数。 你可以使用 https://www.tutorialspoint.com/compile_java_online.php 进行在线验证。 一道测验题12345678910111213141516171819202122232425262728293031323334public class StaticTest &#123; public static void main(String[] args) &#123; staticFunction(); &#125; static StaticTest st = new StaticTest(); static &#123; //静态代码块 System.out.println(\"1\"); &#125; &#123; // 实例代码块 System.out.println(\"2\"); &#125; StaticTest() &#123; // 实例构造器 System.out.println(\"3\"); System.out.println(\"a=\" + a + \",b=\" + b); &#125; public static void staticFunction() &#123; // 静态方法 System.out.println(\"4\"); &#125; int a = 110; // 实例变量 static int b = 112; // 静态变量&#125;/* Output: 2 3 a=110,b=0 1 4*/ 另一道测验题1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Foo &#123; int i = 1; Foo() &#123; System.out.println(i); int x = getValue(); System.out.println(x); &#125; &#123; i = 2; &#125; protected int getValue() &#123; return i; &#125;&#125;//子类class Bar extends Foo &#123; int j = 1; Bar() &#123; j = 2; &#125; &#123; j = 3; &#125; @Override protected int getValue() &#123; return j; &#125;&#125;public class ConstructorExample &#123; public static void main(String... args) &#123; Bar bar = new Bar(); System.out.println(bar.getValue()); &#125;&#125;/* Output:202*/ 参考 博客园 - java new 一个对象的过程中发生了什么 CSDN - JVM类生命周期概述：加载时机与加载过程 IBM - 解析 Java 类和对象的初始化过程","tags":[{"name":"Android","slug":"Android","permalink":"https://lilei.pro/tags/Android/"},{"name":"面试","slug":"面试","permalink":"https://lilei.pro/tags/面试/"}]},{"title":"西虹市首富","date":"2018-07-28T14:24:56.000Z","path":"2018/07/28/hello-mr-billionaire/","text":"不给我生一百个孩子你都对不起我！ JVM 开心麻花很擅长抓住平凡人的心里的爽点，和网络小说的套路一样，资质平平屡遭白眼的男主角，机缘巧合之下得到一笔巨大的财富/绝世的武功，一路干翻仇家，将曾经不把他放在眼里的对头们一一踩在脚下。最后举目四顾遗世独立，感到无敌是多么寂寞，甘愿自废武功散尽家财，做回一个普通人。 《夏洛特烦恼》是这样，《西虹市首富》也如此。 十亿人民币，首富口中的“小目标”x10，普通人一辈子别说赚这么多钱，能见到一次恐怕都是三生有幸。所以开心麻花拍了这样一部电影，让我们这些平凡人看到，原来十亿人民币可以堆满两百平的屋子，原来有钱人可以吃饭不吃主食只吃龙虾松茸，原来有钱人可以请到王力宏为他开一场私人演唱会，原来有钱人做的决策就算狗屁不通也能让他的钱越滚越多…… 以后老子也是见过十亿人民币的人了，十亿人民币，现金。 不论情怀还是包袱，这部电影比起《夏洛特烦恼》都落于下风，除了王力宏的出场，让影院里响起一片惊叹之声。我个人对开心麻花几部电影的排名是： 《夏洛特烦恼》 《驴得水》 《西红柿首富》 《羞羞的铁拳》 2018.07.28@上影徐汇日月光店","tags":[{"name":"电影","slug":"电影","permalink":"https://lilei.pro/tags/电影/"}]},{"title":"我不是药神","date":"2018-07-27T09:38:47.000Z","path":"2018/07/27/dying-to-survive/","text":"我希望今后会越来越好，我相信会的。 吕受益 如果没有事先从朋友圈里得到铺垫，在看电影前半段，直到徐峥扮演的程勇来到吕受益家中做客时，自己几乎要以为这是一部类似“X囧”的喜剧片。不论从节奏、台词和剧情上来看，都太像了。浑不吝的保健品店老板，戴着蛤蟆镜鬼头鬼脑让人想不起他是病人的吕受益，满嘴英文一本正经的老神父，还有夜店女王这个颜值担当，以及无口黄毛小酷哥。多好的西天取经五人组。 但徐峥毕竟是徐峥，拍过《心花路放》这种喜剧外壳的公路文艺片。他有野心，更有能力。 于是在看到警察突袭白血病人旅馆，拘留了一屋子人，却没有一个供出程勇，老人白发苍苍，向警官哭诉着被疾病剥夺的一切时，我第一次眼眶湿润了。在突如其来的疾病面前，你引以为傲的学识、事业、金钱、地位都脆弱不堪一击。去年有一篇在朋友圈疯传的长文，《流感侵袭下的北京中产阶级》，深深地揭露了这种无力的现状。 为了升职加薪，为了KPI，为了买房上车，为了下一代，为了不比同龄人落后，为了别人的期待目光，为了过上自己想要的生活。你夜以继日熬秃了发际线熬深了近视眼熬出了小肚腩所换来的一切，在一场疾病面前轰然倒塌，瓦砾遍地。 以前自己总会有这种想法，现代医学虽然延长了人类的寿命，但在它的庇护下，人类自身机体的抵抗力反而下降，变得如同温室中的花朵般更加脆弱易折。 我们从病床上赤条条地来，也终将在病床上赤条条地离开，带不走任何一样东西。 最终徐峥被警车押运走，警官吩咐开车的同伴放慢速度，看到街边送行的白血病人纷纷摘下口罩，去世的吕受益和黄毛浩子也出现在人群中，我第二次流泪。 君以国士待我，我必以国士报之。 病魔无情，人间有爱。其实倘若人间无爱，病魔也就无从可怕，不自爱，则身体发肤，皆可毁伤；不爱人，则漠视生命，天性凉薄。可人活着，不就是仗着心底总有一些不可割舍的爱么？ 由爱故生忧，由爱故生怖，若离于爱者，无忧亦无怖。","tags":[{"name":"电影","slug":"电影","permalink":"https://lilei.pro/tags/电影/"}]},{"title":"缝纫机乐队","date":"2018-07-27T09:01:06.000Z","path":"2018/07/27/city-of-rock/","text":"心里还有那口气儿，惦记的是每天什么时候开始；卸下那口气儿，惦记的是每天什么时候结束。 ​ 都选C - 虾米音乐 虽然娜扎很美，但我认为乔杉才是本片的演技、笑点乃至颜值担当。 保健哥 剧情中有一段是老吉他手拿出当年的电吉他擦拭，乔杉盛赞这是吉他界的柳岩，想要摸一摸结果被老吉他手一巴掌扇掉。大鹏在一旁嘲讽道“柳岩那是谁都能摸的么？”。看到这里会心一笑，曾经拍《屌丝男士》时，大鹏没少与柳岩演对手戏。 大鹏强行为自己和娜扎安排的感情线，不仅对剧情推进毫无帮助，而且真的很尬。 岳云鹏扮演的钢琴家，虽然说不出喜感在哪，但让人一看到他那张圆脸，就忍不住想笑，也许这就是祖师爷赏饭吃吧。那一句“女人啊，你的名字是贪婪”硬生生地将整部电影的文学水平拔高了一厘米。 尽管它在豆瓣上的评分不到7，大抵属于“拍的不差，但也算不上多好”的水平。但我偏偏喜欢，自己大概本就是个俗人吧。 看这部电影的时候，正坐在 K8402 杭州 - 上海南 的加1车厢里，求职中第三次往返于杭州上海，这天面试了第十家公司。 看了，笑了，哭了，够了。揣着那口气儿，生活仍要继续。 P.S. 集安市，隶属吉林省通化市，位于吉林东南部，与朝鲜一江之隔。已列入旅游名单。","tags":[{"name":"电影","slug":"电影","permalink":"https://lilei.pro/tags/电影/"}]},{"title":"面试知识整理 2018.07.26","date":"2018-07-26T04:51:20.000Z","path":"2018/07/26/interview-180726/","text":"谈谈 SparseArray用法使用 Key-Value 保存对象的集合，类似 HashMap，但只允许使用 int 型的 Key 特点 （优点）内存效率高，避免自动装箱，避免了使用 Entry 来构建数据结构，int 4 bytes，Integer 16 bytes （缺点）使用二分法查找对象，在数据体量大（more than hundreds of items）的场景下查找/插入/删除效率不如 HashMap 删除过程优化：先标记 item，待 GC 时真正删除 操作 随机插入：put(int, x)，会替换掉已有的对象 顺序插入：append(int, x)，当 Key 比目前所有的都要大时执行效率更高，否则同 put 随机删除：delete(int)，删除 Key 对应的对象 顺序删除：removeAt(int)，删除第 N 项 范围删除：removeAtRange(int, int) 随机访问：get(int)，根据 Key 获取 Value，如果没有则返回 null 顺序访问：valueAt(int) 遍历：keyAt(int)，获取第 n 位的 key；valueAt(int)，获取第 n 位 key 对应的 value；indexOfKey(int)，获取 key 的 index；indexOfValue(int)，获取 value 的 index 源码阅读成员变量部分 12345678910private static final Object DELETED = new Object(); // 删除对象时，并非真正删除，而是将 Value 替换成 DELETE 对象private boolean mGarbage = false; // 标示是否需要进行 gcprivate int[] mKeys;private Object[] mValues;private int mSize;public SparseArray() &#123; this(10); // 默认长度是10&#125; 在调用 append, put, size 等方法时会触发 GC，是一个逐项复制的过程，代码如下 1234567891011121314151617181920212223private void gc() &#123; int n = mSize; int o = 0; int[] keys = mKeys; Object[] values = mValues; for (int i = 0; i &lt; n; i++) &#123; Object val = values[i]; if (val != DELETED) &#123; // 判断是否已经标记 if (i != o) &#123; keys[o] = keys[i]; values[o] = val; values[i] = null; &#125; o++; &#125; &#125; mGarbage = false; mSize = o;&#125; put 过程，核心是先判断有没有同一个 key 存在，有则替换，没有的话，再判断是否目标位置刚好被 DELETED 标记，最后才进行加项操作 1234567891011121314151617181920212223242526public void put(int key, E value) &#123; int i = ContainerHelpers.binarySearch(mKeys, mSize, key); // 二分查找 key 的位置 if (i &gt;= 0) &#123; // 如果已经有同一个 key mValues[i] = value; &#125; else &#123; i = ~i; // 求异或 if (i &lt; mSize &amp;&amp; mValues[i] == DELETED) &#123; // 目标位置项目已经标记 DELETE，可以直接替换 mKeys[i] = key; mValues[i] = value; return; &#125; if (mGarbage &amp;&amp; mSize &gt;= mKeys.length) &#123; // 需要寻找新的位置，此时先 gc gc(); // Search again because indices may have changed. i = ~ContainerHelpers.binarySearch(mKeys, mSize, key); &#125; mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key); // 运用 System.arraycopy 进行添加（有必要则扩容） mValues = GrowingArrayUtils.insert(mValues, mSize, i, value); mSize++; &#125;&#125; delete 过程，先二分查找到目标位置，标记 DELETED，不直接删除 12345678910public void delete(int key) &#123; int i = ContainerHelpers.binarySearch(mKeys, mSize, key); if (i &gt;= 0) &#123; if (mValues[i] != DELETED) &#123; mValues[i] = DELETED; mGarbage = true; &#125; &#125;&#125; Handler 内部原理，HandlerThread 与普通 Thread 区别Handler 的两个用途 管理消息/任务队列，可以控制立即执行或者延迟执行 调度任务在不同线程运行f 主要概念 Handler：消息分发器，一个 Handler 里面会关联一个 MessageQueue，这个 MessageQueue 来自当前线程的 Looper Looper：消息循环器，从 MQ 里面不断取出消息运行。非 UI 线程是没有默认创建 Looper 的，需要人工调用 prepare 和 loop 来启动 Looper。被声明为 ThreadLocal，每一个线程独立拥有 Message：消息单元，内部用消息池管理，默认 capacity = 50 MessageQueue：消息队列，单链表，每个消息入队时会带上一个运行时间 when，根据这个 when 将其放入队列中相应的位置（早执行的放在队首），整个队列是按照运行时间排序的 原理流程概述创建 Handler 时会关联当前线程 Looper 中的 MQ，当用 Handler 对象发送消息时，消息会进入 MQ，经 Looper 轮询取出后进行处理，处理时会调用所实现的 handleMessage 方法。 UI 线程创建 Looper ActivityThread 在 main 方法里通过 Looper.prepareMainLooper() 创建主 Looper，并将其存入 ThreadLocal 变量中。同时将它另存一份作为主线程 Looper，供其他线程访问。 在 main 方法最后通过 looper.loop() 启动轮询 123456public static void main(String[] args) &#123; Looper.prepareMainLooper(); ActivityThread thread = new ActivityThread(); thread.attach(false); Looper.loop(); &#125; Handler 发送消息的流程构造过程中取出当前线程持有的 Looper，并保存其 MQ 对象 123456public Handler(Callback callback, boolean async) &#123; mLooper = Looper.myLooper(); mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async; &#125; handler通过sendMessage(msg) 将消息发出，消息最终走向 queue.enqueueMessage(msg, uptimeMillis) 进入队列，同时将当前 Handler 以 target 保存在消息对象中，当 Looper 轮询时，会取出 target 用于处理消息 1234567891011121314private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; return queue.enqueueMessage(msg, uptimeMillis); &#125;public static void loop() &#123; final Looper me = myLooper(); final MessageQueue queue = me.mQueue; for (;;) &#123; Message msg = queue.next(); // 取出消息，无消息则阻塞 if (msg == null) &#123; return; &#125; msg.target.dispatchMessage(msg);//发送消息 其中target就是Handler &#125; &#125; dispatchMessage 最终会调到 Handler 中实现的 handleMessage 123456789101112public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125; &#125; HandlerThread构造函数里创建了自己的 Looper 并且开启轮询，普通 Thread 不含 Looper Picasso VS Glide 项目 Picasso Glide 图片格式 ARGB8888 RGB_565 缓存 原图尺寸 显示尺寸 GIF 不支持 支持 video 不支持 支持 Library size 100K 500K Methods count 500 2500 View 的绘制过程一个 Activity 的窗口页面，可以分为PhoneWindow、DecorView、TitleBar &amp; ContentView 几个层级 window.png 整个 View 树的绘图流程在 ViewRootImpl.performTraversals() 方法中，它主要做的事情是根据之前设置的状态，判断是否需要重新计算视图大小（measure）、是否需要重新放置视图位置（layout）以及是否需要重新绘制（draw），代码如下 measure：测量，指测量 View 的宽高 layout：布局，指确定在父容器中的位置坐标 draw：绘制并显示 1234567891011121314private void performTraversals() &#123; ...... //最外层的根视图的widthMeasureSpec和heightMeasureSpec由来 //lp.width和lp.height在创建ViewGroup实例时等于MATCH_PARENT int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width); int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height); ...... mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); ...... mView.layout(0, 0, mView.getMeasuredWidth(), mView.getMeasuredHeight()); ...... mView.draw(canvas); ...... &#125; perform_traversals measure 过程分析整个 View 树从根 View 开始，递归进行 measure measure.png View.java 123456789101112131415161718192021222324252627282930313233/** * &lt;p&gt; * This is called to find out how big a view should be. The parent * supplies constraint information in the width and height parameters. * &lt;/p&gt; * * &lt;p&gt; * The actual measurement work of a view is performed in * &#123;@link #onMeasure(int, int)&#125;, called by this method. Therefore, only * &#123;@link #onMeasure(int, int)&#125; can and must be overridden by subclasses. * &lt;/p&gt; * * * @param widthMeasureSpec Horizontal space requirements as imposed by the * parent * @param heightMeasureSpec Vertical space requirements as imposed by the * parent * * @see #onMeasure(int, int) */ //final方法，子类不可重写public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123; ...... //回调onMeasure()方法 onMeasure(widthMeasureSpec, heightMeasureSpec); ......&#125;//View的onMeasure默认实现方法protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));&#125; MeasureSpec 的语义是父 View 对子 View 在长宽上的约束，有三种取值 EXACTLY：不管子 View 想多大，它只能这么大 AT_MOST：最大只能这么大 UNSPECIFIED：不加约束，子 View 想多大就多大 measure 过程主要就是从顶层父 View 向子 View 递归调用 view.measure 方法（measure中 又回调 onMeasure 方法）的过程。具体 measure 核心主要有如下几点 View的measure方法是final的，不允许重载，View子类只能重载onMeasure来完成自己的测量逻辑。 最顶层DecorView测量时的MeasureSpec是由ViewRootImpl中getRootMeasureSpec方法确定的（LayoutParams宽高参数均为MATCH_PARENT，specMode是EXACTLY，specSize为物理屏幕大小）。 ViewGroup类提供了measureChild，measureChild和measureChildWithMargins方法，简化了父子View的尺寸计算。 只要是ViewGroup的子类就必须要求LayoutParams继承子MarginLayoutParams，否则无法使用layout_margin参数。 View的布局大小由父View和子View共同决定。 使用View的getMeasuredWidth()和getMeasuredHeight()方法来获取View测量的宽高，必须保证这两个方法在onMeasure流程之后被调用才能返回有效值。 layout 过程分析View.performTraversals 在 measure 之后，会执行 layout 过程 12345private void performTraversals() &#123; ...... mView.layout(0, 0, mView.getMeasuredWidth(), mView.getMeasuredHeight()); ......&#125; layout() 方法有四个参数，分别是 left、top、right、bottom，表示当前 View 相对 Parent 的四个坐标。layout 过程也是一个递归的过程： layout.png View.layout 方法实际上会调用到 onLayout 方法 1234567891011121314public void layout(int l, int t, int r, int b) &#123; ...... //实质都是调用setFrame方法把参数分别赋值给mLeft、mTop、mRight和mBottom这几个变量 //判断View的位置是否发生过变化，以确定有没有必要对当前的View进行重新layout boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); //需要重新layout if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123; //回调onLayout onLayout(changed, l, t, r, b); ...... &#125; ......&#125; layout 也是从顶层父 View 向子 View 的递归调用 layout 方法的过程，即父 View 根据上一步 measure 子 View 所得到的布局大小和布局参数，将子 View 放在合适的位置上。具体 layout 核心主要有以下几点： View.layout方法可被重载，ViewGroup.layout为final的不可重载，ViewGroup.onLayout为abstract的，子类必须重载实现自己的位置逻辑 measure操作完成后得到的是对每个View经测量过的measuredWidth和measuredHeight，layout操作完成之后得到的是对每个View进行位置分配后的mLeft、mTop、mRight、mBottom，这些值都是相对于父View来说的 凡是layout_XXX的布局属性基本都针对的是包含子View的ViewGroup的，当对一个没有父容器的View设置相关layout_XXX属性是没有任何意义的 使用View的getWidth()和getHeight()方法来获取View测量的宽高，必须保证这两个方法在onLayout流程之后被调用才能返回有效值 draw 过程分析performTraverls 在 layout 后会进行 draw 的操作 123456789private void performTraversals() &#123; ...... final Rect dirty = mDirty; ...... canvas = mSurface.lockCanvas(dirty); ...... mView.draw(canvas); ......&#125; draw 也是一个递归的过程 draw.png 如果该View是一个ViewGroup，则需要递归绘制其所包含的所有子View。 View默认不会绘制任何内容，真正的绘制都需要自己在子类中实现。 View的绘制是借助onDraw方法传入的Canvas类来进行的。 区分View动画和ViewGroup布局动画，前者指的是View自身的动画，可以通过setAnimation添加，后者是专门针对ViewGroup显示内部子视图时设置的动画，可以在xml布局文件中对ViewGroup设置layoutAnimation属性（譬如对LinearLayout设置子View在显示时出现逐行、随机、下等显示等不同动画效果）。 在获取画布剪切区（每个View的draw中传入的Canvas）时会自动处理掉padding，子View获取Canvas不用关注这些逻辑，只用关心如何绘制即可。 默认情况下子View的ViewGroup.drawChild绘制顺序和子View被添加的顺序一致，但是你也可以重载ViewGroup.getChildDrawingOrder()方法提供不同顺序。 参考：Android应用层View绘制流程与源码分析类加载过程/ClassLoader机制Apk 打包过程ListView 和 RecyclerView 原理性能优化考虑性能时一般从以下几个角度 内存优化 UI优化（布局、绘制） 速度优化（线程、网络） 电量优化 启动优化 内存优化内存优化是为了解决内存溢出（OOM）的问题，内存溢出通常有两个原因 使用不当造成的内存泄漏，内存无法释放 虽然不属于泄漏，但一些代码逻辑不当，导致消耗大量内存，难以及时释放 内存泄漏 常见原因与处理方法 单例模式里使用了 Activity 的 Context，导致其生命周期延长至整个应用使用周期，应该使用 ApplicationContext 非静态内部类持有 Activity 对象引用，应该改成静态内部类，同时使用 ApplicationContext；以上两步说明尽量不要使用 Activity 的 Context，而是应当用 ApplicationContext Handler 持有 Activity 对象引用，同样应该改成静态，并使用弱引用，并在 Activity 的 onDestroy 方法里清空 Handler 消息，mHandler.removeCallbacksAndMessages(null); 线程进行耗时操作，导致 Activity 没释放，应当使用弱引用，并且在 Activity 的 onDestroy 方法里 cancel 掉线程 占有系统资源后没有关闭，在使用完 BraodcastReceiver,ContentObserver,File,Cursor,Stream,Bitmap,Animation 等资源时，一定要在 Activity 中的 onDestry 中及时的关闭、注销或者释放内存。 参考：Android中五种常见内存泄漏原因常用工具 Heap SnapShot Heap Viewer LeakCanary MAT TraceView（Device Monitor） 消耗大量内存：通常加载 Bitmap 时会发生这种情况，解决思路是 加载单张图片时候进行压缩，或者使用缩略图 控制每次加载的数量 加载多张图片时，滑动过程中不进行加载，仅在滑动完成后加载 UI优化（布局、绘制）Android 屏幕刷新的频率是 60fps，意味着每一帧的绘制必须要在 16ms 内完成，如果 UI 绘制超过了 16ms，在体验上就会出现卡顿。 以下罗列造成 App 卡顿的一些原因 在 UI 线程里进行轻微耗时操作 布局 Layout 过于复杂，无法在 16ms 内完成渲染 动画执行次数过多，导致 CPU 或 GPU 负载过高 View 过度绘制，屏幕某些像素在一帧时间内绘制多次，CPU 或 GPU 负载过高 View 频繁触发 measure 和 layout，累计耗时过多，频繁渲染造成负载过高 内存频繁 GC，导致阻塞渲染操作 冗余资源和逻辑导致运行缓慢 ANR UI优化，通常是指布局优化和 View 绘制优化 布局优化在“开发者选项”里可以打开“过度绘制开关”，从而查看当前页面 View 是否存在过绘，红色表示层级最多（4+），浅紫色表示层级最低（1），如下所示。找到那些过绘的部分，在布局文件里减少它们的背景，比如把底层 View 的背景设置成透明。同时，尽量减少 ViewGroup 嵌套的情况，通常 LinearLayout 会比 RelativeLayout 的层级要少。还有一点就是要使用设备对应分辨率的资源文件，并不是图片越清晰就越好。 Overdraw 在“开发者模式”里面还有另一项相关的设置，叫做“GPU呈现模式分析”，可以将渲染时间以条形图📊的方式显示在屏幕底部，同时 16ms 的基准线也会以绿色绘制在屏幕中央。条形图中同一个条形的不同颜色表示绘制不同阶段 呈现模式分析 绘制优化主要是针对自定义 View 里面的代码编写，在 onDraw 这一步要尽量减少开销，因为 onDraw 方法是实时执行的，在一帧内会执行多次。因此，在 onDraw 中要避免出现以下两种情况 创建局部对象，这会导致占用大量内存，频繁 GC 执行耗时操作，出现循环，这会占用 CPU 时间 过度绘制优化，使用对应分辨率的资源文件 速度优化（线程、网络）线程优化需要在子线程进行耗时操作，避免阻塞主线程 HandlerThread：拥有自己 Looper 的线程类，可以在这个线程里进行耗时操作，然后通知主线程 AsyncTask：见下面一节“AsyncTask 知识点” IntentService：运行在独立线程的 Service，原理是创建一个 HandlerThread，然后在 onStart 时把消息丢给 Handler 处理 ThreadPool：用 Executor、ThreadPoolExecutor 来管理线程 网络优化网络优化主要是从时间、速度、成功率几个角度来进行，对于提高速度，比较典型的是请求图片的场景 使用WebP格式，能比 JPG 节约25%～35%的流量，比 PNG 节约80%流量 使用缩略图 另外一些网络优化的知识点 对网络请求进行缓存，若请求数据仍在有效期内则直接使用缓存，不走网络 减少 GPS 定位使用，条件允许则多用网络定位 下载过程中使用断点续传 刷新数据时采用局部刷新，少用全局刷新 电量优化 需要进行网络请求时，先判断网络当前状态 批量处理网络请求 在同时有wifi和移动数据的情况下，我们应该直接屏蔽移动数据的网络请求 减少后台任务 启动优化根据应用启动时候的状态，可以分为冷启动、热启动、暖启动三种，其中冷启动的耗时最长，对用户体验影响最大，因此谈启动优化主要是从冷启动的角度给出优化建议。 冷启动初始时，系统完成三个任务 启动和加载应用 创建应用进程 显示启动视图（白屏） 当应用进程创建完毕后，开始创建应用 创建应用对象 启动主线程 (MainThread) 创建 Main Activity 加载视图 (Inflating views) 渲染布局 (Laying out) 执行初始绘制 冷启动优化 减少首页使用的资源，懒加载 优化首页布局，减少层级，不绘制不可见的 UI，而是使用 ViewStub 对象在适当的时间布局绘制 在闪屏页（Fragment）预先加载 AsyncTask 知识点是什么是为了解决 UI 线程无法进行耗时操作的问题而应用的一种 API，通常处理短时耗时任务（长时任务建议使用 Executor、ThreadPoolExecutor、FutureTask），有四个方法需要覆盖 onPreExecute()，在 UI 线程调用，进行任务运行前的准备工作 doInBackground(Params…)，在后台线程运行，读取 execute 传来的参数，运行过程中可以通过 publishProgress(Progress…) 来发布进度信息，进度信息会以 onProgressUpdate(Progress…) 回调的方式通知 UI 线程 onProgressUpdate(Progress…)，在 UI 线程调用，接收进度信息 onPostExecute(Result)，在 UI 线程调用，接受任务运行结果 变更历史 最初问世，采用单线程模型，所有任务串行执行 DONUT（1.6），采用线程池模型，并发运行 HONEYCOMB（3.0），又改回单线程模型，为了简化使用，避免并发带来的同步问题 内部原理（API 26） AsyncTask 无参构造函数里会创建一个任务对象 mWorker（在其中执行 doInBackground），一个任务完成回调对象 mFuture，同时获取到 UI 线程的 Looper，用来在任务完成后通知 UI 线程 维护单例 SERIAL_EXECUTOR，用来串行执行任务 调用 AsyncTask.execute 时，会进入 executeOnExecutor 方法，在其内部先调用 onPreExecute，然后通过 executor 运行 mWorker，由 SERIAL_EXECUTOR 保证了串行运行，真正运行任务的是 THREAD_POOL_EXECUTOR 在任务完成后，通过 UI 线程的 Looper 通知 UI 线程 一个关于类的静态变量归属的问题父类有一个 protected 的静态变量 foo，基于父类 A 创建两个子类 B1 和 B2 如果 B1 和 B2 不声明变量 foo，那么它们使用的 foo 是同一个，来自父类 A 如果 B1 和 B2 都声明变量 foo，那么它们使用各自的变量 简单概括就是说静态变量与类绑定，demo 如下 123456789101112131415161718192021222324252627282930313233343536// case 1abstract class A &#123; protected static int foo = 0;&#125;class B1 extends A &#123;&#125;class B2 extends B &#123;&#125;public static void main(String[] args) &#123; A b1 = new B1(); A b2 = new B2(); System.out.println(\"b1.foo = \" + b1.foo + \"&amp; b2.foo = \" + b2.foo); // b1.foo = 0 &amp; b2.foo = 0&#125;// case 2abstract class A &#123; protected static int foo = 0;&#125;class B1 extends A &#123; static int foo = 100;&#125;class B2 extends B &#123; static int foo = 200;&#125;public static void main(String[] args) &#123; A b1 = new B1(); A b2 = new B2(); System.out.println(\"b1.foo = \" + b1.foo + \"&amp; b2.foo = \" + b2.foo); // b1.foo = 100 &amp; b2.foo = 200&#125;","tags":[{"name":"Android","slug":"Android","permalink":"https://lilei.pro/tags/Android/"},{"name":"面试","slug":"面试","permalink":"https://lilei.pro/tags/面试/"}]},{"title":"美团技术沙龙第39期：新思路打造移动端高效研发体系 小记","date":"2018-07-21T05:37:13.000Z","path":"2018/07/21/dianping-meituan-mobile-share-0721/","text":"偶然在美团技术团队公众号里看到有这个分享，主讲人是周辉、虞惠文、蒋国宝等人，内容基本上是移动研发专场，遂过来凑个热闹。时间是7月21日13:30~17:30，地点田林路200号华鑫天地 时间表 内容 主讲人 Picasso在大众点评首页的应用 虞惠文@美团Android开发工程师 移动前后端开发解耦 林晨@美团后端技术专家 打造稳定、灵活、高效的运营配置平台 蒋国宝@美团后端技术架构师 移动持续集成实践 何智聪@美团iOS技术专家 前言13:44，还未开始，全是年轻的脸庞，未见故人。大概故人们不屑于这种程度的技术分享吧，他们就算来，也应该是站在讲台上，而非听众席。 周校长开场词介绍了一下目前大众点评移动团队的规模和业务内容，base 在上海，100 人。曾经自己也是这个团队的一员，想想竟有些唏嘘。 Picasso 在大众点评首页的应用痛点首页改版多是视觉变更，需要快速上线验证，然而传统的开发发布流程太迟滞，难以实时看到效果。例如，首页十个金刚位入口，需要调整其中某一个，更换图标、文字、角标，并且快速验证，倘若走传统的“开发-测试-发布”流程，显然不能满足产品经理“越快看到效果越好”的需求。这是就需要有一个动态化框架，支持实时对这些进行修改。 技术需求 需要一个动态化框架，在运行时决定需要展示的内容。 性能达到 Native 水准 实践进行设计的时候，没有选择 RN，原因如下 稳定性差 技术栈切换成本高 双端不对齐，某些特性只支持单端 所采取的设计思路是“服务端下发数据（data）和视图规则（layout）”，data 和 layout 会被计算成 PModel，其中包含了该视图被渲染至屏幕上的全部信息。 Picasso构思 同时采用预计算&amp;缓存，降低绘制时的开销，提高绘制速度。 预计算是指 PModel 包含了该视图所有尺寸信息，在随后渲染过程中的 measure 和 layout 这两步直接取用这些信息，而不需要再次计算。 预计算 缓存是指缓存了 PModel，而非 Data（需要再次计算 PModel） 缓存 移动开发前后端解耦实践 主要介绍了点评内部在前后端开发联调测试过程中使用的几个工具，主要是 AppMock（前身是 wendong.dp）、移动之家。的确有了这些工具，对于移动端开发的同学来说是极大的福音，离开点评之后深感如此。 痛点 接口管理困难 ———— 那么多的接口和数据格式，用什么管理呢？Excel文档？Wiki？聊天工具？不一致怎么办，出了锅谁来背？ 移动端接口数据黑盒 ———— 想要查看接口数据，只能借助 Charles 这样的代理工具，使用复杂不说，还几乎无法进行定制。 前后端接口数据依赖 ———— 约好联调时间，难免遇到各种情况发生 delay，测得越晚，风险越大。 测试工作量 ———— 生成测试数据不仅累的一批，还毫无成就感。 接口管理困难 接口数据模型化 接口更新可通知 接口多维度管理 通过“移动之家（mobile.dp）”进行接口注册，注册过程中需要明确标明接口数据结构和类型，注册完成之后，会有代码自动生成工具生成对应平台（Web、App、Server）的代码。 自动生成接口代码 前后端交互黑盒由于网络环境复杂（3G、4G、WIFI），加上数据通常有加密序列化，想要实时查看接口数据信息通常要大费周章。这里介绍了 AppMock 的主要功能和原理，是在 APP 的网络层对请求进行重定向。 AppMock 前后端接口和数据依赖后端同学测试接口：提供 APIReader 工具，可以在网页中组合参数，模拟客户端发送请求，测试后端接口前端同学测试应用：AppMock 自动 mock response 测试工作量自动化测试(Appium) + 自动化Mock，Mock 工具可以存储用例，这部分不细讲。 最后是 AppMock 和业内类似工具的对比 对比 打造稳定、灵活、高效的运营配置平台简单的说就是设计一个“可以设计显示规则”的平台，同时讨论了如何满足测试场景（建立测试用户名单）、如何降低中央节点负载（SDK方案）。 移动持续集成实践这部分没听，直接跑路去找卫鹏和小凡吃小龙虾去了。 感受有高兴也有惋惜，高兴的是，自己从2012年加入大众点评，当年那么生涩的自己得到了不少老同事的包容和宽宥，有些人虽然再未见到过，但他们所开发出来的优秀工具却造福了很多同事，能与这些人共事，是我一生的荣幸；同时，分享现场这么多年轻朝气的面孔，表明点评团队依然充满了吸引力和号召力。惋惜的是自己没有在点评的5年里，全力汲取他人的养分，白白辜负了这么好的土壤。 点评只是我毕业后的第一所大学，而社会是第二所。 望各自安好，一别两宽。","tags":[{"name":"Android","slug":"Android","permalink":"https://lilei.pro/tags/Android/"},{"name":"点评","slug":"点评","permalink":"https://lilei.pro/tags/点评/"}]},{"title":"面试知识整理 2018.07.09","date":"2018-07-09T10:00:17.000Z","path":"2018/07/09/interview-180709/","text":"HashMap 和 HashTable 区别相同点 都是以 Key - Value 的形式存放键值对 不同点 null 支持：HashMap 允许 null key 和 null value，HashTable 不允许 并发特性：HashMap 线程不安全，效率高，HashTable 线程安全，效率低 默认长度和扩容方式：HashMap 默认长度 16，扩容 2n，HashTable 默认长度 11，扩容 2n+1 父类：HashMap 父类 AbstractMap，其子类还有 ConcurrentHashMap、LinkedHashMap 等，HashTable 父类 Dictionary，子类有 Properties 结论 不需要考虑线程安全，用 HashMap 需要考虑线程安全，用 ConcurrentHashMap JVM 垃圾回收机制/GC含义：由 JVM 自动回收那些不再使用的对象，清理内存 意义：程序员不需要人工管理内存，减少开发成本，提高开发效率 基础知识对象实例存在于 Java 堆中 Java 中对对象的引用分成“强软弱虚” 强引用，最普遍的引用，只要有强引用存在，对象就不会被回收 软引用，SoftReference，当 GC 时，如果内存不足，会被回收 弱引用，WeakReference，当 GC 时，不论内存是否足够，都被回收 虚引用，PhantomReference，不影响对象的生命周期，在任何时刻都可能被回收 12345678910111213141516171819202122232425262728293031public class ReferenceDemo &#123; public static void main(String[] arge) &#123; //强引用 Object object = new Object(); Object[] objects = new Object[100]; //软引用 SoftReference&lt;String&gt; stringSoftReference = new SoftReference&lt;&gt;(new String(\"SoftReference\")); System.out.println(stringSoftReference.get()); System.gc(); System.out.println(stringSoftReference.get()); //手动GC,这时内存充足,对象没有被回收 System.out.println(); //弱引用 WeakReference&lt;String&gt; stringWeakReference = new WeakReference&lt;&gt;(new String(\"WeakReference\")); System.out.println(stringWeakReference.get()); System.gc(); System.out.println(stringWeakReference.get()); //手动gc,这时,返回null,对象已经被回收 System.out.println(); //虚引用 //虚引用主要用来跟踪对象被垃圾回收器回收的活动。 //虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。 //当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中 ReferenceQueue&lt;String&gt; stringReferenceQueue = new ReferenceQueue&lt;&gt;(); PhantomReference&lt;String&gt; stringPhantomReference = new PhantomReference&lt;&gt;(new String(\"PhantomReference\"), stringReferenceQueue); System.out.println(stringPhantomReference.get()); &#125;&#125; 引用计数器每个对象拥有一个计数器，当它被引用时，计数器 +1，引用释放时，计数器 -1，当计数器为 0 时，表示可以回收。 存在的问题是循环引用。为了解决这个问题，又引入了“可达性”（GC Roots Tracing）的概念，目前主流的 JVM 都采用了这种计数。简单说，就是从根部开始向下搜索，如果对象无法被触及，则认为是可以回收的，这种对象称为“不可达对象”。 看一下 JVM 运行时的内存结构： JVM GC Roots 包括 虚拟机栈的栈帧中的引用对象（来自局部变量表） 方法区静态属性实体引用的对象 方法区的常量引用对象 本地方法栈中 JNI 引用的对象 存活 Thread 引用的对象 在根搜索算法中，要真正宣告一个对象死亡，至少要经历两次标记过程： 如果对象在进行根搜索后发现没有与 GC Roots 相连接的引用链，那它会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize() 方法 当对象没有覆盖 finalize() 方法，或 finalize() 方法已经被虚拟机调用过，虚拟机将这两种情况都视为没有必要执行 如果该对象被判定为有必要执行 finalize() 方法，那么这个对象将会被放置在一个名为 F-Queue 队列中，并在稍后由一条由虚拟机自动建立的、低优先级的 Finalizer 线程去执行 finalize() 方法 finalize() 方法是对象逃脱死亡命运的最后一次机会（因为一个对象的finalize() 方法最多只会被系统自动调用一次）, 稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果要在finalize（）方法中成功拯救自己，只要在finalize() 方法中让该对象重引用链上的任何一个对象建立关联即可。而如果对象这时还没有关联到任何链上的引用，那它就会被回收掉 垃圾收集算法标记-清除 算法分为“标记”和“清除”两部，首先标记出需要回收的对象，然后在第二步清除它们。是最基础的回收算法，后续算法都是基于它的基础上进行改进。 标记-清除 效率问题：需要两次扫描 空间问题：产生大量内存碎片 复制 算法将可用内存平均分为2块，每次只使用其中的一块。当一块内存使用完成后，将存活对象复制到另一块内存中，然后清空。 复制 优点 每次只操作一块内存，分配时无需要考虑内存碎片情况，只移动指针即可，实现简单，运行高效 缺点 利用率问题：可用内存少了一半 效率问题：老生代对象由于存活率高，频繁复制 标记-压缩 算法标记后，将所有存活对象向一端移动 标记-压缩 优点 对于老年代，会逐渐移动到头部 缺点 新生代对象多的话，会频繁移动 分代收集 算法对新生代采用复制算法（Minor GC），老年代采用标记压缩算法（Major GC），全部回收称为 Full GC。 分代收集 年轻代: 是所有新对象产生的地方.年轻代被分为3个部分(Enden区和两个Survivor区,也叫From和To),当Eden区被对象填满时,就会执行Minor GC,并把所有存活下来的对象转移到其中一个survivor区(Form),Minor GC同样会检查存活下来的对象,并把它们转移到另一个survivor区(To),这样在一段时间内,总会有一个空的survivor区,经过多次GC周期后，仍然存活下来的对象会被转移到年老代内存空间,常这是在年轻代有资格提升到年老代前通过设定年龄阈值来完成的,需要注意，Survivor的两个区是对称的,没先后关系,from和to是相对的. 老年代: 在年轻代中经历了N次回收后仍然没有被清除的对象,就会被放到年老代中,都是生命周期较长的对象.对于年老代,则会执行Major GC,来清理.在某些情况下,则会触发Full GC,来清理整个堆内存 元空间: 堆外的一部分内存,通常直接使用的是系统内存,用于存放运行时常量池,等内容,垃圾回收对应元空间来说没有明显的影响 参考：jvm - 垃圾回收使用OkHttp同时发送3个请求，token过期如何处理 这是面试威佩时的一道面试题 这与发几个请求无关，解决问题的点在于发现 token 过期后如何自动获取 token 并重发请求，也就是，静默自动登录，然后继续请求。解决思路是在拦截器链中增加一个 TokenInterceptor，判断返回状态是否为验证失效。 发送请求给服务端 根据返回状态码判断是否 token 过期 如果过期，则调取同步接口获取新 token 使用新 token 发送请求 1234567891011121314151617181920212223242526272829303132333435363738394041public class TokenInterceptor implements Interceptor &#123; private static final String TAG = \"TokenInterceptor\"; @Override public Response intercept(Chain chain) throws IOException &#123; Request request = chain.request(); Response response = chain.proceed(request); Log.d(TAG, \"response.code=\" + response.code()); //根据和服务端的约定判断token过期 if (isTokenExpired(response)) &#123; Log.d(TAG, \"自动刷新Token,然后重新请求数据\"); //同步请求方式，获取最新的Token String newToken = getNewToken(); //使用新的Token，创建新的请求 Request newRequest = chain.request() .newBuilder() .header(\"Authorization\", \"Basic \" + newToken) .build(); //重新请求 return chain.proceed(newRequest); &#125; return response; &#125; // 根据Response，判断Token是否失效 private boolean isTokenExpired(Response response) &#123; if (response.code() == 301) &#123; return true; &#125; return false; &#125; // 同步请求方式，获取最新的Token private String getNewToken() throws IOException &#123; // 通过获取token的接口，同步请求接口 String newToken = \"\"; return newToken; &#125;&#125; 如果是面试官问的“三个请求同时发送”，那么可以在 token 上增加一个时间戳，通过这个时间戳可以判断该 token 是否为更新过后的。那么，在 A、B、C 三个请求同时发出时，当 A 发现 token 过期并更新 token 后，B 和 C 可以读取新的 token 发送请求，而不必再向服务端获取新的 token。 一点点反思面有赞的那一天自己刚刚撸过 OkHttp 的源码，还写了文字总结，但是被问到这道题时仍然一脸懵逼。问题在于对 OkHttp 以 Interceptor 为核心的根本思想没有把握，其实这道题是稍微有一点小花招。低配版的问法是“如何解决 token 过期”，这就很容易联想到 Interceptor（其实也不容易），高配版才是问“同时三个请求”，需要结合同步来解决。 参考 Android OkHttp实现全局过期token自动刷新示例RecyclerView同样是威佩的面试题 The RecyclerView widget is a more advanced and flexible version of ListView. RecyclerView 支持多种 Layout，如 LinearLayout、GridLayout。使用 RecyclerView 时需要继承 RecyclerView.ViewHolder 类，如果数据发生变化，调用 RecyclerView.Adapter.notify…() 方法。示例代码如下： gradle 123dependencies &#123; implementation &apos;com.android.support:recyclerview-v7:27.1.1&apos;&#125; 布局文件，没啥特别的，除了需要声明一个 Scrollbar 的方向 1234567&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!-- A RecyclerView with some commonly used attributes --&gt;&lt;android.support.v7.widget.RecyclerView android:id=\"@+id/my_recycler_view\" android:scrollbars=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"/&gt; Activity，跟 ListView 不同点在： 如果 RecyclerView 的尺寸不会发生变化，要调用setHasFixedSize(true)来提高性能 要根据布局设置 LayoutManager 12345678910111213141516171819202122232425public class MyActivity extends Activity &#123; private RecyclerView mRecyclerView; private RecyclerView.Adapter mAdapter; private RecyclerView.LayoutManager mLayoutManager; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.my_activity); mRecyclerView = (RecyclerView) findViewById(R.id.my_recycler_view); // use this setting to improve performance if you know that changes // in content do not change the layout size of the RecyclerView mRecyclerView.setHasFixedSize(true); // use a linear layout manager mLayoutManager = new LinearLayoutManager(this); mRecyclerView.setLayoutManager(mLayoutManager); // specify an adapter (see also next example) mAdapter = new MyAdapter(myDataset); mRecyclerView.setAdapter(mAdapter); &#125; // ...&#125; Adapter，与 ListView 的写法差异较大。 需要继承自 RecyclerView.Adapter&lt;MyAdapter.ViewHolder&gt; 必须声明一个静态内部类 ViewHolder 重载 onCreateViewHolder 方法，需要生成布局，初始化 ViewHolder 并返回 重载 onBindViewHolder 方法，这一步是将 ViewHolder 中的 View 都赋予正确的数据 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class MyAdapter extends RecyclerView.Adapter&lt;MyAdapter.ViewHolder&gt; &#123; private String[] mDataset; // Provide a reference to the views for each data item // Complex data items may need more than one view per item, and // you provide access to all the views for a data item in a view holder public static class ViewHolder extends RecyclerView.ViewHolder &#123; // each data item is just a string in this case public TextView mTextView; public ViewHolder(TextView v) &#123; super(v); mTextView = v; &#125; &#125; // Provide a suitable constructor (depends on the kind of dataset) public MyAdapter(String[] myDataset) &#123; mDataset = myDataset; &#125; // Create new views (invoked by the layout manager) @Override public MyAdapter.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; // create a new view TextView v = (TextView) LayoutInflater.from(parent.getContext()) .inflate(R.layout.my_text_view, parent, false); ... ViewHolder vh = new ViewHolder(v); return vh; &#125; // Replace the contents of a view (invoked by the layout manager) @Override public void onBindViewHolder(ViewHolder holder, int position) &#123; // - get element from your dataset at this position // - replace the contents of the view with that element holder.mTextView.setText(mDataset[position]); &#125; // Return the size of your dataset (invoked by the layout manager) @Override public int getItemCount() &#123; return mDataset.length; &#125;&#125; LayoutManagerAndroid Support Library 自带的有三种，你也可以通过继承 RecyclerView.LayoutManager 来实现自己的布局。 LinearLayoutManager，一维线性列表，同 ListView GridLayoutManager，网格列表，同 GridView StaggeredGridLayotManager，瀑布流列表，列之间有错位 动画Item 变化的时候，RecyclerView 使用 animator 来改变外观，animator 继承自 RecyclerView.ItemAnimator。 List-Item Selection这部分略，日后写 Demo 补充 RecyclerView 几大重要成员 RecyclerView Components RecyclerView 缓存 内部两级缓存 划出界面的 ViewHolder 会被放入 Cache（一级缓存），容量为2。Cache 中的对象都是同种 ViewType。 从 Cache 中被清除的对象，会被放入 RecycledViewPool，容量为5。RecycledViewPool 中的对象按照 ViewType 分类。 RecyclerView Cache 参考 RecycyerView - Developers 深入浅出 RecyclerView 微信的“分享”页面使用的是哪种启动模式这是面试有赞时，面试官提问的第一道题目。直觉告诉我 Standard 和 SingleTop 都不适用，但是并不能从 SingleInstance 和 SingleTask 中选出一个合适的来，这一块是知识盲区，以前根本没有从实用的角度来考虑这问题，都是死记硬背启动模式。 本质上还是考察启动模式的应用场景。 SingleInstance与外部应用共享的页面，一般设置成这种启动模式，也就是作为外部App调用自己客户端程序的入口。这是为了方便其它应用的 Activity 调起本应用。同时，由于 SingleInstance 会单独起一个 Task，当用户操作完成该页面后，点击返回按钮，会自动退回到外部应用。在使用时应该注意声明taskAffinity，以便在任务管理中看到新 Task。 1234&lt;activity android:name=\".SingleInstanceActivity\" android:label=\"singleInstance launchMode\" android:launchMode=\"singleInstance\"/&gt; SingleTask一个 Task 内只允许有一个 SingleTask 的 Activity，启东时如果 Task 内已经有了同 Activity，则会将其上所有的 Activity 按照生命流程进行销毁，同时调用该 Activity 的onNewIntent方法。适合的应用场景是应用内部统一入口，比如浏览器首页、商户详情页等。同样，需要声明taskAffinity以保证它会新起一个 Task。 SingleTop同样，如果 Task 顶已经有了同一个 Activity，会调用onNewIntent传入参数。 应用场景： 点击“通知”后打开的详情页面 浏览器搜索结果页，带有关键词输入框 Standard应用于可以打开多个实例的页面，比如与不同人的聊天页面，撰写邮件页面等。 场景：应用进程被杀后再次启动设想一个这样的应用场景：用户在使用你的应用时，突然接收到一个微信消息，他跳转到微信后，你的应用被切换至后台运行。该用户在微信中翻阅了朋友圈、查看一些视频，以及进行了其它很多吃内存的操作，导致系统内存紧张，这时你的应用进程被杀死。但是由于Android系统仍然会保持 Task 栈的内容，所以用户在“最近应用”里仍然是可以看到你的应用的。此时如果用户通过“最近应用”切换回你的应用（进程已经被杀死），极易发生异常导致闪退。 异常原因在于当进程被杀死后，所有的静态常量值会被清空，如果在此时使用并且未经检查，很容易出现 NPE 等异常。常规解决方法是在 onSaveInstance 里面对变量进行保存，然后在 onRestoreInstance 里恢复变量值。缺点是工作量大，代码冗长。 此时的一个解决思路是对于进程被杀死的情况，如果再次启动，则跳转回应用首页（这点需要获取产品经理同意），随后的一切等同于首次启动。 相应的技术思路是，将首页启动模式声明为 SingleTask，同时写一个 BaseActivity，它里面有一个 getAppStatus 方法用来判断应用是否处于回收后重新启动的状态，判断方法是读取一个静态 int 类型变量 appStatus，它默认值是 KILLED，在每一个子 Activity 的 onCreate 方法里将其设置成 NORMAL 值。这样一旦被回收，它就会变成 KILLED，就可以在 BaseActivity.onCreate 里通过对这个变量的判断，决定是不是要重新回到首页。 参考：如何让你的app在后台被干掉后优雅的启动IntentService 实现原理通过startService(Intent)来启动一个 IntentService，它内部有一个工作队列（Worker Thread），在工作线程内运行，不会影响 UI 线程。IntentService 是一个抽象类，继承它时必须实现onHandleIntent方法。 普通 Service 由于运行在 UI 线程，无法进行耗时操作，IntentService 解决了这个问题 运行完成后，IntentService 会自动停止 从原理上讲，IntentService 是创建了一个 HandlerThread，然后用 thread.getLooper() 赋给 Handler，这个 Handler 接收 onStart 时传来的 Intent，并以此 Intent 调用你所覆盖的 onHandleIntent 方法。任务完成后，可以用广播或者 EventBus 等手段通知调用者。 参考：IntentService的原理和实例分析HTTP 请求和响应头的格式有赞和威佩都问到了这一题。 HTTP的头域包括通用头，请求头，响应头和实体头四个部分。每个头域由一个域名，冒号（:）和域值三部分组成。域名是大小写无关的，域值前可以添加任何数量的空格符，头域可以被扩展为多行，在每行开始处，使用至少一个空格或制表符。 通用头通用头域包含请求和响应消息都支持的头域，通用头域包含Cache-Control、Connection、Date、Pragma、Transfer-Encoding、Upgrade、Via。 请求头请求消息的第一行为下面的格式： 1Method SP Request-URI SP HTTP-Version CRLF 请求头域允许客户端向服务器传递关于请求或者关于客户机的附加信息。请求头域可能包含下列字段Accept、Accept-Charset、Accept- Encoding、Accept-Language、Authorization、From、Host、If-Modified-Since、If- Match、If-None-Match、If-Range、If-Range、If-Unmodified-Since、Max-Forwards、 Proxy-Authorization、Range、Referer、User-Agent。 响应头响应消息的第一行为下面的格式： 1HTTP-Version SP Status-Code SP Reason-Phrase CRLF 常见错误码 1xx:信息响应类，表示接收到请求并且继续处理 2xx:处理成功响应类，表示动作被成功接收、理解和接受 3xx:重定向响应类，为了完成指定的动作，必须接受进一步处理 4xx:客户端错误，客户请求包含语法错误或者是不能正确执行 5xx:服务端错误，服务器不能正确执行一个正确的请求 实体信息请求消息和响应消息都可以包含实体信息，实体信息一般由实体头域和实体组成。实体头域包含关于实体的原信息，实体头包括Allow、Content-Base、Content-Encoding、Content-Language、 Content-Length、Content-Location、Content-MD5、Content-Range、Content-Type、 Etag、Expires、Last-Modified、extension-header。 MVP 中对 Presenter 如何进行测试各层单元测试选型各层由于特性不同，所采用的测试工具也不一样 JVM Model层：涉及数据库操作，依赖 Android 环境，使用 AndroidJUnitRunner 测试 View层：涉及 UI，使用 Espresso 进行测试 Presenter层：不需要 Android 环境，纯 JAVA 代码，使用 JUnit 测试 MVP 的一大优点就是将数据、视图、逻辑解耦，从而可以对其中某一角色进行单独测试。然而，想要对 Presenter 进行测试，就必须回答以下几个问题： 测试过程要避免通过网络或者本地存储产生脏数据，因此必须对数据层接口进行 Mock 为了提高执行效率，并且 Presenter 本身是视图无关的，因此测试用例应该可以脱离真机/模拟器独立运行，也就是说，要有对 View 的Mock 如何检验 Presenter 的各个方法运行成功了 我们以 Demo 中对 AddEditTaskPresenter 的测试为例，看参考答案是怎样的，对应的类是AddEditTaskPresenterTest.java 12@Mockprivate TasksRepository mTasksRepository; 这里直接使用 Mockito 的@Mock注解来声明，需要注意的是要在测试用例运行之前通过MockitoAnnotations.initMocks(this)进行注入。如此这般解决了数据层 Mock 的问题。 对 View 的注入也一样 12@Mockprivate AddEditTaskContract.View mAddEditTaskView; 123456789@Beforepublic void setupMocksAndView() &#123; // Mockito has a very convenient way to inject mocks by using the @Mock annotation. To // inject the mocks in the test the initMocks method needs to be called. MockitoAnnotations.initMocks(this); // 注入 Mock 对象 // The presenter wont't update the view unless it's active. when(mAddEditTaskView.isActive()).thenReturn(true); // 这段代码的含义是“当 isActive 被调用时，直接返回 true”&#125; 接下来我们看如何检验 Presenter 里面各个方法调用成功，选一个比较复杂的涉及到回调的场景，也就是获取单个 Task，这是一个异步回调接口。 1234567891011121314151617181920212223@Testpublic void populateTask_callsRepoAndUpdatesView() &#123; Task testTask = new Task(\"TITLE\", \"DESCRIPTION\"); // Get a reference to the class under test mAddEditTaskPresenter = new AddEditTaskPresenter(testTask.getId(), mTasksRepository, mAddEditTaskView, true); // When the presenter is asked to populate an existing task mAddEditTaskPresenter.populateTask(); // 这里会调用 Repository 里面的 getTask 方法 // Then the task repository is queried and the view updated // 验证调用到了 getTask 方法，并且将回调赋给 mGetTaskCallbackCaptor，后面可以对 captor 自由触发回调 verify(mTasksRepository).getTask(eq(testTask.getId()), mGetTaskCallbackCaptor.capture()); assertThat(mAddEditTaskPresenter.isDataMissing(), is(true)); // 这时候还没有加载成功 task // Simulate callback mGetTaskCallbackCaptor.getValue().onTaskLoaded(testTask); // 验证 View 里面相应方法得到调用 verify(mAddEditTaskView).setTitle(testTask.getTitle()); verify(mAddEditTaskView).setDescription(testTask.getDescription()); assertThat(mAddEditTaskPresenter.isDataMissing(), is(false)); // 此时加载成功&#125; 综上，可以理解对 Presenter 进行单元测试的验证流程就是“调用 Presenter 里面的某个方法 -&gt; 将回调暂存 -&gt; 验证 View 里面相应的方法被执行 -&gt; 给回调赋值，验证回调” 屏幕物理尺寸，像素，dp，px，sp物理尺寸：这个很好理解，就是屏幕长多少mm，宽多少mm。但通常不会直接说长宽，而是用“xx英寸”表示，比如我的小米5x就是5.5英寸，这里的5.5英寸指的是对角线长度，1英寸 ≈ 2.54cm，5.5英寸 ≈ 13.97cm ≈ 14cm，市面上如今 90% 以上的手机都是 16:9 的，所以可以列出方程 (16x)^2 + (9x)^2 = 14^2，解方程得到 x = 0.76cm，得出小米5x屏幕物理尺寸为长 12.16cm，宽 6.84cm。 5x屏幕尺寸 分辨率/像素：从上图里看到，5x宽高为 1080px * 1920px，对于这样的手机通常称其分辨率为 1080p。像素的概念比较容易理解，一个像素就是液晶屏的一个最小发光单元，8-bit 游戏常被称为像素游戏，因为像素颗粒通常比较大，图像有方块感。 物理尺寸与分辨率没有必然的关系。 像素密度：Pixels Per Inch，PPI，也称为 Dots Per Inch（DPI）。每英寸上排列的像素个数，这个“每英寸”是长还是宽呢？都不是，是指对角线。通过勾股定理计算，1080*1920 分辨率的屏幕，其对角线像素数为 2203p，那么小米5x的 PPI 就是 2203/5.5 = 400。像素密度越高，锯齿感越低，显示越精细。 倍率和逻辑像素：iPhone 3gs 和 4s，物理尺寸都是 3.5 英寸，3gs 的分辨率是 320x480，4s 的分辨率则是 640x960，4s 的像素密度是 3gs 的两倍，单个像素尺寸是 3gs 的一半。但是在显示中，这两个设备的显示效果却是一样的，原因在于 4s 用 2x2 个像素合并成 1 个像素，如下图。这使得同样的图片在 4s 上显示更加清晰。然而这对图片源文件有要求，必须使用带有“@2x”后缀的图片，系统会自动将其用于 4s 设备上。 3gs 4s 上面讲的是苹果的处理方法，对于 Android 这并不太适用，因为 Android 设备的分辨率实在太多了。因此划分为多种尺寸，如下。 Android DPI 以 160DPI（mdpi） 为基准，倍率为一倍，其它密度以此计算。在 160DPI的情况下，1px = 1dp。 ldpi [0.75倍] mdpi [1倍] hdpi [1.5倍] xhdpi [2倍] xxhdpi [3倍] xxxhdpi [4倍] 所以为了保证准确高效的沟通，无论是在标注图还是在日常沟通中，设计人员与开发人员都需要尽量以逻辑像素尺寸来描述和理解界面，真正决定显示效果的，是逻辑像素尺寸。然而并不是所有 Android 设备的逻辑像素尺寸都一致，比如两种常见的屏幕480×800和1080×1920，它们分别属于hdpi和xxhdpi。除以各自倍率1.5倍和3倍，得到逻辑像素为320×533和360×640。很显然，后者更宽更高，能显示更多内容。 px：pixels,像素，屏幕上实际的像素点单位 dp：device independent pixels, 设备独立像素，安卓专用长度单位，以160ppi屏幕为标准，则 1dp=1px。dp*ppi/160=px sp：scaled pixels,放大像素，安卓专用字体单位，以160ppi屏幕为标准，字体大小为100%时，则1dp=1px Android 一般以 360x640 的逻辑尺寸来设计 UI Android常见屏幕尺寸与DPI","tags":[{"name":"Android","slug":"Android","permalink":"https://lilei.pro/tags/Android/"},{"name":"面试","slug":"面试","permalink":"https://lilei.pro/tags/面试/"}]},{"title":"OkHttp 源码学习","date":"2018-07-06T07:36:57.000Z","path":"2018/07/06/okhttp/","text":"OkHttp 是由 Square 发布的 HTTP Client，用于处理 HTTP 请求。用官网的描述就是，An HTTP &amp; HTTP/2 client for Android and Java applications. 优点 支持 HTTP/2，多个连接可以共用一个 Socket 连接池可以减少延迟（非 HTTP/2） GZIP 压缩减少流量 Response 缓存 重定向和重试 OkHttp 的用法同步请求需要在 AsyncTask 或者起线程来进行，调用execute() 123456789101112private String doRequest(String param) &#123; Request.Builder builder = new Request.Builder(); builder.url(param); Request request = builder.build(); try &#123; Response response = client.newCall(request).execute(); return response.body().string(); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; return null;&#125; 异步请求调用enqueue() 1234567891011121314151617181920212223242526OkHttpClient client = new OkHttpClient();Request request = new Request.Builder() .url(url) .build();client.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; call.cancel(); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; final String myResponse = response.body().string(); MainActivity.this.runOnUiThread(new Runnable() &#123; @Override public void run() &#123; txtString.setText(myResponse); &#125; &#125;); &#125;&#125; 设置 Header 和参数在 URL 构建过程中通过addQueryParameter设置参数，在 Request 构建过程中设置 Header 123456789HttpUrl.Builder urlBuilder = HttpUrl.parse(\"https://httpbin.org/get).newBuilder();urlBuilder.addQueryParameter(\"website\", \"www.journaldev.com\");urlBuilder.addQueryParameter(\"tutorials\", \"android\");String url = urlBuilder.build().toString();Request request = new Request.Builder() .header(\"Authorization\", \"replace this text with your token\") .url(url) .build(); post 请求需要声明MediaType 12345678910111213141516171819202122232425262728293031public String postUrl= \"https://reqres.in/api/users/\";public String postBody=\"&#123;\\n\" + \" \\\"name\\\": \\\"morpheus\\\",\\n\" + \" \\\"job\\\": \\\"leader\\\"\\n\" + \"&#125;\";public static final MediaType JSON = MediaType.parse(\"application/json; charset=utf-8\");void postRequest(String postUrl,String postBody) throws IOException &#123; OkHttpClient client = new OkHttpClient(); RequestBody body = RequestBody.create(JSON, postBody); Request request = new Request.Builder() .url(postUrl) .post(body) .build(); client.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; call.cancel(); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; Log.d(\"TAG\",response.body().string()); &#125; &#125;);&#125; 设计思路我认为 OkHttp 的核心是以分层的思想链式处理网络请求。所有处理的代码都位于XXXInterceptor中，一共有6个这样的 Interceptor，接口如下 123public interface Interceptor &#123; Response intercept(Chain chain) throws IOException; // 处理当前层的请求&#125; 下图来源于 Piasy 的博客，很好地描述了 OkHttp 发送网络请求到处理完成的过程。 flow 关键类讲解 RetryAndFollowUpInterceptor，处理请求失败重试以及重定向（30X） BridgeInterceptor，对 Request 和 Response 进行封装，主要是写 Header，Gzip 解压缩等操作 CacheInterceptor，缓存，很棒的磁盘缓存设计，维护一个日志文件来进行缓存的恢复重建 ConnectInterceptor，管理与目标的连接，采用策略模式，有 HTTP(HTTP/1.1) 和 HTTP/2 两种策略，关键类StreamAllocation CallServerInterceptor，数据交换，将数据传送给服务器，从服务器拉取数据。写请求头 -&gt; 写请求体 -&gt; 获取响应头 -&gt; 获取响应体 设计模式构建器模式构建器模式可以减少冗长的构造函数，并且可以在设置参数时进行检查。OKHttpClient.java、Request.java 这些类里面都用到了 Builder 模式，简单写一个模版 12345678910111213141516171819202122232425public final class Foo &#123; final A a; private Foo(Builder builder) &#123; this.a = builder.a; &#125; public static class Builder &#123; private A a; public Builder() &#123; this.a = \"a\"; &#125; public Builder a(A a) &#123; this.a = a; return this; &#125; public Foo build() &#123; return new Foo(this); &#125; &#125;&#125; 策略模式策略模式体现面向接口编程的概念，将具体实现与接口剥离，减少耦合性。ContentInterceptor 里面的 HttpCodec 接口就是这样的，有 HTTP/1 和 HTTP/2 两种实现。 责任链模式（chain of responbility）责任链模式包含了一系列对象，以及一系列处理指令。这些对象共同构成了一个链表，链表中的每一环都有一系列指令，链表中的对象经过逐级递归处理后，生成最终结果。可以向处理链的末尾添加新的处理指令。Interceptor.Chain 所采用的模式，每一层都处理各自的职责，按照链式递归调用。 小结OkHttp 的代码复杂程度让人头大，我不敢说自己已经摸清了这个框架，有很多地方值得深入挖掘，比如基于日志 Cache 的实现细节，责任链模式的设计。下一课题：Retrofit。学习过程中参考了简书上“被代码淹没的小伙子”okhttp源码分析系列文章，感谢原作者。","tags":[{"name":"Android","slug":"Android","permalink":"https://lilei.pro/tags/Android/"},{"name":"源码学习","slug":"源码学习","permalink":"https://lilei.pro/tags/源码学习/"}]},{"title":"Picasso 源码学习","date":"2018-07-03T09:19:20.000Z","path":"2018/07/03/picasso/","text":"Picasso 是由 Square 发布的图片加载框架，优雅地实现了 Android 系统中图片加载的功能。其中请求分类、任务调度、多级缓存等思想很有借鉴意义，本文将从源码角度阐述 Picasso 的工作原理。 Ask Yourself：实现一个图片加载框架图片的加载流程是获取 - 变换 - 显示，来源可能是网络、资源文件、本地文件，其中还要加上缓存，综上，可以整理出这样的流程图。 流程图 结合上图，整理出主要职责类： 请求包装类，包含请求地址、缓存策略 缓存类，内存+磁盘，两级缓存管理 请求处理类，实现相同的接口，有网络、本地、资源三种实现 下载器类，兼有暂停、恢复、取消功能 图片变换类，获取完图片后进行裁剪、缩放、旋转、圆角等变换 调度器类，管理线程 有了自己的理解之后，再结合 Picasso 的代码进行学习。 请求信息类 Request/RequestCreator首先是 Request.java，这个类包含了待显示图片的地址、尺寸、缩放、旋转、裁剪信息，采用 Builder 模式，属性如下 1234567891011121314151617public static final class Builder &#123; private Uri uri; private int resourceId; private String stableKey; private int targetWidth; private int targetHeight; private boolean centerCrop; private boolean centerInside; private boolean onlyScaleDown; private float rotationDegrees; private float rotationPivotX; private float rotationPivotY; private boolean hasRotationPivot; private List&lt;Transformation&gt; transformations; private Bitmap.Config config; private Priority priority;&#125; 然后才是请求包装类 RequestCreator.java，在 Request.java 基础上，这个类增加了显示效果的属性，比如淡入、加载中的占位图片、错误图片、tag 以及缓存策略 1234567891011121314151617public class RequestCreator &#123; private static final AtomicInteger nextId = new AtomicInteger(); private final Picasso picasso; private final Request.Builder data; private boolean noFade; private boolean deferred; private boolean setPlaceholder = true; private int placeholderResId; private int errorResId; private int memoryPolicy; private int networkPolicy; private Drawable placeholderDrawable; private Drawable errorDrawable; private Object tag;&#125; 另外，Picasso.with(context).load(&quot;fake_url&quot;).into(someImageView) 中的into方法也是由 RequestCreator.java 类实现的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public void into(ImageView target, Callback callback) &#123; long started = System.nanoTime(); checkMain(); // 因为要显示在 ImageView 上，所以必须在主线程调用 if (target == null) &#123; throw new IllegalArgumentException(\"Target must not be null.\"); &#125; if (!data.hasImage()) &#123; // 取图失败 picasso.cancelRequest(target); if (setPlaceholder) &#123; setPlaceholder(target, getPlaceholderDrawable()); &#125; return; &#125; if (deferred) &#123; // 采用 fit 调整图片大小以适应 ImageView，延时操作 if (data.hasSize()) &#123; // fit 后自然不能人工设置长宽 throw new IllegalStateException(\"Fit cannot be used with resize.\"); &#125; int width = target.getWidth(); int height = target.getHeight(); if (width == 0 || height == 0) &#123; if (setPlaceholder) &#123; setPlaceholder(target, getPlaceholderDrawable()); &#125; picasso.defer(target, new DeferredRequestCreator(this, target, callback)); return; &#125; data.resize(width, height); &#125; Request request = createRequest(started); String requestKey = createKey(request); // cache 的 key if (shouldReadFromMemoryCache(memoryPolicy)) &#123; // 检验内存缓存 Bitmap bitmap = picasso.quickMemoryCacheCheck(requestKey); if (bitmap != null) &#123; picasso.cancelRequest(target); setBitmap(target, picasso.context, bitmap, MEMORY, noFade, picasso.indicatorsEnabled); if (picasso.loggingEnabled) &#123; log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), \"from \" + MEMORY); &#125; if (callback != null) &#123; callback.onSuccess(); &#125; return; &#125; &#125; // 内存缓存未命中，先显示占位符，然后去网络获取 if (setPlaceholder) &#123; setPlaceholder(target, getPlaceholderDrawable()); &#125; Action action = new ImageViewAction(picasso, target, request, memoryPolicy, networkPolicy, errorResId, errorDrawable, requestKey, tag, callback, noFade); picasso.enqueueAndSubmit(action);&#125; 代码中有一个deferred的判断，如果为true则会创建一个DeferredRequestCreator，看一下这个类的实现代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class DeferredRequestCreator implements ViewTreeObserver.OnPreDrawListener &#123; final RequestCreator creator; final WeakReference&lt;ImageView&gt; target; Callback callback; @TestOnly DeferredRequestCreator(RequestCreator creator, ImageView target) &#123; this(creator, target, null); &#125; DeferredRequestCreator(RequestCreator creator, ImageView target, Callback callback) &#123; this.creator = creator; this.target = new WeakReference&lt;ImageView&gt;(target); this.callback = callback; target.getViewTreeObserver().addOnPreDrawListener(this); &#125; @Override public boolean onPreDraw() &#123; // 覆盖这个方法，以便当ViewTree计算完成准备绘制时，拿到ImageView的长宽 ImageView target = this.target.get(); if (target == null) &#123; return true; &#125; ViewTreeObserver vto = target.getViewTreeObserver(); if (!vto.isAlive()) &#123; return true; &#125; int width = target.getWidth(); int height = target.getHeight(); if (width &lt;= 0 || height &lt;= 0) &#123; return true; &#125; vto.removeOnPreDrawListener(this); this.creator.unfit().resize(width, height).into(target, callback); // 将ImageView长宽传给RequestCreator以便对图片进行resize return true; &#125; void cancel() &#123; callback = null; ImageView target = this.target.get(); if (target == null) &#123; return; &#125; ViewTreeObserver vto = target.getViewTreeObserver(); if (!vto.isAlive()) &#123; return; &#125; vto.removeOnPreDrawListener(this); &#125;&#125; 只有当在显示图片的地方调用fit()时才会创建DeferredRequestCreator对象。 RequestCreator里面有两个字断分别对应着内存设置与网络设置，是缓存策略，对应的枚举类如下，可以看到两者都有NO_CACHE NO_STORE，网络策略枚举里多了一个OFFLINE。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public enum MemoryPolicy &#123; /** Skips memory cache lookup when processing a request. */ NO_CACHE(1 &lt;&lt; 0), /** * Skips storing the final result into memory cache. Useful for one-off requests * to avoid evicting other bitmaps from the cache. */ NO_STORE(1 &lt;&lt; 1); static boolean shouldReadFromMemoryCache(int memoryPolicy) &#123; return (memoryPolicy &amp; MemoryPolicy.NO_CACHE.index) == 0; &#125; static boolean shouldWriteToMemoryCache(int memoryPolicy) &#123; return (memoryPolicy &amp; MemoryPolicy.NO_STORE.index) == 0; &#125; final int index; private MemoryPolicy(int index) &#123; this.index = index; &#125;&#125;public enum NetworkPolicy &#123; /** Skips checking the disk cache and forces loading through the network. */ NO_CACHE(1 &lt;&lt; 0), /** * Skips storing the result into the disk cache. * &lt;p&gt; * &lt;em&gt;Note&lt;/em&gt;: At this time this is only supported if you are using OkHttp. */ NO_STORE(1 &lt;&lt; 1), /** Forces the request through the disk cache only, skipping network. */ OFFLINE(1 &lt;&lt; 2); public static boolean shouldReadFromDiskCache(int networkPolicy) &#123; return (networkPolicy &amp; NetworkPolicy.NO_CACHE.index) == 0; &#125; public static boolean shouldWriteToDiskCache(int networkPolicy) &#123; return (networkPolicy &amp; NetworkPolicy.NO_STORE.index) == 0; &#125; public static boolean isOfflineOnly(int networkPolicy) &#123; return (networkPolicy &amp; NetworkPolicy.OFFLINE.index) != 0; &#125; final int index; private NetworkPolicy(int index) &#123; this.index = index; &#125;&#125; 缓存管理 LruCachePicasso.java里维护了一个成员变量cache，对应接口是Cache.java，（只贴出主要代码） 1234567891011121314151617181920212223/** * A memory cache for storing the most recently used images. * &lt;p&gt; * &lt;em&gt;Note:&lt;/em&gt; The &#123;@link Cache&#125; is accessed by multiple threads. You must ensure * your &#123;@link Cache&#125; implementation is thread safe when &#123;@link Cache#get(String)&#125; or &#123;@link * Cache#set(String, android.graphics.Bitmap)&#125; is called. */public interface Cache &#123; /** Retrieve an image for the specified &#123;@code key&#125; or &#123;@code null&#125;. */ Bitmap get(String key); /** Store an image in the cache for the specified &#123;@code key&#125;. */ void set(String key, Bitmap bitmap); /** Returns the current size of the cache in bytes. */ int size(); /** Returns the maximum size in bytes that the cache can hold. */ int maxSize(); /** Clears the cache. */ void clear();&#125; 很简单的几个接口，需要注意的是在实现过程中要保证get/set的线程安全。对应的实现类是LruCache.java，这是LruCache一个很漂亮的实现，该有的功能都有，丝毫不拖泥带水，我忍不住把整个类都贴出来。单词eviction的翻译是驱逐。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141/** A memory cache which uses a least-recently used eviction policy. */public class LruCache implements Cache &#123; final LinkedHashMap&lt;String, Bitmap&gt; map; // 有序 map private final int maxSize; private int size; private int putCount; private int evictionCount; private int hitCount; // 命中计数 private int missCount; // 未命中计数 /** Create a cache using an appropriate portion of the available RAM as the maximum size. */ public LruCache(Context context) &#123; this(Utils.calculateMemoryCacheSize(context)); // Utils.java 里用于计算内存的工具方法，返回的数值是1/7（约15%）应用可用内存。 &#125; /** Create a cache with a given maximum size in bytes. */ public LruCache(int maxSize) &#123; if (maxSize &lt;= 0) &#123; throw new IllegalArgumentException(\"Max size must be positive.\"); &#125; this.maxSize = maxSize; this.map = new LinkedHashMap&lt;String, Bitmap&gt;(0, 0.75f, true); // 第三个参数 true 表示 LinkedHashMap 的排序是按照最近 access，false则为最近 insertion &#125; @Override public Bitmap get(String key) &#123; if (key == null) &#123; throw new NullPointerException(\"key == null\"); &#125; Bitmap mapValue; synchronized (this) &#123; // 前面说了，get/set必须要做同步控制 mapValue = map.get(key); if (mapValue != null) &#123; hitCount++; return mapValue; &#125; missCount++; &#125; return null; &#125; @Override public void set(String key, Bitmap bitmap) &#123; if (key == null || bitmap == null) &#123; throw new NullPointerException(\"key == null || bitmap == null\"); &#125; Bitmap previous; synchronized (this) &#123; // 一样的同步 putCount++; size += Utils.getBitmapBytes(bitmap); previous = map.put(key, bitmap); if (previous != null) &#123; size -= Utils.getBitmapBytes(previous); &#125; &#125; trimToSize(maxSize); // 若尺寸超过 maxSize 则需要清理 &#125; private void trimToSize(int maxSize) &#123; while (true) &#123; String key; Bitmap value; synchronized (this) &#123; // 凡是所有操作 map 的地方都加锁 if (size &lt; 0 || (map.isEmpty() &amp;&amp; size != 0)) &#123; throw new IllegalStateException( getClass().getName() + \".sizeOf() is reporting inconsistent results!\"); &#125; if (size &lt;= maxSize || map.isEmpty()) &#123; break; &#125; Map.Entry&lt;String, Bitmap&gt; toEvict = map.entrySet().iterator().next(); key = toEvict.getKey(); value = toEvict.getValue(); map.remove(key); // 清理出 map，由 GC 自动回收 size -= Utils.getBitmapBytes(value); evictionCount++; &#125; &#125; &#125; /** Clear the cache. */ public final void evictAll() &#123; trimToSize(-1); // -1 will evict 0-sized elements &#125; @Override public final synchronized int size() &#123; return size; &#125; @Override public final synchronized int maxSize() &#123; return maxSize; &#125; @Override public final synchronized void clear() &#123; evictAll(); &#125; @Override public final synchronized void clearKeyUri(String uri) &#123; // 清除某个 URI 对应的全部图片，同样内容的图片因为尺寸缩放旋转不同，会在 cache 里存在多个实例 boolean sizeChanged = false; int uriLength = uri.length(); for (Iterator&lt;Map.Entry&lt;String, Bitmap&gt;&gt; i = map.entrySet().iterator(); i.hasNext();) &#123; Map.Entry&lt;String, Bitmap&gt; entry = i.next(); String key = entry.getKey(); Bitmap value = entry.getValue(); int newlineIndex = key.indexOf(KEY_SEPARATOR); if (newlineIndex == uriLength &amp;&amp; key.substring(0, newlineIndex).equals(uri)) &#123; i.remove(); size -= Utils.getBitmapBytes(value); sizeChanged = true; &#125; &#125; if (sizeChanged) &#123; trimToSize(maxSize); &#125; &#125; /** Returns the number of times &#123;@link #get&#125; returned a value. */ public final synchronized int hitCount() &#123; return hitCount; &#125; /** Returns the number of times &#123;@link #get&#125; returned &#123;@code null&#125;. */ public final synchronized int missCount() &#123; return missCount; &#125; /** Returns the number of times &#123;@link #set(String, Bitmap)&#125; was called. */ public final synchronized int putCount() &#123; return putCount; &#125; /** Returns the number of values that have been evicted. */ public final synchronized int evictionCount() &#123; return evictionCount; &#125;&#125; 知道了 cache 的用法，就可以很好地在Picasso.java里面检查 cache 了，用起来十分简单。 123456789Bitmap quickMemoryCacheCheck(String key) &#123; Bitmap cached = cache.get(key); if (cached != null) &#123; stats.dispatchCacheHit(); &#125; else &#123; stats.dispatchCacheMiss(); &#125; return cached;&#125; 请求处理器 RequestHandler在 Picasso.java 的构造函数里，有这样一段初始化代码 123456789101112131415Picasso(Context context, Dispatcher dispatcher, Cache cache, Listener listener, RequestTransformer requestTransformer, List&lt;RequestHandler&gt; extraRequestHandlers, Stats stats, Bitmap.Config defaultBitmapConfig, boolean indicatorsEnabled, boolean loggingEnabled) &#123; allRequestHandlers.add(new ResourceRequestHandler(context)); if (extraRequestHandlers != null) &#123; allRequestHandlers.addAll(extraRequestHandlers); &#125; allRequestHandlers.add(new ContactsPhotoRequestHandler(context)); allRequestHandlers.add(new MediaStoreRequestHandler(context)); allRequestHandlers.add(new ContentStreamRequestHandler(context)); allRequestHandlers.add(new AssetRequestHandler(context)); allRequestHandlers.add(new FileRequestHandler(context)); allRequestHandlers.add(new NetworkRequestHandler(dispatcher.downloader, stats)); requestHandlers = Collections.unmodifiableList(allRequestHandlers);&#125; 可以看出这是实现了多种请求处理类，所有的XXXRequetHandler类都继承自抽象类RequestHandler.java，其中最重要的是canHandleRequest和load这两个方法。源码注释里给出了简洁的说明，不再赘述。 1234567891011121314public abstract class RequestHandler &#123; /** * Whether or not this &#123;@link RequestHandler&#125; can handle a request with the given &#123;@link Request&#125;. */ public abstract boolean canHandleRequest(Request data); /** * Loads an image for the given &#123;@link Request&#125;. * * @param request the data from which the image should be resolved. * @param networkPolicy the &#123;@link NetworkPolicy&#125; for this request. */ public abstract Result load(Request request, int networkPolicy) throws IOException;&#125; 我们看一下NetworkRequestHandler类的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class NetworkRequestHandler extends RequestHandler &#123; static final int RETRY_COUNT = 2; private static final String SCHEME_HTTP = \"http\"; // 这两个常量用于判断 url private static final String SCHEME_HTTPS = \"https\"; private final Downloader downloader; // 下载器，有 OkHttp 和 URLConnectionDownloader 两种实现，稍后讲解 private final Stats stats; public NetworkRequestHandler(Downloader downloader, Stats stats) &#123; this.downloader = downloader; this.stats = stats; &#125; @Override public boolean canHandleRequest(Request data) &#123; String scheme = data.uri.getScheme(); // 从 scheme 判断是否为网络图片请求 return (SCHEME_HTTP.equals(scheme) || SCHEME_HTTPS.equals(scheme)); &#125; @Override public Result load(Request request, int networkPolicy) throws IOException &#123; Response response = downloader.load(request.uri, request.networkPolicy); // 同步下载 if (response == null) &#123; return null; &#125; Picasso.LoadedFrom loadedFrom = response.cached ? DISK : NETWORK; Bitmap bitmap = response.getBitmap(); if (bitmap != null) &#123; // 直接拿到 Bitmap，则返回 return new Result(bitmap, loadedFrom); &#125; InputStream is = response.getInputStream(); // 拿到输入流，需要解析成 Bitmap if (is == null) &#123; return null; &#125; // Sometimes response content length is zero when requests are being replayed. Haven't found // root cause to this but retrying the request seems safe to do so. if (loadedFrom == DISK &amp;&amp; response.getContentLength() == 0) &#123; Utils.closeQuietly(is); throw new ContentLengthException(\"Received response with 0 content-length header.\"); &#125; if (loadedFrom == NETWORK &amp;&amp; response.getContentLength() &gt; 0) &#123; stats.dispatchDownloadFinished(response.getContentLength()); &#125; return new Result(is, loadedFrom); &#125;&#125; 可以看到它是将下载任务委托给了Downloader进行，Downloader的注释里描述的很清楚，它是“A mechanism to load images from external resources such as a disk cache and/or the internet.”，用于加载外部图片（相比于内存缓存而言）。最主要的是load方法 1Response load(Uri uri, int networkPolicy) throws IOException; 其中Response的结构是 123456class Response &#123; final InputStream stream; final Bitmap bitmap; final boolean cached; // 图片是否来源自磁盘缓存（local disk cache） final long contentLength;&#125; Downloader有两个实现 OKHttpDownloader，对应 Android 版本 &gt;= 4.4 URLConnectionDownloader，对应 Android 版本 &lt; 4.4 判断代码位于Utils.java 12345678static Downloader createDefaultDownloader(Context context) &#123; try &#123; Class.forName(\"com.squareup.okhttp.OkHttpClient\"); return OkHttpLoaderCreator.create(context); &#125; catch (ClassNotFoundException ignored) &#123; &#125; return new UrlConnectionDownloader(context);&#125; OKHttpDownloader里面的load方法，采用 square 自家的OKHttp进行下载，在构建其 Builder 时决定是否使用磁盘缓存。换言之，虽然Picasso声称有内存+磁盘两级缓存，其磁盘缓存其实是借助OKHttp实现的。 1234567891011121314151617181920212223242526272829303132333435@Override public Response load(Uri uri, int networkPolicy) throws IOException &#123; CacheControl cacheControl = null; // 这个 CacheControl 是 OKHttp 里面的类 if (networkPolicy != 0) &#123; if (NetworkPolicy.isOfflineOnly(networkPolicy)) &#123; cacheControl = CacheControl.FORCE_CACHE; &#125; else &#123; CacheControl.Builder builder = new CacheControl.Builder(); if (!NetworkPolicy.shouldReadFromDiskCache(networkPolicy)) &#123; builder.noCache(); &#125; if (!NetworkPolicy.shouldWriteToDiskCache(networkPolicy)) &#123; builder.noStore(); &#125; cacheControl = builder.build(); &#125; &#125; Request.Builder builder = new Request.Builder().url(uri.toString()); if (cacheControl != null) &#123; builder.cacheControl(cacheControl); &#125; com.squareup.okhttp.Response response = client.newCall(builder.build()).execute(); // 同步接口 int responseCode = response.code(); if (responseCode &gt;= 300) &#123; response.body().close(); throw new ResponseException(responseCode + \" \" + response.message(), networkPolicy, responseCode); &#125; boolean fromCache = response.cacheResponse() != null; ResponseBody responseBody = response.body(); return new Response(responseBody.byteStream(), fromCache, responseBody.contentLength());&#125; 至此RequestHandler的分析已经完成，虽然它名为 Handler，但实际上并没有包含工作线程一类的东西，这部分相关代码实际上位于Dispatcher.java中。 任务调度器 Dispatcher理解Dispatcher之前，我们需要先了解一下任务类Action.java 123456789101112131415161718192021222324252627abstract class Action&lt;T&gt; &#123; static class RequestWeakReference&lt;M&gt; extends WeakReference&lt;M&gt; &#123; final Action action; public RequestWeakReference(Action action, M referent, ReferenceQueue&lt;? super M&gt; q) &#123; super(referent, q); this.action = action; &#125; &#125; final Picasso picasso; final Request request; final WeakReference&lt;T&gt; target; final boolean noFade; final int memoryPolicy; final int networkPolicy; final int errorResId; final Drawable errorDrawable; final String key; final Object tag; boolean willReplay; boolean cancelled; abstract void complete(Bitmap result, Picasso.LoadedFrom from); abstract void error(); Action可以理解成一项图片加载任务，它组合了之前介绍的Request和RequestCreator的内容，且包含加载成功/失败的回调。 所有的Action任务都会被丢给Dispatcher执行 12345678910111213141516171819202122232425262728293031323334353637383940class Dispatcher &#123; private static final int RETRY_DELAY = 500; private static final int AIRPLANE_MODE_ON = 1; // 飞行模式，会影响并发线程数 private static final int AIRPLANE_MODE_OFF = 0; static final int REQUEST_SUBMIT = 1; // 消息类型，供 handler 使用 static final int REQUEST_CANCEL = 2; static final int REQUEST_GCED = 3; static final int HUNTER_COMPLETE = 4; static final int HUNTER_RETRY = 5; static final int HUNTER_DECODE_FAILED = 6; static final int HUNTER_DELAY_NEXT_BATCH = 7; static final int HUNTER_BATCH_COMPLETE = 8; static final int NETWORK_STATE_CHANGE = 9; static final int AIRPLANE_MODE_CHANGE = 10; static final int TAG_PAUSE = 11; static final int TAG_RESUME = 12; static final int REQUEST_BATCH_RESUME = 13; private static final String DISPATCHER_THREAD_NAME = \"Dispatcher\"; private static final int BATCH_DELAY = 200; // ms final DispatcherThread dispatcherThread; // 调度器线程 final Context context; final ExecutorService service; // 线程池 final Downloader downloader; // 下载器 final Map&lt;String, BitmapHunter&gt; hunterMap; // 线程 map final Map&lt;Object, Action&gt; failedActions; final Map&lt;Object, Action&gt; pausedActions; final Set&lt;Object&gt; pausedTags; final Handler handler; // DispatchHandler final Handler mainThreadHandler; // UI 变更 final Cache cache; final Stats stats; // 统计数据，包含命中缓存、未命中缓存、解码、下载计数 final List&lt;BitmapHunter&gt; batch; final NetworkBroadcastReceiver receiver; // 监听网络变化，调整并发线程数 final boolean scansNetworkChanges; boolean airplaneMode;&#125; 既然名为Dispatcher，肯定少不了dispatchXXX的方法，它们的处理方法完全一样，都是把消息丢给DispatchHandler 123456789101112131415void dispatchSubmit(Action action) &#123; handler.sendMessage(handler.obtainMessage(REQUEST_SUBMIT, action));&#125;void dispatchCancel(Action action) &#123; handler.sendMessage(handler.obtainMessage(REQUEST_CANCEL, action));&#125;void dispatchPauseTag(Object tag) &#123; handler.sendMessage(handler.obtainMessage(TAG_PAUSE, tag));&#125;// 以下还有 dispatchResumeTag、dispatchComplete、dispatchRetry，略...&#125; DispatchHandler是用于接收处理这些消息的类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667private static class DispatcherHandler extends Handler &#123; private final Dispatcher dispatcher; public DispatcherHandler(Looper looper, Dispatcher dispatcher) &#123; super(looper); this.dispatcher = dispatcher; &#125; @Override public void handleMessage(final Message msg) &#123; switch (msg.what) &#123; case REQUEST_SUBMIT: &#123; Action action = (Action) msg.obj; dispatcher.performSubmit(action); break; &#125; case REQUEST_CANCEL: &#123; Action action = (Action) msg.obj; dispatcher.performCancel(action); break; &#125; case TAG_PAUSE: &#123; Object tag = msg.obj; dispatcher.performPauseTag(tag); break; &#125; case TAG_RESUME: &#123; Object tag = msg.obj; dispatcher.performResumeTag(tag); break; &#125; case HUNTER_COMPLETE: &#123; BitmapHunter hunter = (BitmapHunter) msg.obj; dispatcher.performComplete(hunter); break; &#125; case HUNTER_RETRY: &#123; BitmapHunter hunter = (BitmapHunter) msg.obj; dispatcher.performRetry(hunter); break; &#125; case HUNTER_DECODE_FAILED: &#123; BitmapHunter hunter = (BitmapHunter) msg.obj; dispatcher.performError(hunter, false); break; &#125; case HUNTER_DELAY_NEXT_BATCH: &#123; dispatcher.performBatchComplete(); break; &#125; case NETWORK_STATE_CHANGE: &#123; NetworkInfo info = (NetworkInfo) msg.obj; dispatcher.performNetworkStateChange(info); break; &#125; case AIRPLANE_MODE_CHANGE: &#123; dispatcher.performAirplaneModeChange(msg.arg1 == AIRPLANE_MODE_ON); break; &#125; default: Picasso.HANDLER.post(new Runnable() &#123; @Override public void run() &#123; throw new AssertionError(\"Unknown handler message received: \" + msg.what); &#125; &#125;); &#125; &#125;&#125; 可以看到，处理手段是取出消息里的Action，然后调用Dispatcher中performXXX直接进行处理。这种Dispatcher组合Handler的模式值得学习借鉴。接下来我们具体看一下performSubmit也就是提交一个图片加载请求具体是怎么实现的。 12345678910111213141516171819202122232425262728293031323334void performSubmit(Action action, boolean dismissFailed) &#123; if (pausedTags.contains(action.getTag())) &#123; // 如果请求已经被 pause，则不继续向下处理 pausedActions.put(action.getTarget(), action); if (action.getPicasso().loggingEnabled) &#123; log(OWNER_DISPATCHER, VERB_PAUSED, action.request.logId(), \"because tag '\" + action.getTag() + \"' is paused\"); &#125; return; &#125; BitmapHunter hunter = hunterMap.get(action.getKey()); if (hunter != null) &#123; // BitmapHunter 是工作线程类（实现 Runnable 接口），若一张图片已经有工作线程在处理，则将当前 Action 附到工作线程的队列中 hunter.attach(action); return; &#125; if (service.isShutdown()) &#123; // 线程池已停止 if (action.getPicasso().loggingEnabled) &#123; log(OWNER_DISPATCHER, VERB_IGNORED, action.request.logId(), \"because shut down\"); &#125; return; &#125; // 生成一个 BitmapHunter hunter = forRequest(action.getPicasso(), this, cache, stats, action); hunter.future = service.submit(hunter); // 这里很重要，提交一个 Runnable 给线程池 hunterMap.put(action.getKey(), hunter); // 存进工作线程 Map if (dismissFailed) &#123; failedActions.remove(action.getTarget()); &#125; if (action.getPicasso().loggingEnabled) &#123; log(OWNER_DISPATCHER, VERB_ENQUEUED, action.request.logId()); &#125;&#125; 职责重大的 BitmapHunterBitmapHunter实现了Runnable接口，run方法可以看作对一次图片请求的完整处理过程，也就是文初提到的“获取 - 变换 - 显示”。 12345678910111213141516171819202122class BitmapHunter implements Runnable &#123; final int sequence; // 序列号，基于 AtomicInteger 实现 final Picasso picasso; // 单例 final Dispatcher dispatcher; // 任务调度器 final Cache cache; final Stats stats; final String key; final Request data; final int memoryPolicy; int networkPolicy; final RequestHandler requestHandler; Action action; List&lt;Action&gt; actions; // 一个 BitmapHunter 可以处理多个 Action Bitmap result; Future&lt;?&gt; future; Picasso.LoadedFrom loadedFrom; Exception exception; int exifRotation; // Determined during decoding of original resource. int retryCount; Priority priority;&#125; EXIF（Exchangeable Image File）是“可交换图像文件”的缩写，当中包含了专门为数码相机的照片而定制的元数据，可以记录数码照片的拍摄参数、缩略图及其他属性信息。很多图像编辑器会自动读取Exif数据来对图像进行优化，最常见的便是从 Exif中读取出相机姿态信息，从而自动识别出竖拍甚至是颠倒拍摄的照片并对其进行旋转校正。 run()方法是对图片的处理流程 1234567891011121314151617181920212223242526272829303132333435363738@Override public void run() &#123; try &#123; updateThreadName(data); if (picasso.loggingEnabled) &#123; log(OWNER_HUNTER, VERB_EXECUTING, getLogIdsForHunter(this)); &#125; result = hunt(); // 同步获取结果 if (result == null) &#123; // 通知 Dispatcher 任务完成 dispatcher.dispatchFailed(this); &#125; else &#123; dispatcher.dispatchComplete(this); &#125; &#125; catch (Downloader.ResponseException e) &#123; if (!e.localCacheOnly || e.responseCode != 504) &#123; exception = e; &#125; dispatcher.dispatchFailed(this); &#125; catch (NetworkRequestHandler.ContentLengthException e) &#123; // 非常细节的错误处理 exception = e; dispatcher.dispatchRetry(this); &#125; catch (IOException e) &#123; exception = e; dispatcher.dispatchRetry(this); &#125; catch (OutOfMemoryError e) &#123; StringWriter writer = new StringWriter(); stats.createSnapshot().dump(new PrintWriter(writer)); exception = new RuntimeException(writer.toString(), e); dispatcher.dispatchFailed(this); &#125; catch (Exception e) &#123; exception = e; dispatcher.dispatchFailed(this); &#125; finally &#123; Thread.currentThread().setName(Utils.THREAD_IDLE_NAME); &#125;&#125; 可见对图片的获取和处理在hunt中，对得起BitmapHunter这个名字 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162Bitmap hunt() throws IOException &#123; Bitmap bitmap = null; if (shouldReadFromMemoryCache(memoryPolicy)) &#123; // 检查内存缓存 bitmap = cache.get(key); if (bitmap != null) &#123; stats.dispatchCacheHit(); loadedFrom = MEMORY; if (picasso.loggingEnabled) &#123; log(OWNER_HUNTER, VERB_DECODED, data.logId(), \"from cache\"); &#125; return bitmap; &#125; &#125; data.networkPolicy = retryCount == 0 ? NetworkPolicy.OFFLINE.index : networkPolicy; RequestHandler.Result result = requestHandler.load(data, networkPolicy); // 调用 handler 同步获取结果 if (result != null) &#123; loadedFrom = result.getLoadedFrom(); exifRotation = result.getExifOrientation(); // 从 exif 里获取旋转角度 bitmap = result.getBitmap(); // If there was no Bitmap then we need to decode it from the stream. if (bitmap == null) &#123; InputStream is = result.getStream(); // 解码图片 try &#123; bitmap = decodeStream(is, data); &#125; finally &#123; Utils.closeQuietly(is); // quietly 的含义是无视所有异常 &#125; &#125; &#125; if (bitmap != null) &#123; // 取到解码后的图片，进行转换和显示 if (picasso.loggingEnabled) &#123; log(OWNER_HUNTER, VERB_DECODED, data.logId()); &#125; stats.dispatchBitmapDecoded(bitmap); // 这里只是计数，并未操作转换 if (data.needsTransformation() || exifRotation != 0) &#123; synchronized (DECODE_LOCK) &#123; // 必须加锁，同一时间只能处理一张图片，防止 OOM if (data.needsMatrixTransform() || exifRotation != 0) &#123; bitmap = transformResult(data, bitmap, exifRotation); // 运用 matrix 的 scale 与 rotate 处理图片 if (picasso.loggingEnabled) &#123; log(OWNER_HUNTER, VERB_TRANSFORMED, data.logId()); &#125; &#125; if (data.hasCustomTransformations()) &#123; // 自定义转换，比如圆角 bitmap = applyCustomTransformations(data.transformations, bitmap); if (picasso.loggingEnabled) &#123; log(OWNER_HUNTER, VERB_TRANSFORMED, data.logId(), \"from custom transformations\"); &#125; &#125; &#125; if (bitmap != null) &#123; stats.dispatchBitmapTransformed(bitmap); &#125; &#125; &#125; return bitmap;&#125; 到此为止，整个图片的加载流程基本分析完成，下面是一个完整的类图，出处见文末。 类图 碎碎念在我看来，做一个开源项目的源码解读，一般有两个切入点。 先反问自己一个问题，“如果让你实现一个 XX 框架，你会怎么设计？”，画出流程图，列出承担主要职责的类；然后再对照着自己的设计，去阅读并理解项目代码。我把它叫做自顶向下。 从项目代码的入口开始（一般是函数调用处），逐级追踪，弄清楚每一步涉及到哪些类，它们的职责是什么，这样最后会有一个链式的调用在你脑海中。我把它叫做自底向上。 方法 1 能让你在开始时纵览全局，对每一个模块有大致的轮廓，随着逐步深入学习代码，对其认识会进一步加深，最后化为己用；但缺点也很明显，你不可能一上来就把流程图、类图绘制地明明白白，需要你对项目代码有一些理解，也许还需要一定的设计模式知识。方法 2 容易上手，如果项目简单还好，若是复杂项目很容易让人迷失其中。本文采用的是方法 1 的思路，以下两篇文章分别对应方法 1 和 2，它们在我写本文的过程中提供了大量帮助，非常感谢原作者。 Android 面试助力：一次读懂热门图片框架 Picasso 源码及流程 Picasso源代码分析","tags":[{"name":"Android","slug":"Android","permalink":"https://lilei.pro/tags/Android/"},{"name":"源码学习","slug":"源码学习","permalink":"https://lilei.pro/tags/源码学习/"}]},{"title":"作息时间表","date":"2018-05-15T00:31:05.000Z","path":"2018/05/15/schedule2018/","text":"A man is not old as long as he is seeking something. A man is not old until regrets take the place of dreams. 开始日期 2018.5.15 时间 事项 备注 6:00~7:00 起床，洗漱，早饭，清理房间 解冻牛排 7:00~11:00 上午自习 前端开发 11:00~13:30 训练 胸，背，腿，肩，上臂，小腿小臂 13:30~14:30 午饭 / 14:30~18:00 下午自习 计算机通用技能 18:00~19:00 晚饭 全家购买蔬菜色拉 19:00~22:00 晚自习 博客，日记 22:00~23:00 洗漱，洗衣服 / 23:00 睡觉 /","tags":[{"name":"生活","slug":"生活","permalink":"https://lilei.pro/tags/生活/"}]},{"title":"我，堂吉诃德","date":"2018-05-06T08:33:43.000Z","path":"2018/05/06/Man-of-Lamancha/","text":"To dream the impossible dreamto fight the unbeatable foeto bear with unbearable sorrowto run where the brave dare not goto right the unrightable wrongto love pure and chaste from afarto try when your arms are too wearyto reach the unreachable star 点击播放英文版The Impossible Dream 我，堂吉诃德 这是李磊在2018年记录的第一部音乐剧/话剧，2018年5月5日，于上海大舞台。 周六，下着小雨，从人广地铁站14号口走出不远，就到了此剧的演出地点上海大舞台，离开场还有45分钟，于是在附近走了一走。街对面有一所造型优美的教堂，两颗路口外，是人头攒动的南京路步行街，即使天公不作美，也并未打消游人们的兴致。上一次自己来这里还是什么时候？怕是有一两年吧。 辞职之后，自己变得太懒，这不是个好现象。14:15回到剧场，检票，进场入座。 初识不知剧中意，再见已是剧中人。 这部剧好么？ 好，每一个在社会的汪洋大海中找不到方向的人，都应该去看一看。她配得上那一句宣传语——“一生中值得看三遍的音乐剧”。现实生活中，他是拉曼查的老迈乡绅阿隆索，在他的世界里，却是身披甲胄挑战恶龙赢得公主芳心的游侠骑士堂吉诃德。 印象最深的是，当堂吉诃德的骑士幻梦被镜子骑士揭穿后，那躺在病床上的老人仿佛一瞬间被抽去了灵魂，尽管自己坐在影院二楼，似乎却可以看到他的眼中失去了往昔的光彩。 在“正常人”眼中，退休的乡绅应该拾掇花圃安度晚年，妓女一定是狂蜂浪蝶人尽可夫，而阿隆索收税收到了教堂头上，简直是不识抬举。 在他们看来，风车就是风车，理发匠的脸盆跟金头盔八杆子打不着，姑且叫你一声哭丧脸的骑士，与疯子不需计较。 我们的文化一直以来强调的是人的社会属性：父亲、儿子、员工、老板、外乡人、消费者……当我们向陌生人自我介绍时，最先说的是“他是一个教师”、“他是一名医生”，我们自然会在听到这句话后，为眼前这个人贴上好多个属性标签。但是，我们太少谈及作为一个人的自然属性：人格、尊严、自由、快乐、幸福、追求、还有理想。 这种理想，不是YY自己身披金甲圣衣、脚踩七彩祥云，于万众瞩目中以一己之力逆转乾坤，理想应当是坚定的、值得持之以恒的、可以实现的。理想不应当是动物性，贪婪、懒惰、暴食、淫欲、愤怒、嫉妒、傲慢。理想应当是无害于人并且有利于己。 即使一个人活的像条狗，也不矛盾。 去问自己的内心，想成为什么样的人，而不是让这个社会告诉你，要过什么样的生活。 片中的小马小驴表演的颇有灵气，在舞台一角戏份很足，可惜坐在二楼视线不好，被遮挡了一些。 去摘，遥不可及的星！ 分享一篇文章 如何评价音乐剧《我，堂吉诃德》中文版？ - NYLE的回答 - 知乎","tags":[{"name":"音乐剧","slug":"音乐剧","permalink":"https://lilei.pro/tags/音乐剧/"}]},{"title":"渐行渐远渐无书","date":"2018-05-05T00:20:28.000Z","path":"2018/05/05/渐行渐远渐无书/","text":"欧阳修《玉楼春 别后不知君远近》 别后不知君远近，触目凄凉多少闷，渐行渐远渐无书，水阔鱼沉何处问。夜深风竹敲秋韵，万叶千声皆是恨，故欹单枕梦中寻，梦又不成灯又烬。","tags":[{"name":"诗词","slug":"诗词","permalink":"https://lilei.pro/tags/诗词/"}]},{"title":"后来的我们","date":"2018-04-30T12:28:17.000Z","path":"2018/04/30/后来的我们/","text":"缘分这件事，不负对方就好了，想不负此生是很难的。 点击播放五月天《后来的我们》 这是李磊在2018年记录的第2部电影。 后来的我们 想去影院看这部电影，来源于它的主题——小人物在大城市里的打拼，以及他们之间的爱恨悲欢。身为其中一员，也想看看那个曾经唱出《很爱很爱你》和《后来》的刘若英，拍出来的故事会是怎样的。最后一点是五月天的音乐加成，好可惜在正片里并没有采用这首歌。 故事比较简单，不再复述剧情，想到哪里就说到哪里。 “时隔许久回到故乡，发现这里好像并没有变过”，这是林见清在剧中的一段独白。听到这一句时，我的心里仿佛有一根弦被“zong”地一声拨动了。见惯了大城市里的变化，新的行业、潮流、生活方式一夜之间可以占据各大头版。再回到人生前十几年成长的故乡时，看到的山水车马，仍旧是小时候的样子，仿佛时间从不曾流逝。 也许家乡唯一可见的变化，就是亲人日渐老去的样貌。他们的腰杆不再像年轻时那么笔直，常常会想不起刚刚做过的事和对你唠叨过的话语，看报纸文章乃至遥控器上的字母，都要借助放大镜。 让人更悲伤的是，他们的记忆里再怎么衰退，总还会记得，顽劣如你小时候做过的那些事，你最爱吃的家乡菜，以及你的生日。 如同田壮壮饰演的林父，在火车站接林见清和他女朋友时，脱口而出的那句“小晓！”，看着银幕上老人浑浊的双眼，让自己在观看这部电影的过程中第一次想哭。 其中有一段，林见清刚刚丢了工作，除夕夜与方小晓窝在狭小的出租屋。林在打游戏时（分明是《求生之路》），林父打来电话，两人你瞒我瞒，一个说在北京很好，吃着烤鸭过着年，一个说家里来了好多亲戚热闹得很，你在北京要照顾好自己别惦记我。事实呢？是不是每一句“我很好，你不要惦记”背后，都有一个善意的谎言？ 刘若英在讲这个故事时，有一点我觉得处理得并不是很好，那就是两个人为什么分开。无疑他们还是彼此相爱着的，方小晓应该是始终未婚，林见清的婚姻也不见得多幸福，是为了悲剧而悲剧吗？虽然末尾借助林父的信件说出了引文中“缘分这件事，不负对方就好了，想不负此生是很难的”的话，但仍然让人觉得如鲠在喉。 把这部电影里的“北京”换成“上海”、“广州”，没有丝毫不妥。同样的故事在不同的情侣之间，每一天都在上演着。然而，个人的悲欢在这些拥有几千万人口的大都市里，被无限稀释了。每天地铁早晚高峰涌出多少人流，就有多少个林见清方小晓。在别人的故事里，我们是看客，在自己的故事里，我们是主角。 这部戏还有一些很用心的小细节，比如一开始07年两人乘坐绿皮车去北京（当年我从哈市到上海坐的33小时硬座大概也是绿皮的），背景电视里响起的北京申奥成功新闻报道，以及除夕夜见清为家里买了新电视时，电视里播放的西单女孩在春晚的表演。还有“粘豆包”，尽管自己并不喜欢吃，但好久之后听人说起这个词语，还是蓦然心里一热。 让人出戏的地方也有，像剧中三名主角的东北话，分明不是黑龙江内疙瘩的（末尾林见清租车开去上海，是一辆黑A牌照的凯迪拉克SUV，可见他们是在哈尔滨租的车），有点出戏，但瑕不掩瑜。田壮壮——北京人，周冬雨——石家庄人，井柏然倒是地道的沈阳人，不过辽宁的东北话与黑龙江、吉林差异还是蛮大的。 影片后半段，剧院里陆陆续续响起抽泣的声音，我喜欢这部电影，尽管外界对它的评价很低，而且刘若英并不擅长讲故事，但只要有可以触动我的地方就够了。别人都看好的，不一定合你的口味，电影如此，爱情也一样。 2018年4月30日，于长宁影剧院。","tags":[{"name":"周冬雨","slug":"周冬雨","permalink":"https://lilei.pro/tags/周冬雨/"},{"name":"井柏然","slug":"井柏然","permalink":"https://lilei.pro/tags/井柏然/"}]},{"title":"I'm a motherfuckin beast - 杰克吉伦哈尔《铁拳》","date":"2018-04-29T13:44:39.000Z","path":"2018/04/29/motherfuckin-beast-杰克吉伦哈尔《铁拳》/","text":"坚持到第12回合，坚持到你敌人倒下的那一刻。 这是李磊在2018年记录的第1部电影。 Southpaw 说实话，自己是被杰克吉伦哈尔一身腱子肉吸引，才观看这部电影的。在《夜行者/nightcrawler》一片中吉伦哈尔扮演了一名文质彬彬、为达目的不择手段的新闻贩子，很难想象他那样弱不禁风的样子，竟然可以在本片里饰演拳击手一角，一身精壮而有线条分明的肌肉，体脂率目测7～8左右。为了这个电影，他一定付出了很多努力。 关于影片本身，能够讲述的东西并不多，情节谈不上曲折，是运动题材电影一贯的套路，所向无敌-骄傲放肆-跌下神坛-洗心革面（这时候通常需要一个促使主角觉醒要素，在本片中是女儿&amp;教练）-遭遇宿敌-开局逆风-绝地反击。值得称赞的是杰克吉伦哈尔的演技始终在线，将一个生活、事业接连受挫、处于逆境中的拳击手/父亲形象演绎得极棒，尤其是他的眼神。后面的打斗部分倒不如《监狱斗士》来得精彩刺激。 尽管如此，这部电影能在我workout时候，激励我多做一个反复，如此这般就足够了。","tags":[{"name":"杰克吉伦哈尔","slug":"杰克吉伦哈尔","permalink":"https://lilei.pro/tags/杰克吉伦哈尔/"}]},{"title":"我们为什么需要《基督山伯爵》","date":"2018-04-28T00:40:12.000Z","path":"2018/04/28/再读《基督山伯爵》/","text":"人类的一切智慧，都包含在这两个词语里面。 这是李磊在2018年读完的第1本书。 《基督山伯爵》这本书，应该是在中学时代读的第一遍吧，从百草园书店租借的书籍。这周中，由于写信时需要引用书中的一段话，遂在网上找来原文，谁知再次被吸引，一发不可收拾，花3天时间又从头读完了这本不薄的著作。 故事内容颇有现在网文的套路，男主角（埃德蒙唐泰斯）出身平平，禀性纯良，有一青梅竹马红颜知己，本来可以升职船长娶妻生子安稳过完这一生，谁知被嫉妒他的小人暗中加害，不仅老父亲贫困而死，连蒙在鼓里的未婚妻都成为仇人的妻子，自己也在暗无天日的海上监牢里度过了十四年时光。所幸在遭难时，遇到了不世出的高人（法利亚神父），传授给他一身文武本领，又赠予一大笔富可敌国的财宝。当他成功越狱后，摇身一变基督山伯爵，将仇人玩弄于股掌之间。最后看破世事，携美人归隐。 从这个角度看，《基督山伯爵》这本由大仲马（1802—1870）出版于1846年的小说，引领了后世潮流足有近两百年。然而，它并非仅仅像龙傲天那么简单粗暴。 善恶分明、机智果敢、算无遗策、沉默高贵、慷慨无私……我们可以将太多赞美的词汇加诸于埃德蒙，然而对于他所承受过的痛苦，我们始终无法感同身受。不论是从与爱人的婚礼上被警察带走含冤入狱，还是在黑暗阴森的伊夫堡监狱度日如年，以及目睹亦师亦友亦父的法利亚神父死亡，还有得知所爱之人已经嫁给了谋害自己的凶徒，这些痛苦中的任何一个都足以压垮一个心智健全的人，何况是全部。 其实我最想知道的是，当埃德蒙移花接木代替法利亚神父，从悬崖被投入黑暗大海时，是什么支撑着他朝着渺茫希望游去，而不是就此放手，自戕于大海。 人生如此艰难，活下去比死亡更需要勇气。 我来自暗无天日的地狱，只想见一见阳光。我还有健壮的身体、渊博的知识、等待发掘的无尽财富，以及，饮不完的杯中酒，杀不尽的仇人头。怎么会就这样放弃？ 善良的莫雷尔先生，他在我蒙冤入狱后四处奔波，导致遭人嫉恨排挤家道中落；我从伊夫堡逃狱出来后，遇到的单纯水手雅各布，丝毫没有怀疑我的身份，把我当做同伴一样赤诚对待；那落草为寇恩怨分明的罗吉万帕，比道貌岸人的衣冠禽兽好上何止千万倍；还有一心一意依赖我关心我的海黛，苦命的公主。 这世界并没有那么荒凉，那么无药可救。 这周初收到了壹个村小的家访反馈，小朋友生活和学习上遇到一些困难，遂写信鼓励，望其可以度过难关。 我不祝福你万事顺利前路平坦，而是祝你有直面一切困难的勇气。 值得一提的是，在大仲马去世132年后，于2002年11月30日，他的灵柩在时任法国总统希拉克的亲自护送下，被移入先贤祠，他是第70位进入先贤祠的伟人，也是其中的第六名作家。他将长眠于左拉和他生前挚友雨果之间。 莫雷尔拆开信念道：—— “我亲爱的马西米兰，——岛边为你们停着一只小帆船。贾可布会带你们到里窝去，那里诺瓦蒂埃先生正在等着他的孙女儿，他希望在他领他的孙女到圣坛前去以前，能先为你们祝福，我的朋友，这个洞里的一切，我在香榭丽舍大道的房子，以及我在黎港的别墅，都是爱德蒙·唐太斯送给莫雷尔船主的儿子的结婚礼物。也请维尔福小姐接受其中的一半，因为，她的父亲现在已成了一个疯子，她的弟弟已在九月间和他的母亲一同去世，我想请她把她从她父亲和她弟弟那儿继承来的那笔财产捐赠给穷人。莫雷尔，告诉那位你将终生眷顾的天使，请她时时为一个人祈祷，那个人，象撒旦一样，一度曾自以为可与上帝匹敌；但现在，他已带着基督徒的自卑承认只有上帝拥有至高无上的权力和无穷的智慧。或许那些祈祷可以减轻他心里所感到的内疚。至于你，莫雷尔，我对你说一句知心话。世界上既无所谓快乐或也无所谓痛苦；只有一种状况与另一种状况的比较，如此而已。只有体验过不幸的人才能体会最大的快乐。莫雷尔，我们必须体验过死的痛苦，才能体会到生的快乐。 所以，我心爱的孩子们，享受生命的快乐吧！永远不要忘记，直至上帝揭露人的未来图景的那一天以前，人类的一切智慧就包含在这两个词里面：‘等待’和‘希望’。 你的朋友基督山伯爵爱德蒙·唐太斯。”","tags":[{"name":"小说","slug":"小说","permalink":"https://lilei.pro/tags/小说/"}]},{"title":"Android-Performance-Patterns-s4ep11-Culling","date":"2017-02-27T02:59:09.000Z","path":"2017/02/27/Android-Performance-Patterns-s4ep11-Culling/","text":"去芜存菁，avoid donig unnecessary work.link 过度绘制过度绘制（Overdraw）是指对不可见的部分也进行绘制的情况，如下图左侧，在开发者设置里可以打开查看开关。一般解决过度绘制的方法是减少布局深度，去除无用背景。 Draw with care在编写自定义控件时，可以使用canvas.cliprect(..)方法来使不显示的View不进行绘制。 链接：https://www.youtube.com/watch?annotation_id=annotation_104709861&amp;feature=iv&amp;index=38&amp;list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE&amp;src_vid=KFklLqiEG6w&amp;v=vkTn3Ule4Ps 多重条件搜索比如要搜索同时满足 A &amp; B &amp; C 三个条件下的结果，有两种方法 把ABC三个条件同时传入，一步搜索出结果 先搜A，得到结果集后，在结果集中搜索B，最后在B的结果集中搜索C 不要想当然地以为一定是1更高效，实际操作时要根据搜索服务的特征来选择两者中的一种进行。2也是一种Culling的思想，逐层深入，抽丝剥茧。 （视频里是用的Mc Collins大叔的照片来举例的，很搞笑） 提升用户体验在使用地理定位等实时服务时，消减那些用户不需关心的信息，比如用户居住在A地，那就无需把B地的实时状况推送给用户，使用地图软件中的实时路况查看就是这样，只需要请求并展示当前屏幕范围内的区域路况，而不是全市乃至全省、全国。 ====Ending====","tags":[{"name":"Android Performance Patterns","slug":"Android-Performance-Patterns","permalink":"https://lilei.pro/tags/Android-Performance-Patterns/"}]},{"title":"Android Performance Patterns - s4ep10 Approximation","date":"2017-02-22T01:27:48.000Z","path":"2017/02/22/Android-Performance-Patterns-s4ep10-Approximation/","text":"在用户无感知的情况下，合理地进行近似计算，以加快响应，增强性能。link Good enough. Let’s ship it.在一些情况下，用户只需要70%的精确程度，这时在程序里提供100%的精确程度是不合适的，这会额外增加30%的成本。 Position is not always helpful以一个路线规划App为例，如果缩放级别仅仅到省，那么对用户定位的标示只需要精确到城市即可，完全不必精确到街道门牌号，因为就算通过GPS精确到了街道门牌号，在省级视图上观察，也并不会有任何区别。只有当用户放大地图到街道程度时，才需要更精确的定位。 Do less, when you can.Use less time, to calculate a less precision result, that still meets the user’s current need. 同样以上方的路线规划App为例，当用户以固定速度在高速巡航时，可以基于用户车速计算，得到用户在公路上的大概位置，也无需时时通过GPS定位。当用户接近POI（Point of Interest）时，才唤起GPS。 图像上的近似计算在需要展示图片的场景，如果无需展示大图，则只加载低分辨率下的图片，这样可以节约内存并且加快加载速度。一个例子就是微信里面察看对话以及朋友圈的图片。 ====Ending====","tags":[{"name":"Android Performance Patterns","slug":"Android-Performance-Patterns","permalink":"https://lilei.pro/tags/Android-Performance-Patterns/"}]},{"title":"Android Performance Patterns - s4ep9 Caching","date":"2017-02-20T02:11:07.000Z","path":"2017/02/20/Android-Performance-Patterns-s4ep9-Caching/","text":"本节内容纯理论，概括成一句话：Cache很重要！link Caches are FAST计算机可以对Cache进行快速的读取，原因在于，读取Cache时是CPU直接操作RAM；如果不借助Cache，CPU需要间接与硬盘通信，而硬盘的读写速度是比不上RAM的。 在有Cache的时候，通常情况下第一次读取是从硬盘加载，后续的读取就全都走Cache了。 When to cache?在循环中重复执行并且结果不变的计算，可以将其抽出来保存在Cache中。不要在循环中进行重复计算，这是编程中必须遵守的一项基本原则。 Caches help manage resources这部分强调的是Cache更新算法，LRU是个很好的选择。 Caching by pre-computing提前执行解析程序，预处理体量大的查找表或者XML文件，这样在运行时可以很快地获取想要的结果，而不是同步等待。 ====Ending====","tags":[{"name":"Android Performance Patterns","slug":"Android-Performance-Patterns","permalink":"https://lilei.pro/tags/Android-Performance-Patterns/"}]},{"title":"关于陆金所App在小米手机上无法展示项目详情页的问题原因与解决办法","date":"2017-02-17T10:12:21.000Z","path":"2017/02/17/Lu-App-Not-Work-On-Mi-Devices/","text":"在使用陆金所Android版本的App时，进入任何理财产品详情页，都显示为空白，无法进行查阅与购买。 情景再现 小米系统是升级后的最新版Webkit内核版本：54.0.2840.85 发现截图中无法显示产品详情的问题后，我联系了陆金所的人工在线客服，在描述问题并提供截图后，客服告知需要1到2个工作日给出反馈。实际上并没有那么久，我是早上反馈的问题，下午临近下班时就收到了客服的回复电话。 客服应该是从开发那里得到了反馈邮件，在这里表扬一下陆金所响应问题的速度。无法显示的原因在于小米系统里使用的WebView内核版本是53或者54，这两个版本存在bug，解决办法也很“简单”，只要把它升级成55就可以了。这里的“简单”为什么打上了引号呢？因为升级WebView需要手机上装有GooglePlay，而由于众所周知的原因，国内的Android手机系统里，安装GooglePlay的少之又少。不过什么也难不住广大的网民朋友对墙外世界的向往，内事不决问百度，自然可以找到安装的途径。 解决途径先安装Google框架，再安装GooglePlay后，在GooglePlay中搜索WebView进行升级安装，再打开陆金所——duang！问题迎刃而解了。 问题起因探究在百度上搜不出任何国内开发者对这个问题的描述！按说但凡是使用了小米手机，只要升级到了最新版本，在打开WebView时都有很大可能遭遇这个问题，为什么内网上搜不到，我也很费解。 而在Google上，很容易就找到下面这篇由Chromium官方发布的文档：WebView FAQ for Symantec Certificate Transparency Issue 我在这里依个人理解简单描述一下，建议各位直接阅读原文，会认识得更加全面。 根本原因从WebView的53版本开始，它要求所有被Symantec（赛门铁克）签署的证书，必须执行Chrome证书政策。但是，Chrome自己在进行验证时，竟然出错了！！！在加载具有Symantec证书的页面时，会导致onReceivedSslError()的回调，页面显示一片空白。 这算不算弄巧成拙？ 影响范围自Android L版本开始，WebView版本53和54会受到影响，55开始恢复正常。需要注意的是，问题并非是立刻显现的，而会在WebView的build date十周之后，才暴露出来。Build版本与过期时间如下表所示，这也就解释了为什么在我刚升级Android系统时并没有发生这个问题，而是在上周使用陆金所App时才显露出来。 Build ID Expiration Date 54.0.2840.68 12/27/2016 54.0.2840.85 1/7/2017 现身说法为了验证上文的情况，我在代码中使用getPackageManager().getPackageInfo(&quot;com.google.android.webview&quot;, 0).versionCode察看小米手机的WebView版本号，果然是54.0.2840.85，不幸中招。 在通过GooglePlay安装最新的55.0.2883.91版本后，再打开陆金所App，一切正常了。 Q &amp; AQ：Android N系统也会遇到这个问题吗？怎么解决？A：自L开始的系统都会遇到，而N系统由于不是使用单独的WebView，而是使用由Chrome提供的WebView，因此只要升级Chrome就可以。（在Chrome的属性里可以看到Webview版本） Q：用户可以通过修改系统时间为未过期的时间，来避免这个问题吗？A：笔者亲测可以，但是不建议这么做，有可能导致更多潜在的问题。 Q：可否通过UserAgent嗅探来解决这个问题？A：验证失败发生在连接TLS层时，这时还没有发送UserAgent信息，意味着页面挂掉时候是还不知道UA的。如果一定要在TLS层获取UA也不是没有办法，但这么做过于复杂，并且不安全。 Q：开发者怎样修复这个问题呢？A：唯一的修复办法是提示用户更新WebView，当发生问题时，WebView会发出一个onReceivedSslError()回调，但是回调里并没有足以说明问题的提示信息。并且通过这个回调来回避问题（比如停止使用证书）会导致更多安全隐患，强烈不建议这么做。 一些思考整个问题的描述与解释看下来，还真不是陆金所团队的锅——好久没见寸志了，如果当面问他这个事，他一定摆着手说：这个锅我不背！要怪就怪Android碎片化太严重，尤其是国内市场，各大厂商把原生系统做做美化，改头换面，再预装一大堆垃圾软件，就摇身一变成了自己的东西。而关键特性又更新不及时，就导致了上文发生的问题。 Android系统的开放特性是一把双刃剑，就看我们怎么使用它。 ====Ending====","tags":[{"name":"Android","slug":"Android","permalink":"https://lilei.pro/tags/Android/"}]},{"title":"解决Android Studio导入项目时速度过慢的问题","date":"2017-02-17T02:41:49.000Z","path":"2017/02/17/Fix-Slow-Inilizating-Project-In-AS/","text":"当我们通过Android Studio导入新项目时，往往需要同步下载新项目所需的gradle版本，这是导致加载过慢的原因。 卡住的原因项目需要特定版本的gradle进行构建，而本地没有对应版本的gradle，需要从网络下载（ http://services.gradle.org/distributions ），由于大家心知肚明的原因，下载速度非常慢；而且，配置的shadowsocks对此似乎不起作用。这就导致了导入项目时一直停留在“Building gradle project info”。 解决办法本以为国内有对应的镜像站点，可以配置，但却没有找到。这里先通过浏览器下载下来gradle-xx.zip，然后替换本地文件来进行。 第一步：在 http://services.gradle.org/distributions 下载需要的版本通过已配置代理的浏览器下载，或者迅雷（要避免再次上演XcodeGhost事件）。下载完成后把zip包丢进本地gradle仓库里。以gradle-2.14.1-all为例，在我的电脑上路径是~/.gradle/wrapper/dists/gradle-2.14.1-all/8bnwg5hd3w55iofp58khbp6yv/。 第二步（可选）：修改项目gradle版本如果下载的gradle版本和项目文件里声明的版本不同，需要修改项目里依赖的gradle版本。有两个文件需要修改，分别是gradle/wrapper/gradle-wrapper.properties和build.gradle gradle/wrapper/gradle-wrapper.properties修改distributionUrl 12345distributionBase=GRADLE_USER_HOMEdistributionPath=wrapper/distszipStoreBase=GRADLE_USER_HOMEzipStorePath=wrapper/distsdistributionUrl=https\\://services.gradle.org/distributions/gradle-2.14.1-all.zip build.gradle修改classpath 12345678910111213buildscript &#123; repositories &#123; maven &#123; url &quot;http://depot.sankuai.com/nexus/content/groups/public/&quot; &#125; &#125; dependencies &#123; classpath &apos;com.android.tools.build:gradle:2.2.0&apos; // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files &#125;&#125; 完成以上步骤后重启AS，就可以顺利地打开项目了。 ===Ending===","tags":[{"name":"Android Studio","slug":"Android-Studio","permalink":"https://lilei.pro/tags/Android-Studio/"}]},{"title":"Android基础知识之View绘制再思考","date":"2017-02-15T07:09:22.000Z","path":"2017/02/15/View-Drawing-In-Android/","text":"近日自己在写一个结合了下拉刷新&amp;ViewPager功能于一体的自定义控件，顺便重温了View绘制的流程。 本文【待完成】可能是你所看过最简单易懂的View绘制流程解读。 几个重要方法学以致用：实现一个简单的PullToRefresh容器","tags":[{"name":"Android","slug":"Android","permalink":"https://lilei.pro/tags/Android/"}]},{"title":"Android基础知识之事件传递","date":"2017-02-15T07:03:55.000Z","path":"2017/02/15/Android-Touch-Event-Delivery/","text":"在Android系统中，事件的传递和处理是让人很容易困惑的一个知识点，在处理复杂界面事件时，如果对这方面掌握不扎实，会遇到很多千奇百怪的问题。 本文可能是你读过的对事件传递系统最简单易懂的解读。 Android事件系统概述任何UI界面系统的设计，都一定离不来事件传递，Android系统当然不例外。 要理解Android中的事件机制，需要牢记下面两个基本原则： 事件传递，从外向内。 事件消费，从内向外。 事件传递先触发外层ViewGroup的dispatchTouchEvent方法，该方法会在事件的整个处理流程结束后异步返回；接着触发外层ViewGroup的onInterceptTouchEvent方法，如果要拦截这个事件，不让它继续向下传递，就在这个方法里就要返回true；当事件继续向下传递时，内层View先触发dispatchTouchEvent，接着进行到事件消费环节。 事件消费如果外层ViewGroup在onInterceptTouchEvent方法里返回true，那么事件仅由外层进行消费，即进入onTouchEvent方法里，消费完成后，进行dispatchTouchEvent结果回调，事件消费掉了则返回true，反之返回false。 如果外层ViewGroup在onInterceptTouchEvent方法里返回false，事件继续向下传递，内层View在它的onTouchEvent里返回处理结果，再把结果交给内层View的dispatchTouchEvent方法返回。如果内层消费了事件（返回true），则外层不会触发onTouchEvent方法；如果内层没有消费事件（返回false），那么事件交由外层消费，会触发外层ViewGroup的onTouchEvent方法。 上例的补充说明上例的case B，还有一种写法，是外层ViewGroup不对事件进行拦截，而是在内层View的onTouchEvent中返回false，这样事件依旧会交由外层ViewGroup的onTouchEvent进行消费。 同理，case D也有另外的写法，聪明的读者，你一定已经猜出来了。 几个关键方法上文中已经看出，Android系统中对事件进行处理，主要是dispatchTouchEvent、onInterceptTouchEvent、onTouchEvent这三个方法，下面逐一进行分析。 dispatchTouchEventView处理事件时，最先进入的方法，直到事件处理完成后，才会返回true（在当前View或者内部View进行了消费）或者false（未进行消费）。 对于View，这个方法的返回值与onTouchEvent返回值相同。 对于ViewGroup，只要内部有任意一个View消费了事件，在ViewGroup的这个方法就会返回true。 onInterceptTouchEvent这个方法只存在于ViewGroup中，控制是否将当前时间拦截下来不向下传递，只给自己消费。 需要注意一旦ACTION_DOWN被拦截，后续的ACTION_MOVE和ACTION_UP根本不会走到这个方法里。 onTouchEvent处理touch事件的地方，如果要处理的是click事件，不要写在onTouchEvent方法里，而是应该写在performClick中。 消费了事件则返回true，消费后的事件立即废弃，不会再交由其它View消费。 requestDisallowInterceptTouchEvent上文讲到，外层的ViewParent可以通过onInterceptTouchEvent来拦截事件，不继续向下传递。上有政策下有对策，内层View同样可以拒绝外层ViewGroup的这种行为，这就是requestDisallowInterceptTouchEvent(boolean)方法所做的事。 这个方法位于ViewParent.java中，可以通过View.getParent()来获取某个View的Parent。该方法会应用到当前View的所有祖先ViewGroup，而不仅仅是父亲。所有接收到这个请求的Parent必须停止它们的Intercept行为，直到当前touch事件结束（收到up信号或者cancel信号）。 学以致用：解决在ScrollView中嵌套ListView的问题有了这些的知识储备，我们来实操一下，解决一个很容易出现的case：在ScrollView中嵌套ListView时，ListView无法进行上下滑动，导致项目展示不完整。 首先，在ScrollView中嵌套ListView并不是好的设计，如果能够避免最好，若不能避免，就必须解决ListView不能滑动的问题。我们希望当手指落在ListView上进行滑动时，会控制ListView的条目，当滑至顶端或底端时，ListView无法再滑，则进行外层ScrollView的滑动。当手指落在ListView外部的ScrollView时，直接控制ScrollView进行滑动。 出现问题的原因原因在于ScrollView在它的onInterceptTouchEvent里对ACTION_MOVE进行了拦截，Code donesn’t lie. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120@Overridepublic boolean onInterceptTouchEvent(MotionEvent ev) &#123; /* * This method JUST determines whether we want to intercept the motion. * If we return true, onMotionEvent will be called and we do the actual * scrolling there. */ /* * Shortcut the most recurring case: the user is in the dragging * state and he is moving his finger. We want to intercept this * motion. */ final int action = ev.getAction(); if ((action == MotionEvent.ACTION_MOVE) &amp;&amp; (mIsBeingDragged)) &#123; return true; &#125; /* * Don't try to intercept touch if we can't scroll anyway. */ if (getScrollY() == 0 &amp;&amp; !canScrollVertically(1)) &#123; return false; &#125; switch (action &amp; MotionEvent.ACTION_MASK) &#123; case MotionEvent.ACTION_MOVE: &#123; /* * mIsBeingDragged == false, otherwise the shortcut would have caught it. Check * whether the user has moved far enough from his original down touch. */ /* * Locally do absolute value. mLastMotionY is set to the y value * of the down event. */ final int activePointerId = mActivePointerId; if (activePointerId == INVALID_POINTER) &#123; // If we don't have a valid id, the touch down wasn't on content. break; &#125; final int pointerIndex = ev.findPointerIndex(activePointerId); if (pointerIndex == -1) &#123; Log.e(TAG, \"Invalid pointerId=\" + activePointerId + \" in onInterceptTouchEvent\"); break; &#125; final int y = (int) ev.getY(pointerIndex); final int yDiff = Math.abs(y - mLastMotionY); if (yDiff &gt; mTouchSlop &amp;&amp; (getNestedScrollAxes() &amp; SCROLL_AXIS_VERTICAL) == 0) &#123; mIsBeingDragged = true; mLastMotionY = y; initVelocityTrackerIfNotExists(); mVelocityTracker.addMovement(ev); mNestedYOffset = 0; if (mScrollStrictSpan == null) &#123; mScrollStrictSpan = StrictMode.enterCriticalSpan(\"ScrollView-scroll\"); &#125; final ViewParent parent = getParent(); if (parent != null) &#123; parent.requestDisallowInterceptTouchEvent(true); &#125; &#125; break; &#125; case MotionEvent.ACTION_DOWN: &#123; final int y = (int) ev.getY(); if (!inChild((int) ev.getX(), (int) y)) &#123; mIsBeingDragged = false; recycleVelocityTracker(); break; &#125; /* * Remember location of down touch. * ACTION_DOWN always refers to pointer index 0. */ mLastMotionY = y; mActivePointerId = ev.getPointerId(0); initOrResetVelocityTracker(); mVelocityTracker.addMovement(ev); /* * If being flinged and user touches the screen, initiate drag; * otherwise don't. mScroller.isFinished should be false when * being flinged. */ mIsBeingDragged = !mScroller.isFinished(); if (mIsBeingDragged &amp;&amp; mScrollStrictSpan == null) &#123; mScrollStrictSpan = StrictMode.enterCriticalSpan(\"ScrollView-scroll\"); &#125; startNestedScroll(SCROLL_AXIS_VERTICAL); break; &#125; case MotionEvent.ACTION_CANCEL: case MotionEvent.ACTION_UP: /* Release the drag */ mIsBeingDragged = false; mActivePointerId = INVALID_POINTER; recycleVelocityTracker(); if (mScroller.springBack(mScrollX, mScrollY, 0, 0, 0, getScrollRange())) &#123; postInvalidateOnAnimation(); &#125; stopNestedScroll(); break; case MotionEvent.ACTION_POINTER_UP: onSecondaryPointerUp(ev); break; &#125; /* * The only time we want to intercept motion events is if we are in the * drag mode. */ return mIsBeingDragged;&#125; 可以看到当(action == MotionEvent.ACTION_MOVE) &amp;&amp; (mIsBeingDragged)条件为真时，这个方法直接返回true，拦截掉了ACTION_MOVE事件。解决办法也很简单，在内层View接收到ACTION_DOWN时，禁止掉外层的拦截；在内层View收到手指抬起来的ACTION_UP时，放掉禁制。我们在dispatchTouchEvent中写入这段逻辑，也可以把它写进内层View的onTouchListener中。 恢复ListView滑动dispatchTouchEvent中的写法 123456789@Overridepublic boolean dispatchTouchEvent(MotionEvent ev) &#123; switch (ev.getAction()) &#123; case MotionEvent.ACTION_DOWN: getParent().requestDisallowInterceptTouchEvent(true); break; // ...... &#125;&#125; onTouchListener中的写法 1234567891011listView.setOnTouchListener(new View.OnTouchLister &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; if(event.getAction() == MotionEvent.ACTION_UP)&#123; scrollView.requestDisallowInterceptTouchEvent(false); &#125;else&#123; scrollView.requestDisallowInterceptTouchEvent(true); &#125; return false; &#125;&#125;); 这个时候ListView已经可以上下滑动了，但是当滑动到上／下尽头时，我们希望外层的ScrollView继续接管滑动。 外层ScrollView接管滑动首先需要写两个方法判断ListView已经到了穷途末路。 12345678910111213141516171819202122public boolean scrollToBottom() &#123; int first = getFirstVisiblePosition(); int last = getLastVisiblePosition(); int visibleCoutn = getChildCount(); int count = getCount(); if ((first + visibleCoutn) == count) &#123; return true; &#125; return false;&#125;public boolean scrollToTop() &#123; int first = getFirstVisiblePosition(); int last = getLastVisiblePosition(); int visibleCoutn = getChildCount(); int count = getCount(); if (first == 0) &#123; return true; &#125; return false;&#125; 然后在dispatchTouchEvent方法里判断，到了尽头后，把ACTION_MOVE事件交给外层ScrollView处理。这里包含了前文中“禁止外层ViewGroup拦截”的逻辑。 12345678910111213141516171819202122232425262728293031323334353637383940414243float downY, y, mTouchSlop;@Overridepublic boolean dispatchTouchEvent(MotionEvent ev) &#123; switch (ev.getAction()) &#123; case MotionEvent.ACTION_DOWN: downY = ev.getRawY(); y = downY; getParent().requestDisallowInterceptTouchEvent(true); break; case MotionEvent.ACTION_MOVE: y = ev.getRawY(); if (scrollToTop()) &#123; if (y - downY &gt; mTouchSlop) &#123; /** * Point 1 : 如果滑动到顶部，并且手指还想向下滑动，则事件交还给父控件，要求父控件可以拦截事件 */ getParent().requestDisallowInterceptTouchEvent(false); return false; &#125; &#125; if (scrollToBottom()) &#123; if (y - downY &lt; -mTouchSlop) &#123; /** * Point 3 : 如果滑动到底部，并且手指还想向上滑动，则事件交还给父控件，要求父控件可以拦截事件 */ getParent().requestDisallowInterceptTouchEvent(false); return false; &#125; &#125; break; case MotionEvent.ACTION_UP: break; default: break; &#125; return super.dispatchTouchEvent(ev);&#125; 上述写法基本实现了拉到ListView尽头时，将滑动时间交给外部ScrollView处理的功能。还存在的问题是在边界判断时不够精确，会发生第一个／最后一个item只展示一个边界，就触发解除禁止的效果，待完善。 希望这篇文章让你不再为Android中的事件传递机制而困惑。 参考资料 ScrollView嵌套ListView处理事件冲突 ====Ending====","tags":[{"name":"Android","slug":"Android","permalink":"https://lilei.pro/tags/Android/"}]},{"title":"Android Performance Patterns - s4ep8 Removing Unused Resources","date":"2017-02-14T01:40:48.000Z","path":"2017/02/14/Android-Performance-Patterns-s4ep8-Removing-Unused-Resources/","text":"Although YOU may be diligent in removing resources your app won’t use, it’s not safe to assume that the LIBRARIES you’re including will do the same.Thankfully some helpful Gradle tools can put your APK on a diet.link 问题起因无用的Resources存在于两部分，第一部分是项目文件中，开发者可以检查并直接移除这些文件；第二部分存在于依赖的library中。在一些情况下，我们只需要使用库里面的某一些功能，而并非全部功能。如果不加以特殊处理，其它未经使用资源文件也会被打入最终的APK中。 GradleGradle可以分析资源文件的使用情况，从而删除那些不需引入的资源文件。 如果要开启这项功能，需要在gradle配置文件中将minifyEnabled和shrinkResources声明为true。 123456789android &#123; buildTypes &#123; release &#123; minifyEnabled trure shrinkResources true proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; &#125; &#125;&#125; 我们也可以强制保留／删除某些文件 1234&lt;resources xmlns:tools:=&quot;http://schemas.android.com/tools&quot; tools:keep=&quot;@layout/l_used*_c, @layout/l_used_b*&quot; tools:discard=&quot;@layout/unused2&quot; /&gt; Gradle并非是万能的，它不会处理多分辨率／多语言下的资源文件（笔者对这部分存疑，这些资源文件原本就不需要精简，除非APP指定了仅供某些特定用户人群使用） ====Ending====","tags":[{"name":"Android Performance Patterns","slug":"Android-Performance-Patterns","permalink":"https://lilei.pro/tags/Android-Performance-Patterns/"}]},{"title":"Android Performance Patterns s6ep6 - VectorDrawable For Smaller APKs","date":"2017-02-13T01:13:49.000Z","path":"2017/02/13/Android-Performance-Patterns-s6ep6-VectorDrawable/","text":"由于Android系统存在多种分辨率，我们在使用图片时，往往需要准备ldpi、mdpi、hdpi、xhdpi等多种分辨率的图片，占用大量APK体积。针对这种情况，本文介绍了如何VectorDrawable技术的优点，以及使用场景。link 不合适的做法JPEG和PNG是光栅化的图片格式，如果我们不希望在不同分辨率下出现图片模糊的情况，就必须准备多张图片，这会浪费APK体积。 VectorDrawableVectorDrawable则可以只用一个文件满足多种屏幕分辨率。它将图片分解为多个基本图形的组合，如下所示。 对于文章开头的三个圆形的场景，可以将占用空间从56K降低到2K，降低了96%。 使用VectorDrawable还可以避免因使用帧动画，导致图片文件过多的情况 Caveats加载加载时，JPEG、PNG文件可以依靠硬件进行纹理渲染，而VectorDrawable在处理时，需要先翻译成GPU指令，VD中的每一个基本图形，都会被作为一个图层处理。 复杂图像VectorDrawable不适用于处理复杂图像，对于下图的肖像，使用PNG是更好的选择。 简化VectorDrawable的路径，以便更加高效地绘制。 ====Ending====","tags":[{"name":"Android Performance Patterns","slug":"Android-Performance-Patterns","permalink":"https://lilei.pro/tags/Android-Performance-Patterns/"}]},{"title":"Android Performance Patterns s6ep5 Smaller APKs A checklist","date":"2017-02-10T03:49:46.000Z","path":"2017/02/10/Android-Performance-Patterns-s6ep5-Smaller-APKs/","text":"如何减少APK体积link 头脑风暴：怎样减少APK体积呢？ 避免使用分辨率过大的图片 使用矢量图 代码、布局文件复用 精简多媒体文件 懒加载，某些业务功能，直到真正应用时方从网络进行下载 ProGuard Two key areas Smaller resources (easiest to fix) Smaller code Smaller resources移除无用资源文件在gradle文件里配置minifyEnabled true和shrinkResources true，在打包时会忽略实际上没有应用到的资源文件。建议在release时才打开，以减少debug环境编译时间。 12345678910android &#123; ... buildTypes &#123; release &#123; minifyEnabled true shirnkResources true proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; &#125; &#125;&#125; 使用自动分辨率适配功能我们知道Android中有ldpi mdpi hdpi xhdpi xxhdpi 乃至 xxxhdpi 和 tvdpi 等分辨率，如果把每个资源文件，针对这些分辨率都分别制作一个副本，这将占用大量的空间。 针对这个问题，有多个解决途径。 删除一部分分辨率下的文件框架会根据高分辨率的资源文件自动生成低分辨率下的资源文件。这里删除了ldpi（可以从mdpi生成）、hdpi和xhdpi（可以从xxhdpi生成），另外tvdpi只应用于TVapp，这里一并删除。 ![][rescale.png] 使用矢量图代替像素图矢量图会根据设备分辨率不同，自动调整自身大小，一个矢量图可以应用在多种分辨率下 复用已有的图片资源文件对于下图这种只是变更了方向的场景，应当只使用一张图片，通过代码来控制箭头朝向。 12345&lt;rotate xmlns:android=\"http://schemas.android.com/apk/res/android\" android:drawable=\"@drawable/ic_arrow_expand\" android:fromDegrees=\"0\" android:toDegrees=\"270\" /&gt; Smaller Code使用ProGuard设置minifyEnabled true，代码见前文。 优化代码生成器的生成代码代码生成器是将原始代码转化为目标代码的一种工具，在转化的过程中，有可能生成冗余的目标代码，这部分代码需要精简。 注意依赖！当我们的代码需要引入外部库的时候，庞大的外部依赖会导致APK体积剧增。ProGuard能够为我们处理一部分这种情况，更多时候，我们需要有目的地挑选适合移动端使用的工具库。在引入外部依赖的时候，一定要关注它对APK体积产生的影响。 Segment your APK视频作者对这部分的内容讲述不甚清晰，我理解下来，所做的事情是，可以根据API级别、分辨率高低等条件，生成不同的APK包，在应用市场里发布时进行配置。而应用市场会根据用户手机型号，为用户推送不同的APK进行个性化安装。 Android Studio 2.2新版本的AS中，增加了APK分析工具，可以很方便地察看classes、methods的数目，资源文件大小 等信息。 ====Ending====","tags":[{"name":"Android Performance Patterns","slug":"Android-Performance-Patterns","permalink":"https://lilei.pro/tags/Android-Performance-Patterns/"}]},{"title":"禁止Android File Transfer自启动","date":"2017-01-24T12:07:55.000Z","path":"2017/01/24/Stop-Android-File-Transfer-From-Auto-Starting/","text":"Android File Transfer是macOS系统下用于在手机-电脑间传输文件的工具，然而，这个工具默认是每一次将手机连接至电脑，都会自动启动，非常恼人。本文介绍了如何将自启动关闭的方法。 ProblemAndroid File Transfer Auto Launches Solution Close Android File Transfer Open Activity Monitor and kill “Android File Transfer Agent” Go to where you installed “Android File Transfer.app” (I have it under /Applications) Right click and –&gt; “Show package contents” Go to Contents/Resources Rename “Android File Transfer Agent” to e.g. “Android File Transfer Agent_DISABLED” Then go to “/Users/username/Library/Application Support/Google/Android File Transfer” and again rename the Agent app.. “Android File Transfer Agent_DISABLED”. Referencehttps://mtmurdockblog.com/2012/12/17/disable-auto-start-for-android-file-transfer-on-osx/ ====End====","tags":[{"name":"工具","slug":"工具","permalink":"https://lilei.pro/tags/工具/"}]},{"title":"Android Performance Patterns s6ep4 Themed launch screens","date":"2017-01-23T01:40:31.000Z","path":"2017/01/23/Android-Performance-Patterns-s6ep4-Themed-launch-screens/","text":"This video identifies some pitfalls with bad ways to implement launch screens, and provides a solution that everyone can use.link Bad WaysTheme the launch screen声明首页的Theme与App其它页面的Theme相同，视频作者对于这部分内容讲述不清，目前存疑。 Turn off the official startup window使用Window Disable Preview来禁止显示Preview界面，这会导致启动App后依然停留在桌面，在此过程中无法响应用户操作。方法如下： 在styles.xml中声明Theme 123&lt;style name=\"Theme.NoPreviewWindow\" parent=\"Theme.AppCompat.NoActionBar\"&gt; &lt;item name=\"android:windowIsTranslucent\"&gt;true&lt;/item&gt;&lt;/style&gt; 或者 123&lt;style name=\"Theme.NoPreviewWindow\" parent=\"Theme.AppCompat.NoActionBar\"&gt; &lt;item name=\"android:windowDisablePreview\"&gt;true&lt;/item&gt;&lt;/style&gt; 然后在AndroidManifest.xml中使用已经定义的Theme 1234567891011&lt;activity android:name=\".activities.SplashActivity\" android:label=\"@string/app_name\" android:theme=\"@style/Theme.NoPreviewWindow\" android:screenOrientation=\"portrait\" &gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\"/&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\"/&gt; &lt;/intent-filter&gt;&lt;/activity&gt; The better way通过切换Theme的手段来完成首先声明一个以图片为背景的Theme，并且在首页Activity中应用 12345678910&lt;layer-list xmlns:android=\"http://schemas.android.com/apk/res/android\" android:opacity=\"opaque\"&gt; &lt;item android:drawable=\"@android:color/white\"/&gt; &lt;item&gt; &lt;bitmap android:src=\"@drawable/product_log_144dp\" android:gravity=\"center\"/&gt; &lt;/item&gt;&lt;/layer-list&gt;&lt;activity ...android:theme=\"@style/AppTheme.Launcher\"/&gt; 当首页Activity正式启动时，切换到正式的theme 123456@Overrideprotected void onCreate(Bundel savedInstanceState) &#123; setTheme(R.style.Theme_MyApp); super.onCreate(savedInstanceState); // ...&#125; 参考资料 Disabling the Preview(Start) Window in Android Splash Screens the Right Way====Ending====","tags":[{"name":"Android Performance Patterns","slug":"Android-Performance-Patterns","permalink":"https://lilei.pro/tags/Android-Performance-Patterns/"}]},{"title":"如何在控制台输出文件系统结构","date":"2017-01-22T12:47:29.000Z","path":"2017/01/22/Print-File-System-Tree-In-Terminal/","text":"安装并使用tree工具 目录结构12345678910111213141516171819202122232425262728293031323334353637383940main/java/com/example/android/architecture/blueprints/todoapp├── BasePresenter.java├── BaseView.java├── addedittask│ ├── AddEditTaskActivity.java│ ├── AddEditTaskContract.java│ ├── AddEditTaskFragment.java│ └── AddEditTaskPresenter.java├── data│ ├── Task.java│ └── source│ ├── TasksDataSource.java│ ├── TasksRepository.java│ ├── local│ │ ├── TasksDbHelper.java│ │ ├── TasksLocalDataSource.java│ │ └── TasksPersistenceContract.java│ └── remote│ └── TasksRemoteDataSource.java├── statistics│ ├── StatisticsActivity.java│ ├── StatisticsContract.java│ ├── StatisticsFragment.java│ └── StatisticsPresenter.java├── taskdetail│ ├── TaskDetailActivity.java│ ├── TaskDetailContract.java│ ├── TaskDetailFragment.java│ └── TaskDetailPresenter.java├── tasks│ ├── ScrollChildSwipeRefreshLayout.java│ ├── TasksActivity.java│ ├── TasksContract.java│ ├── TasksFilterType.java│ ├── TasksFragment.java│ └── TasksPresenter.java└── util ├── ActivityUtils.java ├── EspressoIdlingResource.java └── SimpleCountingIdlingResource.java 很多时候我们写文章，需要贴出项目的目录结构。我之前采用的方法比较笨，是在IDE中截图。相信很多人在看资料时，遇到过上面这样，在控制台输出的文件目录结构。直观而且赏心悦目，那么这是用什么工具生成的呢？ 答案是：Tree Tree的安装与使用如果你用的是Ubuntu或其他的*nux系统，直接运行sudo apt-get install tree安装即可，但是在macOS中，并没有apt-get工具，需要先安装Homebrew，然后通过brew安装tree。 注意在安装的过程中需要输入管理员密码。 12$/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"$brew install tree 待安装完成后（大概需要10～20分钟），就可以使用tree ${folder_name}在控制台中打印出目录结构了。 ===End===","tags":[{"name":"工具","slug":"工具","permalink":"https://lilei.pro/tags/工具/"}]},{"title":"Android Performance Patterns s6ep3 App Launch time & Bloated Application objects","date":"2017-01-22T01:28:39.000Z","path":"2017/01/22/Android-Performance-Patterns-s6ep3-App-Launch-Time/","text":"This videos are really interesting but it seems to me that the last 3 episodes have been basically the same. ————摘自youtube评论link Slow start-up apps cause unhappy users.是的，我同意！ 但是你能不能多讲一些干货？ Android has tools to help.Method Trace前面两节已经讲过这个，图片我就不贴了。 Solution: lazy loading ====Ending====","tags":[{"name":"Android Performance Patterns","slug":"Android-Performance-Patterns","permalink":"https://lilei.pro/tags/Android-Performance-Patterns/"}]},{"title":"Android Performance Patterns s5ep3 App Launch time & Activity creation","date":"2017-01-17T01:45:40.000Z","path":"2017/01/17/Android-Performance-Patterns-s6ep2-App-Launch-Time-And-Activity-Creation/","text":"ep1介绍了Application启动过慢的原因，本节分析Activity启动过慢的原因，启动速度标准以及工具。link 启动MainActivity过慢原因可能有多个，如下图。 加载布局 加载 Bitmap（引起GC） 网络请求 读写 User Preference 分析问题Method tracing toolMethod Tracer 工具被用来查看每个方法的执行时间。 如果onCreate的执行超过了16ms～30ms，那么它很可能是有问题的。 Inserting Trace Commands使用trace来记录开始／截止时间，所记录的时间会显示在Systrace中。 12345trace.beginSection();// code to be valuedtrace.endSection(); 造成Activity启动过慢的原因Complex Layouts首当其冲的是复杂布局导致加载过慢，布局越复杂，越多的资源文件（图片、主题）需要加载。 解决方法有降低复杂度、使结构扁平化、对于不可见的元素暂时不加载。 懒加载&amp;异步处理 当初始化过程中涉及多个耗时操作，最糟糕的情况是把它们串行起来进行，这会导致每一项操作的延迟被叠加起来，让用户抓狂。 这时应当判断哪些操作是一定要串行进行，哪些是可以异步加载的，从而进行优化。 ====End====","tags":[{"name":"Android Performance Patterns","slug":"Android-Performance-Patterns","permalink":"https://lilei.pro/tags/Android-Performance-Patterns/"}]},{"title":"使用Charles监控Genymotion模拟器发送的请求","date":"2017-01-16T09:25:07.000Z","path":"2017/01/16/Using-Charles-Proxy-with-Genymotion/","text":"Charles在模拟器中的配置，与在真机上的配置有所不同。 背景Charles是很好用的代理工具，可以用来查看网络请求的Request和Response，Genymotion则号称速度最快的Android模拟器。然而，在把这两者结合使用时，会发现并没有用真机做代理那么方便。原因在于模拟器所接入的网络是VirtualBox所建立的模拟网络，跟笔记本电脑所看到的局域网IP不在同一个网络环境。 解决方案在模拟器的WLAN配置中，将代理host改为10.0.3.2，端口改为Charles配置的端口（默认的是8888，我使用的是8642）。 Done！ 参考资料Using Genymotion With Charles Proxy ====End====","tags":[{"name":"工具","slug":"工具","permalink":"https://lilei.pro/tags/工具/"}]},{"title":"Android应用签名实践","date":"2017-01-16T06:15:48.000Z","path":"2017/01/16/Android-Sign/","text":"参考资料 Android给apk签名那点事","tags":[{"name":"Android","slug":"Android","permalink":"https://lilei.pro/tags/Android/"}]},{"title":"Android-Performance-Patterns-s6ep1-Launch-Time-Performance","date":"2017-01-16T02:15:04.000Z","path":"2017/01/16/Android-Performance-Patterns-s6ep1-Launch-Time-Performance/","text":"Season 6 ep 1，第六季集中讨论App启动速度的话题。 link 理解启动时间（Launching Time）当用户启动应用时，Android系统会展示一个空白（dummy）启动页，后面会讲到，可以通过在AndroidManifest.xml中为这个启动页配置背景图片。 空白页持续到App绘制出首屏图像为止。 下面的流程图从进程角度进行说明，系统进程System Process会为App启动一个Application Process，在这进程里先执行Application.onCreate（在musical.ly的face to face中提到了这个），随后，应用主线程MainThread处理Activity初始化事务，直至绘制出第一个界面，系统才将屏幕交给应用来展示。 在这个过程中，inflate views是耗时最多的，因此在开发自己的应用时，应当有意地精简首屏布局，减少加载时间。如果有耗时操作，则使用懒加载。 若你使用懒加载，当所有资源加载完成后，可以通过reportFullyDrawn()方法来告诉系统这一事件。系统在统计初始加载时间的时候，会以调用这个方法的时机作为结束。 帮助我们优化启动时间的工具Android Studio为我们提供了监控启动时间的工具，借助这些工具，我们可以找出启动过程中最耗时的步骤是哪个，通过懒加载等手段，将启动时间控制在合理的范围内。 首先便是App启动时候自动打出的log 精确到方法，在Monitor面板中有MethodTracing工具 更多关于启动时间的知识，将在后续章节中介绍。 参考资料 Launch-Time Performance ====END====","tags":[{"name":"Android Performance Patterns","slug":"Android-Performance-Patterns","permalink":"https://lilei.pro/tags/Android-Performance-Patterns/"}]},{"title":"Linux Shell ${} 用法","date":"2017-01-13T02:02:04.000Z","path":"2017/01/13/Linux-Shell-Usage/","text":"在Linux Shell中，${}可以被用来处理文件路径字符串。 语法${[input][rule]}，其中input是需要处理的字符串，rule是处理规则，详细规则如下。 #去掉左边字符。 $去掉右边字符。 上面两点很好记忆，键盘上#在左，$在右。 单个符号最小匹配，两个符号最大匹配。 举例定义file=/dir1/dir2/dir3/my.file.txt 删除 ${file#*/}：拿掉第一条 / 及其左边的字符串：dir1/dir2/dir3/my.file.txt ${file##*/}：拿掉最后一条 / 及其左边的字符串：my.file.txt ${file#*.}：拿掉第一个 . 及其左边的字符串：file.txt ${file##*.}：拿掉最后一个 . 及其左边的字符串：txt ${file%/*}：拿掉最后条 / 及其右边的字符串：/dir1/dir2/dir3 ${file%%/*}：拿掉第一条 / 及其右边的字符串：(空值) ${file%.*}：拿掉最后一个 . 及其右边的字符串：/dir1/dir2/dir3/my.file ${file%%.*}：拿掉第一个 . 及其右边的字符串：/dir1/dir2/dir3/my 提取 ${file:0:5}：提取最左边的 5 个字节：/dir1 ${file:5:5}：提取第 5 个字节右边的连续 5 个字节：/dir2 替换 ${file/dir/path}：将第一个 dir 提换为 path：/path1/dir2/dir3/my.file.txt ${file//dir/path}：将全部 dir 提换为 path：/path1/path2/path3/my ====END====","tags":[{"name":"Linux","slug":"Linux","permalink":"https://lilei.pro/tags/Linux/"},{"name":"Shell","slug":"Shell","permalink":"https://lilei.pro/tags/Shell/"}]},{"title":"Those Questions","date":"2017-01-11T09:50:41.000Z","path":"2017/01/11/Those-Questions/","text":"在计算机科学的沙滩上，我始终是一个蹦蹦跳跳捡拾贝壳的孩子，而那真理的大海就在身边，我却未能发现它。 Project? Module?AppCompatActivity?AndroidManifest.xml中的tools:context","tags":[{"name":"Android","slug":"Android","permalink":"https://lilei.pro/tags/Android/"}]},{"title":"尝鲜开发微信小程序有感","date":"2017-01-09T10:22:24.000Z","path":"2017/01/09/WeChat-App-Dev/","text":"首次开发小程序，完成了一个简单的功能（半成品），有所思，有所感 始末2017年1月9日，微信小程序上线，朋友圈里铺天盖地的各种截图，足见其火爆。诸多移动应用大厂纷纷上线各自的小程序版本，笔者所在的D公司也悄悄发布了小程序，看来是在保密情况下开发的，在之前一段时间里自己竟从未听闻。 纸上得来终觉浅，绝知此事要躬行。今天笔者就尝试开发了一个小程序，功能非常简单，见下文。 程序页面与功能整个小程序包含两个页面，登陆页与功能页。登陆页显示一张欢迎图片和一个输入框，当用户输入正确的文字后，跳转至功能页。功能页提供一个简单的ASCII字符转换功能。 实操依照官方Demo，新建两个页面目录，布局写入wxml，逻辑写入js。 代码过于简单，而且涉及个人隐私，略去不提。着重谈思考与感想。 思考与感想架构整体看来，小程序的结构还是很清晰的。 按页面组织，每个页面是一个文件夹 文件夹下，wxml（布局），json（配置），wxss（样式），js（逻辑），自带数据绑定，接近设计模式中的MVVM模式 官方集成登陆、定位、地图、支付、分享、网络请求等基础服务，减少二次开发成本 另一方面，这也限制了开发者对于底层工具的选择，只能寄希望于微信提供的API足够强大与高效，因为你压根也没有别的办法去修改底层服务 开发者工具目前看来，微信官方提供的开发者工具只是个半成品，由于缺少一些常用功能，使用起来反而会碍手碍脚，拖慢开发速度。建议开发者使用自己习惯的工具进行开发，只使用官方开发工具中的预览&amp;发布功能。 官方开发者工具的一些槽点 快捷键匮乏：打开文件，关闭文件，自动格式化…… 无法批量操作文件 无法批量重命名变量 无法全局搜索 不支持Less Wxml标签中不支持键盘展开/收起节点 wxml、wxss在sublime等编辑器中无语法高亮 偶尔出现调试面板中只显示Console Sources Network三个标签的bug，重新下载后解决 发布这是笔者最不喜欢的一点，必须以公司/企业/媒体/政府机关的身份进行认证后，才能发布到线上，完全堵死了个人开发者发布的道路。 一些思考张小龙的野心很大，当微信占据了8亿手机入口后，这野心开始显露出来————微信不会满足于只做一个通讯软件，它正试图成为一个入口，一个触达使用者生活方方面面的入口。一旦这个生态系统被证明是行之有效的，未来人们手机上可能只会安装一个微信。 对于开发者，尤其是Android/iOS开发者，这并不是一个好消息，他们可能需要改行写js/css了。 支付宝地位受到威胁，阿里恐成最大输家。 以上的一切，都建立在小程序真正跑得够快、够好的基础上，目前看来这是远远不够的，比起原生系统，小程序的体验要下降许多，尤其是Tap/Scroll事件，卡顿非常明显。 附1: ASCII对照表 附2: JavaScript中获取字符的ASCII值，以及将ACSII转换为字符123var x = 'c';var ascii = c.charCodeAt(); // 99var y = String.fromCharCode(ascii); // 'c' ======Ending======","tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"https://lilei.pro/tags/微信小程序/"}]},{"title":"Android SDK下载极速代理地址","date":"2017-01-09T00:55:17.000Z","path":"2017/01/09/Android-SDK-Manager-Proxy-Server/","text":"HTTP Proxy Server: android-mirror.bugly.qq.comHTTP Proxy Port: 8080 在Android SDK Manager中如上配置即可，为鹅厂点赞👍 记得勾选下面的Force https://... sources to be fetched using http://... ======Ending======","tags":[{"name":"Android","slug":"Android","permalink":"https://lilei.pro/tags/Android/"},{"name":"Android Studio","slug":"Android-Studio","permalink":"https://lilei.pro/tags/Android-Studio/"}]},{"title":"Android WebView 从0到1（二）","date":"2016-11-10T00:31:11.000Z","path":"2016/11/10/Android-WebView-0-to-1-part-2/","text":"WebView中clearCache的执行过程源码分析。 前情提要上一篇文章中我们对Android WebView的loadUrl方法进行了分析，这次我们来看看clearCache究竟做了什么事，进而搞清楚WebView中的缓存机制。 WebView.clearCacheclearCache的源码很简单，唯一的参数includeDiskFiles也很容易理解。如前篇所述，WebView的大部分操作，都是代理给WebViewProvider来进行，clearCache也不例外。不过可以发现，这里有个checkThread()的操作，这是来进行什么的呢？让我们在源码中一探究竟。 12345678910/** * Clears the resource cache. Note that the cache is per-application, so * this will clear the cache for all WebViews used. * * @param includeDiskFiles if false, only the RAM cache is cleared */public void clearCache(boolean includeDiskFiles) &#123; checkThread(); mProvider.clearCache(includeDiskFiles);&#125; 123456789101112131415161718private void checkThread() &#123; // Ignore mWebViewThread == null because this can be called during in the super class // constructor, before this class's own constructor has even started. if (mWebViewThread != null &amp;&amp; Looper.myLooper() != mWebViewThread) &#123; Throwable throwable = new Throwable( \"A WebView method was called on thread '\" + Thread.currentThread().getName() + \"'. \" + \"All WebView methods must be called on the same thread. \" + \"(Expected Looper \" + mWebViewThread + \" called on \" + Looper.myLooper() + \", FYI main Looper is \" + Looper.getMainLooper() + \")\"); Log.w(LOGTAG, Log.getStackTraceString(throwable)); StrictMode.onWebViewMethodCalledOnWrongThread(throwable); if (sEnforceThreadChecking) &#123; throw new RuntimeException(throwable); &#125; &#125;&#125; 开头注释里就已经说明，忽略mWebViewThread为null的情况，因为可能会在超类的构造器里调用这个方法，此时WebView这个类的对象还没有构建出来，意味着mWebViewThread为null。if条件中的Looper.myLooper() != mWebViewThread这条判断，对Android系统有过一定了解的人的人，应该会对Looper.myLooper()这种写法非常熟悉，这是获取当前线程的典型手段。如果当前线程不是WebView线程的话，就要做好抛出异常的准备。为什么要做这种判断呢？我分析了10分钟，得出结论是：因为WebView中很多操作，都需要运用线程内部资源，如果在外部线程中调用，很容易出现并发问题，如果要避免，就只有增加同步的成本，所以索性只限制在线程内了。有一点值得注意的是，因为WebView是一个UI组件，大部分时间里都在主线程中初始化，因此，这里判断的就是当前线程是否为UI线程。 接下来我们看一下WebViewProvider中的clearCache方法，依旧是WebViewChromium.java。 1234@Overridepublic void clearCache(boolean includeDiskFiles) &#123; mAwContents.clearCache(includeDiskFiles);&#125; 同样，这个操作被代理给了AwContents，源码见AwContents.java。需要注意，由于app内所有的WebView缓存都是保存在一个地方，这个方法会清空app全部WebView的缓存，参数includeDiskFiles控制清空硬盘上的缓存文件。 12345678910/** * Clears the resource cache. Note that the cache is per-application, so this will clear the * cache for all WebViews used. * * @param includeDiskFiles if false, only the RAM cache is cleared */public void clearCache(boolean includeDiskFiles) &#123; if (mNativeAwContents == 0) return; nativeClearCache(mNativeAwContents, includeDiskFiles);&#125; 对应的实现位于aw_contents.cc代码。先检测当前线程为UI线程，然后调用render_view_host_ext_的ClearCache方法，如果需要清空硬盘上的缓存的话，调用RemoveHttpDiskCache(web_contents_-&gt;GetRenderProcessHost())。逐个来分析。 12345678void AwContents::ClearCache(JNIEnv* env, const JavaParamRef&lt;jobject&gt;&amp; obj, jboolean include_disk_files) &#123; DCHECK_CURRENTLY_ON(BrowserThread::UI); render_view_host_ext_-&gt;ClearCache(); if (include_disk_files) RemoveHttpDiskCache(web_contents_-&gt;GetRenderProcessHost());&#125; 首先看render_view_host_ext_-&gt;ClearCache()，代码在aw_render_view_host_ext.cc。这里发出了一个信息，AwViewMsg_ClearCache，看出来了，是广播模式。那么消息监听者在哪儿呢？ 1234void AwRenderViewHostExt::ClearCache() &#123; DCHECK(CalledOnValidThread()); Send(new AwViewMsg_ClearCache);&#125; 监听者位于aw_render_thread_observer.cc。通过blink::WebCache::clear()调用clear方法。blink究竟是个啥？I don’t know. 借助Google的力量，找到了WebCache::clear()的实现。 12345678910111213bool AwRenderThreadObserver::OnControlMessageReceived( const IPC::Message&amp; message) &#123; bool handled = true; IPC_BEGIN_MESSAGE_MAP(AwRenderThreadObserver, message) IPC_MESSAGE_HANDLER(AwViewMsg_ClearCache, OnClearCache) IPC_MESSAGE_HANDLER(AwViewMsg_SetJsOnlineProperty, OnSetJsOnlineProperty) IPC_MESSAGE_UNHANDLED(handled = false) IPC_END_MESSAGE_MAP() return handled;&#125;void AwRenderThreadObserver::OnClearCache() &#123; blink::WebCache::clear();&#125; WebCache.cpp 123456void WebCache::clear()&#123; MemoryCache* cache = memoryCache(); if (cache) cache-&gt;evictResources();&#125; 获取memoryCache()的方法位于WebCache.cpp，可以看出该cache是线程相关的，而且从命名上就可以看出，这是MemoryCache，位于RAM中。 1234567MemoryCache* memoryCache()&#123; ASSERT(WTF::isMainThread()); if (!gMemoryCache) gMemoryCache = new Persistent&lt;MemoryCache&gt;(MemoryCache::create()); return gMemoryCache-&gt;get();&#125; 分析完清理内存缓存的路径，我们接下来看如何清理磁盘缓存。 123if (include_disk_files) RemoveHttpDiskCache(web_contents_-&gt;GetRenderProcessHost());&#125; RemoveHttpDiskCache位于net_disk_cache_remover.cc。所做的事情是，在BrowserThread中发布一个Task，清理Render进程拥有的磁盘空间。 123456789void RemoveHttpDiskCache(content::RenderProcessHost* render_process_host) &#123; BrowserThread::PostTask( BrowserThread::IO, FROM_HERE, base::Bind(&amp;ClearHttpDiskCacheOnIoThread, base::Unretained(render_process_host-&gt;GetStoragePartition()-&gt; GetURLRequestContext()), base::Unretained(render_process_host-&gt;GetStoragePartition()-&gt; GetMediaURLRequestContext())));&#125; 到这里，似乎告一段落了。","tags":[{"name":"Android","slug":"Android","permalink":"https://lilei.pro/tags/Android/"},{"name":"源码分析","slug":"源码分析","permalink":"https://lilei.pro/tags/源码分析/"}]},{"title":"Android WebView 从0到1（一）","date":"2016-11-09T00:22:59.000Z","path":"2016/11/09/Android-WebView-0-to-1/","text":"这一系列将从源码角度，分析WebView加载页面的全过程。在摸透缓存机制的基础上，实现自己的WebView缓存控制项目Vindow。从0到1很难，但是克服了之后，从1到100就容易了许多。 WebView.java这里采用android-23的源码示例。 WebView的类说明注释非常长，建议耐心地读完每一行，随后，你就会对WebView的主要功能有一个轮廓上的认识。 1234567/** * A View that displays web pages. This class is the basis upon which you * can roll your own web browser or simply display some online content within your Activity. * It uses the WebKit rendering engine to display * web pages and includes methods to navigate forward and backward * through a history, zoom in and out, perform text searches and more. * / 这段是说，WebView主要用来展示网页信息，它使用WebKit内核（这里很重要，后续分析大部分源码都是来自WebKit的），包含了控制网页前进后退的导航功能、缩放功能、文本搜索功能以及其他。 12345678910111213/** * By default, a WebView provides no browser-like widgets, does not * enable JavaScript and web page errors are ignored. If your goal is only * to display some HTML as a part of your UI, this is probably fine; * the user won't need to interact with the web page beyond reading * it, and the web page won't need to interact with the user. If you * actually want a full-blown web browser, then you probably want to * invoke the Browser application with a URL Intent rather than show it * with a WebView. * Uri uri = Uri.parse(\"http://www.example.com\"); * Intent intent = new Intent(Intent.ACTION_VIEW, uri); * startActivity(intent); * / 这里强调了，WebView应当仅仅提供展示，默认情况下是禁用JavaScript，并且隐藏网页错误信息的。换句话说，Google本意是不提倡在WebView中引导用户进行过多的操作，如果有这种需求，就通过intent打开浏览器页面进行操作。然而当下这条规则在很多应用场景下是被无视的，想想微信在H5页面里，可以做多少事。 1234567891011121314151617181920212223242526/** * &lt;p&gt;A WebView has several customization points where you can add your * own behavior. These are:&lt;/p&gt; * * &lt;ul&gt; * &lt;li&gt;Creating and setting a &#123;@link android.webkit.WebChromeClient&#125; subclass. * This class is called when something that might impact a * browser UI happens, for instance, progress updates and * JavaScript alerts are sent here (see &lt;a * href=\"&#123;@docRoot&#125;guide/developing/debug-tasks.html#DebuggingWebPages\"&gt;Debugging Tasks&lt;/a&gt;). * &lt;/li&gt; * &lt;li&gt;Creating and setting a &#123;@link android.webkit.WebViewClient&#125; subclass. * It will be called when things happen that impact the * rendering of the content, eg, errors or form submissions. You * can also intercept URL loading here (via &#123;@link * android.webkit.WebViewClient#shouldOverrideUrlLoading(WebView,String) * shouldOverrideUrlLoading()&#125;).&lt;/li&gt; * &lt;li&gt;Modifying the &#123;@link android.webkit.WebSettings&#125;, such as * enabling JavaScript with &#123;@link android.webkit.WebSettings#setJavaScriptEnabled(boolean) * setJavaScriptEnabled()&#125;. &lt;/li&gt; * &lt;li&gt;Injecting Java objects into the WebView using the * &#123;@link android.webkit.WebView#addJavascriptInterface&#125; method. This * method allows you to inject Java objects into a page's JavaScript * context, so that they can be accessed by JavaScript in the page.&lt;/li&gt; * &lt;/ul&gt; * / 默认WebView的很多功能是关闭的，需要我们手动打开。这里列出了如何处理JS Alert与错误、如何开启JS、如何使native代码与页面JS进行交互。 123456// Implementation notes.// The WebView is a thin API class that delegates its public API to a backend WebViewProvider// class instance. WebView extends &#123;@link AbsoluteLayout&#125; for backward compatibility reasons.// Methods are delegated to the provider implementation: all public API methods introduced in this// file are fully delegated, whereas public and protected methods from the View base classes are// only delegated where a specific need exists for them to do so. 上面这段说明了WebView主要的实现机理————WebView本身只是一个代理（delegate），提供了公共的API供客户端调用，而这些API的实现，都是代理到了一个叫WebViewProvider的对象上面。既然这样，我们就大致浏览下WebView有哪些公有API，把更多的精力保留下来，集中分析WebViewProvider的实现。 WebView API这部分不罗列了，只做一个简单的归类，API文档见 https://developer.android.com/reference/android/webkit/WebView.html 加载页面这是最主要的功能，全部由代理Provider完成 loadUrl postUrl loadData loadDataWithBaseURL getUrl，getOriginalUrl getFavicon，getTouchIconUrl 保存页面：saveWebArchive 控制加载：stopLoading，reload，getProgress 页面尺寸：getContentHeight，getContentWidth 计时器 JS中的计时器，在onPause时可以暂停，onResume时恢复：pauseTimers，resumeTimers 导航 canGoBack，canGoForward，canGoBackOrForward goBack，goForward，goBackOrForward pageUp，pageDown copyBackForwardList JavaScript evaluateJavascript addJavascriptInterface，removeJavascriptInterface WebViewClient／WebChromeClient setWebViewClient：WebView本身是控制页面整体框架的前进、后退、缩放、加载等功能，而具体页面内容的变化，则要交给WebViewClient来管理。 setWebChromeClient：WebChromeClient主要辅助WebView处理Javascript的对话框、网站图标、网站title、加载进度等。如果页面只是简单地展示HTML，并没有JS操作，那么用WebViewClient就足够了。 下载 完成下载监听器：setDownloadListener 查找 通过FindListener回调接口实现：setFindListener，findNext，findAll…… 缩放 展示缩放控件：invokeZoomPicker 控制缩放：zoomIn，zoomOut…… 安全认证 证书操作：getCertificate，setCertificate（deprecated）， 用户名密码：setHttpAuthUsernamePassword，getHttpAuthUsernamePassword 私密模式：isPrivateBrowsingEnabled 设置网络 网络可用性：setNetworkAvailable 保存状态 代理给Provider进行：saveState，restoreState 生命周期与回调 postVisualStateCallback 页面内容标签 HitTestResult系列：getHitTestResult Cache与访问历史本系列文章重点了解的内容，代理给Provider实现 clearCache clearFormData clearHistory clearSslPreferences 被废弃的方法 设置滚动条样式：setHorizontalScrollbarOverlay，setVerticalScrollbarOverlay，overlayHorizontalScrollbar，overlayVerticalScrollbar…… 获取Title高度：getVisibleTitleHeight 平台通知：enablePlatformNotifications，disablePlatformNotifications 图片操作：savePicture，restorePicture…… 内存：freeMemory Plugins：getPluginList，refreshPlugins…… WebViewProvider前面说了，WebView的功能几乎全部都是代理给WebViewProvider来实现的，android.webkit.WebViewProvider是一个接口，其实现要追溯源码，据版本不同有所区分。 Android4.4之前的版本，由WebViewClassic实现。 Android4.4以及之后的版本，由WebViewChromium实现。 随SDK下载的源码里不包含这部分代码，在这个页面查看：WebViewChromium.java WebViewChromium类实现了WebView中被代理的全部方法，篇幅所限，我们不逐一进行分析，只追踪我们关注的加载页面／cache相关，也就是loadUrl和clearCache两个方法。 loadUrl123456789101112@Overridepublic void loadUrl(String url) &#123; loadUrl(url, null);&#125;@Overridepublic void loadUrl(String url, Map&lt;String, String&gt; additionalHttpHeaders) &#123; // TODO: We may actually want to do some sanity checks here (like filter about://chrome). LoadUrlParams params = new LoadUrlParams(url); if (additionalHttpHeaders != null) params.setExtraHeaders(additionalHttpHeaders); mAwContents.loadUrl(params);&#125; 我们通常所用的loadUrl(&quot;http://www.foo.com&quot;)，会走到loadUrl(String url, Map&lt;String, String&gt; additionalHttpHeaders)这个方法，可以看到首先把url拼装成了一个LoadUrlParams，那么这个LoadUrlParams是用来做什么的呢？ LoadUrlParams.java1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Holds parameters for ContentViewCore.LoadUrl. Parameters should match * counterparts in NavigationController::LoadURLParams, including default * values. */@JNINamespace(\"content\")public class LoadUrlParams &#123; // Should match NavigationController::LoadUrlType exactly. See comments // there for proper usage. Values are initialized in initializeConstants. public static int LOAD_TYPE_DEFAULT; public static int LOAD_TYPE_BROWSER_INITIATED_HTTP_POST; public static int LOAD_TYPE_DATA; // Should match NavigationController::UserAgentOverrideOption exactly. // See comments there for proper usage. Values are initialized in // initializeConstants. public static int UA_OVERRIDE_INHERIT; public static int UA_OVERRIDE_FALSE; public static int UA_OVERRIDE_TRUE; // Fields with counterparts in NavigationController::LoadURLParams. // Package private so that ContentViewCore.loadUrl can pass them down to // native code. Should not be accessed directly anywhere else outside of // this class. final String mUrl; int mLoadUrlType; int mTransitionType; int mUaOverrideOption; private Map&lt;String, String&gt; mExtraHeaders; byte[] mPostData; String mBaseUrlForDataUrl; String mVirtualUrlForDataUrl; boolean mCanLoadLocalResources; public LoadUrlParams(String url) &#123; // Check initializeConstants was called. assert LOAD_TYPE_DEFAULT != LOAD_TYPE_BROWSER_INITIATED_HTTP_POST; mUrl = url; mLoadUrlType = LOAD_TYPE_DEFAULT; mTransitionType = PageTransitionTypes.PAGE_TRANSITION_LINK; mUaOverrideOption = UA_OVERRIDE_INHERIT; mPostData = null; mBaseUrlForDataUrl = null; mVirtualUrlForDataUrl = null; &#125; // 以下略&#125; 一个URL竟然可以解析出这么多东西来，逐个看看这些变量的含义：（参考navigation_controller.h） mUrl：最原始的URL mLoadUrlType：加载类型，有如下三种 LOAD_TYPE_DEFAULT：默认类型，以下两种以外的任意类型。 LOAD_TYPE_BROWSER_INITIATED_HTTP_POST：POST请求需要设置此类型。 LOAD_TYPE_DATA：使用Base64编码的图片类型，通过Base64编码图片能够减少一次网络资源加载。(可以使用以下这两个工具，查看如何在图片与Base64编码之间进行转换：http://dataurl.net/#dataurlmaker http://codebeautify.org/base64-to-image-converter) mTransitionType：页面变化的类型（实在找不出合适的词语来描述），默认为，详见page_transition_types.h，举例说明： PAGE_TRANSITION_LINK：默认值，点击link PAGE_TRANSITION_TYPED：在地址栏输入link PAGE_TRANSITION_RELOAD：刷新页面 略 mUaOverrideOption：控制http中的UserAgent，有三个可选值 UA_OVERRIDE_INHERIT：默认值，Use the override value from the previous NavigationEntry in the NavigationController. UA_OVERRIDE_FALSE：Use the default user agent UA_OVERRIDE_TRUE：Use the user agent override, if it’s available. mPostData：POST请求的data mBaseUrlForDataUrl：仅对LOAD_TYPE_DATA有效，用于URL的相对路径以及JavaScript跨域检验。 mVirtualUrlForDataUrl：仅对LOAD_TYPE_DATA有效，显示在外给用户看的地址。 分析完了LoadUrlParams，继续追溯WebViewChromium中的loadUrl方法。 1if (additionalHttpHeaders != null) params.setExtraHeaders(additionalHttpHeaders); 这里设置的ExtraHeaders是一个Map，具体参见http协议的header部分。 1mAwContents.loadUrl(params); 最终交给AwContent对象处理，完整源码见AwContents.java。”Aw”是”Android WebView”的缩写。 12345678/** * Exposes the native AwContents class, and together these classes wrap the ContentViewCore * and Browser components that are required to implement Android WebView API. This is the * primary entry point for the WebViewProvider implementation; it holds a 1:1 object * relationship with application WebView instances. * (We define this class independent of the hidden WebViewProvider interfaces, to allow * continuous build &amp; test in the open source SDK-based tree). */ 上述注释中最重要的是This is the primary entry point for the WebViewProvider implementation; it holds a 1:1 object relationship with application WebView instances.这一句，说明每一个WebView示例，都有一个AwContent对象和它对应。同样，我们只关注loadUrl方法，这里通过我们上一步分析的LoadUrlParams参数进行加载。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * Load url without fixing up the url string. Consumers of ContentView are responsible for * ensuring the URL passed in is properly formatted (i.e. the scheme has been added if left * off during user input). * * @param params Parameters for this load. */ public void loadUrl(LoadUrlParams params) &#123; if (params.getLoadUrlType() == LoadUrlParams.LOAD_TYPE_DATA &amp;&amp; !params.isBaseUrlDataScheme()) &#123; // This allows data URLs with a non-data base URL access to file:///android_asset/ and // file:///android_res/ URLs. If AwSettings.getAllowFileAccess permits, it will also // allow access to file:// URLs (subject to OS level permission checks). params.setCanLoadLocalResources(true); &#125; // If we are reloading the same url, then set transition type as reload. if (params.getUrl() != null &amp;&amp; params.getUrl().equals(mContentViewCore.getUrl()) &amp;&amp; params.getTransitionType() == PageTransitionTypes.PAGE_TRANSITION_LINK) &#123; params.setTransitionType(PageTransitionTypes.PAGE_TRANSITION_RELOAD); &#125; params.setTransitionType( params.getTransitionType() | PageTransitionTypes.PAGE_TRANSITION_FROM_API); // For WebView, always use the user agent override, which is set // every time the user agent in AwSettings is modified. params.setOverrideUserAgent(LoadUrlParams.UA_OVERRIDE_TRUE); // We don't pass extra headers to the content layer, as WebViewClassic // was adding them in a very narrow set of conditions. See http://crbug.com/306873 // However, if the embedder is attempting to inject a Referer header for their // loadUrl call, then we set that separately and remove it from the extra headers map/ final String REFERER = \"referer\"; Map&lt;String, String&gt; extraHeaders = params.getExtraHeaders(); if (extraHeaders != null) &#123; for (String header : extraHeaders.keySet()) &#123; if (REFERER.equals(header.toLowerCase(Locale.US))) &#123; params.setReferrer(new Referrer(extraHeaders.remove(header), 1)); params.setExtraHeaders(extraHeaders); break; &#125; &#125; &#125; if (mNativeAwContents != 0) &#123; nativeSetExtraHeadersForUrl( mNativeAwContents, params.getUrl(), params.getExtraHttpRequestHeadersString()); &#125; params.setExtraHeaders(new HashMap&lt;String, String&gt;()); mContentViewCore.loadUrl(params); // The behavior of WebViewClassic uses the populateVisitedLinks callback in WebKit. // Chromium does not use this use code path and the best emulation of this behavior to call // request visited links once on the first URL load of the WebView. if (!mHasRequestedVisitedHistoryFromClient) &#123; mHasRequestedVisitedHistoryFromClient = true; requestVisitedHistoryFromClient(); &#125; if (params.getLoadUrlType() == LoadUrlParams.LOAD_TYPE_DATA &amp;&amp; params.getBaseUrl() != null) &#123; // Data loads with a base url will be resolved in Blink, and not cause an onPageStarted // event to be sent. Sending the callback directly from here. mContentsClient.getCallbackHelper().postOnPageStarted(params.getBaseUrl()); &#125; &#125; 设置加载本地文件 1234567if (params.getLoadUrlType() == LoadUrlParams.LOAD_TYPE_DATA &amp;&amp; !params.isBaseUrlDataScheme()) &#123; // This allows data URLs with a non-data base URL access to file:///android_asset/ and // file:///android_res/ URLs. If AwSettings.getAllowFileAccess permits, it will also // allow access to file:// URLs (subject to OS level permission checks). params.setCanLoadLocalResources(true);&#125; 重设transitionType 12345678// If we are reloading the same url, then set transition type as reload.if (params.getUrl() != null &amp;&amp; params.getUrl().equals(mContentViewCore.getUrl()) &amp;&amp; params.getTransitionType() == PageTransitionTypes.PAGE_TRANSITION_LINK) &#123; params.setTransitionType(PageTransitionTypes.PAGE_TRANSITION_RELOAD);&#125;params.setTransitionType( params.getTransitionType() | PageTransitionTypes.PAGE_TRANSITION_FROM_API); 设置UA为override 123// For WebView, always use the user agent override, which is set// every time the user agent in AwSettings is modified.params.setOverrideUserAgent(LoadUrlParams.UA_OVERRIDE_TRUE); 把ExtraHeaders中的referer属性提取出来单独设置，并将其从ExtraHeaders中删除，referer属性用于声明当前页面是从哪个页面跳转来的。 123456789101112131415// We don't pass extra headers to the content layer, as WebViewClassic// was adding them in a very narrow set of conditions. See http://crbug.com/306873// However, if the embedder is attempting to inject a Referer header for their// loadUrl call, then we set that separately and remove it from the extra headers map/final String REFERER = \"referer\";Map&lt;String, String&gt; extraHeaders = params.getExtraHeaders();if (extraHeaders != null) &#123; for (String header : extraHeaders.keySet()) &#123; if (REFERER.equals(header.toLowerCase(Locale.US))) &#123; params.setReferrer(new Referrer(extraHeaders.remove(header), 1)); params.setExtraHeaders(extraHeaders); break; &#125; &#125;&#125; 然后对于剩下的属性，单独设置，最终清楚ExtraHeaders 12345if (mNativeAwContents != 0) &#123; nativeSetExtraHeadersForUrl( mNativeAwContents, params.getUrl(), params.getExtraHttpRequestHeadersString());&#125;params.setExtraHeaders(new HashMap&lt;String, String&gt;()); 对params进行过上述二次加工后，调用mContentViewCore的loadUrl方法 1mContentViewCore.loadUrl(params); 继续追溯至ContentViewCore.java，位于org.chromium.content.browser包中。 12345678910111213141516171819202122232425/** * Load url without fixing up the url string. Consumers of ContentView are responsible for * ensuring the URL passed in is properly formatted (i.e. the scheme has been added if left * off during user input). * * @param pararms Parameters for this load. */public void loadUrl(LoadUrlParams params) &#123; if (mNativeContentViewCore == 0) return; if (isPersonalityView()) &#123; // For WebView, always use the user agent override, which is set // every time the user agent in ContentSettings is modified. params.setOverrideUserAgent(LoadUrlParams.UA_OVERRIDE_TRUE); &#125; nativeLoadUrl(mNativeContentViewCore, params.mUrl, params.mLoadUrlType, params.mTransitionType, params.mUaOverrideOption, params.getExtraHeadersString(), params.mPostData, params.mBaseUrlForDataUrl, params.mVirtualUrlForDataUrl, params.mCanLoadLocalResources);&#125; 这里调用了nativeLoadUrl方法，传入的参数我们之前都已经分析过其含义，除了第一个参数mNativeContentViewCore，它是一个指向ContentViewCoreImpl的指针地址。 12// Native pointer to C++ ContentViewCoreImpl object which will be set by nativeInit().private int mNativeContentViewCore = 0; 接下来就要深入到cpp文件中了，content_view_core_impl.cc。注意！可能是版本的原因，这里的LoadUrl方法多出了第一个参数JNIEnv* env，通过对比可以发现，其它的参数是完全一致的。 123456789101112131415161718192021222324252627282930313233343536373839void ContentViewCoreImpl::LoadUrl( JNIEnv* env, jobject obj, jstring url, jint load_url_type, jint transition_type, jint ua_override_option, jstring extra_headers, jbyteArray post_data, jstring base_url_for_data_url, jstring virtual_url_for_data_url, jboolean can_load_local_resources) &#123; DCHECK(url); NavigationController::LoadURLParams params( GURL(ConvertJavaStringToUTF8(env, url))); params.load_type = static_cast&lt;NavigationController::LoadURLType&gt;( load_url_type); params.transition_type = PageTransitionFromInt(transition_type); params.override_user_agent = static_cast&lt;NavigationController::UserAgentOverrideOption&gt;( ua_override_option); if (extra_headers) params.extra_headers = ConvertJavaStringToUTF8(env, extra_headers); if (post_data) &#123; std::vector&lt;uint8&gt; http_body_vector; base::android::JavaByteArrayToByteVector(env, post_data, &amp;http_body_vector); params.browser_initiated_post_data = base::RefCountedBytes::TakeVector(&amp;http_body_vector); &#125; if (base_url_for_data_url) &#123; params.base_url_for_data_url = GURL(ConvertJavaStringToUTF8(env, base_url_for_data_url)); &#125; if (virtual_url_for_data_url) &#123; params.virtual_url_for_data_url = GURL(ConvertJavaStringToUTF8(env, virtual_url_for_data_url)); &#125; params.can_load_local_resources = can_load_local_resources; LoadUrl(params);&#125; GURL是一个宏，虽然不了解它具体做了什么，但是根据上下文可以猜测这里生成了一个NavigationController::LoadURLParams对象 12NavigationController::LoadURLParams params( GURL(ConvertJavaStringToUTF8(env, url))); 随后对几个参数进行类型转换，把它们拼入params中，最后调用LoadUrl(params)方法。 12345void ContentViewCoreImpl::LoadUrl( NavigationController::LoadURLParams&amp; params) &#123; GetWebContents()-&gt;GetController().LoadURLWithParams(params); UpdateTabCrashedFlag();&#125; 虽然自己对C语言不是很熟悉，但在这里也可以发现，是把上一步拼装成的params参数集合传递给了某个Controller对象。那么到底是哪一个Controller呢？跟着代码走～ 123WebContents* ContentViewCoreImpl::GetWebContents() const &#123; return web_contents_;&#125; 这里返回成员变量web_contents_，而Controller就在它内部 1234567891011121314151617181920void ContentViewCoreImpl::InitWebContents() &#123; DCHECK(web_contents_); notification_registrar_.Add( this, NOTIFICATION_RENDER_VIEW_HOST_CHANGED, Source&lt;NavigationController&gt;(&amp;web_contents_-&gt;GetController())); notification_registrar_.Add( this, NOTIFICATION_RENDERER_PROCESS_CREATED, content::NotificationService::AllBrowserContextsAndSources()); notification_registrar_.Add( this, NOTIFICATION_WEB_CONTENTS_CONNECTED, Source&lt;WebContents&gt;(web_contents_)); notification_registrar_.Add( this, NOTIFICATION_WEB_CONTENTS_SWAPPED, Source&lt;WebContents&gt;(web_contents_)); static_cast&lt;WebContentsViewAndroid*&gt;(web_contents_-&gt;GetView())-&gt; SetContentViewCore(this); DCHECK(!web_contents_-&gt;GetUserData(kContentViewUserDataKey)); web_contents_-&gt;SetUserData(kContentViewUserDataKey, new ContentViewUserData(this));&#125; 找到了，是NavigationController类型，源码见navigation_controller_impl.cc。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576void NavigationControllerImpl::LoadURLWithParams(const LoadURLParams&amp; params) &#123; TRACE_EVENT0(\"browser\", \"NavigationControllerImpl::LoadURLWithParams\"); if (HandleDebugURL(params.url, params.transition_type)) return; // Checks based on params.load_type. switch (params.load_type) &#123; case LOAD_TYPE_DEFAULT: break; case LOAD_TYPE_BROWSER_INITIATED_HTTP_POST: if (!params.url.SchemeIs(kHttpScheme) &amp;&amp; !params.url.SchemeIs(kHttpsScheme)) &#123; NOTREACHED() &lt;&lt; \"Http post load must use http(s) scheme.\"; return; &#125; break; case LOAD_TYPE_DATA: if (!params.url.SchemeIs(chrome::kDataScheme)) &#123; NOTREACHED() &lt;&lt; \"Data load must use data scheme.\"; return; &#125; break; default: NOTREACHED(); break; &#125;; // The user initiated a load, we don't need to reload anymore. needs_reload_ = false; bool override = false; switch (params.override_user_agent) &#123; case UA_OVERRIDE_INHERIT: override = ShouldKeepOverride(GetLastCommittedEntry()); break; case UA_OVERRIDE_TRUE: override = true; break; case UA_OVERRIDE_FALSE: override = false; break; default: NOTREACHED(); break; &#125; NavigationEntryImpl* entry = NavigationEntryImpl::FromNavigationEntry( CreateNavigationEntry( params.url, params.referrer, params.transition_type, params.is_renderer_initiated, params.extra_headers, browser_context_)); if (params.should_replace_current_entry) entry-&gt;set_should_replace_entry(true); entry-&gt;set_should_clear_history_list(params.should_clear_history_list); entry-&gt;SetIsOverridingUserAgent(override); entry-&gt;set_transferred_global_request_id( params.transferred_global_request_id); entry-&gt;SetFrameToNavigate(params.frame_name); switch (params.load_type) &#123; case LOAD_TYPE_DEFAULT: break; case LOAD_TYPE_BROWSER_INITIATED_HTTP_POST: entry-&gt;SetHasPostData(true); entry-&gt;SetBrowserInitiatedPostData( params.browser_initiated_post_data.get()); break; case LOAD_TYPE_DATA: entry-&gt;SetBaseURLForDataURL(params.base_url_for_data_url); entry-&gt;SetVirtualURL(params.virtual_url_for_data_url); entry-&gt;SetCanLoadLocalResources(params.can_load_local_resources); break; default: NOTREACHED(); break; &#125;; LoadEntry(entry);&#125; 这里做的事情与前面类似，取出参数再次拼装成NavigationEntryImpl* entry，然后调用LoadEntry。LoadEntry这里的注释讲解的很清楚，当我们进入新页面时，我们并不清楚是不是要终止上一个页面，因为新页面有可能只是一个下载或者邮件。由于我们的url等信息都保存在entry中，继续追溯 SetPendingEntry(entry) 方法。 1234567void NavigationControllerImpl::LoadEntry(NavigationEntryImpl* entry) &#123; // When navigating to a new page, we don't know for sure if we will actually // end up leaving the current page. The new page load could for example // result in a download or a 'no content' response (e.g., a mailto: URL). SetPendingEntry(entry); NavigateToPendingEntry(NO_RELOAD);&#125; 12345678void NavigationControllerImpl::SetPendingEntry(NavigationEntryImpl* entry) &#123; DiscardNonCommittedEntriesInternal(); pending_entry_ = entry; NotificationService::current()-&gt;Notify( NOTIFICATION_NAV_ENTRY_PENDING, Source&lt;NavigationController&gt;(this), Details&lt;NavigationEntry&gt;(entry));&#125; 上述代码中，先是终止了尚未提交处理的Entry，然后将欲访问的entry保存在pending_entry_变量，最后通过NotificationService::current()-&gt;Notify，把Entry插入一个消息队列，可以在notification_service_impl.cc的源码中看到，收到这个消息后，会通知所有的Observer 12345678910111213141516171819202122232425262728293031323334void NotificationServiceImpl::Notify(int type, const NotificationSource&amp; source, const NotificationDetails&amp; details) &#123; DCHECK_GT(type, NOTIFICATION_ALL) &lt;&lt; \"Allowed for observing, but not posting.\"; // There's no particular reason for the order in which the different // classes of observers get notified here. // Notify observers of all types and all sources if (HasKey(observers_[NOTIFICATION_ALL], AllSources()) &amp;&amp; source != AllSources()) &#123; FOR_EACH_OBSERVER(NotificationObserver, *observers_[NOTIFICATION_ALL][AllSources().map_key()], Observe(type, source, details)); &#125; // Notify observers of all types and the given source if (HasKey(observers_[NOTIFICATION_ALL], source)) &#123; FOR_EACH_OBSERVER(NotificationObserver, *observers_[NOTIFICATION_ALL][source.map_key()], Observe(type, source, details)); &#125; // Notify observers of the given type and all sources if (HasKey(observers_[type], AllSources()) &amp;&amp; source != AllSources()) &#123; FOR_EACH_OBSERVER(NotificationObserver, *observers_[type][AllSources().map_key()], Observe(type, source, details)); &#125; // Notify observers of the given type and the given source if (HasKey(observers_[type], source)) &#123; FOR_EACH_OBSERVER(NotificationObserver, *observers_[type][source.map_key()], Observe(type, source, details)); &#125;&#125; 我们必须找到是哪个Observer处理了加载Entry的消息，可是到这里，线索似乎断了，怎么才能找到对应的Observer呢？ 内事不决问百度，外事不决问谷歌。 在Google的帮助下，找到了这篇文档Getting Around the Chromium Source Code Directory Structure。这里介绍了整个Chromium的架构，重点关注“Navigating from the URL bar”一节。 Navigating from the URL bar When the user types into or accepts an entry in the URL bar, the autocomplete edit box determines the final target URL and passes that to AutocompleteEdit::OpenURL. (This may not be exactly what the user typed - for example, an URL is generated in the case of a search query.) The navigation controller is instructed to navigate to the URL in NavigationController::LoadURL. The NavigationController calls TabContents::Navigate with the NavigationEntry it created to represent this particular page transition. It will create a new RenderViewHost if necessary, which will cause creation of a RenderView in the renderer process. A RenderView won’t exist if this is the first navigation, or if the renderer has crashed, so this will also recover from crashes. Navigate forwards to RenderViewHost::NavigateToEntry. The NavigationControllerstores this navigation entry, but it is marked as “pending” because it doesn’t know for sure if the transition will take place (maybe the host can not be resolved). RenderViewHost::NavigateToEntry sends a ViewMsg_Navigate to the new RenderView in the renderer process. When told to navigate, RenderView may navigate, it may fail, or it may navigate somewhere else instead (for example, if the user clicks a link). RenderViewHost waits for a ViewHostMsg_FrameNavigate from the RenderView. When the load is “committed” by WebKit (the server responded and is sending us data), the RenderView sends this message, which is handled in RenderViewHost::OnMsgNavigate. The NavigationEntry is updated with the information on the load. In the case of a link click, the browser has never seen this URL before. If the navigation was browser-initiated, as in the startup case, there may have been redirects that have changed the URL. The NavigationController updates its list of navigations to account for this new information. 在步骤3中看到，NavigationController调用了TabContents::Navigate来处理Entry，随后就进入了渲染（Render）过程。而我们想要追踪的缓存文件管理的疑问，还是要深入到渲染阶段才能有个答案。 更多分析，将在后续文章中一一道出。","tags":[{"name":"Android","slug":"Android","permalink":"https://lilei.pro/tags/Android/"},{"name":"源码分析","slug":"源码分析","permalink":"https://lilei.pro/tags/源码分析/"}]},{"title":"Deploy Web Application In Tomcat","date":"2016-09-09T09:17:03.000Z","path":"2016/09/09/Deploy-Web-Application-In-Tomcat/","text":"在开发CrashReporter项目时遇到的一些坑 Tomcat启动时卡在”Tomcat: error deploying web application directory”原因是Tomcat7/8需要使用org.apache.catalina.util.SessionIdGeneratorBase.createSecureRandom来产生安全随机类SecureRandom的实例作为会话ID。而我们知道，任何随机数发生器都需要一个种子，Linux中的随机数，可以从这两个特殊的文件中产生 /dev/urandom /dev/random 这两个文件产生随机数的原理，是利用系统的熵池，计算出固定一定数量的随机比特，然后将这些比特作为字节流返回。 熵池就是当前系统的环境噪音，熵指的是一个系统的混乱程度，系统噪音可以通过很多参数来评估，如内存的使用，文件的使用量，不同类型的进程数量等等。如果当前环境噪音变化的不是很剧烈或者当前环境噪音很小，比如刚开机的时候，而当前需要大量的随机比特，这时产生的随机数的随机效果就不是很好了。 /dev/random在不能产生新的随机数时会阻塞程序，而/dev/urandom不会，当然产生的随机数效果就不太好了，这对加密解密这样的应用来说就不是一种很好的选择。/dev/random会阻塞当前的程序，直到根据熵池产生新的随机字节之后才返回，所以使用/dev/random比使用/dev/urandom产生大量随机数的速度要慢。 解决办法： 在Tomcat环境解决：启动时加入参数-Djava.security.egd=file:/dev/urandom 在JVM环境解决：修改$JAVA_PATH/jre/lib/security/java.security中的securerandom.source=file:/dev/random为securerandom.source=file:/dev/urandom crontab 配置crontab -e 编辑当前用户的定时命令crontab -l 查看当前用户的定时命令 一条典型的定时任务 10 4 * * * /usr/bin/java -Xms256m -Xmx1024m -Duser.timezone=GMT+08 -jar /root/projects/crash-reporter/crash-reporter-0.1-SNAPSHOT-jar-with-dependencies.jar 在配置这个任务时，由于没有理解它本质上的原理，自己犯了一个愚蠢的错误，把时间写成了* 4 * * *，导致凌晨4点内，每分钟发出一篇邮件，还是发给全组人的…… 附图一张，crontab的命令配置 Tomcat容器时间在Linux系统里通过date命令查看，时区已经更改为北京时间。但是实际运行时，发现代码里通过new Date()创建的时间，format后打印出来居然是标准时间；同时，log4j记录的时间也有一样的问题。 原因在于，JVM的时间需要在启动时配置，需要在tomcat的启动命令中增加如下参数 1-Duser.timezone=GMT+08 参考资料 Tomcat启动时SecureRandom超级慢的问题 每天一个linux命令（50）：crontab命令 ===Ending===","tags":[{"name":"技术流","slug":"技术流","permalink":"https://lilei.pro/tags/技术流/"},{"name":"Backend","slug":"Backend","permalink":"https://lilei.pro/tags/Backend/"}]},{"title":"Android 中 View Visibility 的坑","date":"2016-06-29T03:37:37.000Z","path":"2016/06/29/Android-View-Visibility/","text":"前几天爆出来一个线上bug：处于“已售完”状态的菜品，依然可以点击加菜。好在提交订单时有校验，对于这种订单会直接打回。究其原因，是加减控件中的代码出了问题 问题回顾在加减控件中，提供了enlargeEmptyAddBtnClickArea方法，用来扩大第一次加菜按钮的点击区域（PM提出的渣渣，更渣渣的是UX居然通过了这个需求）。 Talk is cheap, read the code. 123456789101112131415161718192021222324252627282930/** * 将初始加菜按钮点击矩形区域向外扩大 * @param parentView 包含更大点击区域的父View * @param unit 扩大的dp值 */ public void enlargeEmptyAddBtnClickArea(final View parentView, final int unit) &#123; parentView.post(new Runnable() &#123; @Override public void run() &#123; if (emptyAddBtn.getVisibility() != VISIBLE) &#123; return; &#125; checkContext(); Context context = getContext(); int[] emptyAddBtnCoord = new int[2]; emptyAddBtn.getLocationOnScreen(emptyAddBtnCoord); int[] parentViewCoord = new int[2]; parentView.getLocationOnScreen(parentViewCoord); int[] relativeCoord = &#123;emptyAddBtnCoord[0] - parentViewCoord[0], emptyAddBtnCoord[1] - parentViewCoord[1]&#125;; Rect delegateArea = new Rect(relativeCoord[0], relativeCoord[1], relativeCoord[0] + emptyAddBtn.getMeasuredWidth(), relativeCoord[1] + emptyAddBtn.getMeasuredHeight()); int enlargeUnit = ViewUtils.dip2px(context, unit); delegateArea.left -= enlargeUnit; delegateArea.top -= enlargeUnit; delegateArea.right += enlargeUnit; delegateArea.bottom += enlargeUnit; CustomTouchDelegate touchDelegate = new CustomTouchDelegate(delegateArea, emptyAddBtn); parentView.setTouchDelegate(touchDelegate); &#125; &#125;); &#125; 这样通过直接operateBtn.enlargeEmptyAddBtnClickArea就可以扩大点击区域。 乍看起来没什么问题对吧？代码中同样考虑到了如果加菜按钮当前不可见，就不会主动扩大其区域。 但是为什么，还会出现文章开头提到的“已售完的菜品仍然可以添加至购物车”问题！！！ 原因分析在debug后，发现问题出在这段代码中的判断 123if (emptyAddBtn.getVisibility() != VISIBLE) &#123; return;&#125; 当整个加减控件（OperateButton）的Visibility == INVISIBLE or GONE时，其内部emptyAddBtn的Visibility居！然！还！是！Visible！ 写个Demo验证一下 Talk is cheap, just codedemo功能很简单，外层的ViewGroup &amp; 内层的View，当outer置为不可见（INVISIBLE or GONE）时，输出inner的Visibility。界面如下： 验证后发现一个惊人的事实，Outer的Visibility不会影响Inner的Visibility！也就是说，不论Outer设置为Gone还是Invisible，只要Inner之前是Visible，那么调用inner.getVisibility()后，都会返回Visible！ 正确的判断方法View.java中为我们提供了isShown()方法，从注释中即可看出它会将外层ViewGroup可见性计算进去 123456789101112131415161718192021222324/** * Returns the visibility of this view and all of its ancestors * * @return True if this view and all of its ancestors are &#123;@link #VISIBLE&#125; */public boolean isShown() &#123; View current = this; //noinspection ConstantConditions do &#123; if ((current.mViewFlags &amp; VISIBILITY_MASK) != VISIBLE) &#123; return false; &#125; ViewParent parent = current.mParent; if (parent == null) &#123; return false; // We are not attached to the view root &#125; if (!(parent instanceof View)) &#123; return true; &#125; current = (View) parent; &#125; while (current != null); return false;&#125; 反思起初编码的时候，谁能想到，外层设置Invisibile后，内层View居然还是Visible的状态呢？ 出现这个问题的根本原因在于自己对View的机制研究不够深入，引以为戒。 更应该注意到View本身提供了isShown()方法来判断可见性，根本不需要使用Visibility来重复造轮子，更何况还是错误的轮子。 =========END=========","tags":[{"name":"技术流","slug":"技术流","permalink":"https://lilei.pro/tags/技术流/"}]},{"title":"Use DiffMerge As Default Git Diff Tool","date":"2016-06-22T04:58:54.000Z","path":"2016/06/22/Use-Diffmerge-As-Default-Git-Diff-Tool/","text":"使用DiffMerge作为默认的git diff GUI工具 P4Merge: 界面美观，功能强大，安装包大（100M） DiffMerge: 界面简单，功能一般，安装包小（10M） 配置方法123456$ git config --global merge.tool diffmerge$ git config --global mergetool.diffmerge.cmd \"/Applications/DiffMerge.app/Contents/MacOS/diffmerge --merge --result=\\$MERGED \\$LOCAL \\$BASE \\$REMOTE\"$ git config --global mergetool.keepBackup false$ git config --global diff.tool diffmerge$ git config --global difftool.diffmerge.cmd \"/Applications/DiffMerge.app/Contents/MacOS/diffmerge \\$LOCAL \\$REMOTE\" 使用方法1$ git difftool 参考链接：Configure DiffMerge for Your Git DiffTool","tags":[{"name":"技术流","slug":"技术流","permalink":"https://lilei.pro/tags/技术流/"}]},{"title":"macOS 通过终端启动 Sublime2","date":"2016-06-22T01:15:10.000Z","path":"2016/06/22/Launch-Sublime-In-Terminal/","text":"同样适用于 *nix 系统下通过控制台启动任何指令 将Sublime的启动命令加入到环境变量中macOS中，Sublime Text 2 的启动命令位于/Applications/Sublime Text 2.app/Contents/SharedSupport/bin中，该目录下仅有一个命令，就是subl。如果我们需要在终端中启动Sublime对文件foo.txt进行编辑，需要执行的指令是 1$ subl foo.txt 前提是，环境变量中包含了subl这个指令。在macOS中，有两种途径可以达成这个效果。 在~/.zshrc（我使用的是zsh）中添加$SUBLIME_HOME，并将$SUBLIME_HOME/bin添加至$PATH 在/usr/local/bin中创建指向subl的符号链接 两种方法具体实现分别如下所示： .zshrc，注意空格前需要用\\转义 12export SUBLIME_HOME=/Applications/Sublime\\ Text\\ 2.appexport PATH=$PATH:$&#123;SUBLIME_HOME&#125;/Contents/SharedSupport/bin 创建符号链接 1$ ln -s \"/Applications/Sublime Text 2.app/Contents/SharedSupport/bin/subl\" /usr/local/bin/subl 方法1适用于一个文件夹下多个命令的启动（比如Android SDK），方法2适用于单个指令的启动（比如Sublime）。 在Windows中我们怎么做在Windows中，我们可以通过类似方法2的途径，来快速启动某个应用，步骤如下： 任意位置创建一个文件夹A 将文件夹A加入到环境变量中 对于要快速启动的App，对其创建快捷方式后，把快捷方式重命名（比如lol），然后将快捷方式丢入A文件夹 以后可以通过cmd+R打开运行窗口后，直接输入lol来启动对应App ===Ending===","tags":[{"name":"技术流","slug":"技术流","permalink":"https://lilei.pro/tags/技术流/"}]},{"title":"Android Studio .gitignore 文件范本","date":"2016-06-22T01:09:14.000Z","path":"2016/06/22/Android-Studio-gitignore/","text":"一份标准的 Android Studio 工程 .gitignore 文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# Built application files*.apk*.ap_# Files for the ART/Dalvik VM*.dex# Java class files*.class# Generated filesbin/gen/out/# Gradle files.gradlebuild/# Local configuration file (sdk path, etc)local.properties# Proguard folder generated by Eclipseproguard/# Log files*.log# Android Studio Navigation editor temp files.navigation/# Android Studio captures foldercaptures/# Intellij*.iml.idea/# Keystore files*.jks# Windows thumbnail dbThumbs.db# OSX files.DS_Store# Eclipse project files.classpath.project# NDKobj/ ===Ending===","tags":[{"name":"技术流","slug":"技术流","permalink":"https://lilei.pro/tags/技术流/"}]},{"title":"Android中动态加载JNI失效问题探究(未完待续)","date":"2016-06-17T02:33:02.000Z","path":"2016/06/17/Dynamic-Loading-JNI-Not-Work/","text":"在做so动态加载时遇到了后加载的JNI方法失效的问题 背景描述在进行动态加载3期分享时，使用so文件的动态加载作为示例，发现一个有趣的现象——在某些情况下，通过System.load(&quot;foo.so&quot;)加载进来的so并没有生效。 先看作为示例的动态加载Demo代码。 声明的native接口 1public native String say(); C文件中实现方法很简单，返回一个预定义好的字符串Keep Quiet! jni.c 1234567#include \"com_leili_season1_jni_activity_JNIActivity.h\"JNIEXPORT jstring JNICALL Java_com_leili_season1_jni_activity_JNIActivity_say (JNIEnv *env, jobject obj) &#123; return (*env)-&gt;NewStringUTF(env, \"Keep Quiet!\");&#125; 初始化时，加载返回Keep Quiet!的so文件 123456@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; System.loadLibrary(\"Jni\"); // 写法A，通过System.loadLibrary()首次加载 System.load(getFilesDir().getParent() + \"/lib/libJni.so\"); // 写法B，通过System.load()首次加载 ... // 以下无关内容省略&#125; 点击按钮后加载新的so文件，其中修改了say()方法的返回值为Hello World! 12soFilePath = getFilesDir() + \"/libJni2.so\"; // /data/data/com.leili.season1/lib/libJni.soSystem.load(soFilePath); 此时再次调用say()后，根据预期，应该返回的是修改后的Hello World!。然而，如代码中的注释所写，使用写法A进行首次加载的so库，无法通过System.load(soFilePath)被覆盖；使用写法B进行首次加载的so库，却可以通过System.load(soFilePath)被覆盖。 原因探究第一个想法是，System.load和System.loadLibrary内部实现有差异，通过System.loadLibrary加载进来的so库，其方法无法被覆盖。 先来看一下SDK源码中这两个方法的细节，首先是System.load，使用SDK版本为23 System.load 过程System.java 123456/** * See &#123;@link Runtime#load&#125;. */public static void load(String pathName) &#123; Runtime.getRuntime().load(pathName, VMStack.getCallingClassLoader());&#125; 调用了Runtime中的load方法 Runtime.java 123456789101112/* * Loads the given shared library using the given ClassLoader. */void load(String absolutePath, ClassLoader loader) &#123; if (absolutePath == null) &#123; throw new NullPointerException(\"absolutePath == null\"); &#125; String error = doLoad(absolutePath, loader); if (error != null) &#123; throw new UnsatisfiedLinkError(error); &#125;&#125; 跟进 doLoad 方法查看 1234567891011121314151617181920212223242526272829303132333435363738394041private String doLoad(String name, ClassLoader loader) &#123; // Android apps are forked from the zygote, so they can't have a custom LD_LIBRARY_PATH, // which means that by default an app's shared library directory isn't on LD_LIBRARY_PATH. // The PathClassLoader set up by frameworks/base knows the appropriate path, so we can load // libraries with no dependencies just fine, but an app that has multiple libraries that // depend on each other needed to load them in most-dependent-first order. // We added API to Android's dynamic linker so we can update the library path used for // the currently-running process. We pull the desired path out of the ClassLoader here // and pass it to nativeLoad so that it can call the private dynamic linker API. // We didn't just change frameworks/base to update the LD_LIBRARY_PATH once at the // beginning because multiple apks can run in the same process and third party code can // use its own BaseDexClassLoader. // We didn't just add a dlopen_with_custom_LD_LIBRARY_PATH call because we wanted any // dlopen(3) calls made from a .so's JNI_OnLoad to work too. // So, find out what the native library search path is for the ClassLoader in question... String ldLibraryPath = null; String dexPath = null; if (loader == null) &#123; // We use the given library path for the boot class loader. This is the path // also used in loadLibraryName if loader is null. ldLibraryPath = System.getProperty(\"java.library.path\"); &#125; else if (loader instanceof BaseDexClassLoader) &#123; BaseDexClassLoader dexClassLoader = (BaseDexClassLoader) loader; ldLibraryPath = dexClassLoader.getLdLibraryPath(); &#125; // nativeLoad should be synchronized so there's only one LD_LIBRARY_PATH in use regardless // of how many ClassLoaders are in the system, but dalvik doesn't support synchronized // internal natives. synchronized (this) &#123; return nativeLoad(name, loader, ldLibraryPath); &#125;&#125;// TODO: should be synchronized, but dalvik doesn't support synchronized internal natives.private static native String nativeLoad(String filename, ClassLoader loader, String ldLibraryPath); 可以看到最终通过native调用nativeLoad加载了lib文件。 System.loadLibrary 过程System.loadLibrary 的写法是 1System.loadLibrary(\"Jni\"); 真实加载的so文件是libJni.so，可以猜想内部进行了一个拼接文件名的过程。 System.java 123456/** * See &#123;@link Runtime#loadLibrary&#125;. */public static void loadLibrary(String libName) &#123; Runtime.getRuntime().loadLibrary(libName, VMStack.getCallingClassLoader());&#125; Runtime.java中的loadLibrary方法 Runtime.java 123456789101112131415161718192021222324252627282930313233343536373839404142/* * Searches for and loads the given shared library using the given ClassLoader. */void loadLibrary(String libraryName, ClassLoader loader) &#123; if (loader != null) &#123; String filename = loader.findLibrary(libraryName); if (filename == null) &#123; // It's not necessarily true that the ClassLoader used // System.mapLibraryName, but the default setup does, and it's // misleading to say we didn't find \"libMyLibrary.so\" when we // actually searched for \"liblibMyLibrary.so.so\". throw new UnsatisfiedLinkError(loader + \" couldn't find \\\"\" + System.mapLibraryName(libraryName) + \"\\\"\"); &#125; String error = doLoad(filename, loader); if (error != null) &#123; throw new UnsatisfiedLinkError(error); &#125; return; &#125; String filename = System.mapLibraryName(libraryName); List&lt;String&gt; candidates = new ArrayList&lt;String&gt;(); String lastError = null; for (String directory : mLibPaths) &#123; String candidate = directory + filename; candidates.add(candidate); if (IoUtils.canOpenReadOnly(candidate)) &#123; String error = doLoad(candidate, loader); if (error == null) &#123; return; // We successfully loaded the library. Job done. &#125; lastError = error; &#125; &#125; if (lastError != null) &#123; throw new UnsatisfiedLinkError(lastError); &#125; throw new UnsatisfiedLinkError(\"Library \" + libraryName + \" not found; tried \" + candidates);&#125; 注意到这里参数中的libraryName仍然是形如Jni的不包含前缀lib与后缀.so的文件名。真正的文件名补全是在这一步进行的。 1String filename = loader.findLibrary(libraryName); BaseDexClassLoader.java 1234@Overridepublic String findLibrary(String name) &#123; return pathList.findLibrary(name);&#125; DexPathList.java 12345678910111213141516171819/** * Finds the named native code library on any of the library * directories pointed at by this instance. This will find the * one in the earliest listed directory, ignoring any that are not * readable regular files. * * @return the complete path to the library or &#123;@code null&#125; if no * library was found */public String findLibrary(String libraryName) &#123; String fileName = System.mapLibraryName(libraryName); for (File directory : nativeLibraryDirectories) &#123; String path = new File(directory, fileName).getPath(); if (IoUtils.canOpenReadOnly(path)) &#123; return path; &#125; &#125; return null;&#125; 绕了一圈，又回到System这个类中，看到下面这儿一目了然。 1234567891011/** * Returns the platform specific file name format for the shared library * named by the argument. On Android, this would turn &#123;@code \"MyLibrary\"&#125; into * &#123;@code \"libMyLibrary.so\"&#125;. */public static String mapLibraryName(String nickname) &#123; if (nickname == null) &#123; throw new NullPointerException(\"nickname == null\"); &#125; return \"lib\" + nickname + \".so\";&#125; 追踪过了补全文件名的过程，我们回到最初System.loadLibrary的代码中，可以看到与System.load一样，也是调用了同样的doLoad方法！！！ 到这里可能会有些困惑了，既然两者殊途同归，为什么在应用时会有差别呢？先别急，既然方法是同样的，会不会是参数有区别？ System.load &amp; System.loadLibrary 加载so库文件通过断点，分别查看以下两个语句的执行情况，果然发现了一丝区别 1System.loadLibrary(\"Jni\"); // 写法A，通过System.loadLibrary()首次加载 写法A加载的lib文件，真实路径是/data/app/com.leili.season1-1/lib/x86/libJni.so，这是用户app在安装时的路径（系统app安装目录为/system/app） 1System.load(getFilesDir().getParent() + \"/lib/libJni.so\"); // 写法B，通过System.load()首次加载 写法B加载的lib文件，真实路径是/data/data/com.leili.season1/lib/libJni.so。与我们的预期一致。 等等，我们通过adb shell看一下/data/data/com.leili.season1/lib/这个目录 1234root@vbox86p:/data/data/com.leili.season1 # lldrwxrwx--x u0_a174 u0_a174 2016-06-16 19:34 cachedrwx------ u0_a174 u0_a174 2016-06-16 19:34 fileslrwxrwxrwx install install 2016-06-17 10:28 lib -&gt; /data/app/com.leili.season1-1/lib/x86 发现了什么？目录/data/data/com.leili.season1/lib/竟然是指向/data/app/com.leili.season1-1/lib/x86的软链接。天哪！这说明，通过System.load(filePath)加载的so文件，与通过System.loadLibrary(libName)加载的so文件，压根就是同一个！ 我的天哪。。。明明是调用同样的方法加载同一个文件，为啥会出现两种截然不同的结果？！！！ 最新发现：初次加载时不用System.loadLibrary(&quot;Jni&quot;)，而用System.load(&quot;/data/app/com.leili.season1-2/lib/x86/libJni.so&quot;)来直接加载/data/app的库文件时，一样会阻止后续的加载！ 到这里被BLOCK住了，HELP～","tags":[{"name":"技术流","slug":"技术流","permalink":"https://lilei.pro/tags/技术流/"},{"name":"Android Performance Patterns","slug":"Android-Performance-Patterns","permalink":"https://lilei.pro/tags/Android-Performance-Patterns/"}]},{"title":"MT&DP Hackathon 小结","date":"2016-05-27T11:38:15.000Z","path":"2016/05/27/Hackathon-1-0/","text":"16年5月27日～28日，北京美团总部举办Hackathon，项目小结不论比赛排名如何、能否拿到奖品，学到知识才是自己硬实力的提升 Database部分VARCHAR, TEXTVARCHAR(n): 存储在列元素中；可以作为索引TEXT: 列元素中只保存一个指针，真实文本保存在另外的存储区域；不可作为索引 注：存储位置区别仅出现在MySQL上，对于InnoDB，如果VARCHAR类型的元素过长，内部仍然会使用TEXT形式的保存方案 实际应用中，要根据不同类型的输入，选择不同类型的格式 Type Case VARCHAR(X) user name, email, country, subject, password TEXT messages, emails, comments, formatted text, html, code, images, links MEDIUMTEXT large json bodies, short to medium length books, csv strings LONGTEXT textbooks, programs, years of logs files, harry potter and the goblet of fire, scientific research logging Node部分数据库连接一个典型的SELECT请求写法 1234567891011121314151617181920212223242526// 依赖mysql模块var mysql = require('mysql');// 创建连接，指定DB地址／用户名／密码／库名var pool = mysql.createPool(&#123; host: '10.4.232.53', user: 'mock_user', password: 'mock_user_pwd', database: 'live_show'&#125;);// exports以将接口暴露在模块外exports.queryComments = function (channelId, limit, callback) &#123; var select = 'SELECT `comment` FROM instant_comment where `channel_id` = \\'' + channelId + '\\' ORDER BY `id` DESC LIMIT ' + limit; console.log(\"queryComments: \" + select); // 建议每一次执行DB操作，都通过log记录下具体指令 pool.getConnection(function (err, conn) &#123; // 请求一个连接 if (err) throw err; // js里通常的写法，回调函数中第一个参数是err conn.query(select, function (err, rows, fields) &#123; if (err) &#123; throw err; &#125; else &#123; callback(rows); // 回调函数处理row &#125; conn.release(); // 注意！一定要在回调函数中释放连接，不然一旦进行10次（默认值）数据请求，就会导致连接打满而挂掉 &#125;); &#125;);&#125;; http请求一般写法是 12345678// handler为回调函数require('http').createServer(handler).listen(port);// handler写法function handler(req, resp) &#123; // do your business resp.write('this is response'); resp.end();&#125; 其中 resp.write(&#39;foo&#39;) resp.end() 也可以简写为 resp.end(&#39;foo&#39;) 数据Json化js中使用的是弱类型对象 1234var foo = &#123; code : 200, msg : '成功'&#125; 对于这种对象，直接使用 resp.write(foo.toString()) 是无法返回数据的，拿到的其实是对象在内存中的指针。这里要用 JSON.stringify(foo).toString() 来生成结果。 1resp.write(JSON.stringify(foo).toString()); 静态资源使用 express 框架，非常简单（@王善成 介绍说现在 koa 更为流行，待调研）。通过形如 http://10.4.232.53:9528/live_1.jpg 的地址来获取静态资源（不需要拼接 public） 1234require('express');var app = express();app.use(express.static('public')); // 项目目录下的public文件夹，即为静态文件目录app.listen(9528); 定时任务使用 setInterval(func, delay) 来执行周期任务，因为代码本身有运行时间，函数有调用时间，因此在时刻上并不会保证100%的精确，（如声明了3000ms，可能在2990时执行，也可能在3010时执行） 12345678// 定时任务,关闭不在保活列表里的直播源var livingPeriod = 10 * 1000; // 需要保活的直播,要在30s内调用保活接口setInterval(function() &#123; console.log(\"living shows: \" + livingShows); dbHelper.killDeadShow(livingShows, function () &#123; livingShows = []; // clear &#125;);&#125;, livingPeriod); ===Ending===","tags":[{"name":"技术流","slug":"技术流","permalink":"https://lilei.pro/tags/技术流/"}]},{"title":"使用Git对最近n个commit进行合并","date":"2016-03-31T13:22:41.000Z","path":"2016/03/31/Git-Squash-Commits/","text":"如何在Git中合并多次commit呢？ 通过Git对最近的n个commit进行合并，可以使用下面的命令 12$ git reset --soft HEAD~n$ git commit 炒鸡简单！ 如果要合并的是有间隔的commit，笔者目前还没有学会…","tags":[{"name":"技术流","slug":"技术流","permalink":"https://lilei.pro/tags/技术流/"}]},{"title":"Android Performance Patterns - s4ep7 Removing Unused Code","date":"2016-03-31T01:41:01.000Z","path":"2016/03/31/Android-Performance-Patterns-s4ep7-Removing-Unused-Code/","text":"Third party libraries can be some serious time savers for Android development. They allow us to do awesome things in our app without having to write any of the functionality ourselves. That’s a pretty big convenience. What’s not convenient though is the code-bloat they can often come with. Video Link Third Party Library在自己的app中使用第三方库有哪些优点呢？ 第三方库可以为我们提供便捷的功能 它们都经过了良好全面的测试，并且在生产环境中得到验证 而缺点可能就不那么明显 你必须引用整个第三方库，即使用到的只是其中一个简单的类——这被叫做code bloat（代码膨胀） 这会使你的apk体积增大 甚至可能触及65k的方法数天花板（关于65k，请查阅这一篇Building Apps with Over 65K Methods） 对于MultiDex，小哥给出了非常幽默的描述 It’s pretty much as much fun going to the dentist… Proguard作用 Shrink：精简代码，去除无用的类 Optimize：优化逻辑 Obfuscate：混淆，增加逆向工程的难度 一个例子是，使用Proguard后，原本8.4mb的Google IO app被缩减到了4.1mb 开启 proguard 也十分简单，只要在 gradle 文件中将 minifyEnabled 属性声明为 true，并写明 proguardFiles 路径 123456789android &#123; ... buildTypes &#123; release &#123; minifyEnabled true proguardFiles getDefaultProguardFile('proguard-android.txt') &#125; &#125;&#125; 需要注意的是，proguard会导致应用到“反射”的代码无法正常工作，因为它会改变方法名&amp;类名，需要用 keep 在相关代码上关闭proguard ProGuard 官方文档 ===Ending===","tags":[{"name":"技术流","slug":"技术流","permalink":"https://lilei.pro/tags/技术流/"},{"name":"Android Performance Patterns","slug":"Android-Performance-Patterns","permalink":"https://lilei.pro/tags/Android-Performance-Patterns/"}]},{"title":"骨盆前倾101","date":"2016-03-24T12:17:47.000Z","path":"2016/03/24/Fixing-Anterior-Pelvic-Tilt/","text":"前言骨盆前倾是一种不良的体态，如果你在早晨醒来不时感到下背部疼痛；在健身房里的里的深蹲、硬拉总会因为下背力竭而有所阻滞；身体曲线侧面看起来下腹向前、臀部向后突出，那么要当心，很可能你正在遭遇骨盆前倾。 什么是骨盆前倾骨盆前倾（Anterior Pelvic Tilt，简称APT），常见于久坐伏案工作人群，具体表现就是臀部后凸，腹部向前顶，前挺后撅，图中的第二种即为APT。 另外，在健身房里一些体态发展不均的人身上也经常看到骨盆前倾的现象，故也称为“健美腰”。 从骨骼透视图上来看 如何判断骨盆前倾判断骨盆前倾的原因有很多种，当然，去正规医院进行外科（脊柱）检验是最省事也最准确的方法。医学手段之外，还有一些显著特征可以比较容易的帮助我们鉴别骨盆前倾。 方法一：对镜自检，不管是健身房还是卧室的，只要有一面足够大的镜子，按照正常放松姿态站立，观察腰腹及臀部。 方法二：贴墙立正，如果背后能放入一掌，基本身姿还算正常；如果能放入一拳，很有可能是骨盆前倾。 方法三：在睡觉时，如果仰睡时腰部总是悬空，睡醒后伴随疼痛，以至于不得不采取侧卧方式入睡，这时也要小心了。 骨盆前倾的起因首先来看一下APT患者的脊椎与正常的脊椎，APT患者的尾椎呈现了一个夸张的弧度 造成这一切的根本原因是—— 肌力不均 想象你的盆腔，它的前上（腹直肌）、后下（臀大肌、腘绳肌）是肌肉组A，它的后上（竖脊肌）、前下（髂腰肌、股直肌）为肌肉组B。 A与B之间维持平衡时，人的盆腔处于一个刚好的直立状态。 A弱B强时，造成骨盆前倾，Anterior Pelvic Tilt（APT） A强B弱时，造成骨盆后倾，Posterior Pelvic Tilt（PPT） 力矩图 竖脊肌、髂腰肌太强（过短）导致骨盆前倾 正常状态下，腹直肌、臀大肌会起到抑制骨盆前倾的效果 为什么竖脊肌、髂腰肌会起一个负面作用呢？ 竖脊肌，也就是通常我们所说的“下背部”，当练习硬拉、深蹲时都会带到这部分肌肉。而肌肉越强壮，肌纤维往往也会变得越短越粗，导致拉动盆腔向前倾斜。 腹直肌、腹外斜肌、臀大肌、腘绳肌这几处肌肉，往往在训练中得不到重视，导致松垮无力，带不动盆腔回归。 说到底，就是一组拮抗肌相互之间发展不均的问题。 这位美国大叔很好地解释了骨盆前倾的起因，并介绍了几种容易操作的矫正方法。 YouTube视频，请自备云梯 Your Back is Whack!https://www.youtube.com/watch?v=BEn61BL4Nwk 骨盆前倾的危害 丑！让人小腹前凸、臀部横向发展并下垂；辛辛苦苦练成的8块／6块腹肌从侧面看就像裹在了一个球外面 腰椎前凸，病理性姿势不正确，必然会导致腰酸背痛，并且肩颈酸胀。此外骨盆承托着腹部内脏等，如果骨盆倾斜，也会导致内脏的运转不畅 僵硬的下背部成为阻碍硬拉、深蹲水平进一步提高的瓶颈 如果说骨盆前倾有什么好处的话，大概就是会产生“前凸后翘”的效果。你所见到的翘臀，极有可能是骨盆前倾造成的“伪”翘臀 如何矫正骨盆前倾矫正骨盆前倾，最根本的原则只有一点 增强弱势肌肉，拉伸强势肌肉 “弱势肌肉”：将骨盆拉回平衡状态的腹直肌、腹外斜肌、臀大肌、腘绳肌 “强势肌肉”：将骨盆向前倾状态拉动的髋部屈肌（髂腰肌 股直肌）、竖脊肌 一方面强化弱势肌肉，使身体增强将骨盆拉回原角度的扭力，另一方面拉伸强势肌肉，放松紧张的肌肉，拉长肌纤维 强化臀大肌、腘绳肌、腹外斜肌、腹直肌 臀大肌：臀桥，仰卧顶臀，美式硬拉 腘绳肌：俯卧腿弯举，反向腿弯举 腹肌：RKC平板支撑，反向卷腹，悬垂V字举腿 拉伸竖脊肌、髋部屈肌（髂腰肌、股直肌） 竖脊肌：泡沫轴放松、坐姿拉伸、扶杆下蹲 髂腰肌：弓步拉伸 股直肌：侧卧拉腿 下面是一些训练方法的图片，需要强调的是，每个人的身体条件不同，肌肉强弱有别，要根据实际情况选取不同的动作；就算是同一个动作，在做的时候使用不同的角度、拉伸不同的时间，也会产生迥异的效果。 臀大肌（强化）臀桥：下背放松，靠臀部收紧发力，顶峰收缩，感受臀大肌夹紧带来的刺激感。 臀桥对于塑造翘臀有着无可比拟的作用，注意在动作顶端时身体应该保持一条直线，腹部不要上顶。 进阶臀桥使用单腿支撑。 下面是视频讲解： https://youtu.be/viyoVBR_J5c 仰卧顶臀，臀桥的负重强化版，请量力而行，也可借助长凳顶在背部进行。 视频讲解： https://youtu.be/vSA-EBNUb-M 美式硬拉：我们Glute Lab已经发现在进行罗马尼亚硬拉训练时，臀部几乎没有参与活动，主要是腘绳肌，至少在轻负重的时候是这样。这不是一件好事。因此，我们需要了解在髋屈伸过程中如何利用臀大肌。美式硬拉与罗马尼亚硬拉非常相似，然而它加入了一些骨盆运动。在杠铃下降的过程中，你需要保持骨盆稍向前倾。在杠铃上升的过程中，你需要利用臀大肌的收缩来让骨盆稍向后倾。要注意的是骨盆后倾是由臀部的收缩挤压达成的！而不是腰椎翻转！当硬拉至躯干直立时，杠铃可能由于你的臀部收缩从而向前移动。你可以把美式硬拉想象成一种以臀部为中心的罗马尼亚硬拉。再次强调，依靠臀大肌使骨盆向后倾，保持腰椎稳定。 美式硬拉；杠铃位于底部时，保持脊柱中立；杠铃位于顶部时，弯曲胸椎（上背部），同时骨盆后倾 杠铃至顶部，挤压臀大肌但避免腰椎翻转 Dimel硬拉是几年前由路易·西蒙斯和美国西部杠铃俱乐部推广开来的。你可以看成是多次数的美式硬拉。用你最大重量的30%-40%负重练习15-30次硬拉，以最大化的刺激你的臀大肌，增强泵感。如果你动作正确，这和臀推（Hip Thrust）有点像的。 美式硬拉的视频演示：https://youtu.be/1aVjkPzKovc 另外，关于罗马尼亚硬拉、美式硬拉、屈腿硬拉、直腿硬拉，请参考下面这篇文章 http://www.actrainer.com/bbs/detail_962 腘绳肌（强化）俯卧腿弯举：大部分健身房里都会有的器械，注意训练时集中注意力到腘绳肌上，感受肌肉收缩。 反向腿弯举：需要借助特定器械或者伙伴帮助才能进行，持续对腘绳肌、臀大肌进行狂轰滥炸。 腹肌（强化）RKC平板支撑：这项平板支撑和一般的初始动作没有什么区别，但是你身体肌肉的紧张程度会相对较高，平衡感的要求也会更高，相当于一般平板支撑4倍的运动量，而且每组仅仅需要你10秒的时间，你就能够拥有坚实的6块腹肌了。让我们来接下来看一些RKC平板支撑应该怎么做。 先以传统的平板支撑做好准备姿势，小臂着地，与肩部处在一条直线上，双脚并拢，面部朝下。身体从头到脚呈一条直线。 双手握拳，两肩张开，小臂向地面用力，就好像你要把你的小臂往你的脚所在的地方拖拽一样。 臀部以及脚筋用力，让你的尾椎骨抬升至微微向头部倾斜，保持后背下部分挺直，这时你就会感觉到你的臀部和腿开始有相应的感觉了。保持膝盖打直。 保持姿势，注意保持整个身体肌肉的最大紧张程度。 RKCP的视频讲解：https://youtu.be/6TKktamzq4o 反向卷腹： 动作描述 仰卧开始，可以直腿，也可以曲腿。双手也可以抓住健身凳或床沿支撑。 使用腹肌的力量卷曲身体。慢慢将大腿拉近身体。下腰部离开地面。 慢慢放下，重复。 动作要点 重点不是大腿的运动，而是腹肌带动躯干的卷曲！你甚至可以不改变大腿与身体的角度（腿和髂等肌群就不发力了）。 试着把大腿和躯干的角度维持固定。 V字举腿：《囚徒健身》里面，“六艺”中的“举腿”最终式，注意在举起－下放的过程中有意识地控制腹部肌肉——尤其是下腹部，不要借助惯性甩上去。 视频讲解：https://youtu.be/rI1xHnMVcfk 竖脊肌（拉伸）泡沫轴放松 泡沫轴讲解视频（同样来自YouTube） https://youtu.be/QJLxruO3su0 坐姿拉伸：坐在椅子上，双脚打开，臀部坐在椅面的前面，上身直立双手交叉从后面抱住颈部的下端（颈椎与胸椎交界的肩部位置）。慢慢地双手用力，身体逐步往下压，直到头部低于椅面后进一步弯向椅子的后面，这时感觉到腰背部的肌肉充分被拉长拉紧，尤其是下腰部可能还有酸痛的感觉，保持这样的姿势10~20秒（心里读数20~40下）后，缓慢返回起始位置。 髂腰肌（拉伸）弓步拉伸：采用单跪式的体位，保持上身直立（腹部不能往前挺），前面的腿保持大腿与小腿成90°。身体逐步往下坐开始拉伸，后面的腿尽量往后伸和下压，感觉到腰椎以及髋关节被拉紧，维持10~20秒（心里读数20~40下）后慢慢抬起身体回到起始位置完成一侧的拉伸。更换姿势重复动作拉伸另一侧的髂腰肌后完成两侧的拉伸。注意在动作的过程中，腹部不能往前挺。 股直肌（拉伸）美女演示的卧姿拉伸 https://youtu.be/cWuVcqvoEFo 侧卧拉腿：选择采用比较舒适的卧位进行自我拉伸。侧身平躺在垫子上，远离地面的手抓住同侧的脚背，保持身体挺直。抓住脚背的手慢慢用力，将腿往自己身体的后上方拉和往臀部靠，到达大腿和骨盆都处于后伸的位置，明显感觉股直肌被拉紧并有隐隐的痛感时往回放松一丁点儿便保持在这样的位置10~20秒（心里读数达到20或40下），缓慢放松回到起始位置，完成单侧股直肌的一次拉伸后，进行另一侧的拉伸。 参考资料&amp;扩展阅读https://www.t-nation.com/training/dont-be-like-donald-duck http://www.styleforum.net/t/380309/oksus-guide-to-anterior-pelvic-tilt-apt http://zhuanlan.zhihu.com/oh-hard/19986866 http://tieba.baidu.com/p/2492811917 ===Ending===","tags":[{"name":"大保健","slug":"大保健","permalink":"https://lilei.pro/tags/大保健/"}]},{"title":"nova自动化测试后续内容安排","date":"2016-03-24T09:27:17.000Z","path":"2016/03/24/Nova-Automation-Develop-Plan/","text":"上篇链接 milestone 1 milestone 2 appium 1. 配置在独立机器2. 使用命令行启动 n/a mock server 1. 配置在独立机器 2. 多终端注册3. 多终端配置加载4. 使用sql数据库存储配置文件5. 精简代码，删除无用功能 1. 梳理日志 test case 1. 排队全套用例2. 用例模板优化3. 用例执行过程可以截屏 1. 用例执行报告（email）2. 每日构建，自动执行3. 其它业务线主流程case 完成节点 排队业务主流程回归迁移到自动化测试 n/a with iOS 前提 iOS本身有清晰化的MVC结构，对View做测试 优点 组件输入的组合 包含截图的报表 不够完善 人肉验证 改进 mock server 平台化，可供 iOS 使用 appium 文档阅读 http://appium.io/slate/en/master/?java#introduction-to-appium appium的设计思想 You shouldn’t have to recompile your app or modify it in any way in order to automate it. You shouldn’t be locked into a specific language or framework to write and run your tests. A mobile automation framework shouldn’t reinvent the wheel when it comes to automation APIs. A mobile automation framework should be open source, in spirit and practice as well as in name! Parallel Android Tests -p the main Appium port-U the device id-bp the Appium bootstrap port–chromedriver-port the chromedriver port (if using webviews or chrome)–selendroid-port the selendroid port (if using selendroid) If we had two devices with the ID’s 43364 and 32456, we would start two different Appium servers with the following commands: node . -p 4492 -bp 2251 -U 32456 node . -p 4491 -bp 2252 -U 43364 ignoreUnimportantViews Another example of a use-case for settings would be telling appium to ignore elements which are not visible.s","tags":[{"name":"技术流","slug":"技术流","permalink":"https://lilei.pro/tags/技术流/"},{"name":"自动化测试","slug":"自动化测试","permalink":"https://lilei.pro/tags/自动化测试/"}]},{"title":"Android Performance Patterns - s4ep6 Service Performance Patterns","date":"2016-03-20T11:03:45.000Z","path":"2016/03/20/Android-Performance-Patterns-s4ep6-Service-Performance-Patterns/","text":"Services are an integral component of almost every android application. But the functionality they provide comes with a drain on battery and system resources. And if you’re not paying attention, services can easily stick around longer than they should which wastes system resources, and can often cause performance problems for your rendering thread. But Colt McAnlis has the answer : using services in the most efficient way possible means killing them off the right way, and sometimes, not even using them.Video Link On System Level, Services Ain’t Free创建、销毁 Service 需要时间与内存 Service May Cost Frame Lost 作为 Local Service 启动，对应的 Service 运行在主进程的主线程上 作为 Remote Service 启动，对应的 Service 则是运行在独立进程的主线程上 对于1中的情况，如果 Service 中进行了耗时操作（超过了16ms），则在屏幕绘制时可能引起丢帧。 Don’t Use Servicesif you don’t have to… 参见下一节罗列的 Solutions Async Event Functions GCM BroadcastReceiver LocalBroadcastReceiver HandlerThreads AsyncTaskLoaders IntentService Do not Let Services Live Longer Than They NeededService 有两种不同的启动方法，对应的种植方法也为两种 Started Services：在 Service 中调用stopSelf()，或者在外面调用stopService()来终止 Bound Services：通过unBindService()来终止 Mixed：如果是先通过startService()启动，再用bindService()绑定的 Service，那么在unBind()后，还要显示通过stopService()来终止 Tools 光头哥又在推销 Systrace 了 ===Ending===","tags":[{"name":"技术流","slug":"技术流","permalink":"https://lilei.pro/tags/技术流/"},{"name":"Android Performance Patterns","slug":"Android-Performance-Patterns","permalink":"https://lilei.pro/tags/Android-Performance-Patterns/"}]},{"title":"Android Performance Patterns - s4ep5 Minimizing Asset Payload","date":"2016-03-08T13:29:35.000Z","path":"2016/03/08/Android-Performance-Patterns-s4ep5-Minimizing-Asset-Payload/","text":"No matter how aggressively you’ve optimized your networking code for performance, there’s still a huge problematic performance issue that you haven’t seen: Bloated asset files. If you’re not aggressively attacking the size of the assets you’re transferring to your users, you’re basically stealing time (and money) from them.Video Link Smaller Is Better 速度缓慢并不是所有用户都处于高速的4G／wifi环境下 大数据量导致的大电量消耗 流量＝金钱 引起数据流量过大的，主要有两个因素：图片、序列化数据。 Images 如果不需要图片透明度设定，那就尽量不要使用PNG格式的图片文件，这会产生难以置信的图片体积。 JPG和WEBP是不错的选择，在使用这两种图片格式时，记住图片质量的极小降低，可以大大缩小图片体积。 图片的分辨率并不是越大越好，根据具体的使用场景，返回不同像素的图片。如果只是需要缩略图，那就不要返回高清的无码大图。 Serialized DataJSON /dʒeɪ’sʌn/ 是一个horrible的数据格式！！！ 看看下面的代码，包含了大量的空格、引号、key值等冗余信息，这些字段存在的意义只是为了方便人工阅读，并非数据传输。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&#123; \"__name\": \"MOPayOrderDo\", \"RefundDetails\": [\"10.1元 2016-02-12 20:00 退款\", \"10.02元 2016-02-17 19:00 退款\", \"10.003元 2016-02-18 17:00 退款\", \"10.0004元 2016-02-18 18:00 退款\"], \"BaseOrderId\": null, \"OriAmount#D\": 2.123456, \"RemainAmount#D\": 100.123456, \"SerializedId\": null, \"RepayUrl\": \"dianping://shopinfo?id=2062015\", \"CurrentAmount#D\": 0.01, \"SaveAmount#D\": 0, \"OrderRemarks\": null, \"ErrorMsg\": \"支付成功|此为付款凭证，请向商户展示\", \"SerialNumber\": \"80033630111\", \"RightDos\": null, \"MerchantAmountString\": \"\", \"Discounts\": null, \"HuiTicketShareDo\": &#123; \"__name\": \"HuiTicketShareDo\", \"TicketValidPeriod\": \"\", \"TicketDesc\": \"\", \"TicketValue\": \"\", \"TicketShareStatus#I\": 0, \"TicketButtonClickable\": false, \"PayTicketDesc\": \"\", \"TicketPicUrl\": \"\", \"TicketTitle\": \"\", \"TicketButtonText\": \"\", \"ShareDo\": null, \"ExtraTickets\": \"\" &#125;, \"ShopID#I\": 2062015, \"PointMallDo\": null, \"RefundAmount#D\": 40.1234, \"BuffetDescs\": null, \"PayFailDescription\": \"您的付款将于1-5个工作日原路退还\", \"Time#U\": 1442469357, \"HuiReviewInfo\": null, \"Banner\": null, \"OrderID#I\": 43956789, \"VoucherSerials\": [], \"Status#I\": 3, \"OperationBanners\": null, \"AlertLoginTips\": \"绑定手机后订单不会丢哦\", \"AlertLoginLink\": &#123; \"__name\": \"Link\", \"Name\": \"现在去绑定\", \"Url\": \"\" &#125;, \"MerchantAmount#D\": 0.01, \"ServiceUrl\": null, \"StatusMsg\": \"已退款\", \"ContactMerchantTip\": \"\", \"OrderDetailTipsDo\": null, \"ShopPhones\": [ \"4008205527\" ], \"ShopName\": \"大众点评网\", \"IsHobbit#I\": 0, \"NoDiscountAmount#D\": 0, \"SuccessMsg\": \"请向服务员出示验证码\", \"HasVoiceReport\": false, \"MobileNo\": \"13774283697\", \"VerifyStatus#I\": 2, \"MOPayShare\": &#123; \"__name\": \"Share\", \"IconUrl\": \"http://qcloud.dpfile.com/pc/9vKBXqRXPl6vyOVFe4zlXMLys21f38u--LZmWbufGI2pRKzSBzQnLPwzWURFZUAvtOnd3gXQdDYlAqlaVaAFeZ0rYYyiRo_EhzufqWWjTjs.jpg\", \"Title\": \"在【大众点评网】不用现金，手机买单有优惠!\", \"Desc\": \"\", \"BtnText\": null, \"Url\": \"http://m.dianping.com/hui/share/weixin?shopId=2062015\" &#125;, \"UserAmountString\": \"&#123;\\\"userAmount\\\":\\\"1.123456元\\\",\\\"boughtVoucher\\\":\\\"\\\",\\\"usedVoucher\\\":\\\"\\\"&#125;\", \"BizType#I\": 10&#125; 光头哥在video中给出了几种高效的序列化替代方式，讲解参见Serialization performance (Android Performance Patterns Season 4 ep14) Protocol Buffers Nano-Proto-Buffers FlatBuffers 同样，在http压缩过程里，也有进一步优化的空间，参见Smaller Serialized Data (Android Performance Patterns Season 4 ep15) ===Ending===","tags":[{"name":"技术流","slug":"技术流","permalink":"https://lilei.pro/tags/技术流/"},{"name":"Android Performance Patterns","slug":"Android-Performance-Patterns","permalink":"https://lilei.pro/tags/Android-Performance-Patterns/"}]},{"title":"Android Performance Patterns - s4ep4 Adapting to Latency","date":"2016-03-08T12:26:26.000Z","path":"2016/03/08/Android-Performance-Patterns-s4ep4-Adapting-to-Latency/","text":"One of the most frequent performance problems your users will notice is how your app reacts when moving from a great network connection to a bad one. If things slow down, get sluggish, or start showing too many spinners, they can show your app the “uninstall“ button.Video Link Bottlenecks Happen Anywhere在一次由app发起的网络请求过程中，会建立“手机－基站－负载均衡服务器－后端server”的一个往复链路，在这个链路的任何一个环节，都可能造成网络请求的延迟。 Adapting To Lagency为了适应复杂多变的网络环境，必须做下面两件事： Gather information. Make adjustments. SDK中为我们提供了判断当前网络环境的Api 123456789ConnectivityManager cm = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);NetworkInfo activeNetwork = cm.getActiveNetworkInfo();if (activeNetwork.getType() != ConnectivityManager.TYPE_WIFI) &#123; String typeName = activeNetwork.getSubtypeName(); int type = activeNetwork.getSubtype(); switch (type) &#123; // do the cases &#125;&#125; 不同网络环境的基本传输速度如下图所示： Do It Yourself然而，即使判断出当前处于诸如LTE的网络环境，依然不能完全保证较高的传输速度，比如，瓶颈可能发生在服务端。 这时就需要主动去测算当前网络延迟了，多次测算后，求平均值。 接着，你可以定义出三个网络状况区间，以60ms、220ms为界 GOOD OK BAD &lt; 60ms 60ms ~ 220ms &gt; 220ms 更多的预加载，几乎不需要缓存 依赖缓存，拒绝部分网络请求 拒绝大部分网络请求，只加载重要信息 当然，阈值（60ms、220ms）不是固定的。 Tools在测试时，针对难测的网络环境条件，可以使用一些工具进行延时模拟。 Emulator Throttling: http://developer.android.com/tools/devices/emulator.html Network Attenuator: http://developer.att.com/developer/legalAgreementPage.jsp?passedItemId=14500040 ===Ending===","tags":[{"name":"技术流","slug":"技术流","permalink":"https://lilei.pro/tags/技术流/"},{"name":"Android Performance Patterns","slug":"Android-Performance-Patterns","permalink":"https://lilei.pro/tags/Android-Performance-Patterns/"}]},{"title":"Android Performance Patterns - s4ep3 Effective Prefetching","date":"2016-03-08T12:03:11.000Z","path":"2016/03/08/Android-Performance-Patterns-s4ep3-Effective-Prefetching/","text":"If you’re looking for the optimal way to batch requests to reduce overall network traffic, then prefetching is for you.Video Link Why Prefetching?很多场景下，app发出的网络请求是连续的，譬如，一个正在下拉中的每一项都包含一张缩略图的列表。 如果可以预见的话，将未来即将发生的网络请求合并到一起进行发送，比起单独来发送各自请求，一方面减少了网络请求对于资源的消耗（如：节约电量与带宽），另一方面也使得app界面运行更加流畅。 但是，如何确定预加载的度，是一个值得思考的问题。加载的太少了，起不到期望的效果；加载太多了，反而拖慢app。 How much do we prefetch?有2个可以参考的指标 空间：预加载1~5mb的数据 时间：预加载未来1~2min内会用到的数据 此外，预加载必须要考虑用户所处的网络环境 4G：12张图片 2G：3张图片 一个很好的衡量用户网络环境的方法是，计算某一个特定大小文件的传输时间。 在一个网络连接的窗口期，可以把之前hold住的网络请求，连同后面即将加载的网络请求一同打包发送。 GcmNetworkManager为你提供了强力的工具用以完成上面的需求。 ===Ending===","tags":[{"name":"技术流","slug":"技术流","permalink":"https://lilei.pro/tags/技术流/"},{"name":"Android Performance Patterns","slug":"Android-Performance-Patterns","permalink":"https://lilei.pro/tags/Android-Performance-Patterns/"}]},{"title":"Android Performance Patterns - s4ep2 Optimizing Network Request Frequencies","date":"2016-03-07T12:11:36.000Z","path":"2016/03/07/Android-Performance-Patterns-s4ep2-Optimizing-Network-Request-Frequencies/","text":"Syncing too often, can be the worst idea for the performance of your application.Video Link Do not Over Sync对于用户来说，有些信息是要保持最新的（天气、账户余额等等），有些信息却不必时刻更新，太频繁的同步操作反而过犹不及： 耗电量：比起待机，网络请求会消耗更多的电量 网络流量：同样，会占用带宽，小心用户在收到流量账单变得抓狂 Sync Less, Win More优化缓存的关键在于区分数据是当下立即需要的还是稍后请求也无伤大雅的，比如，用户进行下拉刷新，显然需要马上向服务器请求数据。而后台进行的数据下载与上传，相比之下就不那么重要。 Don’t Always Poll, Just Listen不要试图经常轮询Server请求新数据，这并没有什么卵用，要知道很多情况下数据在服务端根本就没有更新。 使用诸如Google Cloud Messaging的服务进行从Server发起的push —— What the hell is this? 由于天朝的特殊性，GCM无法使用，因此诞生了诸如极光推送等一系列替代品，一些有能力的大厂干脆自己实现消息推送系统，可以参考微信这篇文章：Android微信智能心跳方案 如果不得不采用客户端轮询来做，考虑二进制退让算法 因地制宜下面这个听起来就有一些炫酷了：根据用户当前不同的行为模式采取不同的同步策略，比如用户在驾驶时、跑步时、睡觉时…… 比如，当你监测到用户刚刚从8小时的睡眠中醒来并开启手机时，不妨马上进行一次同步。 根据是否正在充电、是否连接wifi等配置信息，调节同步时间： 然而，场景那么多，你要怎么办呢？ 幸运的是，你并不需要为此实现太多复杂的逻辑，参考GCM Network Manager ===Ending===","tags":[{"name":"技术流","slug":"技术流","permalink":"https://lilei.pro/tags/技术流/"},{"name":"Android Performance Patterns","slug":"Android-Performance-Patterns","permalink":"https://lilei.pro/tags/Android-Performance-Patterns/"}]},{"title":"Android Performance Patterns - s4ep1 Cachematters for networking","date":"2016-03-07T01:31:26.000Z","path":"2016/03/07/Android-Performance-Patterns-s4ep1-Cachematters-for-networking/","text":"You know what the fastest, most efficient piece of content for networking performance is? The one you never have to download.Video Link Reading data from local memory v.s. Reading data from network 访问本地数据的速度要远远快于访问网络数据（废话！）。接下来，文章中会介绍一些本地缓存的策略与实现。 Enable Http Caching默认情况下，Http Cache在Android系统中是关闭的，需要使用HttpResponseCache手动开启，如下代码： 12345678910111213141516protected void onCreate(Bundle savedInstanceState) &#123; try &#123; File httpCacheDir = new File(context.getCacheDir(), \"http\"); long httpCacheSize = 10 * 1024 * 1024; // 10 MB HttpResponseCache.install(httpCacheDir, httpCacheSize); &#125; catch (Exception e) &#123; Lot.i(TAG, \"Http response cache installation failed\" + e); &#125;&#125;protected void onStop() &#123; HttpResponseCache cache = HttpResponseCache.installed(); if (cache != null) &#123; cache.flush(); &#125;&#125; 这样做会为所有的Http请求提供缓存，不仅是自己代码中发出的，也包括所依赖外部jar包发出的请求。 InvalidationCache有两种最基本的过期的策略：空间（Cache空间不足时触发）和时间（Cache超过过期时间后触发）。 在 Http 1.x 的header中，用Cache-Control来标示缓存策略。 HttpResponseCache的限制HttpResponseCache通过Server来控制所有Cache策略，这在大部分场景是没有问题的，毕竟Server知道它返回给Client的具体内容是什么（文字、图片、文件等等），然而，移动应用的特殊性使得它还需要更精细的控制。 Server可能在Header中压根就没有为Cache-Control赋值 移动设备的存储空间有限以至于无法保存Cache数据 网络环境高延迟 因此，你需要自己定制一个Cache框架并引入Cache功能，这两件事不得不做： Write your own Disk Cache manager Use custom Caching Logic 可以参照已有的DiskLruCache 不同数据的各自属性通常要求各异的Cache策略，比如，文字提示语的过期时间与头像的过期时间是不同的。 Codes &amp; Tools一些优秀的网络请求框架 Volly: https://developer.android.com/training/volley/index.html OkHttp: http://square.github.io/okhttp Picasso: http://square.github.io/picasso AndroidStudio提供了查看网络数据流量的Network Traffic Tool 更专业的工具是AT&amp;T提供的ARO tool ===Ending===","tags":[{"name":"技术流","slug":"技术流","permalink":"https://lilei.pro/tags/技术流/"},{"name":"Android Performance Patterns","slug":"Android-Performance-Patterns","permalink":"https://lilei.pro/tags/Android-Performance-Patterns/"}]},{"title":"长宁国际体操中心游泳馆开放时间","date":"2016-03-04T01:45:22.000Z","path":"2016/03/04/Changning-Swimming-Pool-Opening-Hours/","text":"🏊🏊🏊🏊🏊🏊🏊🏊🏊🏊🏊🏊🏊🏊🏊 性价比最高时段依旧为工作日6:30~8:30，水质好，人少，价格低游泳馆网址：link ===Ending===","tags":[{"name":"大保健","slug":"大保健","permalink":"https://lilei.pro/tags/大保健/"}]},{"title":"Android Performance Patterns - s5ep10 Profile GPU Rendering, M Update","date":"2016-02-25T13:49:59.000Z","path":"2016/02/25/Android-Performance-Patterns-s5ep10-Profile-GPU-Rendering/","text":"Season 5 的最后一期，Android M 中新增了GPU渲染分析工具光头哥，我们下一季再见！PS. 光头哥的大名是 Colt McAnlisVideo Link Why GPU Profile Tool用户在使用app时，并不关心你的代码内部使用了多么NB的算法、多么碉堡的框架，用户最直观的体验是——你的app有没有卡顿、会不会丢帧。同网站一样，app加载的时间越长，用户流失也就越严重。因此，找到画面卡顿的原因便格外重要。 GPU Profiling Tool Before M在笔者的Meizu手机上（Android 5.0），可以在开发者选项中开启“GPU呈现模式分析”来查看CPU绘制情况。现在笔者打开微信朋友圈的一个链接（html5页面） 结合说明，可以初步判断那一条暴增的曲线是由于Process过程所致。 Strongerrrrrrr!Android M 为我们提供了更为强大的GPU渲染分析工具，可以细化到以下8个维度，注意到1、2、4也就是上一节图中的三个维度（Process、Execute、Update），它们保持了与历史相同的颜色！ 下面我们着重分析一下另外的五项指标。 Sync &amp; Upload 这项指数衡量了bitmap被同步到GPU的耗时，越大的图像，数值越高，通常处理高像素的图片时会导致飙升。 减少同时展示的图片数量，或者对图片进行预处理，降低图片尺寸可以有效降低数值。 Measure / Layout 过高的指数，表明页面布局过于复杂（super complex view hierarchy） 也可能是由于double taxation所致（关于double layout taxation请参阅Season 3 ep 8） 试着简化布局 Animation 若GPU在动画上的负载过高，去检查你所使用到的自定义动画 谨慎使用 PropertyAnimation Input Handling GPU消耗了多少时间用于处理用户输入 或者说，在相应用户输入的callback中，GPU的消耗 如果处理输入的逻辑过于复杂，使用Worker Thread Misc / Vsync Delay 如果你从日志中看到诸如“misc vsync … skipping … frames”的信息，That’s this thing! 发生在相邻两帧之间的事情，都可以归类于此 使用Worker Thread来处理耗时操作，避免丢帧 A Bigger Bar上面提到了5个维度，加上之前的3个，一共是8个维度。要把这8个维度同时用柱状图展示出来可不是件容易的事，这对你的视力有着相当的要求。 方便的是，GPU工具里贴心地适当扩宽加重了那些可能有问题的标示，你会看到一个更醒目的柱状图展示。 Bye Bye! Colt McAlnisSee you in Season 6! ===Ending===","tags":[{"name":"技术流","slug":"技术流","permalink":"https://lilei.pro/tags/技术流/"},{"name":"Android Performance Patterns","slug":"Android-Performance-Patterns","permalink":"https://lilei.pro/tags/Android-Performance-Patterns/"}]},{"title":"Android Performance Patterns - s5ep9 The Importance Of Thread Priority","date":"2016-02-25T12:57:25.000Z","path":"2016/02/25/Android-Performance-Patterns-s5ep9-The-Importance-Of-Thread-Priority/","text":"CPU同一时间只能处理有限数目的线程，赋予线程怎样的优先级，将决定其最终在CPU上得以执行的顺序光头哥回归啦！读信的样子简直不要太萌！Video Link Thread Scheduling线程调度是现代计算机系统必不可少的功能，Android做为独特的移动系统，在线程调度上，还有一些它与众不同的特性。 Android系统中对于线程优先级的考虑，还会包括以下方面： Activity生命周期 是否可见 Activity在前台还是运行 Visible vs InvisibleCPU时间的90%左右，都是用以处理界面展示中的线程，只有约10%留给了后台线程 拼爹的线程在线程的世界里，一样要拼爹——新创建的线程，其优先级与创建它的线程相同。 也就是说，如果UI Thread创建了20个Worker Thread，那么这20个Worker Thread都具有相同的优先级，它们会平等竞争CPU时间。 这其实是很不好的，我们知道哪些工作更重要，哪些工作相比于其它不那么重要，所以我们要主动设置线程优先级，让那些具有更高优先级的线程优先得到执行。 Priority1android.os.Process.setThreadPriority(int); 上面的方法接受-20~24闭区间内所有的整数作为参数，数值越小，优先级越高。为甚么采用负数呢？数值越低，表示这个线程越没有耐心，情绪越暴躁，越急切希望得到执行。 android.os.Process中为我们定义了一些表示线程优先级的常量。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** * Standard priority of application threads. * Use with &#123;@link #setThreadPriority(int)&#125; and * &#123;@link #setThreadPriority(int, int)&#125;, &lt;b&gt;not&lt;/b&gt; with the normal * &#123;@link java.lang.Thread&#125; class. */ public static final int THREAD_PRIORITY_DEFAULT = 0; /* * *************************************** * ** Keep in sync with utils/threads.h ** * *************************************** */ /** * Lowest available thread priority. Only for those who really, really * don't want to run if anything else is happening. * Use with &#123;@link #setThreadPriority(int)&#125; and * &#123;@link #setThreadPriority(int, int)&#125;, &lt;b&gt;not&lt;/b&gt; with the normal * &#123;@link java.lang.Thread&#125; class. */ public static final int THREAD_PRIORITY_LOWEST = 19; /** * Standard priority background threads. This gives your thread a slightly * lower than normal priority, so that it will have less chance of impacting * the responsiveness of the user interface. * Use with &#123;@link #setThreadPriority(int)&#125; and * &#123;@link #setThreadPriority(int, int)&#125;, &lt;b&gt;not&lt;/b&gt; with the normal * &#123;@link java.lang.Thread&#125; class. */ public static final int THREAD_PRIORITY_BACKGROUND = 10; /** * Standard priority of threads that are currently running a user interface * that the user is interacting with. Applications can not normally * change to this priority; the system will automatically adjust your * application threads as the user moves through the UI. * Use with &#123;@link #setThreadPriority(int)&#125; and * &#123;@link #setThreadPriority(int, int)&#125;, &lt;b&gt;not&lt;/b&gt; with the normal * &#123;@link java.lang.Thread&#125; class. */ public static final int THREAD_PRIORITY_FOREGROUND = -2; /** * Standard priority of system display threads, involved in updating * the user interface. Applications can not * normally change to this priority. * Use with &#123;@link #setThreadPriority(int)&#125; and * &#123;@link #setThreadPriority(int, int)&#125;, &lt;b&gt;not&lt;/b&gt; with the normal * &#123;@link java.lang.Thread&#125; class. */ public static final int THREAD_PRIORITY_DISPLAY = -4; /** * Standard priority of the most important display threads, for compositing * the screen and retrieving input events. Applications can not normally * change to this priority. * Use with &#123;@link #setThreadPriority(int)&#125; and * &#123;@link #setThreadPriority(int, int)&#125;, &lt;b&gt;not&lt;/b&gt; with the normal * &#123;@link java.lang.Thread&#125; class. */ public static final int THREAD_PRIORITY_URGENT_DISPLAY = -8; /** * Standard priority of audio threads. Applications can not normally * change to this priority. * Use with &#123;@link #setThreadPriority(int)&#125; and * &#123;@link #setThreadPriority(int, int)&#125;, &lt;b&gt;not&lt;/b&gt; with the normal * &#123;@link java.lang.Thread&#125; class. */ public static final int THREAD_PRIORITY_AUDIO = -16; /** * Standard priority of the most important audio threads. * Applications can not normally change to this priority. * Use with &#123;@link #setThreadPriority(int)&#125; and * &#123;@link #setThreadPriority(int, int)&#125;, &lt;b&gt;not&lt;/b&gt; with the normal * &#123;@link java.lang.Thread&#125; class. */ public static final int THREAD_PRIORITY_URGENT_AUDIO = -19; 此外，还有两个常量用于提高／降低优先级，记住，负数越小，优先级越高（more favorable）。 123456789/** * Minimum increment to make a priority more favorable. */public static final int THREAD_PRIORITY_MORE_FAVORABLE = -1;/** * Minimum increment to make a priority less favorable. */public static final int THREAD_PRIORITY_LESS_FAVORABLE = +1; 有了上面的知识，你就可以在UI Thread启动Worker Thread时，通过setPriority(THREAD_PRIORITY_DEFAULT + THREAD_PRIORITY_LESS_FAVORABLE * n)的方式，酌情降低Worker Thread的优先级了。 That’s How We Did It!还记得之前我们总是提到的 AsyncTask/HandlerThread/ThreadPool/IntentService 么？其中AsyncTask和IntentService已经为自动我们实现了“降低Worker Thread优先级”的功能，我们无需额外设置。而另外两种则没有这么周到，我们需要主动设置工作线程优先级。 ===Ending===","tags":[{"name":"技术流","slug":"技术流","permalink":"https://lilei.pro/tags/技术流/"},{"name":"Android Performance Patterns","slug":"Android-Performance-Patterns","permalink":"https://lilei.pro/tags/Android-Performance-Patterns/"}]},{"title":"Android Performance Patterns - s5ep8 Threading And Loaders","date":"2016-02-25T01:25:53.000Z","path":"2016/02/25/Android-Performance-Patterns-s5ep8-Threading-And-Loaders/","text":"Let’s say you’ve got some 20 bitmaps being decoded on a worker thread. Well, what happens if your activity is destroyed before that work completes?相比于本期的大叔，笔者更喜欢之前的光头哥Video Link No One Writes to the Colonel 五十六年了，上校唯一做过的事情就是等待。 我们知道，Worker Thread是在UI Thread之外用来处理耗时任务的线程，存在这样一种情况，当任务由Worker Thread执行完毕时，引发这项任务的Activity已经走完了onDestroy，这会产生什么样的后果呢？ 第一，Activity虽然结束了它的生命周期，可这个实例并没有从内存中释放——因为Worker Thread还拥有着Activity的reference，这会导致内存泄漏，如图1；第二，已经onDestroy过的Activity早已从屏幕上消失，无法响应任务执行后的返回，我们必须重新创建Activity2来处理任务返回后界面变化，如图2。 图1 图2 You Should Use Loaders针对上面的场景，建议使用Loader。设计合理的Loader可以避免内存泄漏、正确处理UI事件、并且不需要重复执行。 LoaderManager是用来管理Loader的接口，借助前面链接中例子不难理解Loader运行的机制：获取LoaderManager实例－初始化Loader－实现LoaderCallbacks接口处理回调。 LoaderManager可以缓存任务执行结果，这样当Activity销毁并重建时，就不需要重复执行前面已经执行过的任务了。 如果一个Activity被终止后不会重建，我们就应该在LoaderManager的onLoaderReset中处理这种情形，释放引用。 The Downside of Loaders集成较为复杂，代码量大。 参考下面Reference给出的例子，实现了Fragment的ListView从联系人ContentProvider中通过CursorLoader获取数据的过程。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154public static class CursorLoaderListFragment extends ListFragment implements OnQueryTextListener, OnCloseListener, LoaderManager.LoaderCallbacks&lt;Cursor&gt; &#123; // This is the Adapter being used to display the list's data. SimpleCursorAdapter mAdapter; // The SearchView for doing filtering. SearchView mSearchView; // If non-null, this is the current filter the user has provided. String mCurFilter; @Override public void onActivityCreated(Bundle savedInstanceState) &#123; super.onActivityCreated(savedInstanceState); // Give some text to display if there is no data. In a real // application this would come from a resource. setEmptyText(\"No phone numbers\"); // We have a menu item to show in action bar. setHasOptionsMenu(true); // Create an empty adapter we will use to display the loaded data. mAdapter = new SimpleCursorAdapter(getActivity(), android.R.layout.simple_list_item_2, null, new String[] &#123; Contacts.DISPLAY_NAME, Contacts.CONTACT_STATUS &#125;, new int[] &#123; android.R.id.text1, android.R.id.text2 &#125;, 0); setListAdapter(mAdapter); // Start out with a progress indicator. setListShown(false); // Prepare the loader. Either re-connect with an existing one, // or start a new one. getLoaderManager().initLoader(0, null, this); &#125; public static class MySearchView extends SearchView &#123; public MySearchView(Context context) &#123; super(context); &#125; // The normal SearchView doesn't clear its search text when // collapsed, so we will do this for it. @Override public void onActionViewCollapsed() &#123; setQuery(\"\", false); super.onActionViewCollapsed(); &#125; &#125; @Override public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) &#123; // Place an action bar item for searching. MenuItem item = menu.add(\"Search\"); item.setIcon(android.R.drawable.ic_menu_search); item.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM | MenuItem.SHOW_AS_ACTION_COLLAPSE_ACTION_VIEW); mSearchView = new MySearchView(getActivity()); mSearchView.setOnQueryTextListener(this); mSearchView.setOnCloseListener(this); mSearchView.setIconifiedByDefault(true); item.setActionView(mSearchView); &#125; public boolean onQueryTextChange(String newText) &#123; // Called when the action bar search text has changed. Update // the search filter, and restart the loader to do a new query // with this filter. String newFilter = !TextUtils.isEmpty(newText) ? newText : null; // Don't do anything if the filter hasn't actually changed. // Prevents restarting the loader when restoring state. if (mCurFilter == null &amp;&amp; newFilter == null) &#123; return true; &#125; if (mCurFilter != null &amp;&amp; mCurFilter.equals(newFilter)) &#123; return true; &#125; mCurFilter = newFilter; getLoaderManager().restartLoader(0, null, this); return true; &#125; @Override public boolean onQueryTextSubmit(String query) &#123; // Don't care about this. return true; &#125; @Override public boolean onClose() &#123; if (!TextUtils.isEmpty(mSearchView.getQuery())) &#123; mSearchView.setQuery(null, true); &#125; return true; &#125; @Override public void onListItemClick(ListView l, View v, int position, long id) &#123; // Insert desired behavior here. Log.i(\"FragmentComplexList\", \"Item clicked: \" + id); &#125; // These are the Contacts rows that we will retrieve. static final String[] CONTACTS_SUMMARY_PROJECTION = new String[] &#123; Contacts._ID, Contacts.DISPLAY_NAME, Contacts.CONTACT_STATUS, Contacts.CONTACT_PRESENCE, Contacts.PHOTO_ID, Contacts.LOOKUP_KEY, &#125;; public Loader&lt;Cursor&gt; onCreateLoader(int id, Bundle args) &#123; // This is called when a new Loader needs to be created. This // sample only has one Loader, so we don't care about the ID. // First, pick the base URI to use depending on whether we are // currently filtering. Uri baseUri; if (mCurFilter != null) &#123; baseUri = Uri.withAppendedPath(Contacts.CONTENT_FILTER_URI, Uri.encode(mCurFilter)); &#125; else &#123; baseUri = Contacts.CONTENT_URI; &#125; // Now create and return a CursorLoader that will take care of // creating a Cursor for the data being displayed. String select = \"((\" + Contacts.DISPLAY_NAME + \" NOTNULL) AND (\" + Contacts.HAS_PHONE_NUMBER + \"=1) AND (\" + Contacts.DISPLAY_NAME + \" != '' ))\"; return new CursorLoader(getActivity(), baseUri, CONTACTS_SUMMARY_PROJECTION, select, null, Contacts.DISPLAY_NAME + \" COLLATE LOCALIZED ASC\"); &#125; public void onLoadFinished(Loader&lt;Cursor&gt; loader, Cursor data) &#123; // Swap the new cursor in. (The framework will take care of closing the // old cursor once we return.) mAdapter.swapCursor(data); // The list should now be shown. if (isResumed()) &#123; setListShown(true); &#125; else &#123; setListShownNoAnimation(true); &#125; &#125; public void onLoaderReset(Loader&lt;Cursor&gt; loader) &#123; // This is called when the last Cursor provided to onLoadFinished() // above is about to be closed. We need to make sure we are no // longer using it. mAdapter.swapCursor(null); &#125;&#125; ===Ending===","tags":[{"name":"技术流","slug":"技术流","permalink":"https://lilei.pro/tags/技术流/"},{"name":"Android Performance Patterns","slug":"Android-Performance-Patterns","permalink":"https://lilei.pro/tags/Android-Performance-Patterns/"}]},{"title":"Android Performance Patterns - s5ep7 The Zen Of IntentService","date":"2016-02-24T12:44:20.000Z","path":"2016/02/24/Android-Performance-Patterns-s5ep7-The-Zen-Of-IntentService/","text":"Season 5 ep 7，IntentService之禅。见山是山，见水是水；见山不是山，见水不是水；见山仍是山，见水仍是水。Video Link Work With An Intent在Android系统中我们经常会用Intent来传递消息，如果一个Intent需要花很长时间来处理，在上过了前面几节课之后，你一定已经掌握了如何应对这种task的办法——在新的Worker Thread中解决这个任务。 基于Season 5前面几节所讲的知识，你可能会选用AsyncTask或者HandlerThread来完成这个工作，然而，这两个并非最好的选择，因为： AsyncTask通常处理UI交互方面的事情，当你的Activity正处于后台（没有任何UI元素在渲染中）时，AsyncTask并不能完成它的任务 HandlerThread倒是可以脱离UI运行，不过因为它是一个独立的Thread，当没有Intent过来时，这个Thread仍然会维持它的生命活动，意味着，空闲时占用资源。（一条Thread会占用65k+的内存） IntentService这是就要隆重推出IntentService了。IntentService更像是Service与HandlerThread的合体（a hybrid between Service class and HandlerThread），它继承自Service，在运行时会创建HandlerThread，来处理接收到的Intent请求。 因为IntentService本质上是一个Service，你可以通过它进行一些Service既有的功能，如使用alarm做定时／循环操作。 Be Careful With IntentService在享受IntentService所带来便利的时候，也有一些注意事项。 首先，IntentService所有任务是在同一个队列中按顺序处理的，同AsyncTask一样，如果排在前面的一个任务极其耗时，会使得后面任务迟迟得不到执行，这是就要考虑HandlerThread等其他解决方案了。 其次，IntentService使用类似Broadcast Receiver的机制将任务执行结果返回给Activity，这在运行结果的正确性上并没有任何问题。然而对于简单的结果返回操作，是不需要使用如此重量级的Broadcast Receiver来进行的。你可以改用runOnUIThread来降低资源消耗。 Other Benifits of IntentService使用IntentService还有一个附加的好处——它会使你的app在被切换到后台时，不那么容易被杀死。（相比于那些在后台运行且没有Service的app而言） ===Ending===","tags":[{"name":"技术流","slug":"技术流","permalink":"https://lilei.pro/tags/技术流/"},{"name":"Android Performance Patterns","slug":"Android-Performance-Patterns","permalink":"https://lilei.pro/tags/Android-Performance-Patterns/"}]},{"title":"Android Performance Patterns - s5ep6 Swimming in ThreadPools","date":"2016-02-24T11:30:08.000Z","path":"2016/02/24/Android-Performance-Patterns-s5ep6-Swimming-In-ThreadPools/","text":"Season 5 ep 6，关于线程池你应该知道的事Video Link One Thread, One Thing 且说孔明自引一军屯于五丈原，累令人搦战，魏兵只不出。孔明乃取巾帼并妇人缟素之服，盛于大盒之内，修书一封，遣人送至魏寨。诸将不敢隐蔽，引来使入见司马懿。懿对众启盒视之，内有巾帼妇人之衣，并书一封。懿拆视其书，略曰：“仲达既为大将，统领中原之众，不思披坚执锐，以决雌雄，乃甘窟守土巢，谨避刀箭，与妇人又何异哉！今遣人送巾帼素衣至，如不出战，可再拜而受之。倘耻心未泯，犹有男子胸襟，早与批回，依期赴敌。”司马懿看毕，心中大怒，乃佯笑曰：“孔明视我为妇人耶！”即受之，令重待来使。懿问曰：“孔明寝食及事之烦简若何？”使者曰：“丞相夙兴夜寐，罚二十以上皆亲览焉。所啖之食，日不过数升。”懿顾谓诸将曰：“孔明食少事烦，其能久乎？” ——《三国演义》第一百十三回 上方谷司马受困 五丈原诸葛禳星 论智计谋略，诸葛亮要胜过司马懿，然而，由于丞相不论巨细事必躬亲，只落得星落五丈原的悲惨结局。可见，人的精力是有限的，不应当把所有的任务都压在同一个人头上。在计算机科学中，这一理论同样适用。 对于线程，有专门处理音频的Audio Thread，有响应IO的IO Thread，还有负责网络事务的Networking Thread，这些都是良好的编程典范。 然而，存在这样的情况：当某一系列的任务数量实在太多，已经超过了单个线程所能承受的极限。这时我们应当怎么做？如果工作线程有且只能由一个，就像诸葛丞相一样不得不亲力亲为，那可就GG了。不必担心，新时代的计算机科学已经让我们习得了秘-影分身之术。 看一看下面这个场景，页面里需要展示40张图片，每张图片的解码消耗4ms时间，如果只有单一线程进行操作，总共需要用掉160ms。这显然是难以接受的。 如果我们用10条线程并行计算，可以把时间压缩到16ms。 Thread Pool Executor有了并发处理这一个思路，便可以借助于JAVA提供的强力工具ThreadPoolExecutor来执行任务了。你只需要声明需要的线程数，并且把拆分好的Task传递给ThreadPoolExecutor，ThreadPoolExecutor自身会处理任务分配、线程调度、线程回收等操作。 The More, The Better? Thread is evil 并发的线程数并非越多越好，首先，一台主机能够开启的线程数是有上限的；其次，线程之间切换本身有代价（线程同步、锁与互斥、环境准备等等）；再次，跟CPU数有关，CPU越多，最大性能下可并发线程数越多。 最佳线程数要在实践中通过压测等手段获知。通常我们开发中控制并行线程数=CPU数即可。 每条线程至少占用64k的内存 ThreadPoolExecutor的构造过程中，允许我们控制初始线程数、最大线程数。需要注意的是，通过Runtime.getRuntime().availableProcessors()获取到的内核数也许会小于真实CPU数——出于节约电量等考虑，Android系统会让某些CPU在空闲时处于休眠状态，这些CPU不会被计数。 1234567private static int NUM_OF_CORES = Runtime.getRuntime().availableProcessors();mDecodeThreadPool = new ThreadPoolExecutor( NUM_OF_CORES &gt;&gt; 1, // initial pool size NUM_OF_CORES, // max pool size KEEP_ALIVE_TIME, // keep alive time KEEP_ALIVE_TIME_UNIT, // keep alive units (seconds etc) mDecodeTaskQueue); For Power Users Like URenderScript是专门用来进行大量并行计算的工具，当你有这方面的需求时，不妨尝试一下。 Use Systrace to Analyze用以分析线程、内存的Systrace工具在前文已经介绍过，这里不再赘述。 ===Ending===","tags":[{"name":"技术流","slug":"技术流","permalink":"https://lilei.pro/tags/技术流/"},{"name":"Android Performance Patterns","slug":"Android-Performance-Patterns","permalink":"https://lilei.pro/tags/Android-Performance-Patterns/"}]},{"title":"Android Performance Patterns - s5ep5 Getting A HandlerThread","date":"2016-02-24T01:45:19.000Z","path":"2016/02/24/Android-Performance-Patterns-s5ep5-Getting-A-HandlerThread/","text":"Season5 ep5的主题是HandlerThreadlink A Case – Camera Preview在大部分场景下，AsyncTask已经可以满足我们的功能需求。不过，AsyncTask并不是对于各种场景全都适用的。对于特别耗时的操作，如照相机的预览图绘制。 1public abstract void onPreviewFrame (byte[] data, Camera camera); onPreviewFrame放在主线程中执行的话，会因为大量时间用于计算而产生丢帧，方案一pass！ 放在AsyncTask中执行的话，因为自身的耗时特别长，导致后续任务始终得不到执行，方案二pass！ How?基于上面的考虑，我们需要有这样一个独立于主线程、可以执行冗长任务的机制，来完成照相机预览图的获取。 让我们来认识一下HandlerThread。HandlerThread继承自java.lang.Thread，可以通过getLooper()的方法来获取某个HandlerThread的Looper，拿到Looper之后，就可以通过它创建一个Handler，进而用这个Handler处理预览图绘制这样的工作了。 demo见下面的代码片段 1234HandlerThread handlerThread = new HandlerThread(\"photo preview\");handlerThread.start();Handler handler = new Handler(handlerThread.getLooper());handler.sendMessage(Handler.obtainMessage(0)); // 在handleMessage方法中绘制预览图 当计算完成后，就可以通过Activity.runOnUIThread(Runnable r)来更新预览图了。 HandlerThread不仅可以处理冗长的触发UI事件，也可以用它来做UI无关的事情。 Priority创建HandlerThread时，记得根据实际需求赋予它适当的优先级，这会使cpu为它分配合适的执行顺序。 ===Ending===","tags":[{"name":"技术流","slug":"技术流","permalink":"https://lilei.pro/tags/技术流/"},{"name":"Android Performance Patterns","slug":"Android-Performance-Patterns","permalink":"https://lilei.pro/tags/Android-Performance-Patterns/"}]},{"title":"你好哇，汤圆儿！","date":"2016-02-23T14:13:36.000Z","path":"2016/02/23/Hello-TangYuan/","text":"===Ending===","tags":[{"name":"槑","slug":"槑","permalink":"https://lilei.pro/tags/槑/"}]},{"title":"Android Performance Patterns - s5ep4 Good AsyncTask Hunting","date":"2016-02-23T13:51:03.000Z","path":"2016/02/23/Android-Performance-Patterns-s5ep4-Good-AsyncTask-Hunting/","text":"本节介绍AsyncTask的使用方法与风险link AsyncTask BasicsAsyncTask是一把双刃剑，用的好了无往不利，用得不好则伤人伤己。 考虑下面这种场景，有一个非常耗时的操作需要进行，我们在UI Thread之外启动了一个Worker Thread，当Worker Thread完成它的工作时，会把计算结果返回给UI Thread。 由于这种应用场景太常见了，Android为我们提供了AsyncTask这一机制。AsyncTask有三个重要的函数。 onPreExecute()，在UI Thread中执行，准备Task doInBackground()，在Worker Thread中执行复杂的任务 onPostExecute()，在UI Thread中执行，处理任务执行结果 特别说明！onPreExecute并不保证在UI线程中执行！虽然官方API文档中的说明写到AsyncTask“必须在UI线程中执行”，但Framework底层实现中并没有保证这一机制 The AsyncTask class must be loaded on the UI thread. This is done automatically as of JELLY_BEAN. 换句话说，“保证onPreExecute()在UI线程中执行”是一个编程规范，而并非强制要求。相比之下，onPostExecue()一定是在UI线程中执行的，因为它是用的是mainLooper。 AsyncTask.java 12345678910111213141516171819202122232425262728293031323334353637 private Result postResult(Result result) &#123; @SuppressWarnings(\"unchecked\") Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult&lt;Result&gt;(this, result)); message.sendToTarget(); return result; &#125;private static Handler getHandler() &#123; synchronized (AsyncTask.class) &#123; if (sHandler == null) &#123; sHandler = new InternalHandler(); &#125; return sHandler; &#125; &#125;private static class InternalHandler extends Handler &#123; public InternalHandler() &#123; super(Looper.getMainLooper()); &#125; @SuppressWarnings(&#123;\"unchecked\", \"RawUseOfParameterizedType\"&#125;) @Override public void handleMessage(Message msg) &#123; AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj; switch (msg.what) &#123; case MESSAGE_POST_RESULT: // There is only one result result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break; &#125; &#125; &#125; 关于上面这一点，可以参考这个例子。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class MainActivity extends AppCompatActivity &#123; private static String TAG = \"mainactivity\"; View titleView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initViews(); new Thread(new Runnable() &#123; @Override public void run() &#123; MyAsyncTask task = new MyAsyncTask(); task.execute(); &#125; &#125;).start(); &#125; private void initViews() &#123; titleView = findViewById(R.id.title); titleView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; toast(\"Hello World!\"); &#125; &#125;); &#125; private void toast(String s) &#123; Toast.makeText(this, s, Toast.LENGTH_SHORT).show(); &#125; class MyAsyncTask extends AsyncTask &#123; @Override protected void onPreExecute() &#123; checkRunningInMainThread(\"onPreExecute\"); super.onPreExecute(); &#125; @Override protected void onProgressUpdate(Object[] values) &#123; checkRunningInMainThread(\"onProgressUpdate\"); super.onProgressUpdate(values); &#125; @Override protected void onPostExecute(Object o) &#123; checkRunningInMainThread(\"onPostExecute\"); super.onPostExecute(o); &#125; @Override protected Object doInBackground(Object[] params) &#123; checkRunningInMainThread(\"doInBackGround\"); return null; &#125; &#125; private static void checkRunningInMainThread(String methodName) &#123; Log.d(TAG, methodName + \" is running in UI Thread? \" + (Looper.myLooper() != null &amp;&amp; Looper.getMainLooper() == Looper.myLooper())); &#125;&#125; 例子中有一些无关代码（titleView），不过不影响阅读。 日志输出如下： 12302-29 20:29:06.440 13212-13239/com.leili.geeker D/mainactivity: onPreExecute is running in UI Thread? false02-29 20:29:06.443 13212-13241/com.leili.geeker D/mainactivity: doInBackGround is running in UI Thread? false02-29 20:29:06.850 13212-13212/com.leili.geeker D/mainactivity: onPostExecute is running in UI Thread? true 印证了onPreExecute()并不保证在UI线程中执行。 AsyncTask May Get You Into A Trouble有了上面三个函数，似乎AsyncTask用起来并没有什么困难。然而，如果使用不当，AsyncTask会产生很多匪夷所思的问题。 首先，AsyncTask处理的所有Task，都是放在同一个队列中依次进行的。这意味着，如果前面的Task相当耗时，会使得它后面的Task在很久之后才得以执行。在你处理long running task时应给予高度关注。 实际上，AsyncTask提供了一个用来并行执行Task的方法executeOnExecutor，然而光头哥建议，当你足够理解这个方法时，你就会觉得还是不用为好。 AsyncTask CancelingAsyncTask在执行之前／执行过程中，是可以被Cancel掉的。参数mayInterruptIfRunning决定了是否允许在执行过程中被中断。如果一项任务执行了cacel方法，那么在doInBackground后被调起的将不再是onPostExecute，而是onCancel，同样是在UI Thread中进行。 12345/* * Attempts to cancel execution of this task. This attempt will fail if the task has already completed, already been cancelled, or could not be cancelled for some other reason. If successful, and this task has not started when cancel is called, this task should never run. If the task has already started, then the mayInterruptIfRunning parameter determines whether the thread executing this task should be interrupted in an attempt to stop the task. * Calling this method will result in onCancelled(Object) being invoked on the UI thread after doInBackground(Object[]) returns. Calling this method guarantees that onPostExecute(Object) is never invoked. After invoking this method, you should check the value returned by isCancelled() periodically from doInBackground(Object[]) to finish the task as early as possible. */public final boolean cancel (boolean mayInterruptIfRunning); 如果你的Task在设计时，考虑了cancel的情况，那么你还需要额外做两件事。 Check a “canceled” flag regularly Report work results invalid 对于1，如下 123456doInBackground(..) &#123; // Doing some stuff if (isCanceled()) &#123;..&#125; // Oh noez, we done, clean up for (i &lt; obj.length) if (isCanceled()) &#123;..&#125; // Oh noez, we done, clean up&#125; 对于2，当我们知道被cancel的task会调用onCancel方法时，可以在onCancel中做一些诸如更新UI、清理内存的事情。 ===Ending===","tags":[{"name":"技术流","slug":"技术流","permalink":"https://lilei.pro/tags/技术流/"},{"name":"Android Performance Patterns","slug":"Android-Performance-Patterns","permalink":"https://lilei.pro/tags/Android-Performance-Patterns/"}]},{"title":"Android Performance Patterns - s5ep3 Memory & Threading","date":"2016-02-23T12:09:23.000Z","path":"2016/02/23/Android-Performance-Patterns-s5ep3-Memory-And-Threading/","text":"Season5 ep3 主要介绍了Android中使用多线程可能导致的风险——内存泄漏link Memory Contention Problems内存问题的产生，是由于两个线程操作了同一块内存，由于两者执行的先后顺序未知，导致运行结果不可预测。 用光头哥的话说（给光头哥的幽默感点赞） Memory contention problems with read-write access order, ABA problems, rips in the fabric of space-time… 怎样解决上述问题呢？加锁是一个通用的方法——不过这一点要是扩展起来讲，可说来话长了。 Memory Problems in Android记住一点：Android中的UI对象不！是！线！程！安！全！的！（not thread-safe）！所有UI对象的生命周期都在UI线程里进行，在其它线程中维护的UI对象引用，很可能正处于一个invalid的状态。 譬如，在Worker Thread中持有一个View的引用，而这个引用实际上已经在UI Thread中结束了它的生命周期，从view hierarchy里面被移除掉了。然而，Worker Thread却傻傻地对此一无所知，接下来对这个View的一切操作都将是徒劳。 Don’t Keep Activity ReferencesWorker Thread中是不应该持有Activity引用的，这会导致Activity无法正常回收，进而产生内存泄漏。在Android中，当我们不可避免地用到多线程时，这个问题的风险被放大了。当在Worker Thread中持有Activity引用时，除非Worker Thread完成运算（通常这是一项非常耗时的操作），否则Activity的实例不会真正被释放。 Implicit Reference of Activity除了上文提到的显式引用（explicit reference），还应该当心内部类导致的隐式引用（implicit reference）。Android为我们提供了解决方案——WeakReference &amp; static 关键字。 上述场景是可能导致应用程序crash的一个原因——AsyncTask持有一个Activity的引用，而这个Activity实际上已经处于invalid状态时（例如，执行过onDestroy()），AsyncTask却对此一无所知，当AsyncTask执行完它所运行的任务，试图操作Activity的界面时，这个Activity实际上并不可用。这就导致了下面的糟糕场景—— Don’t Hold References不要试图在UI线程外保存任何UI元素的引用！！！ How We Do?我们要遵守的唯一准则是：所有UI操作，都在UI线程里进行。 Worker Thread可以通过callback、intent等任意进程间通信方法来告诉UI线程——我需要你帮我变更一下界面。 Tool in Android Studio 2.0如果你想更深入地了解运行时Thread&amp;Memory的情况，请使用Android Studio 2.0中提供的有力工具。 ===Ending===","tags":[{"name":"Android Performance Patterns","slug":"Android-Performance-Patterns","permalink":"https://lilei.pro/tags/Android-Performance-Patterns/"}]},{"title":"Android Performance Patterns - s5ep2 Understanding Android Threading","date":"2016-02-23T01:49:39.000Z","path":"2016/02/23/Android-Performance-Patterns-s5ep2-Understanding-Android-Threading/","text":"ep2讲解了将Thread原型扩展为HandlerThread的原理与实践。link 大叔的帽衫造型很有范儿啊！！！ Build Worker Thread一个Thread，从本质上讲，就是完成了一个“接受任务－执行任务－完成任务”的过程 如果我们希望这个Thread可以在它的生命周期内多做一些事，是的，尽可能压榨这个Thread，毕竟我们在前面要创建它，在后面要摧毁它，在这中间要让它物尽其用。 Do Work … Do Work … Do Work … 现在这个Thread已经被成功洗脑，进入了无限Do Work的循环中，就像一头拉磨的毛驴，是时候向磨盘里加上一些谷子了。我们将待处理的工作称为Task，这些Task被组织在一个叫做WorkQueue的队列中。 加谷子的工作，交由另一个Thread进行——把专业的事情交给专业的角色去做。 Android Implementations了解过上面的基本原理，我们看看Android中是如何实现这一机制的。 首先是Looper，也就是上文中的Worker Thread，干活儿的线程。 然后是MessageQueue，Looper在运行的过程中，会不断从MessageQueue里拉取任务执行。 Handler被用来向工作队列中添加任务 每一个被添加的单元任务（Unit of Work），可以是Intent/runnable/message 这样一整套系统，就构成了Android中很重要的Handler机制。注意到，在Handler之外还有一个Handler Thread，它用来处理Task执行结果。 When An App Starts当我们的App启动时，系统为它分配了一个单独的进程，并且启动了MainThread，MainThread本质上是一个HandlerThread，它有且只有一个MainLooper。 MainThread也是UI Thread，在它运行过程中几乎会处理一切操作（在ep1中已经提到过） 系统消息（翻转手机，界面重新绘制） 用户输入（下滑列表） 其它应用传过来的信息 要知道，MainThread一个很重要的任务是负责UI绘制，如果交给MainThread太多的任务，会影响每16ms一次的UI渲染，造成ANR。 Choose Your Tool – No Silver Bullet AsyncTask：将任务切换到UI线程／非UI线程 HandlerThread：当需要Callback时使用 ThreadPool：执行更细化的单元任务 IntentService：用以执行后台任务，或将Intent任务从UI线程中提取出来执行 SystraceSystrace 是SDK提供、用于查看CPU操作耗时的工具，当你在测试应用时发现了丢帧现象，需要深究原因的时候，可以通过Systrace获得一些有用的信息。 ===Ending===","tags":[{"name":"技术流","slug":"技术流","permalink":"https://lilei.pro/tags/技术流/"},{"name":"Android Performance Patterns","slug":"Android-Performance-Patterns","permalink":"https://lilei.pro/tags/Android-Performance-Patterns/"}]},{"title":"Android Performance Patterns - s5ep1 Threading Performance 101","date":"2016-02-23T01:00:00.000Z","path":"2016/02/23/Android-Performance-Patterns-s5ep1-Threading-Performance-101/","text":"Season 5 ep 1 介绍了Android系统中线程与UI渲染一些最基础的知识。link Main Thread主线程是Android中最重要的线程，承担了响应系统时间、处理输入、绘制UI等重要任务。 UI drawing and frame dropping出于简化的考虑，android系统将大部分任务都放在了主线程中进行。然而其中一个任务是与其它有所不同的 —— UI 渲染。因为UI渲染一旦出现卡顿，用户会立刻感知到ANR，极不友好。下面我们模拟一个输入并处理的过程，看一下冗长的操作是如何阻塞UI绘制的。 My Awesome Code!!! 人眼能感知的流畅UI界面必须保持在60fps，意味着每16ms就要有一次绘制完成。 一旦主线程被某个操作阻塞超过了16ms，势必会丢掉（至少）一次绘制，这就是 dropping frame。 Solve frame dropping解决上述问题的思路很简单：既然主线程必须保证流畅运行，那我们就在自己的worker thread里处理这些恼人的Lame Work（瘸腿工作）好了。 我们可以直接使用以下几种由系统提供的解决方案，注意它们不同的应用场景。 Be Careful!当你决定使用内部类来完成上述操作时，一定要注意这可能引起内存泄漏！因为非静态内部类实例会保存外部类的引用，而在移动系统这种内存有限的设备上，内存泄漏是非常可怕的。 一个解决方案是用静态内部类替代，并且内部以WeakReference保存Activity的引用。 ===Ending===","tags":[{"name":"技术流","slug":"技术流","permalink":"https://lilei.pro/tags/技术流/"},{"name":"Android Performance Patterns","slug":"Android-Performance-Patterns","permalink":"https://lilei.pro/tags/Android-Performance-Patterns/"}]},{"title":"乔-韦德健美训练法则","date":"2016-02-19T08:26:42.000Z","path":"2016/02/19/乔-韦德健美训练法则/","text":"乔·韦德，男，1922年出生，加拿大裔健美冠军，被称为“健美冠军之父”、“现代健美之父”，他曾创办了韦德运动器材公司，是《肌肉与健美》、《形体美》和《男子健康》等健美杂志主编，开创了当今最具影响力和最高水准的职业健美比赛——“奥林匹亚先生”大赛，并设立了高额奖金。他是阿诺德·施瓦辛格的恩师，开创了乔·韦德训练法则，推动了世界健美运动的发展。 在笔者看来，韦德的成功之处，不仅仅在于他是一个优秀的bodybuilder，更是因为他推广了健身健美的训练法则、创办了举世闻名的奥赛、并且培育了施瓦辛格这样伟大的健美者，不得不提的是，韦德是一位成功的商人。 韦德健美训练法则共32条，分为初、中、高级三个阶段，仔细阅读，科学训练，定会受益无穷。 入门须知器械须知 全套家庭健身器械包括：卧推凳、腹肌板、杠铃和哑铃各一副。可以按个人条件配置其它器械。 服装须知 宽松舒适，不会妨碍动作（务必要穿比较舒适的内裤）； 保证适宜的体温； 最好穿鞋，保护踝关节； 进行负重训练时，为了保护腰背部位，腰间最好扎上举重皮带； 锻炼须知 渐进增重。初练者可从25％-30％最大重量开始进行训练。 注意动作的规范性和节奏感。每个动作要使肌肉充分伸展和彻底收缩，不能用借力的方法进行练习。在有一定经验后，初练者可开始在最后一组或最后几次练习中，对该肌肉采用助力的方法。在每个动作中都要集中精神，有助于调动更多的肌纤维参加用力。 注意姿势。在负重练习中，要保持两边重量的平衡，两眼平视，两脚自然开立，身体上下移动过程中始终保持头部正直。 控制动作速率。在训练中，每组间间歇时间是60-90秒，可以保持体温，避免肌肉伤害，还能使大量血液集中到肌肉中去。做动作时，上举和放下的速度必须缓慢，且有节奏。若举起时间为2-3秒，则放下时间为4秒。掌握了正确的技术动作后，可适当加快动作。 为了减轻肌肉酸痛，在训练中要穿足够的衣服以使身体保持适宜的体温，并在训练后洗温水浴，用橡胶皮肤刷按摩全身。 呼吸特别重要。通常当用力时呼气，在放松还原时吸气；胸腔被扩大时吸气，胸腔受压时呼气。 补充高质量的蛋白质、维生素、矿物质和不经过精炼的碳水化合物（粗粮）； 饮大量的纯开水（每天至少12-16杯容量为30毫升的水）； 持之以恒； 计划须知 保证足够的睡眠和休息，晚上睡眠时间约为6-10小时，有条件最好白天小睡一会儿； 最初阶段每周练三天，每隔一天锻炼一次； 最好的训练时间是日常学习和工作之余，且精力最佳时，尽量安排在每天同一时间锻炼； 制订课程计划时必须考虑对有缺陷部位的突出训练，但不提倡偏练有缺陷部位。初练者应按课程内容训练至少六个月，绝不能在初练的六个月内安排重点部位的突出训练。 练习次数 低次数（1-5次）：主要增长体力和力量； 中次数（8-12次）：主要增长肌肉块、线条和耐力； 高次数（15次以上）：主要增强肌肉耐力、线条和减缩肌肉块； 如果做较高次数（20次以上）并采用一种连续的循环训练，组与组织间没有休息，还可以增强心脏和呼吸系统的功能。 精神因素 训练时集中精力，排除杂念。平时在脑海里塑造体型，并为之努力，保持愉快的心情。 训练伴侣 依个人爱好，选择是否要伴侣或谁做伴侣。 本能训练－跟着感觉走 重视自身的身体感觉，在体能允许的情况下，充分满足自身的愿望，但不要有懒惰和训练过度。这样有利于保持自己较高的情绪水平。 初级篇 渐增超负荷训练原则 （Progressive Overload Training Principle） 使肌肉逐渐增加负荷，并让肌肉受到更强烈的训练是增强任何身体素质（力量、肌肉围度、耐久力等）的基础。如：要增长力量，就必须使用较大的重量；若增加肌肉围度，不仅要采用越来越重的负荷，还要增加训练组数和每周的训练次数；如要增加局部肌肉的耐久力，就要逐渐减少组与组之间的间歇时间或增加训练组数和训练次数。一切都要逐渐增长。超负荷训练是所有体型训练法的基础。 注：通常在超力量或大强度训练中使用。 多组数训练原则 （Set System Training Principle） 多组数训练原则（有时每个动作最多3-4组），以便使每个肌肉群都能完全彻底地得到锻炼，并达到最大限度的肌肉膨胀。 注：不同的训练课程中，要更具自己的体力情况和所锻炼的部位的强弱情况安排合适的训练组数。 孤立训练原则（Isolation Training Principle） 不同的肌肉群可以一起练或相对地各自单独分开训练。在完成动作过程中，每一块肌肉都有它们各自的用力特点，但总有某肌肉群是主要用力的，其它肌肉起着协同作用或相对关节的固定作用，或对抗作用。如果您要最大限度地单独发展某一部位的肌肉，就要尽可能使主要用力的肌肉与其它肌肉的活动分开。可按解剖位置进行变换，如斯高特（斜托）弯举对臂部的屈肌锻炼就比用窄握重锤下拉的效果要好。 注：适合于在需要重点发展的肌肉训练中使用。 肌肉全面训练原则（Muscle Priority Training Principle） 要使肌肉不断地增长，就不能采用某个固定不变的锻炼课程。如果固定采用相同的动作、组数、次数和角度，就不能使肌肉获得全面的强度刺激以使肌肉增长。 注：适合在平时的训练课程中使用。 中级篇 重点肌肉优先训练原则（Muscle Priority Training Principle） 薄弱部位的锻炼应在训练课刚开始体力最旺盛、精力最充沛的时候进行，以承受最大的刺激强度和运动量。 注：适合在每次训练课所需重点训练的肌肉。 金字塔训练原则(Pyramiding Training Principle) 肌肉纤维的增长与力量的增长是阻力训练的结果。理论上来讲，如果在一个动作中能用最大的重量做8次，并能做几组，那么对增长体围和力量有很大效果。但没做热身活动就用大重量来练，会有潜在的危险。因此应从极小重量开始逐渐地增大负荷重量。金字塔训练法就是解决这个问题。如：开始用60％最大重量做15次，然后再增加重量，试做10-12次，最后加重到80％，最多做5-6次，会获得很好的效果，避免受伤。 注：适用于平时的训练课程，或超量训练课程。 分化训练原则（Split System Training Principle） 当连续三个月的每星期三次训练以后，就可以进行超强度训练。可以把全身分成上身和下身两部分来训练，每个部分可以增加动作和训练组数，这样每个部分肌肉就可以得到更多的锻炼。分化训练方法是：把一个星期的第一次训练课先安排锻炼上身的8个动作，采用超强度的训练；在当天的第二次训练课中只做下身的6-8个动作，采取同样的超强度训练。如果采用每周练三天的方法，同一次训练课中同时练上身和下身，肌肉的刺激强度就很难上去。分化训练对每个部位肌肉的锻炼强度会更大，时间会更长。 注：适用于平时训练阶段，或增长肌肉块的训练课中。 局部集中训练原则（Flushing Training Principle） 训练中必须使大量血液集中到被锻炼的肌肉中去，才能使肌肉更好地增长。如：在锻炼胸部时，课程中安排的3-4个动作要连续进行，中间不插入锻炼其它部位肌肉的动作，不断地使血液集中到这个部位，从而达到局部肌肉充分膨胀的状态。 注：适合于重点发展或强化某块肌肉时使用。 双组合训练原则（Supersets Training Principle） 这是韦德最著名的训练原则之一。几把两个功能相对应的肌肉群结合在一起锻炼。如，把锻炼肱二头肌的弯举和锻炼肱三头肌的臂屈伸结合起来就是一个双组合训练。双组合是把两个功能相对应的单块肌肉的动作轮流地练，一个动作练一组，组与组之间只允许有极少的间歇时间或不休息，是神经系统处于集中刺激状态。 注：适合于集中锻炼某部位肌肉或减脂时使用。 复合组数训练原则（Compound Sets Training Principle） 同一部位的肌肉群的双组合训练（如连续两个练肱二头肌的动作成为一个复合组数训练），即在局部肌肉还没恢复时，使其连续进行超强度刺激。 注：对赛前减脂或加大某锻炼部位的肌肉强度效果较好。 综合训练原则（Holistic Training Principle） 经不同方式使不同部位肌肉细胞的蛋白质和热能产生不同反应。当肌肉纤维遇到较大阻力负荷时，肌肉纤维就会增大，即经过不同角度的阻力负荷能促使整块肌肉的细胞增大。因此，必须采用各种不同的动作和训练次数。 注：更适合于集中对某块重点肌肉的突击训练，但不宜长期使用。 循环训练原则(Cycle Training Principle) 在全年训练中的某一时期，训练课程可集中安排增长肌肉块和力量，而另一时期安排以减轻负荷、增加试举次数、缩短间歇时间（优质训练）为主。可避免机能受伤并保持训练效果的稳步提高。 注：适用于减脂或提高心血管系统的功能水平。 静力紧张训练原则(ISO-Tension Training Principle) 静力紧张是韦德最被公认的训练原则之一。静力紧张用于肌肉控制，即把肌肉收缩到极点，保持静止控制3-6秒，重复做3次。这种训练能提高神经系统对肌肉的控制能力，可使在比赛中表现各种造型姿势时，分别控制各部位肌肉，以使肌肉线条更加清晰和突出。 注：适用于动作造型的训练。 高级篇 助力训练原则(Cheating Training Principle) 借助其它肌肉的力量完成动作练习的最后1-2次，或利用身体其它部位来协助在运动中的肌肉完成最后试举。如：俯立弯举做到最后几次试举感到很难完成时用另一只手轻微托住手背在完成几次。但如在做仰卧推举时，采用背和臀部离开凳面的力量来多完成几次，就不是韦德助力训练原则了。 注：适用于对某块重点肌肉的超强度训练。 三组合训练原则(Tri-Sets Training Principle) 同一块肌肉采用三个不同的动作锻炼，且动作之间没有休息。该方法对增加血管中血流量很有效。 注：适用于对某块重点肌肉的超强度和减脂训练。 超组合训练原则(Giant Sets Training Principle) 同一肌肉群采用4-6种动作锻炼，动作间歇很短或没有。 注：适用于减脂训练和提高肌肉耐力训练。 预热训练原则(Pre-Exhaustion Training Principle) 在锻炼某块肌肉时，开始先采用孤立动作练习，然后立刻用双组合训练进行正常训练。 注：通常用于训练课程的开始阶段或某块肌肉的开始训练之前。 停息训练原则(Rest-Pause Training Principle) 用最大重量试举时，每次都试举到极限次数，然后停息一会儿，再接着试举。第一次停息可为30-45秒，以后每次增加30秒。这是增长力量和肌肉围度的好方法。 注：适用于增长力量的练习。 顶峰收缩训练原则(Peak Contraction Training Principle) 顶峰收缩是指肌肉达到完全收缩时使活动的肌肉处于最紧张的收缩状态。肌肉完全收缩时若没有锁定这个重量，肌肉会出现松弛现象。为了避免这一现象，在肌肉收缩到最紧张的位置时，应给予一定的减阻力。如，做哑铃弯举到最高点时，把躯干稍向前倾，让上臂处于重力的垂线之外，就会锁定重量，使肌肉处于彻底收紧状态。这种训练课使肌肉增大且肌纹分割线清晰。 注：适合于所有动作练习中肌肉收缩至极限时采用。 持续紧张训练原则(Continuous Tension Training Principle) 在整个动作过程中，动作要做得慢些，使肌肉能逐渐收缩，始终保持紧张的收缩状态。 注：适用于平时训练中增长肌肉的最后几组训练，或提高肌肉耐力训练。 抗重力训练原则(Reverse-Gravity Training Principle) 举起重物后放下时，用力抵抗下降重物，进行退让性练习，是让已收缩的肌肉被动拉长的动作，对肌肉刺激更强烈，有利于增大肌肉，增加力量。因为这种方法强度很大，在训练中不宜经常使用。运动负荷安排要注意以下几点： 强度：采用90％-120％最大重量。 组数：较少，通常为4±2组。 次数：较少，通常做2-3次。 时间：6-8秒。 速度：慢。 这种训练方法也可用于发展薄弱环节，强迫促使其平衡发展。 注：通常在平时的训练周期中发展力量或超强度刺激被锻炼的肌肉 强迫次数训练原则(Forced Reps Training Principle) 当举至力竭时，由同伴稍加助力再做2-3次的强迫次数，但助力只在举起的开始阶段，接下来把杠铃举至两臂伸直就应该依靠自己的力量。 注：通常在平时训练周期对所重点发展肌肉的最后1-2组的最后几次推举中使用，不宜整个训练课程的每组推举都采用。 双分化训练原则(Double-Split Training Principle) 高级健美运动员为提高总负荷，又不至于过度训练，将总负荷量一分为二，上午练1-2个部位，下午练另外1-2个部位。有利于精力更集中，采用更大的重量和组数。 注：适用于时间不能保证的锻炼者，或赛前减脂。 三分化训练原则(Triple-Split Training Principle) 少数健美运动员有惊人的恢复能力，根据双分化原理，一天练三次。 注：适用于具有很好体力的高级健美运动员的赛前减脂。 膨胀训练原则(Burns Training Principle) 在正常训练的最后一次试举时再做2-3次半程的练习，是正在活动 的肌肉进入更多的血液并产生超量的乳酸，引起肌肉发胀感觉。这种感觉是由于局部动作时更多的血液进入肌肉中引起的毛细血管膨胀，有助于增加肌肉围度和肌肉中毛细血管的增粗。 注：适用于训练课程中的重点肌肉训练，不宜经常使用。 优化训练原则(Quality Training Principle) 按规定的组数和次数进行锻炼时，逐渐减少组间间歇时间。 注：适用于赛前提高肌肉质量或减脂训练。 递减训练原则(Descending Sets Training Principle) 采用由重到轻的逐降重量的方法，需要有两个训练伙伴帮助，当采用一定重量完成规定的次数时，有两旁的伙伴立即从两端各取下一片杠铃；继续举到力竭时，在各取下一片，再举几次，直至没有杠铃片为止。此法的训练强度很大，每次训练课不超过1-2个动作。 注：适用于在平时训练周期的训练课中需要重点发展的大肌肉。 本能训练原则(Instinctive Training Principle) 根据自己的感觉安排动作、组数和次数、饮食营养及训练计划。有利于充分发挥自己的潜能。 注：适用于不同训练周期的不同训练课程。 兼顾训练原则(Eclectic Training Principle) 把大肌肉群的发展和肌肉孤立训练结合起来，即为发展某主要肌肉块，把相应的大肌肉群训练动作和局部肌肉训练动作放到同一课程中，并于本能训练原则结合起来，是力量、形体、肌肉块增强到最大限度。 注：适用于平时训练周期的调整训练。 粘点训练原则(Partial Reps Training Principle) 粘点指在做某组动作到力竭时，肌肉不能再收缩出现的粘滞状态。不同肌肉做不同动作出现粘点的时间和位置不一样。一般做徒手动作很难出现粘点，对肌肉力量的增长效果不大，故给徒手动作增加负重能取得很好的效果。对于高级健美运动员来说，采用粘点训练方法克服薄弱环节能取得最大效果。 注：适用于平时训练周期的发展力量训练课程。 快速原则(Speed Principle) 一般健美训练中的组数和次数使用要严格掌握要点，使局部肌肉感到完全收缩才能达到最好的训练效果。而采用大重量训练是增长围度的好方法，快速原则能使训练更加完美。快速原则必须有高级训练阶段的技术基础，结合大重量训练同时进行（超过75％~80％重量），且动作决不能变形，或助力。快速原则最好是在平时训练周期集中增长力量和肌肉围度的早期使用。 注：通常在发展力量训练课程或减脂训练课程中使用。 交叉训练原则(Staggered Sets principle) 是优先训练原则的一种高级形式。把较小且发展较慢部位的肌肉穿插在重点要练的大肌肉群中练习，或贯穿在主要大肌肉群众锻炼。通常交叉训练的部位要求相隔较远，以免相互影响，前臂、颈部、小腿、斜方肌等都是采用交叉训练较好的候补部位。把交叉训练放在最前面连可以使精力更好地集中在最重要部位的肌肉群上。 注：适用于具有较高训练水平且时间不足者，或赛前减脂者使用，但不宜经常使用。 ===Ending===","tags":[{"name":"大保健","slug":"大保健","permalink":"https://lilei.pro/tags/大保健/"}]},{"title":"Android Performance Patterns - 序言","date":"2016-02-18T12:33:29.000Z","path":"2016/02/18/Android-Performance-Patterns-序言/","text":"Android Performance Patterns 是 Android Developers 在youtube上发布的一系列Android性能优化小视频，每一部都不超过5分钟，目前为止发布到了Season 5，共73部。 播放列表地址：link（视频下方有字幕开关，你也可以点击键盘上的C键来操作字幕） 目录Season 5 链接 标题 s5ep1 Threading Performance 101 s5ep2 Understand Android Threading s5ep3 Memory &amp; Threading s5ep4 Good AsyncTask Hunting s5ep5 Getting a HandlerThread s5ep6 Swimming in Threadpools s5ep7 The Zen of IntentService s5ep8 Threading and Loaders s5ep9 The Importance of Thread Priority s5ep10 Profile GPU Rendering : M Update ===Ending===","tags":[{"name":"技术流","slug":"技术流","permalink":"https://lilei.pro/tags/技术流/"},{"name":"Android Performance Patterns","slug":"Android-Performance-Patterns","permalink":"https://lilei.pro/tags/Android-Performance-Patterns/"}]},{"title":"ProGit读书笔记（Chapter3）","date":"2016-02-17T13:23:42.000Z","path":"2016/02/17/ProGit读书笔记Chapter3/","text":"Chapter 3. Git Branching本章讲解Git分支功能实现的基本原理、merge操作、rebase操作等等 基本思想：snapshot首先要理解，不同于其它VCS，对于版本之间的提交，Git存储的不是diff，而是snapshot。对于下面这样一次commit，Git会生成5个文件 12$ git add README test.rb LICENSE$ git commit -m 'The initial commit of my project' 生成一个树状结构：98ca9记录了本次commit的信息（committer、date、message等），并有一个指针，指向tree，tree中包含本次commit中改动的全部文件snapshot A branch in Git is simply a lightweight movable pointer to one of these commits. 这也就解释了为什么在Git中，创建、删除、切换分支的操作都很快速。 创建分支Git使用如下命令创建分支 1$ git branch testing 创建后的testing分支，跟master都指向同一个Snapshot 那么Git如何知道当前你在编辑的是哪一个分支呢？用HEAD！例如，在上面的命令后，内部的分支是这样的 可以在git log中使用--decorate参数来观察当前HEAD分支。（这里推荐一下zsh，自动标示当前HEAD，非常方便） 1234$ git log --oneline --decoratef30ab (HEAD -&gt; master, testing) add feature #32 - ability to add new formats to the central interface34ac2 Fixed bug #1328 - stack overflow under certain conditions98ca9 The initial commit of my project 切换分支使用git checkout [branch_name]来切换分支 1$ git checkout master 创建&amp;切换分支可以放在一个命令里完成：git checkout -b [branch_name]，作用是基于当前HEAD切出一个名为branch_name的新分支，并且将HEAD切换到该新分支上。 Basic Branching and Merging想象一个比较复杂的分支模型：当你开发某个功能时（iss53），突然线上基于master分支的代码爆出一个bug，此时必须要进行hotfix，并且在完成hotfix后，将hotfix的内容合并回master，最后再切换回iss53分之继续进行功能开发。 怎样让master合并hotfix呢？切换回master分支，使用git merge hotfix来完成 123456$ git checkout master$ git merge hotfixUpdating f42c576..3a0874cFast-forward index.html | 2 ++ 1 file changed, 2 insertions(+) 看到Fast-forward的提示没有？这是说，master的指针已经“向前移动到了hotfix指针所在位置”，如下图： 这个时候hotfix已经完成了它的任务，继续留着它只会让我们的分支更加混乱。本着兔死狗烹鸟尽弓藏的原则，杯酒释兵权～最后切换回iss53分支继续coding 12345678$ git branch -d hotfixDeleted branch hotfix (3a0874c).$ git checkout iss53Switched to branch \"iss53\"$ vim index.html$ git commit -a -m 'finished the new footer [issue 53]'[iss53 ad82d7a] finished the new footer [issue 53]1 file changed, 1 insertion(+) Basic Merging现在我们完成了iss53的功能开发与测试，需要将代码合并回master，以备后续上线。当然，需要先切回master，然后使用git merge来合并iss53分支。 123456$ git checkout masterSwitched to branch 'master'$ git merge iss53Merge made by the 'recursive' strategy.index.html | 1 +1 file changed, 1 insertion(+) 合并前 合并后 从图上可以看出来，Git基于master与iss53的提交历史，新创建了一个commit－C6，图中此处有误，最右边master指向的应该为C6。惯例，卸磨杀驴。 1$git branch -d iss53 Basic Merge Conflicts在并行开发的过程中，经常会遇到两个开发者同时修改了一个文件，在合并时发生冲突的场景，比如下面这样 1234$ git merge iss53Auto-merging index.htmlCONFLICT (content): Merge conflict in index.htmlAutomatic merge failed; fix conflicts and then commit the result. 使用git status查看当前合并进程与状态 1234567891011$ git statusOn branch masterYou have unmerged paths. (fix conflicts and run \"git commit\")Unmerged paths: (use \"git add &lt;file&gt;...\" to mark resolution) both modified: index.htmlno changes added to commit (use \"git add\" and/or \"git commit -a\") 原来是index.html被分别修改了2次，导致git无法自动合并。使用编辑器或者IDE打开这个文件后，能看到 1234567&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html&lt;div id=\"footer\"&gt;contact : email.support@github.com&lt;/div&gt;=======&lt;div id=\"footer\"&gt; please contact us at support@github.com&lt;/div&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html Git用非常容易识别的方式标示有冲突的代码：&lt;&lt;&lt;&lt;和====之间的是HEAD的改动（也就是master），====和&gt;&gt;&gt;&gt;之间的是另一个分支（iss53）的改动，保留想保留的即可。 如果喜欢图形化的界面，使用git mergetool来打开，Git默认的是opendiff。修改完成后，文件处于modified状态，需要先用add将其变为staged，然后在commit中注明这次merge。 Branch Management查看本地branch，使用git branch，增加-r参数以查看远端仓库branch，增加-v参数查看最新一次的commit 12345678$ git branch iss53* master testing$ git branch -v iss53 93b412c fix javascript issue* master 7a98805 Merge branch 'iss53' testing 782fd34 add scott to the author list in the readmes 如果你想看哪些分支已经被merge进了HEAD中，用--merged，前面没有星号*的分支是可以用git branch -d删除的。 123$ git branch --merged iss53* master 查看没有merge的分支，用--no-merged参数。对于这样的分支，当你试图使用git branch -d进行删除时，Git会给出提示，告诉你这样的操作不被允许。（你可以使用git branch -D来强制删除） 12345$ git branch --no-merged testing$ git branch -d testingerror: The branch 'testing' is not fully merged.If you are sure you want to delete it, run 'git branch -D testing'. Remote Branches对于远端仓库的每一个分支，本地都有一个与其对应的分支，用(remote)/(branch)来表示，比如origin/master。通常我们看到remote的名字是origin，但这不是固定的，你可以用以下命令来更改这个名字git clone -o booyah，这样你创建的就是booyah/master。最开始clone并checkout时，origin/master与master指向同一个snapshot 只要不fetch，origin/master指向的位置就不会变更，master分支会随着commit一直向前。 也可以把两个remote的历史都拉下来，酌情使用 Pushing使用git push &lt;remote&gt; &lt;branch&gt;来push到远端仓库。 12345678$ git push origin serverfixCounting objects: 24, done.Delta compression using up to 8 threads.Compressing objects: 100% (15/15), done.Writing objects: 100% (24/24), 1.91 KiB | 0 bytes/s, done.Total 24 (delta 2), reused 0 (delta 0)To https://github.com/schacon/simplegit * [new branch] serverfix &gt; serverfix 这其实是一个缩写，背后完整的命令是git push origin refs/heads/serverfix:refs/heads/serverfix，直接引用原文 which means, “Take my serverfix local branch and push it to update the remote’s serverfix branch.” 分支名前面的refs/heads是Git内部机制，你也可以省略这个路径，写作serverfix:serverfix，或者你觉得在remote端不希望叫serverfix的名字，那就改一个你喜欢的！git push origin serverfix:awesomebranch 使用git checkout -b &lt;branch_name&gt; &lt;remote&gt;/&lt;branch_name&gt;来创建一个基于远端的本地分支，这种分支被叫做tracking branch，被跟踪的那个远端branch叫做upstream branch。有了这层关系在里面，当你进行pull/push时，Git就自然知道要操作哪一个分支了。 由于git checkout -b &lt;branch_name&gt; &lt;remote&gt;/&lt;branch_name&gt;实在是太常用了，Git为它提供了一个缩写git checkout --track &lt;remote&gt;/&lt;branch&gt; 123$ git checkout --track origin/serverfixBranch serverfix set up to track remote branch serverfix from origin.Switched to a new branch 'serverfix' 甚至，Git提供了一个缩写的缩写：git checkout &lt;branch&gt;，这个命令要求本地分支与远程分支保持名字一致。 123$ git checkout serverfixBranch serverfix set up to track remote branch serverfix from origin.Switched to a new branch 'serverfix' 如果尚未给本地的一个分支指定远端分支，使用-u参数 12$ git branch -u origin/serverfixBranch serverfix set up to track remote branch serverfix from origin. 小技巧：可以用{@u}或者@{upstream}来代替upstream，比如当你处在master分支时，可以用git merge @{u}来代替git merge origin/master 如果你想了解本地分支的track情况（分支、ahead、behind），使用git branch -vv，记得先git fetch --all 12345$ git branch -vv iss53 7e424c3 [origin/iss53: ahead 2] forgot the brackets master 1ae2a45 [origin/master] deploying index fix* serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this should do it testing 5ea463a trying something new Pulling相比于fetch把远端分支更新到本地，pull命令更进了一步，完成了merge的功能。pull = fetch + merge。笔者赞同书中的观点，还是单独使用fetch&amp;merge的好。 Generally it’s better to simply use the fetch and merge commands explicitly as the magic of git pull can often be confusing. Deleting Remote Branches使用git push origin --delete &lt;branch_name&gt;来删除服务器上的某个分支 123$ git push origin --delete serverfixTo https://github.com/schacon/simplegit - [deleted] serverfix 还有一种写法，git push origin :&lt;branch_name&gt;，能起到同样的作用 123$ git push origin :feature/8.0.0_bugfix_leiliTo git@code.dianpingoa.com:mobile/android-nova-booking.git - [deleted] feature/8.0.0_bugfix_leili 记住，所删除的“分支”本质上只是“指针”，所有的代码snapshot依旧保存在服务器上，可以随时check出来 Rebasing接下来我们来学习与Merge分庭抗礼的另一个强有力的功能——Rebase。两者同是将不同分支上的提交合并到一起的功能，它们之间的区别是什么样的呢？容笔者细细道来。首先来看一个熟悉的场景，有master和experiment两个分支，对merge而言，如果在master分支的基础上，对experiment进行merge，Git会创建一个新的commit（C5），包含了两个分支最近的共同祖先（C2）以来发生的所有变更（C4和C3），最后把master的指针指向C5 而对于rebase，我们这么操作。注意HEAD指向的是experiment分支。 1234$ git checkout experiment$ git rebase masterFirst, rewinding head to replay your work on top of it...Applying: added staged command 非常神奇地，C4这个commit消失了！！！，取而代之，Git在C3后面创建了C4’，同时将experiment的指针转移到了这里。整个提交历史变成了一根直线，清爽了许多。 接下来，我们让master move forward，以合并experiment带来的改动。 12$ git checkout master$ git merge experiment 注意！虽然merge与rebase看起来都是把两个分支上的改动合并到一起，但一个是“同时合并A和B”，一个是“将A合并到B”，仔细体会其中的不同。 Rebasing replays changes from one line of work onto another in the order they were introduced, whereas merging takes the endpoints and merges them together. 有趣的Rebasing 想象上面一个场景，对于master server client三个分支，如果我想要将client上的改动提交到master（C8和C9），而暂时不想合并server上的代码，应该怎么做？ 12$ git checkout cient$ git rebase master 上述这样肯定不行，因为会把C3带过去。针对这种场景，Git也为我们提供了这个功能 1$ git rebase --onto master server client 是不是有点一头雾水？这都什么鬼啊！别急，我们来仔细看看这段指令。 This basically says, “Check out the client branch, figure out the patches from the common ancestor of the client and server branches, and then replay them onto master.” 明白了吧！不过，虽然这看上去很神奇，笔者可不希望在实际的工作中碰到这种复杂的场景。Rebase后的提交历史如图： 接下来该怎么做，相信不用我说，你也知道了——把master fast forward过去～ 12$ git checkout master$ git merge client 当你完成了server分支的开发，狠狠地用rebase把它甩在master脸上吧，git rebase [basebranch] [topicbranch]——将topicbranch上的改动在basebranch上重放（checks out the topic branch (in this case, server) for you and replays it onto the base branch (master)） 1$ git rebase master server 删除无用分支后，最终得到一个无比清爽的提交记录 Rebase的风险Rebase是一个无比强大的工具，借助它，我们可以将项目提交历史梳理成一条直线，然而，如果应用不当，它产生的麻烦要远远大于带来的好处。 Do not rebase commits that exist outside your repository. 简单的说，如果一个commit已经被公布给其他人使用，那就不要试图再rebase它。如果你遵守了这条准则，一切安好；可一旦你违反了他，你的同事将会恨你入骨……下面用几张图来说明这种深刻仇恨的来源 首先是一个简单的分支模型，teamone和你正在合作中，显然你的工作效率更高些，已经提交了C2、C3两次 远端仓库也有一些更新，而且他们用到了merge，真是厉害啊！你当然不甘示弱，立即把他们的提交merge了过来。 这时，远端team发现merge不如rebase好用，他们使用非常邪恶的git push --force命令，覆盖掉了代码仓库中的历史，意图抹杀掉merge的出现。 天真的你并没有发现他们的邪恶企图，当你fetch时候，发现远端仓库有了更新，你自然想再merge一把，以保持最新代码 Boom！灾难发生了，由于C4和C4’实际上是一模一样的改动（实际上，如果你用git log来查看，你会发现这两个提交甚至有完全相同的author、date、message，当然他们的SHA1是不同的）。而且，就算你解决了冲突，把你的代码推送回远端时，邪恶的他们发现，原来让他们避之不及的C4和C6这两个提交——They are back！ Rebase When You Rebase一旦出现了上面的情况，不要慌，Git为我们提供了解决这种问题的途径，那就是——Rebase！这时你checkout到自己的master分支上，执行git rebase teamone/master，Git会为你做以下事情（实在是懒得翻译了） Determine what work is unique to our branch (C2, C3, C4, C6, C7) Determine which are not merge commits (C2, C3, C4) Determine which have not been rewritten into the target branch (just C2 and C3, since C4 is the same patch as C4’) Apply those commits to the top of teamone/master 最后得到如图的提交历史。需要注意，只有当C4和C4’几乎完全一致时，Git才会采取以上策略。不然，即使如上操作，依然会产生冲突。 Rebase vs. Merge关于Rebase和Merge该用哪个的问题，要因地制宜——Rebase可以极大简化提交历史，但它会篡改提交记录，而Merge可以原汁原味地保存每个人的提交时间与内容。应当记住，不论使用哪一个，都要按照基本法。 In general the way to get the best of both worlds is to rebase local changes you’ve made but haven’t shared yet before you push them in order to clean up your story, but never rebase anything you’ve pushed somewhere. ===Ending===","tags":[{"name":"技术流","slug":"技术流","permalink":"https://lilei.pro/tags/技术流/"}]},{"title":"ProGit读书笔记（Chapter2）","date":"2016-02-14T11:21:22.000Z","path":"2016/02/14/ProGit读书笔记Chapter2/","text":"2016年春节前大概一周时间，忘了什么契机，忽然觉得自己用了Git这么久，一直处于一知半解的状态，而Git作为一个出色的VCS，自问世以来长盛不衰，一定有其道理。本着“不但要知其然，还要知其所以然”的态度，决定认真读一读《Pro Git》。说来惭愧，组内最开始从Subversion迁移到Git时，一新就向大家推荐过这本书，当时自己简单翻了翻，由于有其他事情就耽搁下，一直没有再打开过。 Chapter 2. Git Basics第二章主要讲了如何将一个文件添加进VCS、提交改动、历史查看、撤销操作、Tag。 文件状态Git中有四种文件状态，相互间转换关系见下图 使用Git时，要多多用git status来查看当前文件状态 同一个文件是可以同时处于modified和staged两种状态的，试着edit-add-edit，你就会发现 git status --short可以用来查看更简短的文件状态描述，用处不大 .gitignore对于不想加入到版本控制中的文件（IDE生成文件、编译中间文件等），可以使用.gitignore来告诉Git系统，不需要关注这些文件。gitignore的例子如下，以#开头的行是注释，会被Git忽略掉。1234567891011121314151617# no .a files*.a# but do track lib.a, even though you&apos;re ignoring .a files above!lib.a# only ignore the TODO file in the current directory, not subdir/TODO/TODO# ignore all files in the build/ directorybuild/# ignore doc/notes.txt, but not doc/server/arch.txtdoc/*.txt# ignore all .pdf files in the doc/ directorydoc/**/*.pdf git diffgit diff用来查看进行的改动，控制台的输出不够直观，尤其是改动很多的时候。推荐使用GUI进行查看（需要在.gitconfig中进行配置，位置是~/.gitconfig），目前笔者在用的是DiffMerge，基本满足日常使用需求。 git diff用来查看modified的变更。 git diff --cached同git diff --staged作用一样，用来查看staged的变更 git commit使用git commit将改动提交到仓库，以创建一个Snapshot。Snapshot是一个很重要的概念，是Git内部实现的最关键机制，也是Git能够超越Subversion等其他VCS的杀手级特性，这一点将在Chapter3中进行说明。 直接输入git commit后，将会打开一个编辑器页面（笔者用的是Vim，可以在gitconfig中配置），内容如下： 1234567891011# Please enter the commit message for your changes. Lines starting# with &apos;#&apos; will be ignored, and an empty message aborts the commit.# On branch master# Changes to be committed:# new file: README# modified: CONTRIBUTING.md#~~~&quot;.git/COMMIT_EDITMSG&quot; 9L, 283C 可以在其中编辑本次提交信息，如果不写任何东西的话，Git是不会承认本次commit的。 如果不想打开编辑器，可以直接在commit时加上-m参数，如下 1$ git commit -m &quot;Story 182: Fix benchmarks for speed&quot; 可以用-a -m或者-am把stage、commit两个操作一起完成 123456789101112$ git statusOn branch masterChanges not staged for commit: (use \"git add &amp;lt;file&amp;gt;...\" to update what will be committed) (use \"git checkout -- &amp;lt;file&amp;gt;...\" to discard changes in working directory) modified: CONTRIBUTING.mdno changes added to commit (use \"git add\" and/or \"git commit -a\")$ git commit -a -m 'added new benchmarks'[master 83e38c7] added new benchmarks 1 file changed, 5 insertions(+), 0 deletions(-) Removing Files直接rm文件的话，文件是处于unstaged状态的，此时需要先add，再commit 1234567891011$ rm PROJECTS.md$ git statusOn branch masterYour branch is up-to-date with 'origin/master'.Changes not staged for commit: (use \"git add/rm &amp;lt;file&amp;gt;...\" to update what will be committed) (use \"git checkout -- &amp;lt;file&amp;gt;...\" to discard changes in working directory) deleted: PROJECTS.mdno changes added to commit (use \"git add\" and/or \"git commit -a\") 或者直接用git rm，将文件直接置于staged状态 12345678$ git rm PROJECTS.mdrm 'PROJECTS.md'$ git statusOn branch masterChanges to be committed: (use \"git reset HEAD &amp;lt;file&amp;gt;...\" to unstage) deleted: PROJECTS.md 另外一个很有用的参数是--cached，用来将文件从staged状态转移到untracked。如果在最初编辑.gitignore时漏写了某个文件，后面发现Git已经记录了这个文件的变更，可以先用--cached参数停止track该文件，然后编辑.gitignore，将文件添加进去。 1$ git rm --cached README Moving Files同样，可以用git mv来完成文件重命名 1234567$ git mv README.md README$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &amp;lt;file&amp;gt;...&quot; to unstage) renamed: README.md -&amp;gt; README 无比重要的 git loggit log用来查看当前分支的查看历史，如果不加任何参数，默认输出每次提交的SHA1值、提交者、提交时间、提交信息 123456789101112131415161718$ git logcommit ca82a6dff817ec66f44342007202690a93763949Author: Scott Chacon &lt;schacon@gee-mail.com&gt;Date: Mon Mar 17 21:52:11 2008 -0700 changed the version numbercommit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7Author: Scott Chacon &lt;schacon@gee-mail.com&gt;Date: Sat Mar 15 16:40:33 2008 -0700 removed unnecessary testcommit a11bef06a3f659402fe7563abf99ad00de2209e6Author: Scott Chacon &lt;schacon@gee-mail.com&gt;Date: Sat Mar 15 10:31:28 2008 -0700 first commit 使用-p参数可以展示每次提交的文件具体改动，使用-[num]（如-2）来控制显示的commit数 1234567891011121314151617181920212223242526272829303132333435363738394041$ git log -p -2commit ca82a6dff817ec66f44342007202690a93763949Author: Scott Chacon &amp;lt;schacon@gee-mail.com&amp;gt;Date: Mon Mar 17 21:52:11 2008 -0700 changed the version numberdiff --git a/Rakefile b/Rakefileindex a874b73..8f94139 100644--- a/Rakefile+++ b/Rakefile@@ -5,7 +5,7 @@ require 'rake/gempackagetask' spec = Gem::Specification.new do |s| s.platform = Gem::Platform::RUBY s.name = \"simplegit\"- s.version = \"0.1.0\"+ s.version = \"0.1.1\" s.author = \"Scott Chacon\" s.email = \"schacon@gee-mail.com\" s.summary = \"A simple gem for using Git in Ruby code.\"commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7Author: Scott Chacon &amp;lt;schacon@gee-mail.com&amp;gt;Date: Sat Mar 15 16:40:33 2008 -0700 removed unnecessary testdiff --git a/lib/simplegit.rb b/lib/simplegit.rbindex a0a60ae..47c6340 100644--- a/lib/simplegit.rb+++ b/lib/simplegit.rb@@ -18,8 +18,3 @@ class SimpleGit end end--if $0 == __FILE__- git = SimpleGit.new- puts git.show-end\\ No newline at end of file 如果觉得-p参数展示的太多了，就用--stat来看改动文件与行数 1234567891011121314151617181920212223242526272829$ git log --statcommit ca82a6dff817ec66f44342007202690a93763949Author: Scott Chacon &amp;lt;schacon@gee-mail.com&amp;gt;Date: Mon Mar 17 21:52:11 2008 -0700 changed the version number Rakefile | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-)commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7Author: Scott Chacon &amp;lt;schacon@gee-mail.com&amp;gt;Date: Sat Mar 15 16:40:33 2008 -0700 removed unnecessary test lib/simplegit.rb | 5 ----- 1 file changed, 5 deletions(-)commit a11bef06a3f659402fe7563abf99ad00de2209e6Author: Scott Chacon &amp;lt;schacon@gee-mail.com&amp;gt;Date: Sat Mar 15 10:31:28 2008 -0700 first commit README | 6 ++++++ Rakefile | 23 +++++++++++++++++++++++ lib/simplegit.rb | 25 +++++++++++++++++++++++++ 3 files changed, 54 insertions(+) --pretty参数可以美化信息展示，这是一个复合参数，有oneline、short、full、fuller等选择 1234$ git log --pretty=onelineca82a6dff817ec66f44342007202690a93763949 changed the version number085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 removed unnecessary testa11bef06a3f659402fe7563abf99ad00de2209e6 first commit 或者自己定制输出模版 1234$ git log --pretty=format:\"%h - %an, %ar : %s\"ca82a6d - Scott Chacon, 6 years ago : changed the version number085bb3b - Scott Chacon, 6 years ago : removed unnecessary testa11bef0 - Scott Chacon, 6 years ago : first commit 模版参数定义如下 Option Description of Output %H Commit hash %h Abbreviated commit hash %T Tree hash %t Abbreviated tree hash %P Parent hashes %p Abbreviated parent hashes %an Author name %ae Author email %ad Author date (format respects the –date=option) %ar Author date, relative %cn Committer name %ce Committer email %cd Committer date %cr Committer date, relative %s Subject 在log中使用--graph来展示ASCII格式的图形化提交历史，建议使用更傻瓜的GUI工具来查看 1234567891011$ git log --pretty=format:\"%h %s\" --graph* 2d3acf9 ignore errors from SIGCHLD on trap* 5e3ee11 Merge branch 'master' of git://github.com/dustin/grit|\\| * 420eac9 Added a method for getting the current branch.* | 30e367c timeout code and tests* | 5a09431 add timeout protection to grit* | e1193f8 support for heads with slashes in them|/* d6016bc require time for xmlschema* 11d191e Merge branch 'defunkt' into local 如果想查看两周以来的提交，用--since参数，同理，也有--until可供使用，后面可以接2016-01-01这样的时间格式 1$ git log --since=2.weeks -S参数查看提交中包含某个特定字段变更的log，比如你想看哪些提交改到了onCreate函数，就这么写 1$ git log --SonCreate 还有其它选择功能，如查看某人的提交--committer，查看包含某些敏感词的提交--grep等等，如下表所示 Option Description -(n) Show only the last n commits –since, –after Limit the commits to those made after the specified date. –until, –before Limit the commits to those made before the specified date. –author Only show commits in which the author entry matches the specified string. –committer Only show commits in which the committer entry matches the specified string. –grep Only show commits with a commit message containing the string -S Only show commits adding or removing code matching the string 举个🌰，直接照搬书中的好了： For example, if you want to see which commits modifying test files in the Git source code history are merged and were committed by Junio Hamano in the month of October 2008, you can run something like this: 12345678$ git log --pretty=\"%h - %s\" --author=gitster --since=\"2008-10-01\" \\ --before=\"2008-11-01\" --no-merges -- t/5610e3b - Fix testcase failure when extended attributes are in useacd3b9e - Enhance hold_lock_file_for_&#123;update,append&#125;() APIf563754 - demonstrate breakage of detached checkout with symbolic link HEADd1a43f2 - reset --hard/read-tree --reset -u: remove unmerged new paths51a94af - Fix \"checkout --track -b newbranch\" on detached HEADb0ad11e - pull: allow \"git pull origin $something:$current_branch\" into an unborn branch Undoing Things如果在一次commit后，发现忘了修改某个文件foo，那要怎么办？当然可以修改了foo后，用git commit -am来增加一次commit。可如果想与之前的commit并成一个呢？git为我们提供了这样的工具--amend(amend: vt&amp;vi 改良，修改，修订)。Git会检查staged区域，将其中的变更与上一个commit合并，你还可以修改合并后的commit信息。针对上面的场景 123$ git commit -m 'initial commit'$ git add forgotten_file$ git commit --amend 如果staged区域并没有任何改动，--amend可以用来单纯的修改commit message，同样十分有用。 下面讲讲，要是在stage文件后，反悔了，想要把文件回滚，怎么办？其实git status已经给了我们提示，那就是git reset，要结合HEAD使用 1234567891011121314151617181920212223$ git add *$ git statusOn branch masterChanges to be committed: (use \"git reset HEAD &amp;lt;file&amp;gt;...\" to unstage) renamed: README.md -&amp;gt; README modified: CONTRIBUTING.md$ git reset HEAD CONTRIBUTING.mdUnstaged changes after reset:M CONTRIBUTING.md$ git statusOn branch masterChanges to be committed: (use \"git reset HEAD &amp;lt;file&amp;gt;...\" to unstage) renamed: README.md -&amp;gt; READMEChanges not staged for commit: (use \"git add &amp;lt;file&amp;gt;...\" to update what will be committed) (use \"git checkout -- &amp;lt;file&amp;gt;...\" to discard changes in working directory) modified: CONTRIBUTING.md 上面这种用法只是回滚了staged中的文件，如果加上--hard参数，可就要慎重了——这会把commit回滚掉，而且，不留痕迹！ 如果文件还没有进行stage，正处于modified，你想要将它变回到unmodified，就用checkout --。同样，这个操作不会保留之前的任何修改，不带走一丝云彩。 1$ git checkout -- README.md Git还提供了另外一个很有力的工具stash，用来暂存修改，限于篇幅，暂不展开。 Working With RemotesGit是一个强有力的协作工具，必不可少地，你会将自己的代码推送到仓库供他人使用，你也会将他人完成的代码从远端拉下来进行追踪。 git remote -v用来查看本地的分支（fetch &amp; push），对于复杂的项目，会有多个远端remote（实在找不出这个语境下合适的翻译，总不能说“分支”吧，会与branch重复） 1234567891011$ git remote -vbakkdoor https://github.com/bakkdoor/grit (fetch)bakkdoor https://github.com/bakkdoor/grit (push)cho45 https://github.com/cho45/grit (fetch)cho45 https://github.com/cho45/grit (push)defunkt https://github.com/defunkt/grit (fetch)defunkt https://github.com/defunkt/grit (push)koke git://github.com/koke/grit.git (fetch)koke git://github.com/koke/grit.git (push)origin git@github.com:mojombo/grit.git (fetch)origin git@github.com:mojombo/grit.git (push) 一般我们只会看到origin一个remote，使用git remote add来添加remote 12345678$ git remoteorigin$ git remote add pb https://github.com/paulboone/ticgit$ git remote -vorigin https://github.com/schacon/ticgit (fetch)origin https://github.com/schacon/ticgit (push)pb https://github.com/paulboone/ticgit (fetch)pb https://github.com/paulboone/ticgit (push) pb是我们起的别名，然后使用fetch来更新这个remote 12345678$ git fetch pbremote: Counting objects: 43, done.remote: Compressing objects: 100% (36/36), done.remote: Total 43 (delta 10), reused 31 (delta 5)Unpacking objects: 100% (43/43), done.From https://github.com/paulboone/ticgit * [new branch] master &gt; pb/master * [new branch] ticgit &gt; pb/ticgit 也可以不指定remote名称，直接fetch所有remote 讲完了下载，我们来看看如何上传。git push [remote-name] [branch-name]，灰常简单 1$ git push origin master git remote show [remote-name]命令可以用来观察某个remote的状态，注意！这里观察的并不是远端实时状态，而是本地上一次下载下来的版本，如果你想观察最新状态，需要先fetch 1234567891011121314151617181920$ git remote show origin* remote origin URL: https://github.com/my-org/complex-project Fetch URL: https://github.com/my-org/complex-project Push URL: https://github.com/my-org/complex-project HEAD branch: master Remote branches: master tracked dev-branch tracked markdown-strip tracked issue-43 new (next fetch will store in remotes/origin) issue-45 new (next fetch will store in remotes/origin) refs/remotes/origin/issue-11 stale (use 'git remote prune' to remove) Local branches configured for 'git pull': dev-branch merges with remote dev-branch master merges with remote master Local refs configured for 'git push': dev-branch pushes to dev-branch (up to date) markdown-strip pushes to markdown-strip (up to date) master pushes to master (up to date) 如果你觉得某个remote的名字起的太土气了，使用git remote rename [old_name] [new_name]来修改 1234$ git remote rename pb paul$ git remoteoriginpaul 同样，使用git remote rm [remote_name]来删除（可怜的paul） 123$ git remote rm paul$ git remoteorigin Tagging你完成了一个版本的全部需求，已经信心满满地进行了上线，并且线上全面回归过，一切正常——你以为全部的工作都完成了吗？并没有！你需要记录下本次提交作为一个里程碑，Git提供了Tag这个强大的工具。 查看目前的tag，注意是以alphabetical顺序排列的，并非时间 123$ git tagv0.1v1.3 使用-l参数查看包含某个敏感词的tag 123456789$ git tag -l \"v1.8.5*\"v1.8.5v1.8.5-rc0v1.8.5-rc1v1.8.5-rc2v1.8.5-rc3v1.8.5.1v1.8.5.2v1.8.5.3 有两种Tag：lightweighted和annotated。前者非常简单，只是一个tag name，不包含任何其他信息。后者则记录了tagger name、email、date、message等信息，并且可以用GNU Privacy Guard (GPG)进行签名和校验。笔者强烈建议使用annotated进行打Tag。 annotated tag 12345$ git tag -a v1.4 -m \"my version 1.4\"$ git tagv0.1v1.3v1.4 用git show [tag_name]查看一下 123456789101112$ git show v1.4tag v1.4Tagger: Ben Straub &amp;lt;ben@straub.cc&amp;gt;Date: Sat May 3 20:19:12 2014 -0700my version 1.4commit ca82a6dff817ec66f44342007202690a93763949Author: Scott Chacon &amp;lt;schacon@gee-mail.com&amp;gt;Date: Mon Mar 17 21:52:11 2008 -0700 changed the version number lightweighted tag 12345678910111213$ git tag v1.4-lw$ git tagv0.1v1.3v1.4v1.4-lwv1.5$ git show v1.4-lwcommit ca82a6dff817ec66f44342007202690a93763949Author: Scott Chacon &lt;schacon@gee-mail.com&gt;Date: Mon Mar 17 21:52:11 2008 -0700 changed the version number 看到了没，对于这种tag，并没有提供commit之外的任何信息。 如果你想要对几天之前的某一个commit打tag，怎么办？难道git只能在最新提交上打Tag吗？图样图森破！ 123456789101112131415161718192021$ git tag -a v1.2 9fceb02$ git tagv0.1v1.2v1.3v1.4v1.4-lwv1.5$ git show v1.2tag v1.2Tagger: Scott Chacon &amp;lt;schacon@gee-mail.com&amp;gt;Date: Mon Feb 9 15:32:16 2009 -0800version 1.2commit 9fceb02d0ae598e95dc970b74767f19372d61af8Author: Magnus Chacon &amp;lt;mchacon@gee-mail.com&amp;gt;Date: Sun Apr 27 20:43:35 2008 -0700 updated rakefile... 看到没，只需要在后面拼上checksum（可以只是一部分），就可以了 按照上面的指示，你在本地打好了Tag，让我们把它推送到仓库 12345678$ git push origin v1.5Counting objects: 14, done.Delta compression using up to 8 threads.Compressing objects: 100% (12/12), done.Writing objects: 100% (14/14), 2.05 KiB | 0 bytes/s, done.Total 14 (delta 3), reused 0 (delta 0)To git@github.com:schacon/simplegit.git * [new tag] v1.5 &gt; v1.5 如果tag很多，用复数！ 1234567$ git push origin --tagsCounting objects: 1, done.Writing objects: 100% (1/1), 160 bytes | 0 bytes/s, done.Total 1 (delta 0), reused 0 (delta 0)To git@github.com:schacon/simplegit.git * [new tag] v1.4 &gt; v1.4 * [new tag] v1.4-lw &gt; v1.4-lw tag本身是无法进行修改的，这在一定程度上保证了代码的安全，当然，如果tag可以随便修改，那它跟普通的branch有什么区别？我们可以将tag拉成本地一个branch，用git checkout -b [branchname] [tagname] 12$ git checkout -b version2 v2.0.0Switched to a new branch 'version2' Git Aliaes（别名）（也许是使用Git不够重度的原因，笔者认为这部分内容并不十分重要，几个常用的命令都很容易记，不常用的起了别名也记不住…） 用git config --global alias.[alias_name] [original_command]来创建alias，在~/.gitconfig中查看这些alias。 1234$ git config --global alias.co checkout$ git config --global alias.br branch$ git config --global alias.ci commit$ git config --global alias.st status 比如，你可以创建这样的alias，来回滚一个stage 1$ git config --global alias.unstage 'reset HEAD --' 这样，你就可以用 1$ git unstage fileA 来代替 1$ git reset HEAD -- fileA 如果你想要运行Git外部命令（rather than a Git subcommand），在命令前加上!（原文给的解释是This is useful if you write your own tools that work with a Git repository.笔者绞尽脑汁也没有想到这个功能用处在哪里…） 1$ git config --global alias.visual '!gitk' ===Ending===","tags":[{"name":"技术流","slug":"技术流","permalink":"https://lilei.pro/tags/技术流/"}]},{"title":"nova自动化测试探索与实践","date":"2016-01-28T03:27:49.000Z","path":"2016/01/28/Nova-Automation-Practice/","text":"自动化测试可行性分析针对android-nova项目，每个新版本发布之前，RD 都需要进行主流程回归，这是一项重复且耗时的工作，“重复”是指每2～3周发版时就要进行一次，“耗时”则因为平均一条业务线要用一个小时时间——这还只是单android平台。实现自动化后，可以大大减轻 RD 负担，并且可在迭代过程中建立 daily build 机制，及早发现问题，提高提测质量。 对自动化测试的理解这里只针对 UI 方面的白盒测试 自动化测试的输入是用户操作（输入、点击、滑动）、网络请求返回 自动化测试的输出是 UI 控件显示 这两步都可以通过现有的自动化工具完成 自动化工具选取之前组内分享了2个自动化工具，Robutium 和 Appium。查阅相关资料后，发现网络上比较流行的不外乎也就是这两个。简单罗列出各自的特点： Robotium Appium 是否开源 是 是 测试类型 黑盒 黑盒 支持平台 Android Android, iOS, FirefoxOS apk是否需要再编译 需要，测试代码必须打入apk包 无需，测试代码单独存放 可测App类型 原生，hybrid 原生，hybrid，甚至可以通过Safari／Chrome来测试web页面 安全性 “The most notable limitation”, 操作仅限本 app 未知 用例语言 Java Any WebDriver-compatible language: Java, Python, PHP, C#, OC… 参考资料 Android Robotium自动化测试使用手册 by 楼赟程 Android Appium自动化测试指导手册 by 覃少强 比较之后，选用Appium作为实践手段 难点如果要实现自动化测试，总结下来，以下几个方面是难点，也是必须解决的问题 预设数据保存、读取 预设数据填入组件 模拟请求发送接收 检验接收后的界面展示 其中2&amp;4可以由测试框架帮助完成，1&amp;3比较棘手，详见本文讲述。 Appium配置与运行历时一天才跑通了Appium的demo，不得不再次感慨，中文博客的帮助的确是太太太太少了。首先要确认平台是OS X，其次还要是为android进行测试，好不容易找到了一些，发现大家都是一模一样的，不知道是谁抄谁。关键是你抄来抄去，抄的净是些错误内容…… 自己途中遇到一些曲折，记录如下 理解Appium所使用的client-server-app的结构，client的代码不应该写在app里我是这么处理的： client：maven项目，用IntelliJ编写，测试代码位于test/java/com.leili.demo.Demo，注意maven项目要在pom里处理好依赖（见代码） server：Appium的GUI界面，完成配置即可使用，不需二次开发 app：gradle项目，用AndroidStudio编写，不含测试代码 配置ANDROID_HOME时，记得配至到系统默认的bash配置文件中。刚开始时自己只写到了~/.zshrc里（因为平时用的是zsh），结果运行测试用例时报错找不到ANDROID_HOME，上网查找后也没有结果（baidu检索出的中文博客大多是讲路径中不要有空格…），最后醍醐灌顶恍然大悟，改了~/.bash_profile，才生效 在写Appium测试用例（Java）时，在EditText进行输入，直接element.sendKeys(&quot;foooooo&quot;)即可，不要想当然在前面加上element.click()，否则会有奇怪的事情发生 maven依赖 123456789101112131415161718192021222324252627282930313233343536373839&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt; &lt;artifactId&gt;selenium-java&lt;/artifactId&gt; &lt;version&gt;2.48.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;4.5.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.appium&lt;/groupId&gt; &lt;artifactId&gt;java-client&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.14&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 启动 Activity由于Appium目前只能用包名＋类名的方式启动，不支持通过intent启动Activity。如果需要在启动中携带参数，这里提供一个解决方法：在debug面板中通过scheme直接进入目标Activity。这种做法过于依赖Debug面板，其实并不是一种好的实现方式。 希望Appium团队能够在后续更新中提供更多的启动Activity途径。 Appium中启动Activity的方法，代码位于AndroidDriver.java 123456789101112131415161718/** * @param appPackage * The package containing the activity. [Required] * @param appActivity * The activity to start. [Required] * @param appWaitPackage * Automation will begin after this package starts. [Optional] * @param appWaitActivity * Automation will begin after this activity starts. [Optional] * @param stopApp * If true, target app will be stopped. [Optional] * @example driver.startActivity(\"com.foo.bar\", \".MyActivity\", null, null, true); * * @see StartsActivity#startActivity(String, String, String, String) */public void startActivity(String appPackage, String appActivity, String appWaitPackage, String appWaitActivity, boolean stopApp) throws IllegalArgumentException; 测试数据存取对于如何读取mock数据，有两种思路 手机/模拟器连接mock服务器后，在mock服务器上配置，客户端每次请求会发送出去，但不是发送到真实的api后端，而是发送到mock服务器 app代码无需变动 实现简单 android/iOS两个平台可以共用同一套数据、同一个mock服务器 依赖mock服务器，甚至可能需要自己搭建mock服务器 要考虑如何使模拟器在mock服务器上进行注册。已有的扫二维码方式显然不现实 将mock数据存入手机/模拟器，本地读取 不依赖mock服务器 需要app内部支持，实现DB、Service等功能，较复杂 android/iOS各自都需要改动底层代码以进行支持 仍然需要考虑正常开启的app如何自动切换到测试模式 比较后，选用1作为最后的实现方式，同时基于mobile-httpwatch搭建了自己的mock服务器，提供预加载配置的接口。 Show Time主流程测试用例（预订）：test case 这条用例的操作过程中，涉及到调用以下3个接口: getbookingcontext.yy，获取商户预订配置 getbookingholidays.yy，获取节假日信息（商户无关） book.yy，下订单 出于简化的考虑，我们本次只对接口3进行mock。 截图应如下所示： 输入 输出 Q: 预设的mock数据要保存在TestCase中还是保存在Server里？有两种方案 mock data 保存在 TestCase 侧，每次用例执行前，TestCase 把数据传给 Server（这种方案每次传递数据量过大） mock data 保存在 Server 侧，每次用例执行前，TestCase 把 mock data id 传给 Server 每个 case 对应一套 mock data ，可以是一个接口或者多个接口的数据。 功能点开发进度表||状态|功能点|备注||1|done|test engine 发送 pre-req ，告知 server caseid|||2|done|server 收到请求|||3|done|server 解析请求中的 caseid|||4|done|server 根据 caseid ，加载本地对应 mock data ，加载完成后告知 test engine|||5|done|test engine 驱动 client 进行注册|||6|done|test engine 驱动 client 发送真实请求|||7|done|server 根据真实请求，返回已经准备好的 mock data|||8|done|client 获得 mock data|||9|done|test engine 进行自动化 UI 检验|||10||test engine UI 校验完成后，发送 post-req，告知 server 清除 mock data|可选||11||server 接收到 post-req 后，清除 mock data|可选| 一些nodejs函数方法处理get请求 123456&lt;!-- http://appmock.dp/mockconfig.do?caseid=1024 --&gt;console.log(url.parse(request.url, true).query.caseid); // log '1024' hereresponse.writeHead(200, &#123; \"Content-Type\": \"text/plain;charset=utf-8\"&#125;);response.end(); 处理post请求 1234567891011121314var postData = \"\";request.addListener(\"data\", function(postDataChunk) &#123; postData += postDataChunk;&#125;);request.addListener(\"end\", function () &#123; console.log('数据接收完毕'); var params = querystring.parse(postData); console.log(params); console.log(params[\"num\"]); /// &#123;num=1024, name=lilei&#125;, log '1024' here response.writeHead(500, &#123; \"Content-Type\": \"text/plain;charset=utf-8\" &#125;); response.end(\"数据提交完毕\");&#125;); 读取文件（同步） 123var content = fs.readFileSync('/Users/leili/Downloads/7');config = parseJson(content);user.setMockConfig(config); 读取文件（异步） 1234567fs = require(\"fs\");fs.readFile('/Users/leili/Downloads/2', 'utf8', function(err, data) &#123; if (err) &#123; return console.log(err); &#125; console.log(data);&#125;); 遇到的问题 预订可能对已过时间有一些判断，导致在线预订页无法使用mock数据，原因未明 反过来，一些思考 真的需要自动化吗？UI 本身做的逻辑就很少，如果返回数据是正确的，UI 显示也几乎不会出现问题，为何要如此多精力来写自动化 case 准确度：每一个控件，展示什么内容？ 数量：case 数量大，记不住 投入到生产中，会遇到的问题 前期准备量大：扒测试数据，造各种case（定金、预订成功、失败，商家营业中、暂未营业等各种状态） 难以对布局之间的相对位置、缩进等进行测试 即使是使用Appium进行自动化测试，也是需要rd做支持的，qa必须从rd处了解到诸如控件id等属性，方可以定位到目标控件进行操作。 视觉上看是一个TextView，而实际上是两个TextView，作为QA难以判断（可能要求理解功能具体实现） mobile-httpwatch 项目阅读笔记记录的内容比较琐碎 web.js 注册，设置mock数据mockconfig.js mock设置界面User.js 用户数据结构，每个用户有一个MockConfigmock_config.js 默认的mock数值html5 的 localStorageProxyFactory.js mock rule，重点看handleProxyRequest和mockResponse两个方法mockConfig = user.getMockRuleForUrl(req.url)Utils.js 参考资料http://www.cnblogs.com/lori/p/3437562.htmlhttp://www.mkyong.com/java/how-to-send-http-request-getpost-in-java ===Ending===","tags":[{"name":"技术流","slug":"技术流","permalink":"https://lilei.pro/tags/技术流/"},{"name":"自动化测试","slug":"自动化测试","permalink":"https://lilei.pro/tags/自动化测试/"}]},{"title":"携程动态加载实践DynamicAPK项目学习","date":"2016-01-18T14:40:33.000Z","path":"2016/01/18/携程动态加载实践DynamicAPK项目学习/","text":"术语宿主：Host Apk，打包运行的总项目，用于集成各个子工程，相当于android-nova壳，只有一个 插件：Plugin，子工程，由各个业务线独立开发，可以依赖宿主提供的资源，一个宿主能够拥有多个插件 Andoroid Build 流程 Resource Files：项目res路径下的文件，包含anim、drawable、layout、raw等 Source Files：项目src路径下(对于android-nova是src/main/java)的文件 aapt: 将.xml文件转换为java类型 Generated Source Files：由aapt工具生成，存储在/gen目录 javac：java编译器，生成.class文件 dx：将.class文件转换为DVM可识别的dex文件 apkbuilder：将所有文件打包进apk中 zipalign：将apk中未经压缩过的文件进行4字节对齐，以减少运行时RAM消耗 协同开发与引用aar提供的公用UI组件之间的联系与区别 本质上都是classes.dex与res/等文件的集合 依赖关系不同 是否包含业务逻辑 最重要的一点，Activity注册 插件引用宿主资源 在java代码中直接用 12345678910111213public class MainActivity extends Activity &#123; // demo2 @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.demo2_activity_main); TextView textView=(TextView)findViewById(R.id.demo2_textView3); textView.setText(R.string.sample_text); // 宿主资源 ImageView imageView=(ImageView)findViewById(R.id.demo2_imageView2); imageView.setImageResource(R.drawable.sample); // 宿主资源 &#125;&#125; 在布局文件中引用宿主资源，编译时会报错 12/Users/leili/Documents/idea_workspace/BeQuietLee/DynamicAPK/demo2/res/layout/demo2_activity_main.xml:40: error: Error: No resource found that matches the given name (at 'src' with value '@drawable/sample'). 宿主调起插件 宿主AndroidMainifest.xml需要对所有插件Activity进行注册 123456789101112131415161718192021222324252627282930313233&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"ctrip.android.sample\" &gt; &lt;application android:name=\"ctrip.android.sample.BundleBaseApplication\" android:allowBackup=\"true\" android:icon=\"@mipmap/ic_launcher\" android:label=\"@string/app_name\" &gt; &lt;activity android:name=\".MainActivity\" android:label=\"@string/app_name\" &gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=\"ctrip.android.demo1.MainActivity\" &gt; &lt;/activity&gt; &lt;activity android:name=\"ctrip.android.demo2.MainActivity\" &gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; startActivity时需要写明类的完整路径 1startActivity(new Intent(getApplicationContext(), Class.forName(\"ctrip.android.demo1.MainActivity\"))); 对aapt工具的改造为aapt增加--apk-module参数 如前所述，资源ID其实有一个PackageID的内部字段。我们为每个插件工程指定独特的PackageID字段，这样根据资源ID就很容易判明，此资源需要从哪个插件apk中去查找并加载了。在后文的资源加载部分会有进一步阐述。 通常项目中生成的R.java，会包含由aapt生成的所有资源的id，以0x7f开头 1234567891011121314151617181920212223242526package com.dianping.hui;public final class R &#123; public static final class anim &#123; public static int activity_exit=0x7f040000; public static int back_enter=0x7f040001; public static int back_exit=0x7f040002; public static int booking_push_up_out=0x7f040003; public static int fade_light_out=0x7f040004; public static int gradient_enter=0x7f040005; public static int grow_from_bottom=0x7f040006; // ... &#125; public static final class color &#123; public static int actionbar_title_color=0x7f0b0000; // ... &#125; public static final class dimen &#123; public static int action_button_height=0x7f0700a6; public static int action_button_margin_between=0x7f0700a7; // ... &#125; // ...&#125; 0x7f是怎么来的呢，看一下原汁原味的aapt中的逻辑 1234567891011121314151617181920ResourceTable::ResourceTable(Bundle* bundle, const String16&amp; assetsPackage, ResourceTable::PackageType type)ssize_t packageId = -1;switch (mPackageType) &#123; case App: case AppFeature: packageId = 0x7f; break; case System: packageId = 0x01; break; case SharedLibrary: packageId = 0x00; break; default: assert(0); break;&#125; DynamicAPK中改动后的生成packageId的逻辑，位于ResourceTable.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103ResourceTable::ResourceTable(Bundle* bundle, const String16&amp; assetsPackage, ResourceTable::PackageType type) : mAssetsPackage(assetsPackage) , mPackageType(type) , mTypeIdOffset(0) , mNumLocal(0) , mBundle(bundle)&#123; ssize_t packageId = -1; switch (mPackageType) &#123; case App: case AppFeature: packageId = 0x7f; break; case System: packageId = 0x01; break; case SharedLibrary: packageId = 0x00; break; // case Voice:// packageId = 0x34;// break;// case Call:// packageId = 0x35;// break;// case Search:// packageId = 0x36;// break;// case Schedule:// packageId = 0x37;// break;// case Train:// packageId = 0x38;// break;// case Destination:// packageId = 0x44;// break;// case Chat:// packageId = 0x46;// break;// case Flight:// packageId = 0x52;// break;// case MyCtrip:// packageId = 0x54;// break;// case Pay:// packageId = 0x55;// break;// case Foundation:// packageId = 0x56;// break;// case Hotel:// packageId = 0x58;// break;// case Container:// packageId = 0x61;// break;// case CustomerService:// packageId = 0x62;// break;// case ThirdParty:// packageId = 0x63;// break;// case Extend1:// packageId = 0x64;// break;// case Extend2:// packageId = 0x65;// break;// case Extend3:// packageId = 0x66;// break;// case Extend4:// packageId = 0x67;// break;// case Extend5:// packageId = 0x68;// break;// case Extend6:// packageId = 0x69;// break; default: assert(0); break; &#125; if(!bundle-&gt;getApkModule().isEmpty())&#123; android::String8 apkmoduleVal=bundle-&gt;getApkModule(); packageId=apkStringToInt(apkmoduleVal); &#125; sp&lt;Package&gt; package = new Package(mAssetsPackage, packageId); mPackages.add(assetsPackage, package); mOrderedPackages.add(package); // Every resource table always has one first entry, the bag attributes. const SourcePos unknown(String8(\"????\"), 0); getType(mAssetsPackage, String16(\"attr\"), unknown);&#125; 如此一来，不同业务的资源被赋予了不同的id，在加载时，便进入到各个业务打出的插件包里寻找资源. 在sub-project-build.gradle中，组装--apk-module参数 1234...argv &lt;&lt; '--apk-module'argv &lt;&lt; \"$resourceId\"... 动态加载运行时加载资源，需要知道资源从哪个插件中获取。所有插件位于压缩包的assets/baseres/路径下。在运行时会在/data/data/ctrip.android.sample/files/storage/{num}生成对应的文件夹。 1、2分别对应了demo1、demo2 meta记录了下一个可用id，即3 1/meta中保存包名ctrip.android.demo1 1/version_1/bundle.zip就是assets/baseres/ctrip_android_demo1.so，可以解压缩观察 1/version_1/bundle.dex其实与bundle.zip解压缩拿到的dex是一样的 1/version_1/meta无用（内容为file:） 这部分目录与文件的管理，是通过Bundle、Archive接口完成的，version_1、version_2…version_n分别对应一个BundleArchiveRevision，它们统一由BundleAchive管理。BundleArchive由BundleImpl管理。图中有demo1、demo2，对应着就有2个BundleImpl。各个Bundle的启动，更新，卸载，由Framework.java管理。 对应关系如下图所示： 热修复DynamicAPK中，仅仅提供了分包、资源加载的demo，未包含hotfix功能。虽然可以看到HotPatchManager.java，但并没有真正运行。这里我们自己来山寨一次hotfix的过程。 首先了解一下apk安装以及运行时会操作的几个目录。下载好的apk在进行安装时，会对系统中以下几个目录进行操作 /data/app：apk安装时会被复制到该目录 /data/dalvik-cache：安装dex文件的真正位置，后续app启动均从此处进行load /data/data：新建以packageName命名的文件夹，只有app自己能访问，用于管理数据 在没有root过的设备上，应用程序有权限操作的目录仅仅是/data/data/com.foo.foo，想更改/data/dalvik-cache中的dex文件是不可能的。但是，结合上面完成的动态加载工作，我们就可以在运行时更新demo1、demo2的dex文件，从而达到热修复的目的。 这里我们演示一个更换文案的demo，将demo2里面textView预设的文案由This is sample resource:换成下图来自于宿主资源。首先需要把改好的项目进行编译，取出bundle.dex与bundle.zip（这两个文件的来源，前文已经提过）。然后把它们上传到/data/data/com.ctrip.sample/files/storage/2/version_2。上传完成后，下次启动就会加载我们修改后的dex文件，展示新的内容。 这里直接用monitor来模拟hotfix文件下载过程。 1234567891011121314public class MainActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.demo2_activity_main); TextView textView=(TextView)findViewById(R.id.demo2_textView3);// textView.setText(R.string.sample_text); // 宿主资源 textView.setText(\"下图来自于宿主资源\"); ImageView imageView=(ImageView)findViewById(R.id.demo2_imageView2); imageView.setImageResource(R.drawable.sample); // 宿主资源 &#125;&#125; hotfix之前 hotfix之后 附一：更完整的编译流程图 附二：推荐阅读 Android动态加载技术 系列索引 ===Ending===","tags":[{"name":"技术流","slug":"技术流","permalink":"https://lilei.pro/tags/技术流/"}]},{"title":"项目交接那点事儿","date":"2016-01-15T09:01:24.000Z","path":"2016/01/15/项目交接那点事儿/","text":"源文档链接 by 李全民(BigFootprint) 2015年末，我去北京美团总部进行B端Android排号APP交接，历时2个礼拜。这是我第一次单独承接一整个客户端项目的交接，加上这还是毕业3年以来首次出差，过程中犯了一些错误，也走了很多弯路。同时，上海的小伙伴们在与美团同事进行美团app的交接。交接结束后，大家总结了本次遇到的一些问题，同时详细列出了一次成功的交接应该完成哪些任务。 以下表格是综合Team所对接的所有项目列出的对接项，实际对接项目的时候可能不会涉及到所有的内容，填写的时候请注意： 不要空单元，如果没有相应的对接项或者不能确定的内容，请注明，比如“无”、“待确定”，以便于Check整体情况； 所有的Item，如果需要实践的，请对接人实践到位，并将权限申请、联系责任人等过程记录下来； 表格本身内容有限，主要扮演汇总角色，简短的内容可直接写在表格中，较长的内容建议整理成文档，以链接的形式记录在表格内； 交接过程中请随时注意表格中的不足之处并及时补足； 交接一开始就复制该表格，新建文档进行填写； 准备 对接人 交接内容 交接完成标准 交接完成时间点 进度（注意定期反馈） 项目 项目演示 项目入口 项目使用主流程 项目运行需要的配置 项目承载的业务（详细） 项目结构 使用的技术 开源框架 Hybrid框架 JNI（注明支持架构） 技术选型原因 模块划分 划分标准 模块功能 模块负责人 代码 坑（带有Bug的地方，描述请委婉一点） 逻辑复杂 | 实现复杂的地方 建议重构的地方 提交 分支管理 分支命名 commit提交规范 分支合并方式 文档 相关文档 更新频率（规范） 硬件资源 规格 如何使用 申请流程 设备使用情况（多少台在使用中） 开发流程 迭代的重要时间节点以及节点任务 超出节点未完成任务补救措施 出了紧急问题如何处理（主要是线上Crash） Story从提出到上线的过程 PO如何提出Story 接口如何定义 联调方式 如何提测 Bug管理 独立APP 签名 发布流程 版本升级方式和规范 工具 App本身的Debug工具 打包平台的配置使用 包管理平台（MVN仓库地址） 测试工具、账号 项目监测 CrashLog 如何查询 打点 收集上传规则 划分维度（诸如：是否区分线上和beta环境） 字段含义 查询方式 监测数据有无报表，如何添加 项目当前重要数据（请仔细整理，作为项目当前状态的快照，以供日后进行对比） 合作资源 QA 后端 UED PO 相关项目负责人（比如平台） 其余 有没有别的需要注意的点 规划 找PO了解后期规划 第一期Story的开发时间 一段时间内需要的人力 项目后期规划 ===Ending===","tags":[{"name":"技术流","slug":"技术流","permalink":"https://lilei.pro/tags/技术流/"}]},{"title":"博客工具","date":"2016-01-14T13:00:29.000Z","path":"2016/01/14/博客工具/","text":"一些提高网站与博客编辑、浏览效率的工具 Markdown编辑工具dillinger.io 在线md编辑器，所见即所得 hexo的坑title中不可以包含英文的[ ] *字符，其余禁忌字符目前尚未遇到 首页文章“展开更多”默认情况下首页文章是全文展示的，很不友好。 在文件中增加&lt;!--more--&gt;标签，即可实现“展开更多”功能。 变更历史 2016.02.26 修改themes/landscape/source/css/_partial/article.styl中的.article-entry下面img, video的max-width，从100%改为70% ===Never Ending===","tags":[{"name":"工作效率","slug":"工作效率","permalink":"https://lilei.pro/tags/工作效率/"}]},{"title":"半年来我吃过的那些蛋白粉","date":"2016-01-14T12:49:23.000Z","path":"2016/01/14/半年来我吃过的那些蛋白粉/","text":"练身体的人大多会经历以下几个阶段： 初次办卡，没请过教练，自己在健身房里漫无目的地乱玩 有目的有计划地进行独立训练 注重日常饮食中蛋白质的补充，一般会从水煮蛋开始，进阶的会选择鸡胸肉 接触并使用蛋白粉 进一步接触肌酸、氮泵、BCAAs（支链氨酸）、谷氨酰胺乃至促睾等 已经超出了笔者目前认知阶段 由于自己从使用补剂以来，陆续尝试过了市面上几种常见的品牌和口味，这里整理出来，方便自己以后对比选择，也希望为尚未接触补剂的朋友提供一些初级的知识。 下面一一细数，就价格、口味、蛋白质含量、性价比等几个方面，对比一下这几种粉。 表格中列出的每一种粉，均为笔者亲身使用过。 图片、价格均来自于www.iherb.com，截取时间为2016.1.17。计价未加入新人优惠、节假日促销等因素。 名称 价格 重量 每桶份数 每份蛋白质含量/g 每份支链氨酸含量/g 每份谷氨酰胺含量/g 口味 Optimum/欧普特蒙 $65 5磅 74 24 5.5 4 Double Rich Chocolate Bio-X $65 5磅 65 27 未知 未知 Chocolate Dymatize/迪马泰兹 $58 5磅 62 25 5.6 4.4 Chocolate Fudge MRM $59 5磅 73 22 4.6 4.88 Strawberry BSN Syntha-6/六重矩阵 $60 5磅 48 22 未知 未知 Vanilla Ice Cream Optimum/欧普特蒙 金牌乳清蛋白 bodybuilding.com上排名第一的乳清蛋白 蛋白质纯度高，意味着同样是5磅，可以提供更多的份数 口味清淡，容易摇匀 iherb购买链接 Bio-X Power Whey Complex 复合乳清蛋白 笔者尝试的第一桶蛋白粉，@顾老师推荐 淘宝购买，据卖家表示是来自香港bcshop代购 iherb不售卖 因购买途径单一，且使用者少，不推荐 Dymatize／迪马泰兹 Elite精英乳清蛋白 性价比高 口味清淡，容易摇匀 相较于其它蛋白粉，Dymatize的粉吃了之后会有强烈的屁意… iherb购买链接 MRM 性价比高 草莓口味，里面居然有草莓粒！！！口感微甜，有点草莓奶昔的感觉（＋脱脂牛奶）。 用摇杯摇匀时，泡沫非常多，尤其是搭配脱脂牛奶而非纯净水。导致清洗杯子很麻烦 iherb购买链接 BSN Syntha-6 六重矩阵 严格地说这是大众所谓的“增肌粉”，并非乳清蛋白粉 碳水化合物含量高，热量高 日常用量大，每桶只能吃25天左右 香草口味很甜，口感最棒 iherb购买链接 以上就是笔者目前为止使用过的乳清蛋白了，除了Optimum的吃了两桶（一桶来自京东，一桶来自iherb），其它品牌都是一桶。在这里再一次推荐补剂海淘网站iherb，经常不定期推出折扣活动，比如新人减$10优惠、黑五折上8折优惠，而且顺丰快递满¥40是免国际与国内邮费的，即使不免邮，顺丰的邮费也只有$2。与其在淘宝、京东上提心吊胆地买代购，还不如自己海淘来的划算。 这里提供一下我的iherb优惠码：LSH141，在收银台结账时填写进去，会有-$5~$10不等的优惠，我当时首单减了$10，现在貌似优惠力度降低了。而且一旦你使用这个优惠码购买成功，我也将获得一定补贴金额进入账户，两全其美。 最后讲讲肌肉科技（MuscleTech）这个牌子。首先从知名度上来说，肌肉科技在国内大概处于数一数二的地位。而且邀请到了菲尔西斯代言，真是敢砸钱啊。笔者没有尝试过肌肉科技的蛋白粉，但从笔者购买过它的复合肌酸上来看，包装比起其它几个品牌略显简陋。总的看来与Dymatize、MRM这些低价产品比起来，性价比不高；蛋白质含量又比不过Optimum。至于购不购买，就看你对这个品牌的信仰程度了。 ===Ending===","tags":[{"name":"大保健","slug":"大保健","permalink":"https://lilei.pro/tags/大保健/"}]},{"title":"Hello World","date":"2016-01-10T13:00:29.000Z","path":"2016/01/10/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment ===Ending===","tags":[{"name":"工作效率","slug":"工作效率","permalink":"https://lilei.pro/tags/工作效率/"}]}]