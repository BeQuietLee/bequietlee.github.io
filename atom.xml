<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>柘个角落</title>
  <icon>https://www.gravatar.com/avatar/bd80dd1283cd0ce8323c050b40cb6f38</icon>
  <subtitle>IF YOU WANT SOMETHING, GO GET IT. PERIOD.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lilei.pro/"/>
  <updated>2019-10-11T16:22:48.854Z</updated>
  <id>https://lilei.pro/</id>
  
  <author>
    <name>Li Lei</name>
    <email>bequietlee@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>移动设备ID那些事</title>
    <link href="https://lilei.pro/2019/10/12/unique-device-id/"/>
    <id>https://lilei.pro/2019/10/12/unique-device-id/</id>
    <published>2019-10-11T16:09:06.000Z</published>
    <updated>2019-10-11T16:22:48.854Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么需要设备ID"><a href="#为什么需要设备ID" class="headerlink" title="为什么需要设备ID"></a>为什么需要设备ID</h2><p>“设备ID”即用于标识设备唯一身份的ID，即 Unique Device Identifier。基于以下原因，我们经常需要处理设备ID相关功能：</p><ol><li>统计需求。DAU，MAU，转化率，用户行为等统计。</li><li>业务需求。个性化推荐，日志收集，灰度发布，AB Test等业务侧需求。</li><li>风控需求。防刷单，反作弊等。</li></ol><h2 id="设备ID的特征"><a href="#设备ID的特征" class="headerlink" title="设备ID的特征"></a>设备ID的特征</h2><p>为了满足以上需求，一个良好的设备ID方案应当具有“唯一性”和“稳定性”两个特征。</p><ul><li>唯一性：系统中的任意两台设备，它们的设备ID应当不同。</li><li>稳定性：同一台设备在重启、清空应用数据、卸载应用重装、系统升级、Android 版本升级、刷机等情况下，设备ID应当保持不变。</li></ul><p>遗憾的是，Android 平台并没有稳定的API可以提供具有上面两点特征的ID。</p><h2 id="可选方案及限制"><a href="#可选方案及限制" class="headerlink" title="可选方案及限制"></a>可选方案及限制</h2><p>关于Android设备ID，常见的方案有IMEI、MAC地址、Serial、AndroidID等，下面逐一介绍它们是什么，以及为何无法承担唯一ID的职责。</p><h3 id="IMEI"><a href="#IMEI" class="headerlink" title="IMEI"></a>IMEI</h3><p>是 <strong>国际设备识别码（Imternational Mobile Equipment Identity）</strong> 的缩写，即通常所说的手机串号，用于在移动电话网络中识别每一部独立的手机等移动通信设备，共15~17位数字。在拨号键盘输入<code>*#06#</code>即可查看。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取IMEI的样例代码，需要 READ_PHONE_STATE 权限</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getIMEI</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">val</span> tm = getSystemService(Context.TELEPHONY_SERVICE) <span class="keyword">as</span> TelephonyManager</span><br><span class="line">    <span class="keyword">return</span> tm.deviceId</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在早些时候，IMEI是很多应用采取的设备ID方案，因为它读取方便，且同时具备唯一性和稳定性的特征。然而自从Android 6开始，<code>READ_PHONE_STATE</code>被列入<code>dangerous</code>的保护级别，意味着我们不仅要在<code>AndroidManifest.xml</code>文件里申请，还应当在应用到这个权限之前动态申请。尤其在中文的安卓系统上，弹窗里的文字提示是“申请电话设备信息”，很容易让人误以为这是要获取电话号码、短信内容等敏感信息。</p><p>如果说Android 6只是提高了使用IMEI作为设备ID的门槛，Android 10则是完全堵死了这条路。在Android 10的系统里，即使申请了<code>READ_PHONE_STATE</code>权限，也无法获取IMEI，会抛出<code>SecurityException</code>异常或者返回null。</p><h3 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h3><p>MAC地址（Media Access Control Address），用于标识可上网设备的唯一地址，设备有几张网卡，就会有几个MAC地址。在OSI七层模型中，MAC地址位于第二层数据链路层。看到这里你也许以为MAC地址是作为设备ID解决方案的最佳选择，实则不然，首先，MAC地址的获取方法历经多次修改，足见Google正欲收紧MAC地址权限，以后完全堵死也并非不可能。</p><p>在 (?, 6.0)，[6.0, 7.0)，[7.0, ?) 三种不同的Android版本下，有着不同的获取MAC地址方式，可以参考简书这篇文章 <a href="https://www.jianshu.com/p/16d4ff4c4cbe" target="_blank" rel="noopener">《Android 版本兼容 — Android 6.0 和 7.0后获取Mac地址》</a>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取MAC地址，适用于目前Android全版本，不保证以后继续适用（很大可能不再适用）</span></span><br><span class="line"><span class="comment">// 需要 android.permission.INTERNET 权限，为非dangerous权限，可以在AndroidManifst.xml中直接申请</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getMAC</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> enumeration = getNetworkInterfaces() ?: <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        <span class="keyword">while</span> (enumeration.hasMoreElements()) &#123;</span><br><span class="line">            <span class="keyword">val</span> netInterface = enumeration.nextElement()</span><br><span class="line">            <span class="keyword">if</span> (netInterface.name == <span class="string">"wlan0"</span>) &#123;</span><br><span class="line">                <span class="keyword">val</span> addr = netInterface.hardwareAddress</span><br><span class="line">                <span class="keyword">val</span> result = StringBuilder()</span><br><span class="line">                <span class="keyword">for</span> (b <span class="keyword">in</span> addr) &#123;</span><br><span class="line">                    result.append(String.format(<span class="string">"%02X:"</span>, b))</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (result.isNotEmpty()) &#123;</span><br><span class="line">                    result.deleteCharAt(result.length - <span class="number">1</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result.toString()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        Log.e(<span class="string">"tag"</span>, e.message, e)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h3><p>何为Serial？Serial即“设备序列号”，是设备厂商提供的设备唯一串号，唯一性由各厂商保证。拿vivo举例，它会保证自己生产的每一台设备序列号都是不同的，但是不是与OPPO的也不一样呢？这就无法保证了。一个方案是用<code>厂商ID_设备型号_序列号</code>拼接起来，作为设备ID，这样可以避免不同厂商设备具有相同Serial的问题。但是，并非所有厂商都会严格按照这个规定来做。我曾经在RK3399的开发板上做过开发，试过很多张板子，它们的Serial都是0123456789，让人哭笑不得。</p><p>更糟糕的是，Android 10又堵死了获取Serial的路，会直接抛出<code>SecurityException</code>，除非应用是系统签名且具备<code>android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE</code>权限。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取Serial，需要 READ_PHONE_STATE 权限</span></span><br><span class="line"><span class="comment">// Android 10 异常 </span></span><br><span class="line"><span class="comment">// java.lang.SecurityException: getSerial: The user 10236 does not meet the requirements to access device identifiers.</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getSerial</span><span class="params">()</span></span> = android.os.Build.getSerial()</span><br></pre></td></tr></table></figure><h3 id="AndroidID"><a href="#AndroidID" class="headerlink" title="AndroidID"></a>AndroidID</h3><p>AndroidID是SDK提供的获取ID方法，它不需要申明任何权限，具有64bit的取值范围，且唯一性也还不错。但是，它最大的硬伤在于无法满足稳定性：</p><ul><li>刷机、root、恢复出厂设置后都会变化</li><li>对安装在8.0系统的应用来说，AndroidID取决于应用签名+设备两者的组合</li><li>在8.0之前安装的应用，如果在系统升级到8.0后，卸载重装该应用，读取到的AndroidID会变化</li></ul><p>由于以上原因，在一些要求不严格的场景中，可以采用AndroidID作为设备ID，比如记录激活数、曝光数据等。但是在严格的场景中就不能用AndroidID了，如以设备ID标识用户身份，提供相应服务的场景。</p><p>读取AndroidID的样例代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取AndroidID，不需要额外申请任何权限</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getAndroidID</span><span class="params">()</span></span> = Settings.Secure.getString(contentResolver, Settings.Secure.ANDROID_ID)</span><br></pre></td></tr></table></figure><h2 id="可选方案总结"><a href="#可选方案总结" class="headerlink" title="可选方案总结"></a>可选方案总结</h2><p>用一张表格总结上述方案：</p><table><thead><tr><th>方案</th><th>概述</th><th>限制</th></tr></thead><tbody><tr><td>IMEI</td><td>具备唯一性和稳定性，过去的最佳选择</td><td>Android10堵死，无法获取</td></tr><tr><td>MAC</td><td>网卡地址，唯一且稳定</td><td>权限逐渐收紧，未来极有可能关闭</td></tr><tr><td>Serial</td><td>手机厂商提供的设备序列号</td><td>不保证唯一性，Android10堵死</td></tr><tr><td>AndroidID</td><td>Android SDK 提供，不需要申请权限，唯一性较好</td><td>不具备稳定性</td></tr></tbody></table><h2 id="设计一个新方案"><a href="#设计一个新方案" class="headerlink" title="设计一个新方案"></a>设计一个新方案</h2><p>上述四个方案里，没有哪一个是解决设备ID问题的终极武器（银弹），只有各种方法综合运用，才是解决之道。下面提出一种设备ID方案，综合使用多个硬件ID，借助服务器生成唯一虚拟设备ID（VDID），可以最大限度地保证唯一性和稳定性。</p><h3 id="稳定性：拜占庭容错"><a href="#稳定性：拜占庭容错" class="headerlink" title="稳定性：拜占庭容错"></a>稳定性：拜占庭容错</h3><p>稳定性要求当获取不到某种ID，或者某种ID发生变化时，系统能够辨识出这个设备。借助“拜占庭容错”可以解决稳定性的问题。</p><p>拜占庭容错机制源于古老 <strong>拜占庭将军（Byzantine failures）</strong> 问题。用简单的语言解释： <strong>如果系统中有n个故障节点，系统要想正确运行，必须至少要有2n+1个正常节点。</strong> 。但对于Android设备ID，我们采用弱化的拜占庭容错机制，即客户端每次上传4个ID（IMEI、MAC、Serial、AndroidID），服务器根据这4个ID生成一个随机的唯一ID即VDID。后续客户端再请求时，可以使用VDID，或者再次使用4个ID，由服务器拿这4个ID在数据库中进行查找VDID，若找到则返回，若未找到，再使用4个ID中的3个进行查找，3个不行则用2个，以此类推。</p><h3 id="获取VDID的时序图"><a href="#获取VDID的时序图" class="headerlink" title="获取VDID的时序图"></a>获取VDID的时序图</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/20191012_unique_device_id/vdid_sequence.png" alt="vdid_sequence" title="">                </div>                <div class="image-caption">vdid_sequence</div>            </figure><h3 id="唯一性：VDID的生成方式与取值范围"><a href="#唯一性：VDID的生成方式与取值范围" class="headerlink" title="唯一性：VDID的生成方式与取值范围"></a>唯一性：VDID的生成方式与取值范围</h3><p>要实现VDID的唯一性，有两种方案可以考虑：</p><h4 id="方案一：自增主键ID"><a href="#方案一：自增主键ID" class="headerlink" title="方案一：自增主键ID"></a>方案一：自增主键ID</h4><p>自增、分步自增、分段构造、Redis分布式ID等方法，可以保证唯一性。但是在传输此类ID时，应当进行hash操作，且保证hash后的ID不可碰撞。</p><p>自增ID的优点是可作为索引，检索速度快；缺点是生成规则存在被破解的风险。</p><h4 id="方案二：随机生成ID"><a href="#方案二：随机生成ID" class="headerlink" title="方案二：随机生成ID"></a>方案二：随机生成ID</h4><p>这是另一种生成唯一ID的方法，当位数足够多时，可以认为碰撞概率趋近于0。首先看一下这张表，它描述了随机数位数与发生碰撞的概率。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/20191012_unique_device_id/random_collision.png" alt="random_collision" title="">                </div>                <div class="image-caption">random_collision</div>            </figure><p>假设我们应用的活跃用户数为20,000,000，即两千万。可以看到至少要有128Bits，才能在2*10^7（两千万）的数量级有极小的碰撞概率，符合我们的业务需求。</p><p>随机ID的优点是具有隐蔽性，缺点是检索效率一般。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>本文是笔者阅读郭霖公众号推文<a href="https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650247428&amp;idx=1&amp;sn=9d52f7b3262622f9ad25af8af167fcd8&amp;chksm=8863606bbf14e97deb5ecd030ff02ee76f6d320f1c0f586034e442903d00ff79dd7fc5bb3d91&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1570535190224&amp;sharer_shareid=50472349a2a49142535b8b535dc7dac9&amp;key=042d6afab53eaf2ecfd1c244abe072a53b13e46580bd8c41a7ed57b6b5f3360221dd5c5a4ea8dc0fcde4b6632ba630de39d070bbd64a7e4f24155cec02abb5dc1e36d0ecbc6e250d6f3f87c039ad1407&amp;ascene=1&amp;uin=OTUwMTI1NjEw&amp;devicetype=Windows+10&amp;version=62060833&amp;lang=zh_CN&amp;pass_ticket=hOoinQFE6HGs3U8dFKy9YsMWbVerXZqDJCY6dO0Rh4aIO4VWSduOo5tRbTZkwcN3" target="_blank" rel="noopener">《漫谈设备唯一ID的那些秘密》</a>后的总结归纳，此处向原作者@呼啸长风致谢。然而作者原文中有一处纰漏，设备序列号（SERIAL）在Android 10上基本是无法获取的，这也会影响原作者提出的解决方案。笔者已经在Github上对此提了<a href="https://github.com/No89757/Udid/issues/1" target="_blank" rel="noopener">issue</a>。</p><p>出于对用户隐私的保护，Google一直试图收紧的设备ID的获取权限。而由于“账户”的概念在国内市场并不普遍，再加上各大OEM碎片化严重，国内的各种业务不得不依赖于设备ID进行展开。这也是开发者近年来不得不面对的问题，希望未来国内的Android生态可以更加统一，也希望Google也对此类需求提供更好的权限方案，能让开发者可以不必为此头痛。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么需要设备ID&quot;&gt;&lt;a href=&quot;#为什么需要设备ID&quot; class=&quot;headerlink&quot; title=&quot;为什么需要设备ID&quot;&gt;&lt;/a&gt;为什么需要设备ID&lt;/h2&gt;&lt;p&gt;“设备ID”即用于标识设备唯一身份的ID，即 Unique Device Ident
      
    
    </summary>
    
    
      <category term="Android" scheme="https://lilei.pro/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Flash Boys 读书笔记</title>
    <link href="https://lilei.pro/2019/10/11/flash-boys/"/>
    <id>https://lilei.pro/2019/10/11/flash-boys/</id>
    <published>2019-10-11T15:55:18.000Z</published>
    <updated>2019-10-11T15:56:49.115Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言-背景与动机"><a href="#前言-背景与动机" class="headerlink" title="前言-背景与动机"></a>前言-背景与动机</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/191011_flashboys/cover.jpg" alt="cover" title="">                </div>                <div class="image-caption">cover</div>            </figure><p>Flash Boys，中译《高频交易员》，是金融畅销书作家迈克尔刘易斯 2015 年的作品，作者之前出版过《大空头》、《说谎者的扑克牌》等华尔街领域的流行作品。在这本书中，刘易斯借助“胜山”的角色，讲解了一些 HFT 的基础知识，可以给我等小白用来入门 HFT。</p><p>书的前 2/3 值得细读，后 1/3 基本上都是给 IEX 做广告，一扫而过即可。</p><h2 id="定义：何为-HFT（高频交易）"><a href="#定义：何为-HFT（高频交易）" class="headerlink" title="定义：何为 HFT（高频交易）"></a>定义：何为 HFT（高频交易）</h2><p>短线交易是经典力学，研究对象为每个周期的成交价格，最短 6 秒。</p><p>高频交易是量子力学，6秒内可以发生上百次交易，最终成交价只是最后一笔订单的价格。</p><p>交易所保留数据的频度是秒，二市场中高频交易主体的数据频度是纳秒级，1秒=10亿纳秒。</p><p><strong>高频交易（High-Frequency Trading）</strong>是投资银行、对冲基金和专业交易公司等利用高速计算机进行程序化证券交易的投资策略的总称，主要包括以下几种策略：</p><ul><li>流动性回扣交易（Liquidity Rebate Trading）</li><li>猎物算法交易（Predatory Algorithmic Trading）</li><li>自动做市商交易（Automated Market Maker Trading, AMMs）</li><li>闪电订单（Flash Order）</li><li>暗池（Dark Pool）</li></ul><h2 id="理解：高频交易何以赚钱"><a href="#理解：高频交易何以赚钱" class="headerlink" title="理解：高频交易何以赚钱"></a>理解：高频交易何以赚钱</h2><p>假设某支股票价格在400~500元之间波动，股民老王下了一个单：当股票价格低于450元时，买入100股。当这个订单在交易所之间传递时（美国有十几家交易所，纽交所、纳斯达克是其中最耳熟能详的），需要几十毫秒的延迟时间，高频交易员就是在这几十毫秒里做文章。</p><p>当股民老王的订单从交易所A传递给交易所B时，借助于高速网络，高频交易员先于交易所B得到这个信息，即“有一个订单是当股票价格低于450元时买100股”，此时如果交易所B的股票价格低于450，比如说是440，交易员就会买入它，再转手以450元的价格履行刚才得到的订单。在这笔交易中，高频交易员获利1000元，股民老王也以预期的450元价格购入了目标股票。</p><blockquote><p>2013年年初，最大的高频交易公司之一Virtu Financial公开称，在其5年半的交易中心仅有一天没有赚到钱，那一天还是因为出现了“人为误差”。</p></blockquote><p>一个高频交易公司可以在市场上疯狂交易而不带来任何附加价值，而且可以不承担任何风险，当它买入时，它知道有确切的卖家，当它卖出时，它知道肯定有人买。在每个交易日结束时，它在任何市场都完全不持有头寸。</p><p>高频交易公司每天闭市时都是平仓的，他们作为买卖双方桥梁的时间极短，以至于根本没有人知道其存在。</p><h2 id="高频交易的分类"><a href="#高频交易的分类" class="headerlink" title="高频交易的分类"></a>高频交易的分类</h2><h3 id="电子抢先交易（electronic-frontrunning）"><a href="#电子抢先交易（electronic-frontrunning）" class="headerlink" title="电子抢先交易（electronic frontrunning）"></a>电子抢先交易（electronic frontrunning）</h3><p>在一个地方探知投资者的交易信息后，在另一个地方抢在投资者之前通过一系列订单推高或拉低价格，并从中获利</p><h3 id="回扣套利（rebate-arbitrage）"><a href="#回扣套利（rebate-arbitrage）" class="headerlink" title="回扣套利（rebate arbitrage）"></a>回扣套利（rebate arbitrage）</h3><p>交易所通常会为创造流动性的券商提供一定的交易费用回扣，高频交易者利用速度优势创造虚假流动性，骗取交易所的回扣</p><h3 id="慢市场套利（slow-market-arbitrage）"><a href="#慢市场套利（slow-market-arbitrage）" class="headerlink" title="慢市场套利（slow market arbitrage）"></a>慢市场套利（slow market arbitrage）</h3><p>高频交易者在一个交易所探知到股票价格变动之后，再利用速度优势在另一个交易所反应过来之前进行买卖操作。这可能是使用最广的</p><h2 id="疑问：赢家拿走一切"><a href="#疑问：赢家拿走一切" class="headerlink" title="疑问：赢家拿走一切"></a>疑问：赢家拿走一切</h2><p>在高频交易的战场上，是否意味着“赢家拿走一切”？如果甲的算法/线路比乙快10%，最终甲会获取所有的订单并完成交易，乙一分钱都拿不到？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言-背景与动机&quot;&gt;&lt;a href=&quot;#前言-背景与动机&quot; class=&quot;headerlink&quot; title=&quot;前言-背景与动机&quot;&gt;&lt;/a&gt;前言-背景与动机&lt;/h2&gt;&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;di
      
    
    </summary>
    
    
      <category term="高频交易" scheme="https://lilei.pro/tags/%E9%AB%98%E9%A2%91%E4%BA%A4%E6%98%93/"/>
    
  </entry>
  
  <entry>
    <title>架构学习之 master-v2</title>
    <link href="https://lilei.pro/2019/10/11/architecture-master-v2/"/>
    <id>https://lilei.pro/2019/10/11/architecture-master-v2/</id>
    <published>2019-10-11T15:50:24.000Z</published>
    <updated>2019-10-11T15:54:24.831Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Move stones, not mountains.</p></blockquote><p>Google 官方的 <a href="https://github.com/googlesamples/android-architecture" target="_blank" rel="noopener">Android Architecture Blueprints</a> 推出了 v2 版本，相比于之前的 v1 版本，v2 采取了更先进的设计思想与组件：</p><ul><li>采用 Kotlin Coroutines 处理后台操作</li><li>单一 Activity 结构，用 <a href="https://developer.android.com/guide/navigation/navigation-getting-started" target="_blank" rel="noopener">Navigation component</a> 处理Fragment 之间跳转</li><li>由 Fragment(View) 和 ViewModel 组成的 Presentation 层，即 <strong>MVVM</strong> 模式</li><li>基于 LiveData 和 DataBinding 的响应式（Reactive）UI</li><li>data 层使用一个 Repository 和两个 Datasource（本地数据、远端数据），采用直观的调用方式（非回调、非 data stream）</li><li>两个 product flavor，分别是<code>mock</code>和<code>prod</code>，对应着测试与开发环境</li><li>一系列单元测试、集成测试以及端到端测试</li></ul><p>接下来从源码角度解析 master 分支工程，看看 v2 究竟可以为我们带来什么便利。</p><hr><h2 id="程序入口"><a href="#程序入口" class="headerlink" title="程序入口"></a>程序入口</h2><p>入口在<code>TasksActivity.java</code>，注意到这是一个“SPA”，即 Single Page Application，在<code>AndroidManifest.xml</code>中只声明了这一个 Activity。<code>TasksActivity</code>实际上只是一个壳页面，只处理了 Navigation、ActionBar、NavigationDrawer 等基础功能。它在<code>onCreate</code>里进行这些初始化：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> drawerLayout: DrawerLayout</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> appBarConfiguration: AppBarConfiguration</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">    setContentView(R.layout.tasks_act)</span><br><span class="line">    setupNavigationDrawer()</span><br><span class="line">    setSupportActionBar(findViewById(R.id.toolbar))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> navController: NavController = findNavController(R.id.nav_host_fragment)</span><br><span class="line">    appBarConfiguration =</span><br><span class="line">        AppBarConfiguration.Builder(R.id.tasks_fragment_dest, R.id.statistics_fragment_dest)</span><br><span class="line">            .setDrawerLayout(drawerLayout)</span><br><span class="line">            .build()</span><br><span class="line">    setupActionBarWithNavController(navController, appBarConfiguration)</span><br><span class="line">    findViewById&lt;NavigationView&gt;(R.id.nav_view)</span><br><span class="line">        .setupWithNavController(navController)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该应用采用 Navigation component 管理页面跳转，跳转关系在<code>nav_graph.xml</code>文件中以可视化的方式呈现。我们这里不需要关心跳转组件的具体用法， 只要知道它可以启动我们要分析的<code>TasksFragment</code>就可以了。</p><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p>我习惯从数据开始分析代码走向，看一下<code>data</code>目录的结构：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">λ tree data</span><br><span class="line">data</span><br><span class="line">|-- Result.kt</span><br><span class="line">|-- Task.kt</span><br><span class="line">`-- <span class="built_in">source</span></span><br><span class="line">    |-- DefaultTasksRepository.kt</span><br><span class="line">    |-- TasksDataSource.kt</span><br><span class="line">    |-- TasksRepository.kt</span><br><span class="line">    `-- <span class="built_in">local</span></span><br><span class="line">        |-- TasksDao.kt</span><br><span class="line">        |-- TasksLocalDataSource.kt</span><br><span class="line">        `-- ToDoDatabase.kt</span><br></pre></td></tr></table></figure><h3 id="Result-kt-与-Task-kt"><a href="#Result-kt-与-Task-kt" class="headerlink" title="Result.kt 与 Task.kt"></a>Result.kt 与 Task.kt</h3><p><code>Result.kt</code>是一个数据请求的结果封装类，业务层对数据的请求均是通过 Result 对象进行封装。这个类使用到了多个 Kotlin 特性，容我在注释里一一说明。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">Result</span>&lt;<span class="type">out R</span>&gt; </span>&#123; <span class="comment">// 密封类，将继承限制在类内部；out 类型，协变，保留子类型化关系</span></span><br><span class="line">    <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Success</span>&lt;<span class="type">out T</span>&gt;</span>(<span class="keyword">val</span> <span class="keyword">data</span>: T) : Result&lt;T&gt;() <span class="comment">// data 类，协变类型T可以用作构造参数</span></span><br><span class="line">    <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Error</span></span>(<span class="keyword">val</span> exception: Exception) : Result&lt;<span class="built_in">Nothing</span>&gt;() <span class="comment">// Nothing类型，永不返回</span></span><br><span class="line">    <span class="keyword">object</span> Loading : Result&lt;<span class="built_in">Nothing</span>&gt;() <span class="comment">// object直接创建对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">when</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">is</span> Success&lt;*&gt; -&gt; <span class="string">"Success[data=<span class="variable">$data</span>]"</span> <span class="comment">// *表示不关心具体类型</span></span><br><span class="line">            <span class="keyword">is</span> Error -&gt; <span class="string">"Error[exception=<span class="variable">$exception</span>]"</span></span><br><span class="line">            Loading -&gt; <span class="string">"Loading"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * `true` if [Result] is of type [Success] &amp; holds non-null [Success.data].</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">val</span> Result&lt;*&gt;.succeeded <span class="comment">// 扩展属性，注意命名不是isSuccess（Chinglish）</span></span><br><span class="line">  <span class="keyword">get</span>() = <span class="keyword">this</span> <span class="keyword">is</span> Success &amp;&amp; <span class="keyword">data</span> != <span class="literal">null</span></span><br></pre></td></tr></table></figure><p><code>Task.kt</code>描述了任务对象，由<code>title</code>、<code>description</code>、<code>completed</code>和<code>id</code>四个字段构成，同时借助 Room 组件自动关联到名为<strong>tasks</strong>的数据表。</p><h3 id="数据接口：TasksDataSource-kt-与-TasksRepository-kt"><a href="#数据接口：TasksDataSource-kt-与-TasksRepository-kt" class="headerlink" title="数据接口：TasksDataSource.kt 与 TasksRepository.kt"></a>数据接口：TasksDataSource.kt 与 TasksRepository.kt</h3><p><code>TasksDataSource.kt</code>和<code>TasksRepository.kt</code>是两个接口类，内容十分相似：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TasksDataSource.kt</span></span><br><span class="line"><span class="comment">// Main entry point for accessing tasks data.</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">TasksDataSource</span> </span>&#123;</span><br><span class="line">    suspend <span class="function"><span class="keyword">fun</span> <span class="title">getTasks</span><span class="params">()</span></span>: Result&lt;List&lt;Task&gt;&gt;</span><br><span class="line">    suspend <span class="function"><span class="keyword">fun</span> <span class="title">getTask</span><span class="params">(taskId: <span class="type">String</span>)</span></span>: Result&lt;Task&gt;</span><br><span class="line">    suspend <span class="function"><span class="keyword">fun</span> <span class="title">saveTask</span><span class="params">(task: <span class="type">Task</span>)</span></span></span><br><span class="line">    suspend <span class="function"><span class="keyword">fun</span> <span class="title">completeTask</span><span class="params">(task: <span class="type">Task</span>)</span></span></span><br><span class="line">    suspend <span class="function"><span class="keyword">fun</span> <span class="title">completeTask</span><span class="params">(taskId: <span class="type">String</span>)</span></span></span><br><span class="line">    suspend <span class="function"><span class="keyword">fun</span> <span class="title">activateTask</span><span class="params">(task: <span class="type">Task</span>)</span></span></span><br><span class="line">    suspend <span class="function"><span class="keyword">fun</span> <span class="title">activateTask</span><span class="params">(taskId: <span class="type">String</span>)</span></span></span><br><span class="line">    suspend <span class="function"><span class="keyword">fun</span> <span class="title">clearCompletedTasks</span><span class="params">()</span></span></span><br><span class="line">    suspend <span class="function"><span class="keyword">fun</span> <span class="title">deleteAllTasks</span><span class="params">()</span></span></span><br><span class="line">    suspend <span class="function"><span class="keyword">fun</span> <span class="title">deleteTask</span><span class="params">(taskId: <span class="type">String</span>)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TasksRepository.kt</span></span><br><span class="line"><span class="comment">// Interface to the data layer.</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">TasksRepository</span> </span>&#123;</span><br><span class="line">    suspend <span class="function"><span class="keyword">fun</span> <span class="title">getTasks</span><span class="params">(forceUpdate: <span class="type">Boolean</span> = <span class="literal">false</span>)</span></span>: Result&lt;List&lt;Task&gt;&gt;</span><br><span class="line">    suspend <span class="function"><span class="keyword">fun</span> <span class="title">getTask</span><span class="params">(taskId: <span class="type">String</span>, forceUpdate: <span class="type">Boolean</span> = <span class="literal">false</span>)</span></span>: Result&lt;Task&gt;</span><br><span class="line">    suspend <span class="function"><span class="keyword">fun</span> <span class="title">saveTask</span><span class="params">(task: <span class="type">Task</span>)</span></span></span><br><span class="line">    suspend <span class="function"><span class="keyword">fun</span> <span class="title">completeTask</span><span class="params">(task: <span class="type">Task</span>)</span></span></span><br><span class="line">    suspend <span class="function"><span class="keyword">fun</span> <span class="title">completeTask</span><span class="params">(taskId: <span class="type">String</span>)</span></span></span><br><span class="line">    suspend <span class="function"><span class="keyword">fun</span> <span class="title">activateTask</span><span class="params">(task: <span class="type">Task</span>)</span></span></span><br><span class="line">    suspend <span class="function"><span class="keyword">fun</span> <span class="title">activateTask</span><span class="params">(taskId: <span class="type">String</span>)</span></span></span><br><span class="line">    suspend <span class="function"><span class="keyword">fun</span> <span class="title">clearCompletedTasks</span><span class="params">()</span></span></span><br><span class="line">    suspend <span class="function"><span class="keyword">fun</span> <span class="title">deleteAllTasks</span><span class="params">()</span></span></span><br><span class="line">    suspend <span class="function"><span class="keyword">fun</span> <span class="title">deleteTask</span><span class="params">(taskId: <span class="type">String</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到两者的方法几乎是一样的：名字和数量相同，区别仅仅在于<code>TasksRepository</code>中的个别方法多了<code>forceUpdate</code>参数。不过，这两个接口在语义上是不同的。</p><ul><li><code>TasksDatasource</code>是底层数据封装，数据可能来自网络，也可能来自于文件、数据库。</li><li><code>TasksRepository</code>是数据层对外的接口，业务代码通过该接口对数据进行增删改查。<code>forceUpdate</code>参数作用于接口实现类内部的缓存。</li><li><code>suspend</code>关键字说明它们均为 Coroutines 接口。</li></ul><p>然后我们来看下对外的接口是如何给到使用者的。<code>TodoApplication</code>类继承自<code>Application</code>，其中有一个成员变量<code>taskRepository</code>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TodoApplication.kt</span></span><br><span class="line"><span class="keyword">val</span> taskRepository: TasksRepository</span><br><span class="line">    <span class="keyword">get</span>() = ServiceLocator.provideTasksRepository(<span class="keyword">this</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment">// ServiceLocator.kt</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">provideTasksRepository</span><span class="params">(context: <span class="type">Context</span>)</span></span>: TasksRepository &#123;</span><br><span class="line">    synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> tasksRepository ?: tasksRepository ?: createTasksRepository(context)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">createTasksRepository</span><span class="params">(context: <span class="type">Context</span>)</span></span>: TasksRepository &#123;</span><br><span class="line">    <span class="keyword">return</span> DefaultTasksRepository(FakeTasksRemoteDataSource, createTaskLocalDataSource(context))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// TodoApplication.taskRepository 通过 Fragment 的扩展方法给到各个 Fragment</span></span><br><span class="line"><span class="comment">// FragmentExt.kt</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Fragment.<span class="title">getViewModelFactory</span><span class="params">()</span></span>: ViewModelFactory &#123;</span><br><span class="line">  <span class="keyword">val</span> repository = (requireContext().applicationContext <span class="keyword">as</span> TodoApplication).taskRepository</span><br><span class="line">  <span class="keyword">return</span> ViewModelFactory(repository)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="local-目录：本地数据实现"><a href="#local-目录：本地数据实现" class="headerlink" title="local 目录：本地数据实现"></a>local 目录：本地数据实现</h3><p>local 目录下是<code>TasksDatasource</code>的本地实现，与此相对的，若数据来源于网络，则还应当有一个 remote 目录。</p><ul><li><code>ToDoDatabase</code> 是数据库声明</li><li><code>TasksDao</code> 声明 tasks 表的 CRUD 操作</li><li><code>TasksLocalDataSource</code> 是<code>TasksDataSource</code>的本地实现，使用<code>Dispatchers.IO</code>作为协程上下文，调用<code>TasksDao</code>完成数据操作</li></ul><h3 id="数据层总结"><a href="#数据层总结" class="headerlink" title="数据层总结"></a>数据层总结</h3><p>相比于曾经分析过的<strong>todo-mvp</strong>和<strong>todo-mvp-clean</strong>，最直观的感受是，v2在保证数据接口语义不变的前提下，借助 Coroutines 简化了原有的回调写法，用同步的方式写异步的代码。此外，像使用 Room 做 ORM、local/remote 两套数据实现等，与之前的项目并无不同。</p><hr><h2 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h2><h3 id="背景知识：ViewModel-与-LiveData"><a href="#背景知识：ViewModel-与-LiveData" class="headerlink" title="背景知识：ViewModel 与 LiveData"></a>背景知识：ViewModel 与 LiveData</h3><p>ViewModel 与 LiveData 都是 Android Jetpack 中的架构组件，它们通常组合使用，达到将数据和视图解耦的目的。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/191011_architecture_master_v2/jetpack.png" alt="jetpack" title="">                </div>                <div class="image-caption">jetpack</div>            </figure><p><strong>ViewModel</strong></p><ul><li>避免屏幕旋转等事件发生时，保存在 Activity 中的数据被销毁并重建</li><li>异步回调时防止内存泄漏、Context 为 Null</li><li>将数据和视图解耦，防止出现 God Activities 和 God Fragments</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/191011_architecture_master_v2/viewmodel.png" alt="viewmodel" title="">                </div>                <div class="image-caption">viewmodel</div>            </figure><p><strong>LiveData</strong></p><ul><li>DataBinding 思想的一种实现，数据/视图双向绑定</li><li>与生命周期关联，页面销毁后自动将其从订阅者列表去除</li></ul><h3 id="ViewModelFactory"><a href="#ViewModelFactory" class="headerlink" title="ViewModelFactory"></a>ViewModelFactory</h3><p>ViewModel 的创建采用工厂模式进行统一管理。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ViewModelFactory.kt</span></span><br><span class="line"><span class="meta">@Suppress(<span class="meta-string">"UNCHECKED_CAST"</span>)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewModelFactory</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> tasksRepository: TasksRepository</span><br><span class="line">) : ViewModelProvider.NewInstanceFactory() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : ViewModel&gt;</span> <span class="title">create</span><span class="params">(modelClass: <span class="type">Class</span>&lt;<span class="type">T</span>&gt;)</span></span> =</span><br><span class="line">        with(modelClass) &#123;</span><br><span class="line">          <span class="keyword">when</span> &#123;</span><br><span class="line">                isAssignableFrom(StatisticsViewModel::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>) -&gt;</span></span><br><span class="line">                    StatisticsViewModel(tasksRepository)</span><br><span class="line">                isAssignableFrom(TaskDetailViewModel::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>) -&gt;</span></span><br><span class="line">                    TaskDetailViewModel(tasksRepository)</span><br><span class="line">                isAssignableFrom(AddEditTaskViewModel::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>) -&gt;</span></span><br><span class="line">                    AddEditTaskViewModel(tasksRepository)</span><br><span class="line">                isAssignableFrom(TasksViewModel::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>) -&gt;</span></span><br><span class="line">                    TasksViewModel(tasksRepository)</span><br><span class="line">                <span class="keyword">else</span> -&gt;</span><br><span class="line">                    <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"Unknown ViewModel class: <span class="subst">$&#123;modelClass.name&#125;</span>"</span>)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">as</span> T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还记得上文提到过为 Fragment 增加的扩展函数吗？在每一个页面（Fragment）里通过这个扩展函数获取到工厂类，进而获得对应 ViewModel 类的实例。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FragmentExt.kt</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Fragment.<span class="title">getViewModelFactory</span><span class="params">()</span></span>: ViewModelFactory &#123;</span><br><span class="line">  <span class="keyword">val</span> repository = (requireContext().applicationContext <span class="keyword">as</span> TodoApplication).taskRepository</span><br><span class="line">  <span class="keyword">return</span> ViewModelFactory(repository)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TasksFragment.kt</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TasksFragment</span> : <span class="type">Fragment</span></span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> viewModel <span class="keyword">by</span> viewModels&lt;TasksViewModel&gt; &#123; getViewModelFactory() &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是 ViewModel 类，它承担了与 Presenter 类似的职责，是处理业务逻辑的地方。如果需要的话，可以增加一个 Domain 层，负责提取出来的业务逻辑（Use cases），提供复用，这样就变成了 <a href="https://github.com/googlesamples/android-architecture/tree/usecases" target="_blank" rel="noopener">MVVM-Clean</a> 模式。在 master 分支上还没有 domain 层。</p><h3 id="TasksViewModel"><a href="#TasksViewModel" class="headerlink" title="TasksViewModel"></a>TasksViewModel</h3><p>ViewModel 接受一个 TasksRepository 参数，用作数据层接口。（在clean架构里，这里传入的不是Repository，而是UseCases）。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TasksViewModel</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> tasksRepository: TasksRepository</span><br><span class="line">) : ViewModel() &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后声明了一系列变量作为页面数据&amp;状态，这里采用“一个对象，两个变量”的成对写法，略显繁琐，不知道有没有更优美的处理方法。这样做的目的是把对变量的修改关闭，对外（即LiveData）仅提供读取变量的接口，只可以在 ViewModel 内部修改变量。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> _items = MutableLiveData&lt;List&lt;Task&gt;&gt;().apply &#123; value = emptyList() &#125; <span class="comment">// 以下划线开头的为私有变量，apply 和 with 的用法要分清，相当于调用 _items.setValue(emptyList()); return _items;</span></span><br><span class="line"><span class="keyword">val</span> items: LiveData&lt;List&lt;Task&gt;&gt; = _items</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> _dataLoading = MutableLiveData&lt;<span class="built_in">Boolean</span>&gt;()</span><br><span class="line"><span class="keyword">val</span> dataLoading: LiveData&lt;<span class="built_in">Boolean</span>&gt; = _dataLoading</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> _currentFilteringLabel = MutableLiveData&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="keyword">val</span> currentFilteringLabel: LiveData&lt;<span class="built_in">Int</span>&gt; = _currentFilteringLabel</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> _noTasksLabel = MutableLiveData&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="keyword">val</span> noTasksLabel: LiveData&lt;<span class="built_in">Int</span>&gt; = _noTasksLabel</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> _noTaskIconRes = MutableLiveData&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="keyword">val</span> noTaskIconRes: LiveData&lt;<span class="built_in">Int</span>&gt; = _noTaskIconRes</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> _tasksAddViewVisible = MutableLiveData&lt;<span class="built_in">Boolean</span>&gt;()</span><br><span class="line"><span class="keyword">val</span> tasksAddViewVisible: LiveData&lt;<span class="built_in">Boolean</span>&gt; = _tasksAddViewVisible</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> _snackbarText = MutableLiveData&lt;Event&lt;<span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line"><span class="keyword">val</span> snackbarText: LiveData&lt;Event&lt;<span class="built_in">Int</span>&gt;&gt; = _snackbarText</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> _currentFiltering = TasksFilterType.ALL_TASKS   <span class="comment">// Not used at the moment private val isDataLoadingError = MutableLiveData&lt;Boolean&gt;()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> _openTaskEvent = MutableLiveData&lt;Event&lt;String&gt;&gt;()</span><br><span class="line"><span class="keyword">val</span> openTaskEvent: LiveData&lt;Event&lt;String&gt;&gt; = _openTaskEvent</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> _newTaskEvent = MutableLiveData&lt;Event&lt;<span class="built_in">Unit</span>&gt;&gt;()</span><br><span class="line"><span class="keyword">val</span> newTaskEvent: LiveData&lt;Event&lt;<span class="built_in">Unit</span>&gt;&gt; = _newTaskEvent</span><br><span class="line"></span><br><span class="line"><span class="comment">// This LiveData depends on another so we can use a transformation.</span></span><br><span class="line"><span class="keyword">val</span> empty: LiveData&lt;<span class="built_in">Boolean</span>&gt; = Transformations.map(_items) &#123;</span><br><span class="line"> it.isEmpty()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以说管理上面这些数据是 ViewModel 最主要的职责了，从功能上区分，这些数据可以分成<strong>3种</strong>。</p><ol><li>业务实体如 items（任务对象列表），ViewModel 通过修改这类对象，借助于 DataBinding 更新 UI</li><li>数据状态对象如 dataLoading（是否正在加载数据）、currentFilteringLabel（当前的过滤器文字）、noTasksLabel（没有任务的文字）、snackbarText（提示栏文字），这一类对象不进行持久化存储，但是也会影响到 UI 显示</li><li>事件包装对象如 openTaskEvent（打开某个任务，在点击列表中的任务时触发）、newTaskEvent（创建一个任务，在点击+时触发），它们负责通知页面进行跳转——这部分设计得不佳，为了 DataBinding 而强行 DataBinding</li></ol><p>总之贯彻的思想是：一切变动都是数据变动，数据变动通过 DataBinding 自动投射到 UI。</p><hr><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>视图也就是<code>TasksFragment.kt</code>类，负责初始化布局，触发 ViewModel 进行首次加载。这里的 Fragment 继承自 androidx 中的 Fragment。</p><p>在<code>onCreateView</code>里初始化 DataBinding（数据）。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    inflater: <span class="type">LayoutInflater</span>, container: <span class="type">ViewGroup</span>?,</span></span></span><br><span class="line"><span class="function"><span class="params">  savedInstanceState: <span class="type">Bundle</span>?</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: View? &#123;</span><br><span class="line">    viewDataBinding = TasksFragBinding.inflate(inflater, container, <span class="literal">false</span>).apply &#123;</span><br><span class="line">    viewmodel = viewModel</span><br><span class="line">    &#125;</span><br><span class="line">  setHasOptionsMenu(<span class="literal">true</span>)</span><br><span class="line">  <span class="keyword">return</span> viewDataBinding.root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>onActivityCreated</code>里初始化 UI（视图），初始化完成后启动加载（代码最后一行）。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityCreated</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onActivityCreated(savedInstanceState)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the lifecycle owner to the lifecycle of the view</span></span><br><span class="line">    viewDataBinding.lifecycleOwner = <span class="keyword">this</span>.viewLifecycleOwner</span><br><span class="line">    setupSnackbar()</span><br><span class="line">    setupListAdapter()</span><br><span class="line">    setupRefreshLayout(viewDataBinding.refreshLayout, viewDataBinding.tasksList)</span><br><span class="line">    setupNavigation()</span><br><span class="line">    setupFab()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Always reloading data for simplicity. Real apps should only do this on first load and</span></span><br><span class="line">    <span class="comment">// when navigating back to this destination. <span class="doctag">TODO:</span> https://issuetracker.google.com/79672220</span></span><br><span class="line">    viewModel.loadTasks(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，Fragment 中还会进行设置 OnClickListener、Adapter 等操作，比较简单，不赘述。</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>v2 的项目设计时采取了 MVVM 思想，旨在解决 MVP 模式下Presenter 层过于庞大的问题。其实 MVP-Clean 模式已经对此有一些缓解。而 MVVM 做的更彻底，干脆把数据对 UI 的控制完全交给框架自动进行。这样做的好处显而易见，但也并不是没有缺点，比如一旦出了问题，如果没有掌握个中原理，调试时必定摸不清头绪。总而言之，这是一个值得学习与尝试的架构设计。</p><hr><h2 id="Bonus：usecases"><a href="#Bonus：usecases" class="headerlink" title="Bonus：usecases"></a>Bonus：usecases</h2><p><a href="https://github.com/googlesamples/android-architecture/tree/usecases" target="_blank" rel="noopener">usecases</a> 是 v2 中的一个 Stable<br> 分支（另一个是<a href="https://github.com/googlesamples/android-architecture/tree/dagger-android" target="_blank" rel="noopener">dagger-android</a>)。usecases 以解耦、抽象、单向依赖为核心设计理念，这也是 Clean 架构的核心思想。</p><ul><li>表现层只能访问到领域层/用例层，不知道数据层的存在</li><li>领域层/用例层只能访问到数据层，无法访问表现层</li><li>数据层无法访问表现层和领域层</li></ul><p>领域层（或者叫用例层），即 Domain Layer，是由多个 UseCase 组成的，每一个 UseCase 对应一个业务逻辑。以“加载单个Task”为例，可以看到 UseCase 里直接将请求转发给 TasksRepository 来处理，逻辑十分简单。</p><p>在分析具体差别之前，可以先看一遍 usecase 分支与 master 分支的 diff：<a href="https://github.com/googlesamples/android-architecture/compare/usecases#files_bucket" target="_blank" rel="noopener">https://github.com/googlesamples/android-architecture/compare/usecases#files_bucket</a></p><p><strong>GetTaskUseCase.kt</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetTaskUseCase</span></span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> tasksRepository: TasksRepository</span><br><span class="line">  ) &#123;</span><br><span class="line">    suspend <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(taskId: <span class="type">String</span>, forceUpdate: <span class="type">Boolean</span> = <span class="literal">false</span>)</span></span>: Result&lt;Task&gt; &#123;</span><br><span class="line">    wrapEspressoIdlingResource &#123;</span><br><span class="line">      <span class="keyword">return</span> tasksRepository.getTask(taskId, forceUpdate)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而获取 Tasks 列表的 Usecase 相对复杂一些，包括了原本在 TasksViewModel 中处理的过滤逻辑，从另一个角度看，这相当于减轻了 ViewModel 的负担。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetTasksUseCase</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> tasksRepository: TasksRepository</span><br><span class="line">) &#123;</span><br><span class="line">    suspend <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        forceUpdate: <span class="type">Boolean</span> = <span class="literal">false</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        currentFiltering: <span class="type">TasksFilterType</span> = ALL_TASKS</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>: Result&lt;List&lt;Task&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">        wrapEspressoIdlingResource &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> tasksResult = tasksRepository.getTasks(forceUpdate)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Filter tasks</span></span><br><span class="line">            <span class="keyword">if</span> (tasksResult <span class="keyword">is</span> Success &amp;&amp; currentFiltering != ALL_TASKS) &#123;</span><br><span class="line">                <span class="keyword">val</span> tasks = tasksResult.<span class="keyword">data</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">val</span> tasksToShow = mutableListOf&lt;Task&gt;()</span><br><span class="line">                <span class="comment">// We filter the tasks based on the requestType</span></span><br><span class="line">                <span class="keyword">for</span> (task <span class="keyword">in</span> tasks) &#123;</span><br><span class="line">                    <span class="keyword">when</span> (currentFiltering) &#123;</span><br><span class="line">                        ACTIVE_TASKS -&gt; <span class="keyword">if</span> (task.isActive) &#123;</span><br><span class="line">                            tasksToShow.add(task)</span><br><span class="line">                        &#125;</span><br><span class="line">                        COMPLETED_TASKS -&gt; <span class="keyword">if</span> (task.isCompleted) &#123;</span><br><span class="line">                            tasksToShow.add(task)</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> -&gt; NotImplementedError()</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> Success(tasksToShow)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> tasksResult</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于 ViewModel 里，将原来的 Repository 参数改为当前 ViewModel 用到的 UseCase 参数即可，所有处理数据的请求都有 UseCase 来接管。</p><p><strong>TasksViewModel.kt</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TasksViewModel</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> getTasksUseCase: GetTasksUseCase,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> clearCompletedTasksUseCase: ClearCompletedTasksUseCase,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> completeTaskUseCase: CompleteTaskUseCase,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> activateTaskUseCase: ActivateTaskUseCase</span><br><span class="line">) : ViewModel() &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Over~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Move stones, not mountains.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Google 官方的 &lt;a href=&quot;https://github.com/googlesamples/android-architecture&quot; 
      
    
    </summary>
    
    
      <category term="架构" scheme="https://lilei.pro/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>《Java 并发编程实战》勘误表 2019-08-27</title>
    <link href="https://lilei.pro/2019/08/27/jcip-errata/"/>
    <id>https://lilei.pro/2019/08/27/jcip-errata/</id>
    <published>2019-08-27T15:53:23.000Z</published>
    <updated>2019-08-27T15:56:18.605Z</updated>
    
    <content type="html"><![CDATA[<p>Java Concurrency in Practice 是一本讲解 JVM 下并发编程知识的经典作品，建议有志于资深的 Java 工程师将其纳入自己的读书计划中，相信一定会大有裨益。</p><p>在阅读这本书的过程中，我发现中文版本有很多显而易见的错误，尤其是代码里条件判断有时根本是反着来的（本应是<code>&gt;=</code>的条件，书里面却是<code>&lt;</code>）。Google 搜索之后发现在 <a href="http://jcip.net/errata.html" target="_blank" rel="noopener">http://jcip.net/errata.html</a> 有英文原版的勘误表，由于中文版本没有勘误表，故翻译在此，希望可以有所帮助。</p><p>使用之前请确认自己手中的书籍版本是否相符。</p><h1 id="本文适用的中文版本"><a href="#本文适用的中文版本" class="headerlink" title="本文适用的中文版本"></a>本文适用的中文版本</h1><ul><li>书名：《Java 并发编程实战》，Java Concurrency in Practice</li><li>作者：Brain Goetz, Tim Peierls 等</li><li>译者：童云兰 等</li><li>ISBN：978-7-111-37004-8</li><li>出版社：机械工业出版社</li><li>出版时间：2012.2 第一版，2018.9 重印</li><li>定价：69 元</li><li>豆瓣链接：<a href="https://book.douban.com/subject/10484692/" target="_blank" rel="noopener">https://book.douban.com/subject/10484692/</a></li></ul><h1 id="勘误数据来源"><a href="#勘误数据来源" class="headerlink" title="勘误数据来源"></a>勘误数据来源</h1><p><a href="http://jcip.net/errata.html" target="_blank" rel="noopener">官方勘误表</a></p><h1 id="中文版勘误表"><a href="#中文版勘误表" class="headerlink" title="中文版勘误表"></a>中文版勘误表</h1><table><thead><tr><th>页码</th><th>勘误</th></tr></thead><tbody><tr><td>p.5</td><td>程序清单 1-1 下面的第一段，<code>someVariable++</code>应为<code>value++</code></td></tr><tr><td>p.6</td><td>程序清单 1-2，<code>Value</code>应为<code>value</code></td></tr><tr><td>p.53</td><td>4.3 节上面的最后一段，<code>getLocation</code>应为<code>getLocations</code></td></tr><tr><td>p.58</td><td>程序清单 4-11，<code>SafePoint(int x, int y)</code>构造函数的函数体可以精简为<code>set(x, y)</code></td></tr><tr><td>p.62</td><td>程序清单 4-16，<code>if(contains)</code>应为<code>if(!contains)</code></td></tr><tr><td>p.75</td><td>5.3.1 第一段，<code>DiskCrawler</code>应为<code>FileCrawler</code></td></tr><tr><td>p.100</td><td>程序清单 6-7 下面第二段，<code>在 ExcutorService 关闭后提交的任务将由“拒绝执行处理器（Rejected Execution Handler）来处理</code>表述有误，<code>Rejected Execution Handler</code>是仅在<code>ThreadPoolExecutor</code>实现中提供的，并非所有的<code>ExecutorService</code>实现都具备此功能</td></tr><tr><td>p.122</td><td>第二行，<code>那么调用 close 或 wakeup 方法会使线程抛出 ClosedSelectorException</code>，只有<code>close</code>方法会抛出该异常，<code>wakeup</code>方法不会</td></tr><tr><td>p.163</td><td>程序清单 9-6，第一个<code>if(runningTask != null)</code>判断条件应为<code>(runningTask == null)</code></td></tr><tr><td>p.214</td><td>程序清单 12-9，<code>Executors.newFixedThreadPool(MAX_SIZE)</code>方法调用应该增加第二个参数<code>threadFactory</code></td></tr><tr><td>p.229</td><td>程序清单 13-3，代码倒数第三行<code>if (System.nanoTime() &lt; stopTime)</code>判断条件里的<code>&lt;</code>应为<code>&gt;=</code></td></tr></tbody></table><p>以上就是中文版《Java 并发编程实战》的勘误表，如有遗漏，欢迎通过文末留言联系我进行补充。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java Concurrency in Practice 是一本讲解 JVM 下并发编程知识的经典作品，建议有志于资深的 Java 工程师将其纳入自己的读书计划中，相信一定会大有裨益。&lt;/p&gt;
&lt;p&gt;在阅读这本书的过程中，我发现中文版本有很多显而易见的错误，尤其是代码里条件
      
    
    </summary>
    
    
      <category term="Java" scheme="https://lilei.pro/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>架构学习之 mvp-clean</title>
    <link href="https://lilei.pro/2019/08/21/architecture-todo-mvp-clean/"/>
    <id>https://lilei.pro/2019/08/21/architecture-todo-mvp-clean/</id>
    <published>2019-08-20T16:11:55.000Z</published>
    <updated>2019-08-20T16:17:18.801Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>I am the STORM!!!</p></blockquote><p>上一篇文章介绍了 MVP 模式，作为 Android 最朴实的架构，MVP 足以应对复杂度较低的业务场景，回想 2014~2015 年在 DP 做预订闪惠的日子，用的便是 MVP。</p><p>然而随着业务复杂度增加，Presenter 层的逻辑会随之变重，导致的结果便是 Presenter 类过大，动辄一两千行代码，实在是丑陋。在这种场景下，Clean 架构是一个很好的选择。</p><h2 id="关于-Clean"><a href="#关于-Clean" class="headerlink" title="关于 Clean"></a>关于 Clean</h2><h3 id="什么是-Clean"><a href="#什么是-Clean" class="headerlink" title="什么是 Clean"></a>什么是 Clean</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/190821_todo_mvp_clean/CleanArchitecture.jpg" alt="CleanArchitecture" title="">                </div>                <div class="image-caption">CleanArchitecture</div>            </figure><p>Clean 架构最初并不是为了针对 Android 平台的问题而提出，而是作为<strong>软件系统</strong>的通用架构被设计出来，如上面的同心圆所示，它的核心思想是<strong>The Dependency Rule（单向依赖原则）</strong>，即只能从外层向内层依赖，内层对外层一无所知，外层的变动不应当影响到内层。</p><p>另一个重要概念是<strong>Use Case（用例）</strong>，<strong>用例</strong>是业务逻辑的最小抽象单元，它调用数据模块的接口，向上（Presenter）提供业务逻辑操作入口。</p><h3 id="Android-Clean"><a href="#Android-Clean" class="headerlink" title="Android Clean"></a>Android Clean</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/190821_todo_mvp_clean/mvp-clean.png" alt="mvp-clean" title="">                </div>                <div class="image-caption">mvp-clean</div>            </figure><p>Android 平台在 Presenter 和 Model 之间定义了<strong>Domain Layer（域层）</strong>，用于承载<strong>Use Case</strong>，如上图所示，Use Case 的背后是业务逻辑。Domain Layer 脱胎于 MVP 的 Presenter，这样可以避免相同的业务逻辑代码出现在两个 Presenter 中的问题。</p><h4 id="Use-Cases-异步性"><a href="#Use-Cases-异步性" class="headerlink" title="Use Cases 异步性"></a>Use Cases 异步性</h4><p>鉴于 Domain Layer 是 UI 无关的，这里可以统一将 Use Case 放入工作线程运行，通过异步回调进行通信。至于更底层的数据库/网络操作，出于简化的目的，可以直接使用同步接口。</p><h4 id="不同-Layer-是否需要定义各自的-Model"><a href="#不同-Layer-是否需要定义各自的-Model" class="headerlink" title="不同 Layer 是否需要定义各自的 Model"></a>不同 Layer 是否需要定义各自的 Model</h4><p>标准的做法是在视图层（View Layer）、域层（Domain Layer）和数据层（Data/Model Layer）分别使用不同的对象，如 VO、BO、DO 等。这样带来的问题是重复性增加。如果对象是不可变的，在各层之间具有相同的属性和方法，则可以只定义一个对象，共通使用。</p><p>如果视图层对象包含 Android 相关的方法或属性，则应当为其单独定义一个类，然后使用<code>Mapper</code>在不同层之间进行对象转换。</p><h2 id="如何抽象业务场景"><a href="#如何抽象业务场景" class="headerlink" title="如何抽象业务场景"></a>如何抽象业务场景</h2><p>这里我们将 Clean 模式应用在 todo-app 上，想想还有点小激动。</p><h3 id="Use-Cases-amp-Domain-Layer"><a href="#Use-Cases-amp-Domain-Layer" class="headerlink" title="Use Cases &amp; Domain Layer"></a>Use Cases &amp; Domain Layer</h3><p>把 Use Case 的声明和运行机制拆开，是不是跟 Runnable + Executor 的机制很像？没错，这就是设计模式中的<strong>命令模式</strong>。设计模式不是彼此孤立的，一个项目里可以整体采用 Clean 架构，不同的子模块，应用不同的设计模式。设计模式是死的，人是活的。</p><p>抽象类<code>UseCase</code>即是<strong>命令</strong>，包含入参、出参、回调通知对象、运行的抽象过程（这里又出现了<strong>模版模式</strong>）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">UseCase</span>&lt;<span class="title">Q</span> <span class="keyword">extends</span> <span class="title">UseCase</span>.<span class="title">RequestValues</span>, <span class="title">P</span> <span class="keyword">extends</span> <span class="title">UseCase</span>.<span class="title">ResponseValue</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Q mRequestValues;</span><br><span class="line">  <span class="keyword">private</span> UseCaseCallback&lt;P&gt; mUseCaseCallback; <span class="comment">// 任务完成后（成功or失败）的回调</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// set and get</span></span><br><span class="line">  <span class="comment">//..</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="comment">// Executor 运行入口</span></span><br><span class="line">    executeUseCase(mRequestValues);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> voi8d <span class="title">executeUseCase</span><span class="params">(Q requestValues)</span></span>; <span class="comment">// 子类必需实体化这个方法</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RequestValues</span> </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResponseValues</span> </span>&#123;&#125; <span class="comment">// 接口约束</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UseCaseCallback</span>&lt;<span class="title">R</span>&gt; </span>&#123; <span class="comment">// 任务完成后的回调</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(R response)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后选取一个“加载全部任务”的场景为例，看它是如何实现抽象类的，以下是<code>GetTask.java</code>的部分代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetTasks</span> <span class="keyword">extends</span> <span class="title">UseCase</span>&lt;<span class="title">GetTasks</span>.<span class="title">RequestValues</span>, <span class="title">GetTasks</span>.<span class="title">ResponseValues</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> TasksRepository mTasksRepository; <span class="comment">// 更底层的数据源对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> FilterFactory mFilterFactory; <span class="comment">// 过滤器工厂类</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">GetTasks</span><span class="params">(@NonNull TaskRepository tasksRepository, @NonNull FilterFactory filterFactory)</span> </span>&#123; <span class="comment">// 构造时传入数据源对象和过滤器工厂</span></span><br><span class="line">    mTasksRepository = checkNotNull(tasksRepository, <span class="string">"tasksRepository cannot be null!"</span>);</span><br><span class="line">    mFilterFactory = checkNotNull(filterFactory, <span class="string">"filterFactory cannot be null!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">executeUseCase</span><span class="params">(<span class="keyword">final</span> RequestValues values)</span> </span>&#123; <span class="comment">// 利用泛型约束，在不同UseCase实现类里使用不同参数</span></span><br><span class="line">    <span class="keyword">if</span> (values.isForceUpdate()) &#123;</span><br><span class="line">      mTasksRepository.refreshTasks();</span><br><span class="line">    &#125;</span><br><span class="line">    mTasksRepository.getTasks(<span class="keyword">new</span> TasksDataSource.LoadTasksCallback() &#123; <span class="comment">// 调用数据源异步方法</span></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTasksLoaded</span><span class="params">(List&lt;Task&gt; tasks)</span> </span>&#123;</span><br><span class="line">        TasksFilterType currentFiltering = values.getCurrentFiltering();</span><br><span class="line">        TaskFilter taskfilter = mFilterFactory.create(currentFiltering);</span><br><span class="line"></span><br><span class="line">        List&lt;Task&gt; tasksFiltered = taskFilter.filter(tasks);</span><br><span class="line">        ResponseValue responseValue = <span class="keyword">new</span> ResponseValue(tasksFiltered);</span><br><span class="line">        getUseCaseCallback().onSuccess(responseValue);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDataNotAvailable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        getUseCallback().onError();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestValues</span> <span class="keyword">implements</span> <span class="title">UseCase</span>.<span class="title">RequestValues</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TasksFilterType mCurrentFiltering;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> mForceUpdate;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// constructor, get and set</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseValues</span> <span class="keyword">implements</span> <span class="title">UseCase</span>.<span class="title">ResponseValues</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Task&gt; mTasks;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我在上述代码的注释里增加了一些说明，此外，有几处需要额外的注意：</p><ol><li>Use Case 构造函数里需要传入底层数据源对象，这意味着不可以在 Presenter 层直接构造 Use Case，因为 Presenter 不应当跨过 Domain Layer 直接访问数据源。—— 想想如何实现？IOC，DI，Bingo！</li><li>在 Use Case 的类内部，以静态类的方式声明<code>RequestValues</code>和<code>ResponseValues</code>，代码集中，易于管理。<code>UseCase.java</code>基类中提供的空接口也利于不同的子类声明各自不同的参数类型。在模版方法<code>executeUseCase</code>里分别进行调用，化元归一。</li></ol><h3 id="Executor：任务执行机制"><a href="#Executor：任务执行机制" class="headerlink" title="Executor：任务执行机制"></a>Executor：任务执行机制</h3><p><strong>命令模式</strong>由命令与执行机制两部分组成，Java 中的<code>Executor</code>框架就是一种典型应用。虽然<code>Executor</code>只是一个简单的接口，但它却为灵活而强大的异步任务执行框架提供了基础，该框架能支持多种不同类型的任务执行策略。它提供了一种标准的方法将任务的提交过程和执行过程解耦开来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java 中的 Executor，不负责运行结果通知</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>项目里使用同样的机制作为<code>UseCase</code>的运行框架。</p><p><code>UseCaseScheduler.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UseCaseScheduler</span> </span>&#123;</span><br><span class="line">  <span class="comment">// todo-mvp-clean 中的 Executor</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable runnable)</span></span>;</span><br><span class="line">  <span class="comment">// 增加结果通知回调</span></span><br><span class="line">  &lt;V extends UseCase.ResponseValue&gt; <span class="function"><span class="keyword">void</span> <span class="title">notifyResponse</span><span class="params">(<span class="keyword">final</span> V response, <span class="keyword">final</span> UseCase.UseCaseCallback&lt;V&gt; useCaseCallback)</span></span>;</span><br><span class="line">  &lt;V extends UseCase.ResponseValue&gt; <span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">(<span class="keyword">final</span> UseCase.UseCaseCallback&lt;V&gt; useCaseCallback)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的实现类采用线程池方式实现：</p><p><code>UseCaseThreadPoolScheduler.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseCaseThreadPoolScheduler</span> <span class="keyword">implements</span> <span class="title">UseCaseScheduler</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Handler mHandler = <span class="keyword">new</span> Handler(); <span class="comment">// 将运算结果通知主线程</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> POOL_SIZE = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_POOL_SIZE = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIMEOUT = <span class="number">30</span>;</span><br><span class="line">  ThreadPoolExecutor mThreadPoolExecutor; <span class="comment">// 使用线程池提供复用</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">UseCaseThreadPoolScheduler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mThreadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(POOL_SIZE, MAX_POOL_SIZE, TIMEOUT, TimeUnit.SECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(POOL_SIZE));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">    mThreadPoolExecutor.execute(runnable); <span class="comment">// 任务提交给线程池处理</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;V extends UseCase.ResponseValue&gt; <span class="function"><span class="keyword">void</span> <span class="title">notifyResponse</span><span class="params">(<span class="keyword">final</span> V response, <span class="keyword">final</span> UseCase.UseCaseCallback&lt;V&gt; useCaseCallback)</span> </span>&#123;</span><br><span class="line">    mHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        useCaseCallback.onSuccess(response); <span class="comment">// 主线程处理结果</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;V extends UseCase.ResponseValue&gt; <span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">(<span class="keyword">final</span> UseCase.UseCaseCallback&lt;V&gt; useCaseCallback)</span> </span>&#123;</span><br><span class="line">    mHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        useCaseCallback.onError(); <span class="comment">// 主线程处理结果</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="UseCaseHandler：任务执行机制包装"><a href="#UseCaseHandler：任务执行机制包装" class="headerlink" title="UseCaseHandler：任务执行机制包装"></a>UseCaseHandler：任务执行机制包装</h3><p>上文介绍了项目里采用<code>Executor</code>作为命令的运行框架，<code>Executor</code>接收的是<code>Runnable</code>类型的任务，我们还需要一层<strong>UseCase处理器</strong>，用于将<code>UseCase</code>封装成<code>Runnable</code>，并且处理任务的返回值。<code>UseCaseHandler</code>就是负责处理<code>UseCase</code>的组件。</p><p><code>UseCaseHandler.java</code>，省略部分代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseCaseHandler</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> UseCaseHandler INSTANCE; <span class="comment">// 单例模式，饿汉</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T extends UseCase.RequestValues, R extends UseCase.ResponseValue&gt; <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> UseCase&lt;T, R&gt; useCase, T values, UseCase.UseCaseCallback&lt;R&gt; callback)</span> </span>&#123;</span><br><span class="line">    useCase.setRequestValues(values);</span><br><span class="line">    useCase.setUseCaseCallback(<span class="keyword">new</span> UiCallbackWrapper(callback, <span class="keyword">this</span>));</span><br><span class="line">    mUseCaseScheduler.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        useCase.run();</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// UI回调包装器类，将成功/失败事件交给UI线程处理</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">UiCallbackWrapper</span>&lt;<span class="title">V</span> <span class="keyword">extends</span> <span class="title">UseCase</span>.<span class="title">ResponseValue</span>&gt; <span class="keyword">implements</span> <span class="title">UseCase</span>.<span class="title">UseCaseCallback</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UseCase.UseCaseCallback&lt;V&gt; mCallback;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UseCaseHandler mUseCaseHandler;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UiCallbackWrapper</span><span class="params">(UseCase.UseCaseCallback&lt;V&gt; callback, UseCaseHandler useCaseHandler)</span> </span>&#123;</span><br><span class="line">      mCallback = callback;</span><br><span class="line">      mUseCaseHandler = useCaseHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(V response)</span> </span>&#123;</span><br><span class="line">      mUseCaseHandler.notifyResponse(response, mCallback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      mUseCaseHandler.notifyError(mCallback);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><code>UseCaseHandler</code>隐藏了任务的执行机制，对外暴露出通过<code>UseCase</code>提交命令的接口，此时 Presenter 就可以借助<code>UseCaseHandler</code>来提交各项异步任务，并且获取回调。注意到回调是在 UI 线程发生的，意味着 Presenter 可以在回调中直接操作 UI 元素。</p><h3 id="Activity：穿针引线的组织者"><a href="#Activity：穿针引线的组织者" class="headerlink" title="Activity：穿针引线的组织者"></a>Activity：穿针引线的组织者</h3><p>与 MVP 架构一样，在 MVP clean 架构中，Activity 同样担任初始化 Fragment、Presenter 的职责。Activity 类是十分简单的，80% 的逻辑都写在<code>onCreate</code>当中。</p><p><code>TaskActivity.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">  setContentView(R.layout.tasks_act);    <span class="comment">// Set up the toolbar.</span></span><br><span class="line">  <span class="comment">// 初始化 ActionBar</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 初始化 DrawerLayout</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// FragmentManager与Activity是一一对应的，所以这里通过R.id.contentFrame获取Fragment，在Activity B中也可以用R.id.contentFrame获取B当中的Fragment，不用担心重复</span></span><br><span class="line">  TasksFragment tasksFragment = (TasksFragment) getSupportFragmentManager().findFragmentById(R.id.contentFrame);</span><br><span class="line">  <span class="keyword">if</span> (tasksFragment == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Create the fragment</span></span><br><span class="line">    tasksFragment = TasksFragment.newInstance();</span><br><span class="line">    ActivityUtils.addFragmentToActivity(getSupportFragmentManager(), tasksFragment, R.id.contentFrame);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将使用到的Task用作构造参数，创建Presenter</span></span><br><span class="line">  mTasksPresenter = <span class="keyword">new</span> TasksPresenter(</span><br><span class="line">    Injection.provideUseCaseHandler(),</span><br><span class="line">    tasksFragment,</span><br><span class="line">    Injection.provideGetTasks(getApplicationContext()),</span><br><span class="line">    Injection.provideCompleteTasks(getApplicationContext()),</span><br><span class="line">    Injection.provideActivateTask(getApplicationContext()),</span><br><span class="line">    Injection.provideClearCompleteTasks(getApplicationContext())</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">// Load previously saved state, if available.</span></span><br><span class="line">  <span class="keyword">if</span> (savedInstanceState != <span class="keyword">null</span>) &#123;</span><br><span class="line">    TasksFilterType currentFiltering = (TasksFilterType) savedInstanceState.getSerializable(CURRENT_FILTERING_KEY);</span><br><span class="line">  mTasksPresenter.setFiltering(currentFiltering);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后在<code>View.onResume</code>中会调用<code>Presenter.start</code>来首次加载数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>.onResume();</span><br><span class="line">  mPresenter.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，MVP-clean 架构的设计思路就被我们分析透彻了，可以看出，相比于 MVP，clean 架构抽象出来 Domain 层，使具体的业务操作独立可复用，且减轻了 Presenter 类的负担。</p><p>还有一个好处是每一个 Use Case 都是可测试的，单元测试粒度被细化，更容易定位问题，从而针对性解决。关于测试我讲的不多，可以直接参考<a href="https://github.com/googlesamples/android-architecture/tree/todo-mvp-clean" target="_blank" rel="noopener">源码</a>进行理解。</p><h2 id="任务列表功能类图"><a href="#任务列表功能类图" class="headerlink" title="任务列表功能类图"></a>任务列表功能类图</h2><p>最后，我们将 todo app 的任务列表功能绘制成类图，加深理解。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/190821_todo_mvp_clean/mvp-clean-%E7%B1%BB%E5%9B%BE.png" alt="mvp-clean-类图" title="">                </div>                <div class="image-caption">mvp-clean-类图</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;I am the STORM!!!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上一篇文章介绍了 MVP 模式，作为 Android 最朴实的架构，MVP 足以应对复杂度较低的业务场景，回想 2014~2015 年在 DP 做预订闪惠的日子，用的便是
      
    
    </summary>
    
    
      <category term="架构" scheme="https://lilei.pro/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>架构学习之 mvp</title>
    <link href="https://lilei.pro/2019/08/21/architecture-todo-mvp/"/>
    <id>https://lilei.pro/2019/08/21/architecture-todo-mvp/</id>
    <published>2019-08-20T16:04:52.000Z</published>
    <updated>2019-08-20T16:17:44.226Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Life doesn’t give you what your want, it gives you what you DESERVE!</p></blockquote><h1 id="0x00-序言"><a href="#0x00-序言" class="headerlink" title="0x00 序言"></a>0x00 序言</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/190821_todo_mvp/aab-logov2.png" alt="Android Architecture Blueprints" title="">                </div>                <div class="image-caption">Android Architecture Blueprints</div>            </figure><p>Google 官方在 GitHub 推出的<a href="https://github.com/googlesamples/android-architecture" target="_blank" rel="noopener">Android 架构 Demo</a>项目非常值得学习，通过 TODO app 的例子，讲解各种应用架构模式如何在实现需求的基础上，达到可维护性、扩展性、可测试性的优秀设计。</p><p>本系列博客文章聚焦于以下几点：</p><ol><li>简明扼要介绍各个架构的思想与基础模型</li><li>在该架构模式下如何对 TODO App 的各个模块进行划分，以及划分的依据</li><li>取一个页面为例，作出类图，解析代码</li></ol><p><strong>Talk is cheap, show me the code.</strong></p><h1 id="0x01-业务逻辑"><a href="#0x01-业务逻辑" class="headerlink" title="0x01 业务逻辑"></a>0x01 业务逻辑</h1><p>建议 clone 代码后真机运行体验，用一张图概括如下。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/190821_todo_mvp/页面流程图.png" alt="页面流程图" title="">                </div>                <div class="image-caption">页面流程图</div>            </figure><p>Google 也给出了一个<a href="https://github.com/googlesamples/android-architecture/wiki/To-do-app-specification" target="_blank" rel="noopener">wiki 页面</a>说明 TODO app 的特性。至于为什么选择这样一个应用作为 demo，官方给出的解释如下：</p><blockquote><p>它必须足够简单，便于你很快地理解其功能；同时也要足够复杂，这样才能展现不同设计的决策以及提供测试场景。</p></blockquote><h1 id="0x02-todo-mvp"><a href="#0x02-todo-mvp" class="headerlink" title="0x02 todo-mvp"></a>0x02 todo-mvp</h1><h2 id="关于-MVP"><a href="#关于-MVP" class="headerlink" title="关于 MVP"></a>关于 MVP</h2><p>MVP 脱胎于大名鼎鼎的 MVC（Model-View-Controller）。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/190821_todo_mvp/mvc.png" alt="mvc" title="">                </div>                <div class="image-caption">mvc</div>            </figure><p>但凡做软件开发的人应该对 MVC 都不感到陌生，它的基本思想是将数据、视图、控制逻辑拆分。这三部分可以自由进行替换，比如在不改变数据接口的情况下，替换数据来源；或者是调整 UI 显示，而无需改动业务逻辑。</p><p>MVC 是一个具有历史意义的架构模式，它对天马行空、一团乱麻的软件设计进行规约，使后续对程序的修改和扩展简化，并且使重用成为可能。但是，它并不是最适合 Android 开发的架构模式。</p><h3 id="MVC-为什么不适合-Android-开发"><a href="#MVC-为什么不适合-Android-开发" class="headerlink" title="MVC 为什么不适合 Android 开发"></a>MVC 为什么不适合 Android 开发</h3><p>MVC 的核心思想是解耦，单一职责。在 Android 开发中，不使用 MVC 的主要原因是 Activity 的职责太重，往往要同时承担 View 和 Controller 的工作，这会造成 Activity 类非常庞大，UI 代码和逻辑代码交织，耦合严重。</p><h3 id="MVP-为什么适合-Android-开发"><a href="#MVP-为什么适合-Android-开发" class="headerlink" title="MVP 为什么适合 Android 开发"></a>MVP 为什么适合 Android 开发</h3><p>MVP 的架构如下图。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/190821_todo_mvp/mvp.png" alt="MVP" title="">                </div>                <div class="image-caption">MVP</div>            </figure><p>它单独抽出了 Presenter 对象，实现了业务逻辑，用于控制 View 的显示变化，以及与 Model 进行数据交互。Presenter 和 View 互相持有，Model 仅被 Presenter 持有。</p><p>在理想状态下，Presenter 和 Model 仅包含 Java 代码，不含 Android SDK 内容。MVP 架构解决了 MVC 中 Activity 职责过多的问题，将 UI 功能分配给 View 单独管理，View 的接口仅向 Presenter 开放，相比 MVC，更好地实现了职责单一、解耦的需求。</p><h2 id="如何抽象业务场景"><a href="#如何抽象业务场景" class="headerlink" title="如何抽象业务场景"></a>如何抽象业务场景</h2><h3 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h3><p>设计从数据层开始，数据层要承担什么职责呢？其实就是<strong>CRUD</strong>：</p><ul><li>保存新建的任务</li><li>查询已创建任务</li><li>更新任务状态（未完成 -&gt; 已完成）</li><li>删除任务</li></ul><p>数据的持久化方式，数据操作结果采用同步还是异步，这些问题也是设计过程中要考虑的。</p><h4 id="基本的任务对象：Task"><a href="#基本的任务对象：Task" class="headerlink" title="基本的任务对象：Task"></a>基本的任务对象：Task</h4><p>首先设计一个<code>Task.java</code>类，表示任务对象，它是一个典型的 Java Bean。在这里我们将 Task 设计成一个不可变的对象。在一个任务从“未完成”变为“完成”状态时，并不是修改原对象，而是丢弃掉原对象，再以相同<code>id</code>重新创建一个完成状态的对象。这样做的好处是逻辑简单，不可变对象线程绝对安全。缺点是当对象创建、销毁成本高的时候，会产生性能损失。在实际业务中应当酌情选择重用或者舍弃。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String mId;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String mTitle;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String mDescription;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> mCompleted;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Model-层对外暴露的接口：TasksDataSource"><a href="#Model-层对外暴露的接口：TasksDataSource" class="headerlink" title="Model 层对外暴露的接口：TasksDataSource"></a>Model 层对外暴露的接口：TasksDataSource</h4><p>本着面向接口编程的原则，隐藏数据操作具体实现代码，暴露出管理任务的接口（包含回调）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TasksDataSource</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">interface</span> <span class="title">LoadTasksCallback</span> </span>&#123; <span class="comment">// 加载复数任务回调</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onTasksLoaded</span><span class="params">(List&lt;Task&gt; tasks)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onDataNotAvailable</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">interface</span> <span class="title">GetTaskCallback</span> </span>&#123; <span class="comment">// 加载单条任务回调</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onTaskLoaded</span><span class="params">(Task task)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onDataNotAvailable</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">getTasks</span><span class="params">(@NonNull LoadTasksCallback callback)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">getTask</span><span class="params">(@NonNull String taskId, @NonNull GetTaskCallback callback)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">saveTask</span><span class="params">(@NonNull Task task)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">completeTask</span><span class="params">(@NonNull Task task)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">completeTask</span><span class="params">(@NonNull String taskId)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">activateTask</span><span class="params">(@NonNull Task task)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">activateTask</span><span class="params">(@NonNull String taskId)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clearCompletedTasks</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">refreshTasks</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">deleteAllTasks</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">deleteTask</span><span class="params">(@NonNull String taskId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口里有两处与我的编程思路有出入。首先是加载任务回调，我认为可以仅保留复数任务的接口，对于加载单条任务的需求，返回一个长度为 1 的列表就可以了。其次，在命名上，我习惯于将同步接口以<code>getXXX</code>，异步接口以<code>loadXXX</code>来声明。</p><p>有了这个接口，就可以提供给任务详情、任务列表等页面使用。接下来创建一个接口实现类，这个类对外的职责是实现数据操作接口，对内的职责是隐藏两种具体的数据操作实现（内存缓存、数据库、网络）。</p><p>数据源共有三级缓存：</p><ul><li>In-memory cache - Fast</li><li>Disk (SQLiteDb) - Slow</li><li>Network - Very slow</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TasksRepository</span> <span class="keyword">implements</span> <span class="title">TasksDataSource</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> TasksDatasource mTasksRemoteDataSource; <span class="comment">// 网络数据源</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> TasksDatasource mTasksLocalDataSource; <span class="comment">// 本地数据源</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读写数据策略可以概括为“依次读，全部写”，括号里是我补充的内容：</p><ul><li><p>In every <code>get</code>operation:</p><ul><li>Return cache if available, or</li><li>return local copy if it exists (and update cache) , or</li><li>return remote copy ( and update local copy &amp; cache)</li></ul></li><li><p>Every <code>write</code>/<code>delete</code>operation will simply:</p><ul><li>Update cache</li><li>Update local</li><li>Update remote</li></ul></li></ul><p>具体的网络数据源、本地数据库设计为常见写法，不赘述。</p><h3 id="Fragment-即是-View"><a href="#Fragment-即是-View" class="headerlink" title="Fragment 即是 View"></a>Fragment 即是 View</h3><p>处理所有 UI 变化事件，比如显示 loading、显示任务列表、显示任务详情、显示任务状态变更 SnackBar 等，值得注意的是页面跳转操作也属于 UI 变化，是在 Fragment 里面实现的。不妨思考一下为什么“跳转”不放在 Presenter 中进行？一个原因是 Presenter 与 Android SDK 无关，而跳转需要 Context 对象，违背了这一原则。比如从“任务列表”跳转到“任务详情”时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TasksFragment.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showAddTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Intent intent = <span class="keyword">new</span> Intent(getContext(), AddEditTaskActivity.class);</span><br><span class="line">  startActivityForResult(intent, AddEditTaskActivity.REQUEST_ADD_TASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>View 里面没有任何业务逻辑，主要处理以下事件：</p><ul><li>加载中、加载成功、失败页面展示</li><li>展现 Toast、SnackBar 等提示</li><li>处理按钮、菜单点击事件（通常是将其甩给 Presenter 处理）</li><li>处理页面跳转</li><li>声明 Adapter</li><li>在<code>onResume</code>时调用 Presenter 的<code>start</code>方法，启动页面</li><li>提供<code>isActive</code>方法，供 Presenter 在异步回调返回时判断页面是否存活</li></ul><p>最后一点是容易漏掉的，如果异步请求回调时页面被销毁，会导致各种难以预料的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> isAdded();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Presenter-业务逻辑载体"><a href="#Presenter-业务逻辑载体" class="headerlink" title="Presenter - 业务逻辑载体"></a>Presenter - 业务逻辑载体</h3><p>承担了业务逻辑实现的职责，有时业务逻辑过于复杂会导致 Presenter 类太大，此时要考虑拆分业务逻辑到单独的类中，就变成了<code>mvp-clean</code>架构，clean 架构中使用<code>Use Case（用例）</code>处理细分的业务逻辑。</p><p>Presenter 由 Activity 构造，并且提供方法给 Activity 以及 View（Fragment）使用。</p><h3 id="Activity-将一切粘合到一起"><a href="#Activity-将一切粘合到一起" class="headerlink" title="Activity - 将一切粘合到一起"></a>Activity - 将一切粘合到一起</h3><p>现在我们有了 Model、View、Presenter 各个部分，而 Android 应用的页面入口是 Activity 类，我们在 Activity 中创建 Fragment（View）及 Presenter，在这两者之间建立关联。同时还要处理一些必须放在 Activity 中进行的操作，比如<code>onSaveInstanceState</code>、<code>onOptionsItemSelected</code> 等等。</p><h2 id="任务列表功能实现"><a href="#任务列表功能实现" class="headerlink" title="任务列表功能实现"></a>任务列表功能实现</h2><p>用类图来表示 MVP 模式下的任务列表功能相关类：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/190821_todo_mvp/mvp类图.png" alt="mvp" title="">                </div>                <div class="image-caption">mvp</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Life doesn’t give you what your want, it gives you what you DESERVE!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;0x00-序言&quot;&gt;&lt;a href=&quot;#0x00-序言&quot; c
      
    
    </summary>
    
    
      <category term="架构" scheme="https://lilei.pro/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>ACE-PTM 第 II 部分 领导和实施</title>
    <link href="https://lilei.pro/2019/07/14/ace-cpt-part-2/"/>
    <id>https://lilei.pro/2019/07/14/ace-cpt-part-2/</id>
    <published>2019-07-14T10:16:42.000Z</published>
    <updated>2019-07-28T15:54:18.551Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第-2-章-激励和坚持原则"><a href="#第-2-章-激励和坚持原则" class="headerlink" title="第 2 章 - 激励和坚持原则"></a>第 2 章 - 激励和坚持原则</h1><p>只有约20%的美国成人同时符合有氧活动和肌肉强化指南要求。健身专业人员面临着两大挑战：<strong>让人们积极开始</strong>以及之后<strong>坚持运动计划</strong>。本章重点是提高人们在开始之后坚持计划的可能性。</p><p>激励人开始锻炼的因素不一定是使他们长期参与运动计划的因素。健康和健身行业的真正挑战是创造出适宜的计划和运动环境，使人们尽可能提高坚持计划并选择积极生活方式的可能性。</p><h2 id="了解激励"><a href="#了解激励" class="headerlink" title="了解激励"></a>了解激励</h2><p>用于评估激励的两种最常讨论方法是<strong>内在与外在激励</strong>和<strong>自我效能</strong>。</p><h3 id="内在和外在激励"><a href="#内在和外在激励" class="headerlink" title="内在和外在激励"></a>内在和外在激励</h3><p>在运动背景下，要实现内在激励，意味着一个人是因为参与本身所带来的内在愉悦和体验而从事运动活动。</p><p>与其认为需要让自己的客户受到更多的内在激励，私人教练应更努力增加参与计划所带来的愉悦感和成就感。私人教练通过鼓励客户<strong>拥有并参与计划以及教授自足性和自主性</strong>，可以帮助促进内在激励的形成。</p><h3 id="自我效能"><a href="#自我效能" class="headerlink" title="自我效能"></a>自我效能</h3><p>在运动背景下，自我效能定义为个体对自身成功参与体力活动计划的能力和信念。自我效能与激励呈正相关。</p><p>许多健身专业人员所犯的一个重大错误是安排整堂课进行评估，不要让客户感觉像在做测试，在某些情况下，甚至不要让客户知道你在收集评估信息。</p><h2 id="用于保持客户激励的策略"><a href="#用于保持客户激励的策略" class="headerlink" title="用于保持客户激励的策略"></a>用于保持客户激励的策略</h2><p>私人教练应当告知客户可能会出现回复原态并使其提前做好准备，以便他们能够在回复原态后立即重新坚持活动计划。第一步是<strong>宣教</strong>，第二步是<strong>支持</strong>。</p><h3 id="社会支持"><a href="#社会支持" class="headerlink" title="社会支持"></a>社会支持</h3><p>开发和维护运动的社会支持网络。教练应当尽量多利用团体参与和社交互动的机会，让客户感觉自己属于该计划，并且是具有共同兴趣和目标的成员所组成团队的一部分。</p><h3 id="自我肯定"><a href="#自我肯定" class="headerlink" title="自我肯定"></a>自我肯定</h3><p>教导客户进行自我肯定。</p><h3 id="自我调节"><a href="#自我调节" class="headerlink" title="自我调节"></a>自我调节</h3><p>教导客户成为有效的自律者，自我监督行为、日程、时间和优先事项。</p><h3 id="高风险情况"><a href="#高风险情况" class="headerlink" title="高风险情况"></a>高风险情况</h3><p>时间管理技能不佳、缺乏社会支持或日程繁忙的个人最有可能回复圆台。私人教练必须不断了解并观察客户是否出现受打击、沮丧或疲惫的迹象。</p><h2 id="影响运动参与和坚持度的因素"><a href="#影响运动参与和坚持度的因素" class="headerlink" title="影响运动参与和坚持度的因素"></a>影响运动参与和坚持度的因素</h2><p>体力活动的潜在决定因素可分为三类：</p><ul><li>个人特质</li><li>环境因素</li><li>体力活动因素</li></ul><h3 id="个人特质"><a href="#个人特质" class="headerlink" title="个人特质"></a>个人特质</h3><h4 id="人口统计变量"><a href="#人口统计变量" class="headerlink" title="人口统计变量"></a>人口统计变量</h4><h4 id="健康状况"><a href="#健康状况" class="headerlink" title="健康状况"></a>健康状况</h4><h4 id="过往的运动经验"><a href="#过往的运动经验" class="headerlink" title="过往的运动经验"></a>过往的运动经验</h4><h4 id="心理特质"><a href="#心理特质" class="headerlink" title="心理特质"></a>心理特质</h4><h4 id="认识、态度和信念"><a href="#认识、态度和信念" class="headerlink" title="认识、态度和信念"></a>认识、态度和信念</h4><h3 id="环境因素"><a href="#环境因素" class="headerlink" title="环境因素"></a>环境因素</h3><h4 id="设施便利性"><a href="#设施便利性" class="headerlink" title="设施便利性"></a>设施便利性</h4><h4 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h4><h4 id="社会支持-1"><a href="#社会支持-1" class="headerlink" title="社会支持"></a>社会支持</h4><h3 id="体力活动因素"><a href="#体力活动因素" class="headerlink" title="体力活动因素"></a>体力活动因素</h3><h4 id="强度"><a href="#强度" class="headerlink" title="强度"></a>强度</h4><h4 id="损伤"><a href="#损伤" class="headerlink" title="损伤"></a>损伤</h4><h2 id="反馈"><a href="#反馈" class="headerlink" title="反馈"></a>反馈</h2><ul><li>外部反馈：私人教练为客户提供的强化、纠错和鼓励。</li><li>内部反馈：客户根据自己的感觉系统（感受到、看到或听到的内容）为自己提供的相应信息。长期计划坚持度取决于客户提供自我反馈的能力。</li></ul><h2 id="领导特质"><a href="#领导特质" class="headerlink" title="领导特质"></a>领导特质</h2><p>对客户的进展表现出持续不断地关心和兴趣是贯穿私教职业生涯的一部分。私人教练使用系统性目标设定以及教授回复原态预防技巧的目的是，告诉客户他们对客户的关心远远超出这一小时课程的范围。</p><h2 id="私人教练爱建立坚持度中的作用"><a href="#私人教练爱建立坚持度中的作用" class="headerlink" title="私人教练爱建立坚持度中的作用"></a>私人教练爱建立坚持度中的作用</h2><h3 id="计划设计"><a href="#计划设计" class="headerlink" title="计划设计"></a>计划设计</h3><p>私人教练必须能够针对每个客户的偏好、时间表、经验、顾虑和约束条件（例如，钱、便利性和时间）设计计划。</p><h3 id="角色清晰度"><a href="#角色清晰度" class="headerlink" title="角色清晰度"></a>角色清晰度</h3><p>在一段关系中分歧和冲突产生的常见原因是角色模糊。</p><h3 id="目标设定"><a href="#目标设定" class="headerlink" title="目标设定"></a>目标设定</h3><p>目标设定应当遵循<em>SMART</em>原则。</p><ul><li>避免设定过多目标</li><li>避免设定负向目标</li><li>设定短期和长期目标以及过程目标和成绩目标</li><li>定期重审目标</li></ul><h3 id="合同-协议"><a href="#合同-协议" class="headerlink" title="合同/协议"></a>合同/协议</h3><p>使用行为合约和书面协议。</p><h2 id="第-2-章-习题集"><a href="#第-2-章-习题集" class="headerlink" title="第 2 章 - 习题集"></a>第 2 章 - 习题集</h2><h3 id="1-对于刚开始参加运动方案的个体而言，最重要的因素是什么？"><a href="#1-对于刚开始参加运动方案的个体而言，最重要的因素是什么？" class="headerlink" title="1. 对于刚开始参加运动方案的个体而言，最重要的因素是什么？"></a>1. 对于刚开始参加运动方案的个体而言，最重要的因素是什么？</h3><ol><li>家庭和朋友的大力支持</li><li>运动设施的便利性</li><li>与运动有关的行为改变意愿度</li><li>与私人教练联络</li></ol><p>错误选项（1），正确答案（3）。真正的动机都来源于内心。</p><h3 id="4-为了确保客户坚持参加训练，私人教练最好采用下列哪种策略？"><a href="#4-为了确保客户坚持参加训练，私人教练最好采用下列哪种策略？" class="headerlink" title="4. 为了确保客户坚持参加训练，私人教练最好采用下列哪种策略？"></a>4. 为了确保客户坚持参加训练，私人教练最好采用下列哪种策略？</h3><ol><li>为客户设计运动方案，这样客户就只训练，而不会对运动本身想太多</li><li>通过内在动机因素对客户进行激励，以提升其自我效能</li><li>鼓励客户独立安排运动方案，从而促进客户提升内在动机</li><li>主要通过指引（而非教育）建立自己的运动教学风格</li></ol><p>错误选项（2），正确答案（3）。教练不是通过“内在动机”对客户进行激励的。教练的目的是<strong>提升内在动机</strong>。</p><h3 id="9-在监督式环境中运动，最可能与运动坚持水平无关的因素是？"><a href="#9-在监督式环境中运动，最可能与运动坚持水平无关的因素是？" class="headerlink" title="9. 在监督式环境中运动，最可能与运动坚持水平无关的因素是？"></a>9. 在监督式环境中运动，最可能与运动坚持水平无关的因素是？</h3><ol><li>教育</li><li>年龄</li><li>收入</li><li>性别</li></ol><p>错误选项（3），正确答案（2）。其余几个选项都有相关。</p><h3 id="11-坚持的定义为：一种将行为赋予方向和目的的心理驱动力。"><a href="#11-坚持的定义为：一种将行为赋予方向和目的的心理驱动力。" class="headerlink" title="11. 坚持的定义为：一种将行为赋予方向和目的的心理驱动力。"></a>11. 坚持的定义为：一种将行为赋予方向和目的的心理驱动力。</h3><ol><li>正确</li><li>错误</li></ol><p>错误选项（1），正确答案（2）。<strong>坚持</strong>是积极主动地参加运动方案；<strong>激励</strong>则是心理驱动力。</p><h3 id="13-身体活动的三种主要潜在决定因素不包括哪一项？"><a href="#13-身体活动的三种主要潜在决定因素不包括哪一项？" class="headerlink" title="13. 身体活动的三种主要潜在决定因素不包括哪一项？"></a>13. 身体活动的三种主要潜在决定因素不包括哪一项？</h3><ol><li>个人特质</li><li>身体特质</li><li>环境因素</li><li>体育活动因素</li></ol><p>错误选项（1），正确答案（2）。其中1、3、4是体育活动的潜在决定因素。</p><h3 id="18-下列术语种，哪一项的定义为：相信自己有能力成功开始并坚持某种行为？"><a href="#18-下列术语种，哪一项的定义为：相信自己有能力成功开始并坚持某种行为？" class="headerlink" title="18. 下列术语种，哪一项的定义为：相信自己有能力成功开始并坚持某种行为？"></a>18. 下列术语种，哪一项的定义为：相信自己有能力成功开始并坚持某种行为？</h3><ol><li>内在激励</li><li>自我效能</li><li>外在激励</li><li>心里控制源</li></ol><p>错误选项（1），正确答案（2）。注意这是“效能”的定义。</p><hr><h1 id="第-3-章-沟通和教学技巧"><a href="#第-3-章-沟通和教学技巧" class="headerlink" title="第 3 章 - 沟通和教学技巧"></a>第 3 章 - 沟通和教学技巧</h1><h1 id="第-4-章-行为改变与健康心理学基础"><a href="#第-4-章-行为改变与健康心理学基础" class="headerlink" title="第 4 章 - 行为改变与健康心理学基础"></a>第 4 章 - 行为改变与健康心理学基础</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第-2-章-激励和坚持原则&quot;&gt;&lt;a href=&quot;#第-2-章-激励和坚持原则&quot; class=&quot;headerlink&quot; title=&quot;第 2 章 - 激励和坚持原则&quot;&gt;&lt;/a&gt;第 2 章 - 激励和坚持原则&lt;/h1&gt;&lt;p&gt;只有约20%的美国成人同时符合有氧活动和肌肉
      
    
    </summary>
    
    
      <category term="健身" scheme="https://lilei.pro/tags/%E5%81%A5%E8%BA%AB/"/>
    
      <category term="ACE-CPT" scheme="https://lilei.pro/tags/ACE-CPT/"/>
    
  </entry>
  
  <entry>
    <title>ACE-PTM 第 I 部分 简介</title>
    <link href="https://lilei.pro/2019/07/14/ace-cpt-part-1/"/>
    <id>https://lilei.pro/2019/07/14/ace-cpt-part-1/</id>
    <published>2019-07-14T09:32:41.000Z</published>
    <updated>2019-07-28T15:12:04.692Z</updated>
    
    <content type="html"><![CDATA[<h1 id="笔记前言"><a href="#笔记前言" class="headerlink" title="笔记前言"></a>笔记前言</h1><blockquote><p>作为学习 <a href="https://www.acefitness.org/" target="_blank" rel="noopener">ACE-CPT</a> 的读书笔记，这一系列将按章节分为七个部分。</p></blockquote><h2 id="第-I-部分-简介"><a href="#第-I-部分-简介" class="headerlink" title="第 I 部分 - 简介"></a>第 I 部分 - 简介</h2><p>介绍私人教练的角色定位与执业范围，哪些事情应该做，哪些事情可以做，哪些事情不能做。</p><h2 id="第-II-部分-领导和实施"><a href="#第-II-部分-领导和实施" class="headerlink" title="第 II 部分 - 领导和实施"></a>第 II 部分 - 领导和实施</h2><p>从沟通、激励会员角度给出指导意见，是贯彻执教过程始终的中心思想，帮助教练与会员建立相互信赖的关系。</p><h2 id="第-III-部分-ACE-整合式健身训练模式"><a href="#第-III-部分-ACE-整合式健身训练模式" class="headerlink" title="第 III 部分 - ACE 整合式健身训练模式"></a>第 III 部分 - ACE 整合式健身训练模式</h2><p>即 ACE-IFT 训练模式，是 ACE 独家的训练计划与模式，先评估，然后在稳定性、抗阻、心肺等多方面分别给出指导。</p><h2 id="第-IV-部分-特殊运动计划制定主题"><a href="#第-IV-部分-特殊运动计划制定主题" class="headerlink" title="第 IV 部分 - 特殊运动计划制定主题"></a>第 IV 部分 - 特殊运动计划制定主题</h2><p>讲解身心运动以及特殊人群的运动方法。</p><h2 id="第-V-部分-损伤预防和急救"><a href="#第-V-部分-损伤预防和急救" class="headerlink" title="第 V 部分 - 损伤预防和急救"></a>第 V 部分 - 损伤预防和急救</h2><p>常见损伤对运动过程的影响，以及遭遇损伤时候的紧急程序。</p><h2 id="第-VI-部分-职业和法律责任以及业务策略"><a href="#第-VI-部分-职业和法律责任以及业务策略" class="headerlink" title="第 VI 部分 - 职业和法律责任以及业务策略"></a>第 VI 部分 - 职业和法律责任以及业务策略</h2><p>私人教练职业的法律指南。</p><h2 id="第-VII-部分-补充"><a href="#第-VII-部分-补充" class="headerlink" title="第 VII 部分 - 补充"></a>第 VII 部分 - 补充</h2><p>涵盖不属于上述章节的内容。</p><hr><h1 id="第-1-章-私人教练的角色和执业范围"><a href="#第-1-章-私人教练的角色和执业范围" class="headerlink" title="第 1 章 - 私人教练的角色和执业范围"></a>第 1 章 - 私人教练的角色和执业范围</h1><h2 id="健康照护联盟"><a href="#健康照护联盟" class="headerlink" title="健康照护联盟"></a>健康照护联盟</h2><p>健康照护联盟由医疗保健专业人员组成，他们通过执照、注册和/或许可证获得认可，并提供相关服务以识别、预防和治疗疾病和病症。</p><p>团队成员构成如下：</p><ul><li>针灸师</li><li>脊椎按摩师</li><li>营养师</li><li>自然疗法医生</li><li>护士</li><li>医生</li><li>行为医师</li><li>物理治疗师</li><li>职业物理治疗师</li><li>运动教练</li></ul><h2 id="ACE-私人教练认证"><a href="#ACE-私人教练认证" class="headerlink" title="ACE 私人教练认证"></a>ACE 私人教练认证</h2><p>专业能力门槛被称为从事某种行业所需的“<strong>最低能力</strong>”。对于专业人员而言，执照可以将其与未证明自己处于同一能力水平的人区分开。通过获得 ACE 私人教练认证，专业人员证明了其在以下方面的能力：应用相关知识在各种实际情况下做出安全有效的运动计划决策，同时最大限度地减少客户风险和伤害。</p><h3 id="“执业范围”的定义"><a href="#“执业范围”的定义" class="headerlink" title="“执业范围”的定义"></a>“执业范围”的定义</h3><h3 id="ACE-认证的私人教练的执业范围"><a href="#ACE-认证的私人教练的执业范围" class="headerlink" title="ACE 认证的私人教练的执业范围"></a>ACE 认证的私人教练的执业范围</h3><p>根据 <strong>IDEA 私人健身教练的执业范围</strong> 表格，私人教练不可以做以下事情：</p><ul><li>进行诊断</li><li>开处方</li><li>为客户规定饮食或推荐具体的补充剂</li><li>治疗伤害或疾病</li><li>监督医疗转介绍客户的进展</li><li>提供康复服务</li><li>提供咨询</li><li>与患者合作</li></ul><h3 id="ACE-认证的私人教练的知识、技能和能力"><a href="#ACE-认证的私人教练的知识、技能和能力" class="headerlink" title="ACE 认证的私人教练的知识、技能和能力"></a>ACE 认证的私人教练的知识、技能和能力</h3><p>ACE 私人教练考试包括以下领域</p><ul><li>客户面谈和评估 - 31%</li><li>计划设计和执行 - 33%</li><li>进阶和调整 - 19%</li><li>专业行为、安全性和风险管理 - 17%</li></ul><h4 id="教育和经验"><a href="#教育和经验" class="headerlink" title="教育和经验"></a>教育和经验</h4><p>建议应试者流出平均三至四个月的学习时间来充分准备私人教练认证考试。</p><h3 id="执业责任和道德规范"><a href="#执业责任和道德规范" class="headerlink" title="执业责任和道德规范"></a>执业责任和道德规范</h3><p>ACE 制定了<strong>ACE 道德准则</strong>，所有 ACE 认证的专业人员和应试者都必须熟悉并遵守道德准则和专业时间和纪律程序。</p><h4 id="ACE-专业实践和纪律程序"><a href="#ACE-专业实践和纪律程序" class="headerlink" title="ACE 专业实践和纪律程序"></a>ACE 专业实践和纪律程序</h4><h4 id="执照期和续期"><a href="#执照期和续期" class="headerlink" title="执照期和续期"></a>执照期和续期</h4><p>ACE 认证有效期为<strong>两年</strong>，从获得认证之日起开始计算，于当月最后一天到期。续期则需要完成至少 20 小时的持续教育学分（2.0 CEC），并持有当前的<strong>心肺复苏（CPR）</strong>证书。如果持证人生活在北美，则必须能够正确使用<strong>自动外部除颤器（AED）</strong>。</p><p>ACE 为超过截止期限的专业人员的续期留出六个月的延长期限。</p><h4 id="客户隐私"><a href="#客户隐私" class="headerlink" title="客户隐私"></a>客户隐私</h4><h4 id="转介绍"><a href="#转介绍" class="headerlink" title="转介绍"></a>转介绍</h4><h4 id="补充剂和其他营养相关问题"><a href="#补充剂和其他营养相关问题" class="headerlink" title="补充剂和其他营养相关问题"></a>补充剂和其他营养相关问题</h4><p>补充剂<strong>不受美国食品和药物管理局（FDA）管制，因此无法保证起强度、纯度、安全性和效果。</strong>私人教练仅仅有资格向客户推荐补充剂，而没有资格推荐药物或开具药物。</p><h4 id="所提供服务超出执业范围的后果"><a href="#所提供服务超出执业范围的后果" class="headerlink" title="所提供服务超出执业范围的后果"></a>所提供服务超出执业范围的后果</h4><h2 id="由-NCCA-进行的健康照护联盟资格证书认证"><a href="#由-NCCA-进行的健康照护联盟资格证书认证" class="headerlink" title="由 NCCA 进行的健康照护联盟资格证书认证"></a>由 NCCA 进行的健康照护联盟资格证书认证</h2><h3 id="健身与健康行业的认可"><a href="#健身与健康行业的认可" class="headerlink" title="健身与健康行业的认可"></a>健身与健康行业的认可</h3><h3 id="教育界的认可"><a href="#教育界的认可" class="headerlink" title="教育界的认可"></a>教育界的认可</h3><p>ACE 教育伙伴计划提供四门独立的大学课程：</p><ul><li>私教</li><li>团体运动</li><li>健康教练</li><li>特殊人群运动课程</li></ul><h3 id="劳工部的认可"><a href="#劳工部的认可" class="headerlink" title="劳工部的认可"></a>劳工部的认可</h3><h2 id="职业发展"><a href="#职业发展" class="headerlink" title="职业发展"></a>职业发展</h2><h3 id="持续教育"><a href="#持续教育" class="headerlink" title="持续教育"></a>持续教育</h3><h4 id="高级知识"><a href="#高级知识" class="headerlink" title="高级知识"></a>高级知识</h4><h4 id="专业化"><a href="#专业化" class="headerlink" title="专业化"></a>专业化</h4><h3 id="学位"><a href="#学位" class="headerlink" title="学位"></a>学位</h3><h3 id="额外的健身执照"><a href="#额外的健身执照" class="headerlink" title="额外的健身执照"></a>额外的健身执照</h3><h3 id="健康照护联盟的新专业领域"><a href="#健康照护联盟的新专业领域" class="headerlink" title="健康照护联盟的新专业领域"></a>健康照护联盟的新专业领域</h3><hr><h1 id="第-1-章-习题集"><a href="#第-1-章-习题集" class="headerlink" title="第 1 章 - 习题集"></a>第 1 章 - 习题集</h1><h2 id="6-下列哪一项属于-ACE-认证私人教练的执业范围？"><a href="#6-下列哪一项属于-ACE-认证私人教练的执业范围？" class="headerlink" title="6. 下列哪一项属于 ACE 认证私人教练的执业范围？"></a>6. 下列哪一项属于 ACE 认证私人教练的执业范围？</h2><ol><li>帮助客户更好地了解食物分量与健康食品，从而帮助他们做出更明智的选择</li><li>为客户提供 4 周食谱与购物清单，帮助他们走上健康饮食的正轨</li><li>回顾过去 24 小时的饮食情况，帮助客户了解自己缺少哪些微量元素</li><li>就惊喜代谢率（RMR）以及热量摄入要小于 RMR 等知识对客户进行教育，帮助客户减轻体重</li></ol><p>错误选项（4），正确答案（1）。关键点在于选择权由客户持有，而非私人教练做出选择 or 决定。</p><h2 id="9-关于私人教练向客户推荐营养补充剂，下列叙述最恰当的一项是"><a href="#9-关于私人教练向客户推荐营养补充剂，下列叙述最恰当的一项是" class="headerlink" title="9. 关于私人教练向客户推荐营养补充剂，下列叙述最恰当的一项是"></a>9. 关于私人教练向客户推荐营养补充剂，下列叙述最恰当的一项是</h2><ol><li>只能向客户推荐自己已投职业责任险的补充剂</li><li>如果私人教练未持有注册营养师或医学博士学位等其他帧数，则不具有向他人推荐补充剂的合法资质</li><li>私人教练应接受专门的知识培训后才能向客户推荐营养补充剂</li><li>由于服用补充剂与其他药物可能会引起并发症，私人教练只能向客户推荐植物性补充剂</li></ol><p>错误选项（3），正确答案（2）。“专门的知识培训”不够精确。</p><h2 id="15-“执业范围”的定义不包括哪一项？"><a href="#15-“执业范围”的定义不包括哪一项？" class="headerlink" title="15. “执业范围”的定义不包括哪一项？"></a>15. “执业范围”的定义不包括哪一项？</h2><ol><li>专业健身人员在特定领域可提供的合法服务范围</li><li>在工作场所必须遵守的职业道德准则</li><li>可以供私教服务的场所</li><li>必须遵守的指南或参数标准</li></ol><p>错误选项（3），正确答案（2）。道德是道德，业务是业务。</p><h2 id="20-如果客户提到自己参加周末网球比赛后肌肉酸痛，教练给予的最恰当的回应是？"><a href="#20-如果客户提到自己参加周末网球比赛后肌肉酸痛，教练给予的最恰当的回应是？" class="headerlink" title="20. 如果客户提到自己参加周末网球比赛后肌肉酸痛，教练给予的最恰当的回应是？"></a>20. 如果客户提到自己参加周末网球比赛后肌肉酸痛，教练给予的最恰当的回应是？</h2><ol><li>推荐客户服用抗炎类非处方药</li><li>建议客户在下次比赛前服用肌酸补充剂</li><li>对深层组织进行按摩处理，帮助缓解肌肉酸痛</li><li>与客户探讨对患处进行冷敷的正确方法</li></ol><p>错误选项（3），正确答案（4）。其余选项超出执业范围。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;笔记前言&quot;&gt;&lt;a href=&quot;#笔记前言&quot; class=&quot;headerlink&quot; title=&quot;笔记前言&quot;&gt;&lt;/a&gt;笔记前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;作为学习 &lt;a href=&quot;https://www.acefitness.org/&quot; target
      
    
    </summary>
    
    
      <category term="健身" scheme="https://lilei.pro/tags/%E5%81%A5%E8%BA%AB/"/>
    
      <category term="ACE-CPT" scheme="https://lilei.pro/tags/ACE-CPT/"/>
    
  </entry>
  
  <entry>
    <title>ACE-CPT 考试信息汇总</title>
    <link href="https://lilei.pro/2019/07/14/ace-cpt-qualification/"/>
    <id>https://lilei.pro/2019/07/14/ace-cpt-qualification/</id>
    <published>2019-07-14T09:27:29.000Z</published>
    <updated>2019-07-14T09:31:24.837Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/64605617" target="_blank" rel="noopener">国内自考ACE-CPT心得（一）考试流程</a></p><p><a href="https://zhuanlan.zhihu.com/p/67532892" target="_blank" rel="noopener">国内自考ACE-CPT心得（二）读者问答</a></p><p><a href="https://www.zhihu.com/question/54711544" target="_blank" rel="noopener">教材哪里买</a></p><h2 id="四大认证"><a href="#四大认证" class="headerlink" title="四大认证"></a>四大认证</h2><ul><li>ACSM</li><li>NSCA</li><li>ACE</li><li>NASM</li></ul><h2 id="教材"><a href="#教材" class="headerlink" title="教材"></a>教材</h2><p>1000页教材，需要100h学习时间。</p><ul><li>官网英文版</li><li>官网翻译版</li><li>培训机构翻译版</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/190714_acecpt/教材.jpg" alt="教材" title="">                </div>                <div class="image-caption">教材</div>            </figure><ol><li>Personal Trainer Manual —— 主要教材，80%考题来源于此</li><li>Essential of Exercise Science —— 辅助材料，解剖、营养、生理等</li><li>Study Companion —— 课后习题</li><li>宣传手册 —— 没用</li></ol><p>官网有在线模拟题。</p><p>考题分布。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/190714_acecpt/考题分布.jpg" alt="考题分布" title="">                </div>                <div class="image-caption">考题分布</div>            </figure><h2 id="考试"><a href="#考试" class="headerlink" title="考试"></a>考试</h2><p>携带身份证、驾照、护照、CPR证。</p><p>3小时，150道单选题，125题计入总分。每道题都有英文原文和中文翻译。开考前会提供纸笔。</p><p>电脑上有工具：</p><ul><li>题目标记</li><li>未答题数量</li><li>计算器</li></ul><p>考试提交后立马出分数。总分800分，超过500分及格。</p><h2 id="报名"><a href="#报名" class="headerlink" title="报名"></a>报名</h2><p>官网报名。399刀。</p><p>提前一个月申请考场。</p><p>急救培训：CPR or AED，在当地红十字会报名，一周末拿证。</p><h2 id="继续教育"><a href="#继续教育" class="headerlink" title="继续教育"></a>继续教育</h2><p>两年内 2.0 学分 + CPR</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/64605617&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;国内自考ACE-CPT心得（一）考试流程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.
      
    
    </summary>
    
    
      <category term="健身" scheme="https://lilei.pro/tags/%E5%81%A5%E8%BA%AB/"/>
    
      <category term="ACE-CPT" scheme="https://lilei.pro/tags/ACE-CPT/"/>
    
  </entry>
  
  <entry>
    <title>《高效能人士的七个习惯 第三部分 习惯五 知彼解己——移情沟通的原则</title>
    <link href="https://lilei.pro/2019/04/07/Seven-Habbits-7/"/>
    <id>https://lilei.pro/2019/04/07/Seven-Habbits-7/</id>
    <published>2019-04-07T03:00:29.000Z</published>
    <updated>2019-06-08T08:46:26.832Z</updated>
    
    <content type="html"><![CDATA[<h1 id="你真的听懂了吗"><a href="#你真的听懂了吗" class="headerlink" title="你真的听懂了吗"></a>你真的听懂了吗</h1><p>如果你要和我交往，想对我有影响力，你首先要了解我，而做到这一点不能只靠技巧。如果我觉察到你在使用某种技巧，就会有受骗和被操纵的感觉。我不知道你为什么这样做，有什么动机。</p><p>你的影响力在于你的榜样作用和引导能力，前者源于你的品德，是你的真我，别人的评论或者你希望别人如何看你都没有意义，我在同你的交往中已经清楚了解了你。</p><p>你的品德时刻发挥着影响力，并起着沟通的作用。久而久之，我就会本能地信任或者不信任你这个人以及你对我所做的事情。</p><h1 id="移情聆听"><a href="#移情聆听" class="headerlink" title="移情聆听"></a>移情聆听</h1><p>“知彼”是交往模式的一大转变，因为我们通常把让别人理解自己放在首位。大部分人在聆听时并不是想理解对方，而是为了做出回应。这种人要么说话，要么准备说话，不断地用自己的模式过滤一切，用自己的经历理解别人的生活。</p><p>事实上，大部分人都是这么自以为是。我们的聆听通常有层次之分。一是充耳不闻，压根就不听别人说话；二是装模作样，“是的！嗯！没错！”三是选择接受，只听一部分，通常学龄前儿童喋喋不休会让我们采取这种方式；四是聚精会神，努力听到每一个字，但是，很少有人会达到第五个层次，即最高层次——移情聆听。</p><p><strong>移情聆听</strong>是指以理解为目的的聆听，要求听者站在说话者的角度理解他们的思维模式和感受。</p><p>移情（Empathy）不是同情（Sympathy）。后者是一种认同和判断形式，更适合用来表达感情和做出回应，却容易养成对方的依赖性。移情聆听的本质不是你要赞同对方，而是要在情感和理智上充分而深入地理解对方。</p><p>据专家估计，人际沟通仅有10%通过语言来进行，30%取决于语调与声音，其余60%则得靠肢体语言。所以在移情聆听的过程中，不仅要耳到，还要眼到、心到；用眼睛去观察，用心灵去体会。</p><h1 id="心理空气"><a href="#心理空气" class="headerlink" title="心理空气"></a>心理空气</h1><p>除了物质，人类最大的生存需求源自心理，即被人理解、肯定、认可和欣赏。</p><p>移情聆听是有风险的。只有当你做好了被对方影响的准备，才能深入到移情聆听的阶段，而这是需要足够的安全感的，因为这时候的你会变得很脆弱。从某种意义上说，这很矛盾，因为在影响对方之前，你必须先被影响，即真正理解对方。</p><h1 id="先诊断后开方"><a href="#先诊断后开方" class="headerlink" title="先诊断后开方"></a>先诊断后开方</h1><p>平庸的业务员推销产品，杰出的业务员销售解决问题、满足需求之道。万一产品不符合客户需要，也要勇于承认。</p><h1 id="四种自传式回应"><a href="#四种自传式回应" class="headerlink" title="四种自传式回应"></a>四种自传式回应</h1><p>我们在听别人讲话时总是会联系我们自己的经理，因此自以为是的人往往会有四种“自传式回应”（Autobiographical Response）的倾向：</p><ul><li>价值判断——对旁人的意见只有接受或不接受。</li><li>追根究底——依自己的价值观探查别人的隐私。</li><li>好为人师——以自己的经验提供忠告。</li><li>自以为是——根据自己的行为与动机衡量别人的行为与动机。</li></ul><h1 id="表达也要讲技巧"><a href="#表达也要讲技巧" class="headerlink" title="表达也要讲技巧"></a>表达也要讲技巧</h1><p>古希腊人有一种很经典的哲学观点，即品德第一，感情第二，理性第三。我认为这三个词集中体现了让他人理解自己以及有效表达自己的精髓。</p><p>品德指的是你个人的可信度，是人们对你的诚信和能力的认可，是人们对你的信任，是你的情感账户。感情指的是你的移情能力，是感性的，说明你能通过交流迅速理解他人的情感。理性是你的逻辑能力，即合理表达自己的能力。</p><h1 id="一对一沟通"><a href="#一对一沟通" class="headerlink" title="一对一沟通"></a>一对一沟通</h1><p>你现在就可以练习习惯五。下次同别人交流的时候，你可以试着抛开自己的经验，尽力真正了解对方。你应该睿智、敏感而又头脑清楚。不论在办公室或者家中，敞开胸怀，凝神倾听。不要急功近利，即使短期内未获回馈也绝不气馁。</p><p>如果你真正爱一个人，那么花时间了解对方将有益于今后的坦诚相待，这样一来，很多困扰家庭和婚姻的问题都将被扼杀在萌芽状态，没有发展壮大的机会，即便有这样的机会，充足的情感账户储蓄也会让问题迎刃而解。</p><p>先理解别人。在问题出现之前，在评估和判断之前，在你表达个人观点之前，先理解别人，这是有效的相互依赖关系中最有用的习惯。</p><h1 id="付诸行动"><a href="#付诸行动" class="headerlink" title="付诸行动"></a>付诸行动</h1><ol><li>选择一个情感账户出现赤字的人际关系，试着从对方的角度理解并记下他的处境。下一次见面时，通过聆听来理解对方，将现在听到的和以前记下的做一个比较。看看你的想法是否准确？——你真的理解对方的立场和观点么？</li><li>与一个亲近的人分享移情这个概念，告诉他你想要做到真正的移情聆听，并让他在一个星期之后提供反馈意见。——你做的怎么样？那个人有什么感觉？</li><li>下次有机会旁观他人交流的时候，捂住自己的耳朵，只用眼睛观察。哪些情感不是用语言表达出来的？</li><li>下次发现你表现出不恰当的自传式回应的时候，立即承认错误，尽力扭转局面，将情感账户的支出变成存入。（“对不起，我刚才并不是真的努力去理解你，我们可以再来一次吗？”）</li><li>下次表达自己观点的时候，首先做到移情。要能够和对方的同伴一样（甚至更好地）描述对方的观点，然后站在对方的立场上，争取让自己的观点得到理解。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;你真的听懂了吗&quot;&gt;&lt;a href=&quot;#你真的听懂了吗&quot; class=&quot;headerlink&quot; title=&quot;你真的听懂了吗&quot;&gt;&lt;/a&gt;你真的听懂了吗&lt;/h1&gt;&lt;p&gt;如果你要和我交往，想对我有影响力，你首先要了解我，而做到这一点不能只靠技巧。如果我觉察到你在使用某种
      
    
    </summary>
    
    
      <category term="高效能人士的七个习惯" scheme="https://lilei.pro/tags/%E9%AB%98%E6%95%88%E8%83%BD%E4%BA%BA%E5%A3%AB%E7%9A%84%E4%B8%83%E4%B8%AA%E4%B9%A0%E6%83%AF/"/>
    
  </entry>
  
  <entry>
    <title>《高效能人士的七个习惯》第三部分 习惯六 统合综效——创造性合作的原则</title>
    <link href="https://lilei.pro/2019/04/07/Seven-Habbits-8/"/>
    <id>https://lilei.pro/2019/04/07/Seven-Habbits-8/</id>
    <published>2019-04-07T03:00:29.000Z</published>
    <updated>2019-06-08T08:48:02.539Z</updated>
    
    <content type="html"><![CDATA[<p>统合综效的基本态度是如果以为具有相当聪明才智的人跟我意见不同，那么对方的主张必定有我尚未体会的奥妙，值得加以了解。</p><p>与人合作最重要的是，重视不同个体的不同心理、情绪与智能，以及个人眼中所见到的不同世界。假如两人意见相同，其中一人必属多余。与所见略同的人沟通，毫无益处，要有分歧才有收获。</p><p>统合综效的精髓是判断和尊重差异，取长补短。</p><h1 id="敞开胸怀，博采众议"><a href="#敞开胸怀，博采众议" class="headerlink" title="敞开胸怀，博采众议"></a>敞开胸怀，博采众议</h1><p>所谓统合综效的沟通，是指敞开胸怀、接纳一切奇怪的想法，同时也贡献自己的浅见。</p><p>凡是创新就得承担，不怕失败，不断尝试错误。只愿稳扎稳打的人，经不起此种煎熬。</p><h1 id="沟通三层次"><a href="#沟通三层次" class="headerlink" title="沟通三层次"></a>沟通三层次</h1><p>低层次的沟通源自低度信任，其特点是人与人之间互相提防，步步为营，经常借助法律说话，为情况恶化作打算，其结果只能是赢/输或者输/赢，而且毫无效率可言，即产出/产能不平衡，结果只能是让人们更有理由进行自我防御和保护。</p><p>中间一层是彼此尊重的交流方式，唯有相当成熟的人才办得到。但是为了避免冲突，双方都保持礼貌，却不一定为对方设想。在相互依赖的环境中，最常用的态度是<strong>妥协</strong>。</p><p>统合综效意味着1+1等于8或者16，甚至1600。源自高度信任沟通的层次。</p><h1 id="寻求第三条道路"><a href="#寻求第三条道路" class="headerlink" title="寻求第三条道路"></a>寻求第三条道路</h1><p>高余额的情感账户、双赢模式、先理解别人的原则，所有这些加在一起，就是实现创造性统合综效的理想环境。</p><h1 id="消极协作减效"><a href="#消极协作减效" class="headerlink" title="消极协作减效"></a>消极协作减效</h1><p>人际关系最可贵的地方就是能接触到不同的模式。相同不是统一，一致也不等于团结，统一和团结意味着互补，而不是相同。相同毫无创造性可言，而且沉闷乏味。统合综效的精髓就是尊重差异。</p><h1 id="尊重差异"><a href="#尊重差异" class="headerlink" title="尊重差异"></a>尊重差异</h1><p>自以为是的人总以为自己最可观，别人都有所偏颇，其实这才是画地为牢。反之，虚怀若谷的人承认自己有不足之处，而乐于在与人交往之中汲取丰富的知识见解，重视不同的意见，因而增广见闻。</p><h1 id="化阻力为动力"><a href="#化阻力为动力" class="headerlink" title="化阻力为动力"></a>化阻力为动力</h1><p>在互赖关系中，统合综效是对付阻挠成长与改变的最有力途径。</p><p>动力通常是积极、合理、自觉、符合经济效益的力量；相反地，阻力多半消极、负面、不合逻辑、情绪化、不自觉，具社会性与心理性因素。这两组作用力都是真实存在的，在应变时都要考虑周全。</p><p>不涉法削减阻力，只一味增加推力，就仿佛施力于弹簧上，终有一天引起反弹。</p><p>这并不意味着拒绝采取法律手段，有些时候法律手段时绝对必要的，但是我认为它只应该在最后关头发挥作用，而不是问题刚一出现的时候，过早使用只会让恐惧心理和法律模式制约了统合综效的可能性。</p><h1 id="自然界是统合综效的最佳典范"><a href="#自然界是统合综效的最佳典范" class="headerlink" title="自然界是统合综效的最佳典范"></a>自然界是统合综效的最佳典范</h1><p>你应该尊重自己善于分析的一面和富有创造力的一面，尊重它们的差异会催生你的创造力。</p><p>即使处于不利境地，也不应该放弃追求统合综效。不要在意别人的无礼行径，避开那些消极力量，发现并利用别人的优势，提高自己的认识，扩展自己的视野。你应该在相互依赖的环境中勇敢而坦率地表达自己的观点、情感和经历，借此鼓励他人同样地坦诚相待。</p><p>尊重人与人之间的差异，当有人不同意你的观点的时候，你应该说：“你跟我有不一样的看法，这很好。”</p><h1 id="付诸行动"><a href="#付诸行动" class="headerlink" title="付诸行动"></a>付诸行动</h1><ol><li>想一想谁总是跟你的看法不一样，用什么方法可以把这些差异变成通往第三条道路的阶梯。可以就当前的某个项目或者某个问题请教这个人的意见，珍惜这些不同的见解。</li><li>列一张名单，写上让你觉得不快的人的名字。如果你内心有更充足的安全感，能够做到尊重差异，你是否会觉得这些人代表了不同意见，而你可借此实现与他们的统合综效？</li><li>想一想在什么情况下你更需要统合综效？统合综效需要哪些条件来支持？怎样才能创造出这些条件？</li><li>下一次当你同某人意见相左或者发生冲突的时候，尽量理解他的立场和顾虑，以创造性的、互惠互利的方式解决问题。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;统合综效的基本态度是如果以为具有相当聪明才智的人跟我意见不同，那么对方的主张必定有我尚未体会的奥妙，值得加以了解。&lt;/p&gt;
&lt;p&gt;与人合作最重要的是，重视不同个体的不同心理、情绪与智能，以及个人眼中所见到的不同世界。假如两人意见相同，其中一人必属多余。与所见略同的人沟通，毫
      
    
    </summary>
    
    
      <category term="高效能人士的七个习惯" scheme="https://lilei.pro/tags/%E9%AB%98%E6%95%88%E8%83%BD%E4%BA%BA%E5%A3%AB%E7%9A%84%E4%B8%83%E4%B8%AA%E4%B9%A0%E6%83%AF/"/>
    
  </entry>
  
  <entry>
    <title>《高效能人士的七个习惯》第二部分 习惯三 要事第一</title>
    <link href="https://lilei.pro/2019/04/07/Seven-Habbits-4/"/>
    <id>https://lilei.pro/2019/04/07/Seven-Habbits-4/</id>
    <published>2019-04-07T03:00:29.000Z</published>
    <updated>2019-06-08T08:46:02.557Z</updated>
    
    <content type="html"><![CDATA[<h1 id="回答两个问题"><a href="#回答两个问题" class="headerlink" title="回答两个问题"></a>回答两个问题</h1><ul><li>在你目前的生活中，有哪些事情能够彻底改观你的个人生活，但是你一直没有去做？</li><li>在你目前的生活中，有哪些事情能够彻底改观你的工作局面，但是你一直没有去做？</li></ul><p>习惯三是习惯一、二的具体实践。习惯一告诉你，你是创造者，你掌控自己的人生，其基础是人类特有的四大天赋：想象力、良知、独立意志、自我意识。</p><p>习惯二是关于第一次的创造或者智力上的创造的习惯，其原则基础是<strong>想象力</strong>和<strong>良知</strong>这两大天赋。</p><p>习惯三是关于第二次的创造或者体力上的创造的习惯，是对前面两个习惯的实施、执行和自然表现。</p><p>左脑进行管理，右脑进行领导。</p><p>有效的管理指的就是要事第一，先做最重要的事情。领导者首先要决定的，就是哪些事情是重要的；而作为管理者，就是要将这些重要的事务优先安排。自我管理的实质就是自律和条理，是对计划的实施。</p><p>《成功的普遍共性》一文的作者格雷（E.M.Gray）说：“<strong>成功者能为失败者所不能为，纵使并非心甘情愿，但为了理想与目标，仍可以凭毅力克服心理障碍。</strong>”</p><h1 id="四代时间管理理论的演进"><a href="#四代时间管理理论的演进" class="headerlink" title="四代时间管理理论的演进"></a>四代时间管理理论的演进</h1><p>如何分辨轻重缓急与培养组织能力，是时间管理的精髓。</p><ol><li>第一代理论着重利用便条与备忘录，在忙碌中调配时间与精力</li><li>第二代理论强调行事历与日程表，反映出时间管理已经注意到规划未来的重要。</li><li>第三代是讲求优先顺序的概念，依据轻重缓急设定短中长期目标。</li><li>第四代理论从根本否定“时间管理”，主张关键在于“个人管理”，重心应当放在维持产出与产能平衡上。</li></ol><h1 id="别让琐务牵着鼻子走"><a href="#别让琐务牵着鼻子走" class="headerlink" title="别让琐务牵着鼻子走"></a>别让琐务牵着鼻子走</h1><p>第四代时间管理理论从重要性和紧急程度两个维度对事务进行划分。重要性与目标有关，凡有价值、有利于实现个人目标的就是要事。紧急程度与时间紧迫性有关，紧迫之事通常都显而易见，推诿不得。</p><h2 id="第一类事务，重要且紧急"><a href="#第一类事务，重要且紧急" class="headerlink" title="第一类事务，重要且紧急"></a>第一类事务，重要且紧急</h2><p>在矩阵中，第一类事务通常既紧迫又重要，需要立即处理，通常被称为“危机”或者“问题”。如果你过分注重第一类事务，它们的范围会变得越来越大，最终占据你全部的时间和精力。</p><p>大部分时间精力都用于处理危机的人（第一类事务）</p><ul><li>压力大</li><li>精疲力尽</li><li>被危机牵着鼻子走</li><li>忙于收拾残局</li></ul><h2 id="第三类事务，紧急不重要"><a href="#第三类事务，紧急不重要" class="headerlink" title="第三类事务，紧急不重要"></a>第三类事务，紧急不重要</h2><p>这些人将时间致力于紧急不重要的第三类事务，却自以为在处理第一类事务。殊不知紧迫之事往往是别人的优先，对别人很重要，对自己却不然。</p><ul><li>急功近利</li><li>被危机牵着鼻子走</li><li>被视为巧言令色</li><li>轻视目标和计划</li><li>认为自己是受害者，缺乏自制力</li><li>人际关系肤浅，甚至破裂</li></ul><h2 id="第四类事务，既不重要也不紧急"><a href="#第四类事务，既不重要也不紧急" class="headerlink" title="第四类事务，既不重要也不紧急"></a>第四类事务，既不重要也不紧急</h2><p>有些不负责任的人，将时间都花在第三和第四类事务上</p><ul><li>完全不负责任</li><li>被炒鱿鱼</li><li>基本生活都需要依赖他人或社会机构</li></ul><h2 id="第二类事务，重要不紧急"><a href="#第二类事务，重要不紧急" class="headerlink" title="第二类事务，重要不紧急"></a>第二类事务，重要不紧急</h2><p>包括建立人际关系、撰写使命宣言、规划长期目标、防患于未然等等。高效能人士避免陷入第三和第四类事务，通过花费更多时间在第二类事务来减少第一类事务的数量。</p><ul><li>愿景，远见</li><li>平衡</li><li>自律</li><li>自制</li><li>很少发生危机</li></ul><h1 id="勇敢说“不”"><a href="#勇敢说“不”" class="headerlink" title="勇敢说“不”"></a>勇敢说“不”</h1><p>若要集中精力于当急的要务，就得排除次要事务的牵绊，此时需要有说“不”的勇气。</p><blockquote><p>我曾聘用一位极有才华又独立自主的专员，有一天有件急事想拜托他。他说：“你要我做什么都可以，不过请先了解目前的状况。”他指着墙壁上的工作计划表，显示超过 20 个计划正在进行，这是我俩早已谈妥的。然后他说：“这件急事至少占去几天时间，你希望我放下或取消哪个计划来空出时间？”</p></blockquote><p>很多人坦陈自己“缺乏自制力”，实际上，这是“确认目标”的功夫还不到家，而且不能由衷接收“事有轻重缓急”的观念，自然容易半途而废。</p><h1 id="集大成的时间管理理论"><a href="#集大成的时间管理理论" class="headerlink" title="集大成的时间管理理论"></a>集大成的时间管理理论</h1><p>第一代的时间管理理论丝毫没有“优先”的概念。固然做完备忘录上的一件事，会带给人成就感，可是这种成就不一定符合人生大目标。因此，所完成的只是必要而非重要的事。</p><p>然而好此道者不在少数，因为阻力最小，痛苦与压力也最少。</p><p>更何况，根据外在要求与规律行事，容易推卸责任。这类人缺乏效率，缺乏自制力与自尊。</p><p>第四代理论强调以原则为重心，配合个人对使命的认知，兼顾重要性与急迫性；强调产出与产能齐头并进，着重第二类事务的完成。</p><h1 id="管理方法六标准"><a href="#管理方法六标准" class="headerlink" title="管理方法六标准"></a>管理方法六标准</h1><ol><li>和谐一致。</li><li>平衡功能。</li><li>围绕中心理想的管理方法。</li><li>以人为本。</li><li>灵活变通。</li><li>便于携带的管理工具。</li></ol><h1 id="个人管理四步骤"><a href="#个人管理四步骤" class="headerlink" title="个人管理四步骤"></a>个人管理四步骤</h1><h2 id="第一步-确认角色"><a href="#第一步-确认角色" class="headerlink" title="第一步 确认角色"></a>第一步 确认角色</h2><p>写出你自己的关键角色，在家庭中、工作中乃至教会和社区事务中的角色。列举自己想要持续投入时间和精力去做的一些事情。</p><h2 id="第二步-选定周目标"><a href="#第二步-选定周目标" class="headerlink" title="第二步 选定周目标"></a>第二步 选定周目标</h2><p>思考下一个周计划中每一个任务栏下你最想做的一两件要事，作为你选定的目标。这些目标中一定要有几个<strong>第二类事务</strong>，根据自己的感觉判断每个角色中哪些事情是比较重要的，并为每个角色确立一个或两个目标。</p><h2 id="第三步-安排进度"><a href="#第三步-安排进度" class="headerlink" title="第三步 安排进度"></a>第三步 安排进度</h2><p>为每一项目标安排具体的实施时间。有些目标需要在工作日完成，有些目标需要在周末完成。确保自己有充分的自由和灵活性以应付突发事件，让你享受到自发的乐趣。你会感觉很踏实，因为你知道自己已经安排好了一周的要务，照顾到了工作生活中的每一个重要领域。</p><h2 id="第四部-每日调整"><a href="#第四部-每日调整" class="headerlink" title="第四部 每日调整"></a>第四部 每日调整</h2><p>根据突发事件、人际关系的意外发展及崭新机会对每天的要务安排进行适当调整。</p><p>在每天早晨审视自己一天的日程安排。</p><h1 id="付诸实践"><a href="#付诸实践" class="headerlink" title="付诸实践"></a>付诸实践</h1><p>诚心正意，对人不可讲效率，效率是对事而言的，对人应当讲<strong>效用</strong>。第四代个人管理理论的特点在于承认人比事更重要。</p><h1 id="第四代时间管理方法的优点"><a href="#第四代时间管理方法的优点" class="headerlink" title="第四代时间管理方法的优点"></a>第四代时间管理方法的优点</h1><p>第四代时间管理方法比前三代更加先进，这种先进体现在五个方面</p><ol><li>以原则为基础，切实地创造出一个核心模式，让你能够在一个更大的范围内分配自己的时间，看清楚什么是真正重要和有效的。</li><li>接受你内心良知的指导，让你有机会更好地安排自己的生活，并且最大限度地同你的价值观保持一致。同时给你自由和变通，让你在牺牲既定日程安排，服从更重要的价值观的时候心平气和，毫不内疚。</li><li>这种方法确认了你的个人使命，包括价值观和长期目标。</li><li>这种方法帮助你明确自己的角色，平衡自己生活中的各个方面。每个星期为每个关键角色确立要达到的目标，并作出具体的日程安排。</li><li>以一个星期为单位计划生活，不必局限于短暂的一天时间。通过审视自己的主要角色而让自己保持清醒，经常想到自己内心深处的价值观。</li></ol><p>有一条主线贯穿这五个方面，那就是将人际关系和效果放在第一位，将时间放在第二位。</p><h1 id="高效能的秘诀——授权"><a href="#高效能的秘诀——授权" class="headerlink" title="高效能的秘诀——授权"></a>高效能的秘诀——授权</h1><p>把责任分配给其他成熟老练的员工，才有余力从事更高层次的活动。授权是事必躬亲与管理之间的最大分野，事必躬亲者凡事不假外求。反之，管理者注重建立制度，然后汇集群力共同完成工作。</p><p>授权可以划分为两种类型：<strong>指令型授权</strong>和<strong>责任型授权</strong>。</p><h2 id="指令型授权"><a href="#指令型授权" class="headerlink" title="指令型授权"></a>指令型授权</h2><p>指令型授权关注重点是<strong>方法</strong>，管理者自己为最后的结果负责。</p><h2 id="责任型授权"><a href="#责任型授权" class="headerlink" title="责任型授权"></a>责任型授权</h2><p>责任型授权的关注重点是<strong>最终结果</strong>，它给人们自由，允许自行选择做事的具体方法，并为最终的结果负责。起初，这种授权方式费时费力，但却十分值得。通过责任型授权，可以将杠杆的支点向右移动，提高杠杆的作用。</p><p>责任型授权要求双方就以下<strong>五个方面</strong>达成清晰、坦诚的共识，并作出承诺。</p><ol><li>预期结果。双方都要明确并且完全理解最终想要的结果。要以“结果”而不是以“方法”为中心。要有具体的日程，明确截止期限。</li><li>指导方针。确认适用的评估标准，避免成为指令型授权。但是一定要有明确的限制性规定。</li><li>可用资源。告诉他们可以使用哪些人力、财务、技术或者组织资源来取得缩预期的成果。</li><li>责任归属。制定业绩标准，并用这些标准来评估他们的成果。制定具体的时间表，说明何时提交业绩报告，何时进行评估。</li><li>明确奖惩。明确地告诉他们评估可能导致的结果，好的和不好的后果都要告诉他们。</li></ol><p>信任是促使人进步的最大动力，因为信任能够让人表现出自己最好的一面。</p><p>授权的大原则不变，权限却因人而异。对不够成熟的人，目标不必订得太高，指示要详尽，并且充分提供资源；监督考核则较频繁，奖惩也更直接。对成熟的人，可分配挑战性高的任务，精简指示，减少监督考核的次数，考评标准则较为抽象。</p><h1 id="付诸行动"><a href="#付诸行动" class="headerlink" title="付诸行动"></a>付诸行动</h1><ol><li>找出一项平时被你忽略的第二类事务。</li><li>画出一个时间管理矩阵，按照百分比将你的时间分配给每一类事务。然后以十五分钟为计时单位连续记录自己三天的活动状况。对照一下自己的计划，看是否有很大的出入。</li><li>将你认为可以授权给他人作的事情列在一张纸上，然后列出你认为可以做这些工作的人选或者通过培训可以胜任的工作人选。思考一下应该如何开始授权程序或者开展培训工作。</li><li>计划你的下周活动，你的计划应当能够体现你的人生目标和主导价值观。并在星期结束的时候进行总结。</li><li>承诺以后每周都制定一个周计划，并规定一个具体的时间专门做这件事情。</li><li>将目前使用的时间管理工具升级为第四代时间管理工具。</li><li>阅读附录二——高效能人士的一天。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;回答两个问题&quot;&gt;&lt;a href=&quot;#回答两个问题&quot; class=&quot;headerlink&quot; title=&quot;回答两个问题&quot;&gt;&lt;/a&gt;回答两个问题&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;在你目前的生活中，有哪些事情能够彻底改观你的个人生活，但是你一直没有去做？&lt;/li&gt;
&lt;li&gt;在
      
    
    </summary>
    
    
      <category term="高效能人士的七个习惯" scheme="https://lilei.pro/tags/%E9%AB%98%E6%95%88%E8%83%BD%E4%BA%BA%E5%A3%AB%E7%9A%84%E4%B8%83%E4%B8%AA%E4%B9%A0%E6%83%AF/"/>
    
  </entry>
  
  <entry>
    <title>《高效能人士的七个习惯》第四部分 自我提升和完善</title>
    <link href="https://lilei.pro/2019/04/07/Seven-Habbits-9/"/>
    <id>https://lilei.pro/2019/04/07/Seven-Habbits-9/</id>
    <published>2019-04-07T03:00:29.000Z</published>
    <updated>2019-06-08T08:49:30.912Z</updated>
    
    <content type="html"><![CDATA[<ul><li>习惯七：不断更新</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;习惯七：不断更新&lt;/li&gt;
&lt;/ul&gt;

      
    
    </summary>
    
    
      <category term="高效能人士的七个习惯" scheme="https://lilei.pro/tags/%E9%AB%98%E6%95%88%E8%83%BD%E4%BA%BA%E5%A3%AB%E7%9A%84%E4%B8%83%E4%B8%AA%E4%B9%A0%E6%83%AF/"/>
    
  </entry>
  
  <entry>
    <title>《高效能人士的七个习惯》第四部分 再论由内而外造就自己</title>
    <link href="https://lilei.pro/2019/04/07/Seven-Habbits-11/"/>
    <id>https://lilei.pro/2019/04/07/Seven-Habbits-11/</id>
    <published>2019-04-07T03:00:29.000Z</published>
    <updated>2019-06-08T08:51:39.699Z</updated>
    
    <content type="html"><![CDATA[<h1 id="利用刺激与回应之间的距离"><a href="#利用刺激与回应之间的距离" class="headerlink" title="利用刺激与回应之间的距离"></a>利用刺激与回应之间的距离</h1><p>上帝行事由内而外，尘世行事由外而内；尘世让世人摆脱贫穷，耶稣则先让世人摆脱内心的贫穷，然后由他们自己摆脱贫穷；尘世通过改变环境来造就人，耶稣则通过改变人来造就环境：尘世塑造人的行为，而耶稣改变人的本质。</p><p>刺激与回应之间存在一段距离，成长和幸福的关键就在于我们如何利用这段距离。</p><p>我们用新颖而有趣的方式利用刺激与回应之间的那段距离，思考自己如何变成了今天的自己以及这些过程如何决定了我们的世界观。</p><p>从一开始，我们就极力互相支持、鼓励和体谅，这让我们能够更进一步地探索彼此的内心世界，而我们之间的关系也得到滋养。</p><p>我们逐渐有了两项心照不宣的基本规则。一是“不要刨根问底”：无论哪个人露出了内心最脆弱的一面，另一人都不得追根究底，而是要尽力体谅对方，否则就显得太过咄咄逼人、霸道和刻板。二是在话题过于尖锐或痛苦的时候，我们就要及时打住，晚些时候或者等到第二天再说，直到当事人愿意再次开口。</p><p>我们发现，看似琐碎的小事，往往也源自铭心刻骨的情感经历，如果只看表面，而没有挖掘深层的敏感问题，无异于在践踏对方心中的圣土。</p><p>爱情保鲜的秘诀就是交谈，特别是讨论彼此的感受。</p><h1 id="代际传承"><a href="#代际传承" class="headerlink" title="代际传承"></a>代际传承</h1><p>我们的行为模式会对子女的生活产生难以置信的影响，就好像我们的父母影响了我们一样。他们不仅让我们了解了自己是什么样子的人，而且让我们知道自己通过努力可以成为什么样的人。</p><p>一个关系紧密、几代同堂的大家庭往往有一种超常的力量，能帮人们确认自我。让孩子们在这样的“部落”中找到自己的位置，时时感到被关怀。几代同堂的和睦家庭可能蕴含着最富有成效，回报最高，最令人满意的相互依赖关系，许多人都能感觉到这种关系的重要性。</p><h1 id="成为转型者"><a href="#成为转型者" class="headerlink" title="成为转型者"></a>成为转型者</h1><p>在你的家族中已经延续数代的趋势可以在你这里画一个句号。你是一个转型者，连接着过去和未来，你自身的变化可以影响到后世的许多人。</p><p>真正的变革是由内向外实现的，只是利用性格魅力的技巧，在态度和行为方面做些表面功夫根本不行，一定要从根本上改变那些决定了我们的人格和世界观的思想构造和行为模式才行。</p><p>再次引用艾默生（Emerson）的名言：“在我们的不懈努力下，事情变得可以迎刃而解，这并不是因为任务的性质发生了变化，而是因为我们的能力增强了。”</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;利用刺激与回应之间的距离&quot;&gt;&lt;a href=&quot;#利用刺激与回应之间的距离&quot; class=&quot;headerlink&quot; title=&quot;利用刺激与回应之间的距离&quot;&gt;&lt;/a&gt;利用刺激与回应之间的距离&lt;/h1&gt;&lt;p&gt;上帝行事由内而外，尘世行事由外而内；尘世让世人摆脱贫穷，耶稣
      
    
    </summary>
    
    
      <category term="高效能人士的七个习惯" scheme="https://lilei.pro/tags/%E9%AB%98%E6%95%88%E8%83%BD%E4%BA%BA%E5%A3%AB%E7%9A%84%E4%B8%83%E4%B8%AA%E4%B9%A0%E6%83%AF/"/>
    
  </entry>
  
  <entry>
    <title>《高效能人士的七个习惯》第三部分 公众领域的成功</title>
    <link href="https://lilei.pro/2019/04/07/Seven-Habbits-5/"/>
    <id>https://lilei.pro/2019/04/07/Seven-Habbits-5/</id>
    <published>2019-04-07T03:00:29.000Z</published>
    <updated>2019-06-08T08:41:53.526Z</updated>
    
    <content type="html"><![CDATA[<ul><li>习惯一：积极主动</li><li>习惯二：以终为始</li><li>习惯三：要事第一</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;习惯一：积极主动&lt;/li&gt;
&lt;li&gt;习惯二：以终为始&lt;/li&gt;
&lt;li&gt;习惯三：要事第一&lt;/li&gt;
&lt;/ul&gt;

      
    
    </summary>
    
    
      <category term="高效能人士的七个习惯" scheme="https://lilei.pro/tags/%E9%AB%98%E6%95%88%E8%83%BD%E4%BA%BA%E5%A3%AB%E7%9A%84%E4%B8%83%E4%B8%AA%E4%B9%A0%E6%83%AF/"/>
    
  </entry>
  
  <entry>
    <title>《高效能人士的七个习惯》第三部分 习惯四 双赢思维——人际领导的原则</title>
    <link href="https://lilei.pro/2019/04/07/Seven-Habbits-6/"/>
    <id>https://lilei.pro/2019/04/07/Seven-Habbits-6/</id>
    <published>2019-04-07T03:00:29.000Z</published>
    <updated>2019-06-08T08:44:12.949Z</updated>
    
    <content type="html"><![CDATA[<h1 id="人际交往的六个模式"><a href="#人际交往的六个模式" class="headerlink" title="人际交往的六个模式"></a>人际交往的六个模式</h1><ul><li>利人利己（双赢）</li><li>损人利己（赢/输）</li><li>舍己为人（输/赢）</li><li>两败俱伤（输/输）</li><li>独善其身（赢）</li><li>好聚好散（无交易）</li></ul><h2 id="利人利己（双赢）"><a href="#利人利己（双赢）" class="headerlink" title="利人利己（双赢）"></a>利人利己（双赢）</h2><p>双赢者把生活看作合作的舞台，而不是竞技场。但是大多数人都用两分法看问题，非强即弱，不胜则败。实际上这种想法是站不住脚的，它以力量和地位，而非原则为准绳。</p><h2 id="损人利己（赢-输）"><a href="#损人利己（赢-输）" class="headerlink" title="损人利己（赢/输）"></a>损人利己（赢/输）</h2><p>大多数人从小就被这种模式浸染。学校、赛场、法律把人分为敌对双方，不是你死，就是我活。诚然，在竞争激烈和信任薄弱的环境里，我们需要赢/输模式。但是竞争在生活中只居少数，我们不需要每天都和配偶、孩子、同事、邻居、朋友竞争。现实生活需要互相依赖，而不是单枪匹马，你的很多梦想都需要通过与其他人合作才能实现，而赢/输模式是这种合作最大的障碍。</p><h2 id="舍己为人（输-赢）"><a href="#舍己为人（输-赢）" class="headerlink" title="舍己为人（输/赢）"></a>舍己为人（输/赢）</h2><p>有些人则正好相反，他们信奉输/赢模式。</p><ul><li>“我认输，你赢了。”</li><li>“就这样吧，我听你的。”</li><li>“我是个和事佬，只要能息事宁人，我做什么都行。”</li></ul><p>这种人没有标准，没有要求，没有期望，也没有将来。他们通常喜欢取悦他人，喜欢满足他人的希望。别人的认同和接受能够给他们力量，他们没有勇气表达自己的感受和信念，总是服从别人的意志。</p><p>在谈判时，他们常常不是放弃就是退让，如果成为领导，也对下属嫉妒纵容。赢/输模式意味着做好人，然而<strong>好人不长命</strong>。</p><p>可是被压抑的情感并不会消失，累积到一定程度后，反而以更丑恶的方式爆发出来，有些精神疾病就是这样形成的。</p><p>赢/输模式和输/赢模式都存在人格缺陷。短期来看，赢/输模式的人较有效率，因为他们通常在能力和智力方面高人一筹，而输/赢模式自始至终都居于劣势。</p><h2 id="两败俱伤（输-输）"><a href="#两败俱伤（输-输）" class="headerlink" title="两败俱伤（输/输）"></a>两败俱伤（输/输）</h2><p>为了报复，不惜牺牲自身的利益，却不问是否值得；只有不够成熟、掌握不了人生方向的人，才会这样。</p><h2 id="独善其身（赢）"><a href="#独善其身（赢）" class="headerlink" title="独善其身（赢）"></a>独善其身（赢）</h2><p>当竞争和对抗意义不大的时候，独善其身的模式是多数人的处事方法，他们只在意自己的利益无损，别人的就留给他们自己去保护吧。</p><h2 id="哪一种最好"><a href="#哪一种最好" class="headerlink" title="哪一种最好"></a>哪一种最好</h2><p>长远来看，不是双赢，就一定是两败俱伤。</p><p>如果真的抱着双赢的态度，就会多与业主交流，听取意见，并有勇气表达自己的观点，直到结果让双方都满意。</p><h1 id="不能双赢就好聚好散"><a href="#不能双赢就好聚好散" class="headerlink" title="不能双赢就好聚好散"></a>不能双赢就好聚好散</h1><p>如果实在无法达成共识，实现双赢，就不如好聚好散（放弃交易）。</p><p>在相互依赖的环境里，任何非双赢的解决方案都不是最好的，因为他们终将对长远关系产生这样那样的不利影响，你必须慎重对待这些影响的代价。如果你无法同对方达成双赢的协议，那么最好选择放弃。</p><h1 id="双赢思维的五个要领"><a href="#双赢思维的五个要领" class="headerlink" title="双赢思维的五个要领"></a>双赢思维的五个要领</h1><p>双赢的原则是所有人际交往的基础，包括五个独立的方面：<strong>双赢品德</strong>是基础，接着建立起<strong>双赢关系</strong>，由此衍生出<strong>双赢协议</strong>，需要<strong>双赢体系（结构）</strong>作为培育环境，通过双赢的<strong>双赢过程</strong>来完成。</p><h2 id="双赢品德"><a href="#双赢品德" class="headerlink" title="双赢品德"></a>双赢品德</h2><p>双赢品德有三个基本特征。</p><ul><li>诚信。有明确的价值观，信守承诺。</li><li>成熟。成熟就是在表达自己的情感和信念的同时又能体谅他人的想法和感受的能力。</li><li>知足。即相信资源充足，人人有份。公众领域的成功的意思不是压倒旁人，而是通过成功的有效交往让所有的参与者获利，大家一起工作，一起探讨，一起实现单枪匹马无法完成的理想，这种成功要以知足心态为基础。</li></ul><h2 id="双赢关系"><a href="#双赢关系" class="headerlink" title="双赢关系"></a>双赢关系</h2><p>双赢的精髓就是信用，即情感账户。如果情感账户储蓄充足，信用就不再是问题，已有的投入让我们相知相敬，我们可以全神贯注于问题本身，而不是性格或者立场。</p><p>你对双赢的态度越坚持，越真诚，越积极，越投入，你对他人的影响力就越大。</p><h2 id="双赢协议"><a href="#双赢协议" class="headerlink" title="双赢协议"></a>双赢协议</h2><p>关系确立之后，就需要有协议来说明双赢的定义和方向，这种协议有时被称为“绩效协议”或“合作协议”，它让纵向交往转为水平交往，从属关系转为合作关系，上级监督转为自我监督。</p><p>在双赢协议中，对以下五个要素应该有明确的规定：</p><ul><li>预期结果：确认目标和时限，方法不计。</li><li>指导方针：确认实现目标的原则、方针和行为限度。</li><li>可用资源：包括人力、财力、技术或者组织资源。</li><li>任务考核：建立业绩评估标准和时间。</li><li>奖惩制度：根据任务考核确定奖惩的意义。</li></ul><h3 id="双赢的管理培训"><a href="#双赢的管理培训" class="headerlink" title="双赢的管理培训"></a>双赢的管理培训</h3><p>……培训之前，向受训者语言这次培训不会一帆风顺，阻力一定会存在。</p><h3 id="双赢绩效协议"><a href="#双赢绩效协议" class="headerlink" title="双赢绩效协议"></a>双赢绩效协议</h3><p>管理哲学家兼顾问彼得·德鲁克（Peter Drucker）建议，经理和员工之间可以用“给经理的信”这种形式来表述绩效协议的要点。首先就预期结果、指导方针和可用资源深入探讨，保证其与组织的总目标一致，然后写在“给经理的信”中，并提议下一次绩效计划和讨论的时间。</p><p>有四种管理者或家长都可以掌控的奖惩方法：<strong>金钱、精神、机会</strong>以及<strong>责任</strong>。</p><h2 id="双赢体系"><a href="#双赢体系" class="headerlink" title="双赢体系"></a>双赢体系</h2><p>双赢必须有相应体系支撑，包括培训、规划、交流、预算、信息、薪酬等，而且所有体系都要建立在双赢原则的基础上。</p><p>通常情况下，问题都源于体系，而不是人。再好的人置身于一个糟糕的体系中，也不会有好结果。</p><h2 id="双赢过程"><a href="#双赢过程" class="headerlink" title="双赢过程"></a>双赢过程</h2><p>我建议不同的人和机构采用以下四个步骤完成双赢过程：</p><ol><li>首先，从对方的角度看问题。真正理解对方的想法、需要和顾虑，有时甚至比对方理解的更为透彻。</li><li>其次，认清主要问题和顾虑（而非立场）。</li><li>第三，确定大家都能接受的结果。</li><li>第四，实现这种结果的各种可能途径。</li></ol><h1 id="付诸行动"><a href="#付诸行动" class="headerlink" title="付诸行动"></a>付诸行动</h1><ol><li>认真想一下你最近需要打交道的人或者想要解决的问题，在敢作敢为和善解人意间找到平衡点。</li><li>列出最能妨碍双赢模式的因素，设法清除在个人影响圈内的那一部分。</li><li>选择一个你想签订双赢协议的人际关系；尽量设身处地为对方着想，记下你认为对方会接受的结果；从自己的角度出发，列出对自己有利的结果；询问对方是否愿意就这个问题进行交流；一起商讨两全其美的对策。</li><li>列出你生活中最重要的三个人际关系，估算一下与这些人的情感账户余额，记下有助于增加存款的感情投资。</li><li>反省自己的交往模式，是赢/输式的吗？这种模式对你于他人的交往有什么影响？形成这种模式的主要原因是什么？这种模式对你有何助益？</li><li>找到一个双赢模式的榜样，也就是即使身处困境也不忘双赢的人，仔细观察并向他学习。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;人际交往的六个模式&quot;&gt;&lt;a href=&quot;#人际交往的六个模式&quot; class=&quot;headerlink&quot; title=&quot;人际交往的六个模式&quot;&gt;&lt;/a&gt;人际交往的六个模式&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;利人利己（双赢）&lt;/li&gt;
&lt;li&gt;损人利己（赢/输）&lt;/li&gt;
&lt;li
      
    
    </summary>
    
    
      <category term="高效能人士的七个习惯" scheme="https://lilei.pro/tags/%E9%AB%98%E6%95%88%E8%83%BD%E4%BA%BA%E5%A3%AB%E7%9A%84%E4%B8%83%E4%B8%AA%E4%B9%A0%E6%83%AF/"/>
    
  </entry>
  
  <entry>
    <title>《高效能人士的七个习惯》第四部分 习惯七 不断更新——平衡的自我更新的原则</title>
    <link href="https://lilei.pro/2019/04/07/Seven-Habbits-10/"/>
    <id>https://lilei.pro/2019/04/07/Seven-Habbits-10/</id>
    <published>2019-04-07T03:00:29.000Z</published>
    <updated>2019-06-08T08:50:16.213Z</updated>
    
    <content type="html"><![CDATA[<p>人生最值得的投资就是锻炼自己，因为生活与服务人群都得靠自己，这是最真贵的工具。</p><p>工作本身并不能带来经济上的安全感，具备良好的思考、学习、创造与适应能力，才能立于不败之地。拥有财富，并不代表经济独立，拥有创造财富的能力才真正可靠。</p><h1 id="自我提升和完善的四个层面"><a href="#自我提升和完善的四个层面" class="headerlink" title="自我提升和完善的四个层面"></a>自我提升和完善的四个层面</h1><p>习惯七就是个人产能。它保护并优化你所拥有的最重要的资产——你自己。它从四个层面更新你的天性，那就是：身体、精神、智力、社会/情感。</p><h2 id="身体层面"><a href="#身体层面" class="headerlink" title="身体层面"></a>身体层面</h2><p>身体层面指有效呵护我们的身体——健康饮食，充足休息以及定期锻炼。</p><p>锻炼属于第二类事务，但是由于不具紧迫性，所以很少人能坚持不懈，结果终有一天我们会发现自己陷入了第一类事务，不得不面对健康问题和危机，而原因正是之前对锻炼的忽视。</p><p>锻炼的所有好处几乎都产生于最后阶段。我想增强力量，就必须等到肌肉纤维撕裂，神经纤维感到疼痛才行，因为这时候自然机制才会予以过度补偿，纤维在 48 小时后会变得更加坚韧。</p><p>情感“肌肉”（比如耐心）也是一样。当对耐心的磨练超越过去的记录时，情感纤维就会断裂，自然机制就会予以过度补偿，下一次纤维就会更加坚韧。</p><p>刚开始时也许你并不喜欢锻炼，甚至还很厌恶，但是一定要积极一点，坚持下去。在你执行慢跑计划期间，即使清晨有雨，也不能放弃。而是要想太好了！下雨了！我可以在锻炼身体的同时磨练意志。</p><h2 id="精神层面"><a href="#精神层面" class="headerlink" title="精神层面"></a>精神层面</h2><p>精神层面的更新为你指引人生的方向，与习惯二密切相关。</p><p>有些人是通过欣赏优秀的文学或音乐作品来实现精神层面的更新，还有些人是通过与自然交流来达到同样目的。我的做法是每天认真阅读和思考《圣经》。</p><p>大自然会赐福给哪些沉浸在自然中的人。当你远离城市的喧嚣与混乱，尽情享受过大自然的和谐与韵律，再回到城市时会感到耳目一新，在一段时间内，没有什么能够干扰你或让你惊慌失措，直到外界的喧嚣混乱再次侵蚀到你内心的静谧和安详。</p><p>个人的使命宣言至关重要。一旦深刻理解了生活的中心和目标，我们就可以不断反思，持之以恒，在更新精神层面的过程中，就可以抱着坚定的信念，构想并实践每一天的活动。</p><p>仔细聆听，设法回头，检讨动机，把忧愁埋进沙子里。</p><h2 id="智力层面"><a href="#智力层面" class="headerlink" title="智力层面"></a>智力层面</h2><p>我们大多数人的智力发育和学习习惯都源自正规教育。但是，一旦脱离了学校的训导，许多人的头脑就会退化：不再认真读书，不再探索身外的新世界，不再用心思考，也不再写作，至少是不再重视写作，不再把它当作考验我们准确、扼要表达自己的能力的方式。相反，我们把时间花在了看电视（或者是网上冲浪）中。</p><p>电视的确让生活变得丰富多彩，但是，还有很多电视节目完全是在浪费我们的时间和头脑。</p><p>养成定期阅读优秀文学作品的习惯是拓展思维的最佳方式。可以从每个月读一本书开始，然后每两周读一本书，接着是每周读一本书。</p><p>磨砺心志的另一种有效方式是写作。如果能够在写信的时候与他人深入交流思想、感受和理念，而不是肤浅地停留在事物表面，也有助于我们提高思考、推理和获取他人理解的能力。</p><h2 id="社会-情感层面"><a href="#社会-情感层面" class="headerlink" title="社会/情感层面"></a>社会/情感层面</h2><p>社会/情感层面的更新并不像其它层面的更新那样需要花费大量的时间，我们可以在与他人的日常交往中完成这项工作，但练习还是必要的。习惯四、五、六是你在练习当中需要时时关注的地方，这些习惯成功的关键不是智力问题，而是情感问题，与我们个人的安全感密切相关。</p><h1 id="改变他人"><a href="#改变他人" class="headerlink" title="改变他人"></a>改变他人</h1><p>后来，当她又要恢复到旧有的行为模式时，生命垂危的骑士把她叫到病床前，唱起了那曲动人的《无法实现的梦》（The Impossible Dream）。他凝视她的双眼，轻声说：“永远不要忘记，你是杜尔西内娅”。</p><p>我们可以选择清晰而真实地反映出他人的形象，肯定他们的积极性和责任心，帮助他们改变行为模式，成为讲原则，懂判断，独立自主，有价值的个体。知足心态让我们意识到，反映他人的正面形象并不会贬低我们自己，而会使我们更强大，因为它增加了我们与其他积极主动者有效交往的机会。</p><p>歌德（Goethe）说：“以一个人的现有表现期许之，他不会有所长进。以他的潜能和应有成就期许之，他定能不负所望。”</p><h1 id="平衡更新"><a href="#平衡更新" class="headerlink" title="平衡更新"></a>平衡更新</h1><p>自我提升和完善的过程必须包括天性中的所有四个层面：身体、精神、智力、社会/情感。</p><p>企业力争上游的道理也是这样。谋利固然是企业经营的基本目的，但并非企业存在的唯一目的。犹如生命少不了食物，但人绝非为吃而活。</p><h1 id="更新中的统合综效"><a href="#更新中的统合综效" class="headerlink" title="更新中的统合综效"></a>更新中的统合综效</h1><p>人生的四个层面休戚相关：身体健全有助于心智发展，精神提升有益于人际关系的圆满。因此，平衡才能产生最佳的整体效果。</p><p>身体层面的自我更新等同于强化个人愿景（习惯一）。它帮助我们增强积极性、自我意识和独立意志，让我们知道自己是自由的，不需要被动地承受他人的行为后果，这也许是锻炼身体的最大好处。</p><p>精神层面的更新等同于强化自我领导（习惯二）。它帮助我们更好地按照想象和良知（而不只是回忆）行事，深入理解个人思维和价值观，确定核心的正确原则，明确自己在生活中的独特使命，改变思维和行为模式，以及坚持正确原则并利用个人的资源优势。</p><p>精神层面的更新让个人的生活变得更加丰富。</p><p>智力层面的更新等同于强化自我管理（习惯三）。它帮助你在做计划的时候确定第二类事务的重要活动，优先能够有效利用时间和精力的目标与活动，然后围绕这些组织并展开活动。不断接受教育帮助你巩固知识基础，增加选择范围。稳定的经济基础并非来自于工作，而是来自于<strong>个人的产能</strong>（思考、学习、创造、调整）。<strong>真正的经济独立指的不是家财万贯，而是拥有创造财富的能力</strong>，这是内在的。</p><p>“每天的个人领域的成功”（每天至少用一个小时实现身体、精神和智力层面的更新）是培养七个习惯的关键，完全在个人的影响圈范围内。</p><h1 id="螺旋式上升"><a href="#螺旋式上升" class="headerlink" title="螺旋式上升"></a>螺旋式上升</h1><p>良知是人类独特的天赋，帮助我们判断自己是否背离了正确的原则，然后引导我们向这些原则靠拢。</p><p>垃圾食品和缺乏锻炼会毁掉运动员的健康。同样，淫秽、粗俗或色情的东西会使我们的灵魂陷入黑暗之中，削弱我们的判断能力，不再关心是非对错（自然而神圣的良知），只在乎自己是否会被揭发“社会良知”。</p><p>哈马舍尔德（Dag Hammarskjold，前联合国秘书长）说过：把玩内心兽性的人，早晚会变成真正的野兽；整天弄虚作假的人，终将失去获得真理的权利；暴虐成性的人，头脑的判断力会日益减退。如果真的要保持花园整洁，就不能让杂草有立足之地。</p><p>要实现这个良性循环，就必须学习、坚持、实践，并沿着螺旋式上升的路线不断提高实践的层次。如果以为做到一项就已足够，完全是在自欺欺人。</p><h1 id="付诸行动"><a href="#付诸行动" class="headerlink" title="付诸行动"></a>付诸行动</h1><ol><li>写出有助于保持良好的身体状态，符合你的生活方式，能让你从中得到乐趣的活动清单。</li><li>挑选其中一项活动，把它列为你下周的个人活动的目标。</li><li>到一周结束时，评估自己的表现，如果没有实现目标，就思考一下原因，是因为你更看重一种更高尚的价值观，还是因为你未能遵循自己的价值观行事。</li><li>列出在精神和智力层面自我提升和完善的活动清单，在社会、情感层面希望改善的人际关系以及能依靠公众成功来提高效能的具体领域。在每个层面中挑选一项活动，列为本周目标，付诸实施并加以评估。</li><li>坚持每周写下所有四个层面的具体“磨刀”行动，付诸实施并评估自己的表现和效果。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;人生最值得的投资就是锻炼自己，因为生活与服务人群都得靠自己，这是最真贵的工具。&lt;/p&gt;
&lt;p&gt;工作本身并不能带来经济上的安全感，具备良好的思考、学习、创造与适应能力，才能立于不败之地。拥有财富，并不代表经济独立，拥有创造财富的能力才真正可靠。&lt;/p&gt;
&lt;h1 id=&quot;自我提
      
    
    </summary>
    
    
      <category term="高效能人士的七个习惯" scheme="https://lilei.pro/tags/%E9%AB%98%E6%95%88%E8%83%BD%E4%BA%BA%E5%A3%AB%E7%9A%84%E4%B8%83%E4%B8%AA%E4%B9%A0%E6%83%AF/"/>
    
  </entry>
  
  <entry>
    <title>《高效能人士的七个习惯》第二部分 习惯二 以终为始</title>
    <link href="https://lilei.pro/2019/04/07/Seven-Habbits-3/"/>
    <id>https://lilei.pro/2019/04/07/Seven-Habbits-3/</id>
    <published>2019-04-07T02:58:21.000Z</published>
    <updated>2019-04-07T02:59:05.827Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第四章-习惯二-以终为始——自我领导的原则"><a href="#第四章-习惯二-以终为始——自我领导的原则" class="headerlink" title="第四章 习惯二 以终为始——自我领导的原则"></a>第四章 习惯二 以终为始——自我领导的原则</h1><h2 id="设想一段悼词"><a href="#设想一段悼词" class="headerlink" title="设想一段悼词"></a>设想一段悼词</h2><p>请找个僻静的角落，抛开一切杂念，敞开心扉，跟着我走过这段心灵之旅。</p><p>假设你正在前往殡仪馆的路上，要去参加一位至亲的葬礼。抵达之后，居然发现亲朋好友齐聚一堂，是为了向你告别。姑且假定这时亲族代表、友人、同事或社团伙伴，即将上台追述你的生平。请你认真想一想</p><ul><li>你希望人们对你以及你的生活有什么样的评价？</li><li>你希望他们怎样评价你的人格？</li><li>你希望他们回忆起你的哪些成就和贡献？</li><li>你希望对周围人的生活施加过什么样的影响？</li></ul><h2 id="以终为始的定义"><a href="#以终为始的定义" class="headerlink" title="以终为始的定义"></a>以终为始的定义</h2><p>以你的人生目标作为衡量一切的标准，你的一言一行、一举一动，无论发生在何时，都必须遵循这一原则，即由个人最忠实的期许或价值观来决定一切。</p><p>你希望在盖棺定论时获得的评价，才是你心目中真正渴望的成功。</p><h2 id="任何事物都需要两次创造"><a href="#任何事物都需要两次创造" class="headerlink" title="任何事物都需要两次创造"></a>任何事物都需要两次创造</h2><h3 id="第一次创造"><a href="#第一次创造" class="headerlink" title="第一次创造"></a>第一次创造</h3><p>在头脑中构思，即智力上的第一次创造（Mental/First Creation）</p><h3 id="第二次创造"><a href="#第二次创造" class="headerlink" title="第二次创造"></a>第二次创造</h3><p>付诸实践，体力上的第二次创造（Physical/Second Creation）</p><h2 id="主动设计还是被动接受"><a href="#主动设计还是被动接受" class="headerlink" title="主动设计还是被动接受"></a>主动设计还是被动接受</h2><p>“任何事物都是两次创造而成”是个客观原则，但“第一次的创造”未必都是有意的设计。有些人自我意识薄弱，不愿主动设计自己的生活，结果就让影响圈外的人或事控制了自己。这种人的人生方向大多源自个人喜好，不符合客观原则，之所以会被接收，是因为某些人内心脆弱，依赖心理过重，渴望被接纳和获得归属感，向往他人的关怀和爱护，而且一定要别人来肯定自己价值和重要性。</p><h2 id="领导与管理：两次创造"><a href="#领导与管理：两次创造" class="headerlink" title="领导与管理：两次创造"></a>领导与管理：两次创造</h2><p>“以终为始”的另一个原则基础是自我领导，但领导（Leadershi）不同于管理（Management）。领导是第一次的创造，必需先于管理；管理是第二次的创造。</p><p>领导与管理就好比思想与行为。管理关注基层，思考的是“怎样才能有效地把事情做好”；领导关注高层，思考的是“我想成就的是什么事业”。领导是“做正确的事”，管理是“正确地做事”。管理是有效地顺着成功的梯子往上爬，领导则判断这个梯子是否搭在正确的墙上。</p><p>个人生活中的领导意识更为匮乏，很多人连自己的价值观都没有搞清楚，就忙于提高效率，制定目标或完成任务。</p><h2 id="改写人生剧本：成为自己的第一次创造者"><a href="#改写人生剧本：成为自己的第一次创造者" class="headerlink" title="改写人生剧本：成为自己的第一次创造者"></a>改写人生剧本：成为自己的第一次创造者</h2><ul><li>自我意识</li><li>想象力：在心里演练哪些尚未释放的潜能</li><li>良知：遵循自然法则或原则</li></ul><h2 id="个人使命宣言"><a href="#个人使命宣言" class="headerlink" title="个人使命宣言"></a>个人使命宣言</h2><p>以终为始的最有效方法，就是撰写一份个人使命宣言，即人生哲学或基本信念。</p><ul><li>想成为怎样的人（品德）</li><li>想成就什么样的事业（贡献和成就）</li><li>为此奠基的价值观和原则</li></ul><p>对于个人来说，基于正确原则的个人使命宣言也同样是评价一切的标准，成为我们以不变应万变的力量源泉。</p><h2 id="核心区"><a href="#核心区" class="headerlink" title="核心区"></a>核心区</h2><p>制定个人使命宣言必须从影响圈的核心开始，基本的思维定式就在这里，即我们用来观察世界的“透镜”。当我们专注于这个核心并取得丰硕成果时，影响圈就会被扩大，这是最高水平的产能，会提升我们在各生活领域的效能。</p><ul><li>安全感：代表价值观、认同、情感的归属、自尊自重与是否拥有个人的基本能力。</li><li>人生方向：时“地图”的和内心的准绳，人类一次为解释外界事物的理据以及决策与行为的原则和内在标准。</li><li>智慧：是人类对生命的认知、对平衡的感知和对事物间联系的理解，包括判断力、洞察力和理解力，是这些能力的统一体。</li><li>力量：采取行动、达成目标的能力，是做出选择的关键性力量，也包括培育出更有效的习惯以替代旧习惯的能力。</li></ul><h2 id="以原则为中心"><a href="#以原则为中心" class="headerlink" title="以原则为中心"></a>以原则为中心</h2><p>以原则为中心的人会保持冷静和客观，不受情绪或其它因素的干扰，纵观全局——工作需要、家庭需要、其他相关因素以及不同决定的可能后果，深思熟虑后才做出正确选择。</p><h2 id="善用整个大脑"><a href="#善用整个大脑" class="headerlink" title="善用整个大脑"></a>善用整个大脑</h2><p>左脑负责逻辑思考与语言能力，右脑执掌创造力与直觉。左脑处理文字，右脑擅长图像；左脑重局部与分析，右脑重整体与整合。</p><p><strong>拓宽思路</strong>和<strong>心灵演练</strong>是开发右脑的两个途径。</p><h3 id="拓宽思路"><a href="#拓宽思路" class="headerlink" title="拓宽思路"></a>拓宽思路</h3><p>有时，人会因为意外打击而在瞬间从左脑思维变成右脑思维，比如亲人离世、罹患重病、经济危机或陷入困境的时候，我们会扪心自问：什么才是最重要的？我们究竟在追求什么？</p><p>积极主动者不需要这种刺激，就能拓宽思路、自觉转换思维定式。比如设想自己的葬礼，或者银婚及金婚纪念日的情景，邀请你的配偶与你一起来畅想，两人共同的理想婚姻关系应当怎样，怎样通过日常活动来付诸实施？</p><p>你也可以设想自己退休后的情形，那时自己有怎样的贡献和成就，退休后又有什么计划，是否想二次创业？</p><h3 id="心灵演练"><a href="#心灵演练" class="headerlink" title="心灵演练"></a>心灵演练</h3><p>心灵演练与确认施行自我领导不是只要撰写一个使命宣言就完成了，他是一个确立愿景和价值观，并让自己的生活遵从这些重要原则的过程。右脑会在这个过程中帮助你进行心灵演练（Visualization），并对正确行为加以确认（Affirmation）。这会让你的生活更符合使命宣言。</p><p>确认应该包括五个基本要素：个人、积极、果断、可视、情感。例如“发现子女行为不当时，我（个人）能以智慧、爱心、坚定的立场与自制力（积极）及时应对（果断），结果让我深感欣慰（情感）。”</p><h2 id="确定角色和目标"><a href="#确定角色和目标" class="headerlink" title="确定角色和目标"></a>确定角色和目标</h2><p>在撰写使命宣言时，不妨分开不同的角色领域，一一订立目标。事业、生活、政治、信仰等。</p><h2 id="家庭的使命宣言"><a href="#家庭的使命宣言" class="headerlink" title="家庭的使命宣言"></a>家庭的使命宣言</h2><p>每个家庭都有共同的价值观及理念，作为生活的重心，撰写家庭使命宣言正可以凸显这个生活中心，时全家人团结在共同的目标下。</p><h2 id="组织的使命宣言"><a href="#组织的使命宣言" class="headerlink" title="组织的使命宣言"></a>组织的使命宣言</h2><p>一个真正反映每隔成员的共同愿景和价值观的使命宣言，能调动他们的创造力和奉献精神，使他们不再需要旁人的指导、监督和批评，因为他们已经接受了不变的核心原则，接受了企业为之奋斗的共同目标。</p><h2 id="付诸行动"><a href="#付诸行动" class="headerlink" title="付诸行动"></a>付诸行动</h2><ol><li>把你参加葬礼心灵演练时的心得列表整理。</li><li>根据目前理解，写下自己的人生角色。检讨你对目前扮演的角色和自己的生活是否满意。</li><li>每天抽空撰写个人使命宣言。</li><li>阅读各种生活中心，看你的行为符合其中哪种类型？他们是否让你的日常行为有了一定依据？你是否满意？</li><li>为编写使命宣言而手机笔记、引言、想法以及可能有用的各种资料。</li><li>设想近期内可能会从事的某个项目，用心灵演练的原则，写下你希望获得的结果与应采取的步骤。</li><li>向家人呢或同事讲述本章的精华，并建议大家共同拟定家庭或团队的使命宣言。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第四章-习惯二-以终为始——自我领导的原则&quot;&gt;&lt;a href=&quot;#第四章-习惯二-以终为始——自我领导的原则&quot; class=&quot;headerlink&quot; title=&quot;第四章 习惯二 以终为始——自我领导的原则&quot;&gt;&lt;/a&gt;第四章 习惯二 以终为始——自我领导的原则&lt;/
      
    
    </summary>
    
    
      <category term="高效能人士的七个习惯" scheme="https://lilei.pro/tags/%E9%AB%98%E6%95%88%E8%83%BD%E4%BA%BA%E5%A3%AB%E7%9A%84%E4%B8%83%E4%B8%AA%E4%B9%A0%E6%83%AF/"/>
    
  </entry>
  
  <entry>
    <title>《高效能人士的七个习惯》第二部分 习惯一 积极主动</title>
    <link href="https://lilei.pro/2019/04/07/Seven-Habbits-2/"/>
    <id>https://lilei.pro/2019/04/07/Seven-Habbits-2/</id>
    <published>2019-04-07T02:56:26.000Z</published>
    <updated>2019-04-07T02:57:22.680Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第三章-习惯一-积极主动——个人愿景的原则"><a href="#第三章-习惯一-积极主动——个人愿景的原则" class="headerlink" title="第三章 习惯一 积极主动——个人愿景的原则"></a>第三章 习惯一 积极主动——个人愿景的原则</h1><h2 id="自我思维（Self-paradigm）"><a href="#自我思维（Self-paradigm）" class="headerlink" title="自我思维（Self-paradigm）"></a>自我思维（Self-paradigm）</h2><blockquote><p>行有不得，反求诸己</p></blockquote><p>试着跳出自我的框框，把意识转移到屋子的某个角落，然后用心客观地审视自己，站在旁观泽的角度观察自己，描述现在的心情与精神状态，思考你头脑的工作方式，它是否反应灵敏。</p><h2 id="社会之镜（Social-Mirro）"><a href="#社会之镜（Social-Mirro）" class="headerlink" title="社会之镜（Social Mirro）"></a>社会之镜（Social Mirro）</h2><p>社会观点认为，环境与条件对我们起着决定性的作用。我们不否认条件作用的影响巨大，但并不等于承认它凌驾于一切之上，甚至可以决定我们的命运。根据这种看法绘制的社会地图可以分为三种，也被称作揭示人性的三种“决定论”：</p><ol><li>基因决定论（Genetic Determinism）：人的本性由DNA决定，自先祖遗传下来。</li><li>心理决定论（Psychic Determinism）：人的本性由父母的言行决定，即原生家庭论。</li><li>环境决定论（Environmental Determinism）：环境决定人的本性，如周遭的人与事，例如老板、配偶、子女乃至自然环境和经济环境。</li></ol><p>这三种社会地图都已“刺激-回应”理论为基础，来源于巴甫洛夫所做的关于狗的实验，基本观点认为我们会受条件左右，以某一特定方式回应某一特定刺激。</p><h2 id="选择的自由"><a href="#选择的自由" class="headerlink" title="选择的自由"></a>选择的自由</h2><p>人类的自我意识是独立的，能够超脱肉体的束缚，以旁观者的身份审视自己的遭遇。他可以决定外界刺激对自己的影响程度，或者说，在遭遇（刺激）与对遭遇的回应之间，他有选择回应方式的自由和能力。</p><p>即，在刺激与回应之间，人类有选择的自由。这便是“积极主动”的价值。</p><p>责任感（Responsibility）从构词法来说是能够回应（Response-able）的意思，即选择回应的能力，人类应当有营造有利的外在环境的积极性和责任感。积极主动是人的天性，即使生活受到了外界条件的制约，那也是因为我们有意或无意地选择了被外界条件控制，这种选择成为消极被动（Reactive）。</p><h2 id="除非你愿意，否则没人能伤害你"><a href="#除非你愿意，否则没人能伤害你" class="headerlink" title="除非你愿意，否则没人能伤害你"></a>除非你愿意，否则没人能伤害你</h2><p>伤害我们的并非悲惨遭遇本身，而是我们对于悲惨遭遇的回应。尽管这些事的确会让人身心受创或者经济受损，但是品德和本性完全可以不受影响。事实上月痛苦的经历，越能磨练意志，开发潜能，提升自如应对困境的能力，甚至还可能感召他人争取同样的自由。</p><h2 id="聆听自己的语言"><a href="#聆听自己的语言" class="headerlink" title="聆听自己的语言"></a>聆听自己的语言</h2><p>消极被动的人，言语中往往会暴露出推卸责任的意图，例如：</p><ul><li>“我就是这样做事的。”天生如此，爱看不看。</li><li>“他把我气疯了！”责任不在我，是外界因素控制了我的情绪。</li><li>“我根本没时间做。”外界因素——时间扼住了我的咽喉。</li><li>“我只能这样做。”迫于环境（外界因素）</li></ul><p>推卸责任的言语往往会强化宿命论。说者一遍遍被自己洗脑，变得更加自怨自艾，怪罪别人和环境，甚至把星座也扯了进去。</p><h2 id="关注圈与影响圈"><a href="#关注圈与影响圈" class="headerlink" title="关注圈与影响圈"></a>关注圈与影响圈</h2><p>积极主动的人专注于“影响圈”，他们专心做自己力所能及的事，他们的能量是积极的，能够使影响圈不断扩大、扩张和成长。只要我们的焦点在关注权，就等于是允许自己受制于外界条件，自然就不会主动采取必要措施来推动积极变化。</p><p>一个人的关注圈可能会小于影响圈，这说明此人由于自己的缘故，在情感方面缺乏远见和判断力，消极而又自私，全部精力都放在关注圈内。</p><h2 id="三种问题"><a href="#三种问题" class="headerlink" title="三种问题"></a>三种问题</h2><p>可直接控制/可间接控制/无法控制</p><blockquote><p>上帝啊，请赐我勇气，改变那些我能改变的；请赐我胸襟，接收那些我无法改变的；请赐我慧眼，能够分辨这两者。</p></blockquote><h2 id="“如果”和“我可以”"><a href="#“如果”和“我可以”" class="headerlink" title="“如果”和“我可以”"></a>“如果”和“我可以”</h2><p>与关注圈相关的语句多半带有假设性质，“如果”；与影响圈相关的语句多半体现了这个人的品德修养，“我可以”。</p><h2 id="对待错误的态度"><a href="#对待错误的态度" class="headerlink" title="对待错误的态度"></a>对待错误的态度</h2><p>马上承认， 改正并从中吸取教训，这样才能反败为胜。如果不肯承认而后改正，也不丛中吸取教训，等于错上加错，自欺欺人。</p><h2 id="两种直接掌控人生的途径"><a href="#两种直接掌控人生的途径" class="headerlink" title="两种直接掌控人生的途径"></a>两种直接掌控人生的途径</h2><p>一、作出承诺，信守诺言<br>二、确立目标，付诸实践</p><h2 id="付诸行动"><a href="#付诸行动" class="headerlink" title="付诸行动"></a>付诸行动</h2><ol><li>用一整天的时间，听自己和周围的人说话，注意看是否常有“但愿”、“我办不到”、“我不得不”等消极语言出现</li><li>想一想近期是否会发生一些按照以前的习惯拟会消极对待的事情？他是否在你的影响圈之内？你应如何以积极主动的原则应对？在心里演练一下积极的应对方式；提醒自己刺激与回应之间存在空间；想自己承诺，要抓住选择回应的自由</li><li>找出一个工作或生活中令你备感挫折的问题，判断它属于直接控制、间接控制还是无法控制的问题，然后在影响圈内找出解决问题的第一个步骤，并付诸行动</li><li>实行积极主动的原则30天，观察自己的影响圈有何变化</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第三章-习惯一-积极主动——个人愿景的原则&quot;&gt;&lt;a href=&quot;#第三章-习惯一-积极主动——个人愿景的原则&quot; class=&quot;headerlink&quot; title=&quot;第三章 习惯一 积极主动——个人愿景的原则&quot;&gt;&lt;/a&gt;第三章 习惯一 积极主动——个人愿景的原则&lt;/
      
    
    </summary>
    
    
      <category term="高效能人士的七个习惯" scheme="https://lilei.pro/tags/%E9%AB%98%E6%95%88%E8%83%BD%E4%BA%BA%E5%A3%AB%E7%9A%84%E4%B8%83%E4%B8%AA%E4%B9%A0%E6%83%AF/"/>
    
  </entry>
  
  <entry>
    <title>《高效能人士的七个习惯》第一部分 重新探索自我</title>
    <link href="https://lilei.pro/2019/04/07/Seven-Habbits-1/"/>
    <id>https://lilei.pro/2019/04/07/Seven-Habbits-1/</id>
    <published>2019-04-07T02:54:17.000Z</published>
    <updated>2019-04-07T02:55:43.372Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章-由内而外全面造就自己"><a href="#第一章-由内而外全面造就自己" class="headerlink" title="第一章 由内而外全面造就自己"></a>第一章 由内而外全面造就自己</h1><h2 id="本书要阐述的内容"><a href="#本书要阐述的内容" class="headerlink" title="本书要阐述的内容"></a>本书要阐述的内容</h2><p>以原则为中心，以品德为基础，要求“由内而外”地实现个人效能和人际效能。</p><p>由内而外的观点认为个人领域的成功必需先于公众领域的成功；只有先信守对自己的承诺，才能信守对他人的承诺。由内而外是一个持续的更新过程，以主宰人类成长和进步的自然法则为基础，是螺旋向上的，它让我们不断进步，直到实现独立自强与有效的互赖。</p><h1 id="第二章-七个习惯概论"><a href="#第二章-七个习惯概论" class="headerlink" title="第二章 七个习惯概论"></a>第二章 七个习惯概论</h1><h2 id="习惯的引力"><a href="#习惯的引力" class="headerlink" title="习惯的引力"></a>习惯的引力</h2><p>宇宙飞船必须先摆脱强大的地球引力，为此在刚发射的几分钟，即刚升空时的几公里消耗的能量比之后几天几十万公里旅程消耗的能量还要多。习惯也一样有极大的引力，只是许多人不加注意或不肯承认罢了。要根除根深蒂固的不良习惯，仅有一点点毅力，只作一点点改变是不够的。</p><h2 id="习惯的定义"><a href="#习惯的定义" class="headerlink" title="习惯的定义"></a>习惯的定义</h2><p>习惯是知识、技巧、意愿相互交织的结果。</p><ul><li>知识：理论范畴，指点“做什么”及“为何做”</li><li>技巧：告诉“如何做”</li><li>意愿：促使“想要做”</li></ul><h2 id="成熟模式图"><a href="#成熟模式图" class="headerlink" title="成熟模式图"></a>成熟模式图</h2><ul><li>依赖：以“你”为核心</li><li>独立：以“我”为核心</li><li>互赖：以“我们”为核心</li></ul><p>只重独立并不适于互赖的现实生活。只知独立却不懂互赖的人只能称为独个的“生产标兵”，却与“优秀领导”或“最佳合作者”之类的称呼无缘，也不会拥有美满的家庭、婚姻或集体生活。</p><p>互赖是一个更为成熟和高级的概念。生理上互赖的人，可以自力更生，但也明白合作会比单干更有成效；情感上互赖的人，能充分认识自己的价值，但也知道爱心、关怀以及付出的必要性；智力上互赖的人懂得取人之长，补己之短。</p><h2 id="七个习惯"><a href="#七个习惯" class="headerlink" title="七个习惯"></a>七个习惯</h2><h3 id="依赖-gt-独立，个人领域的成功"><a href="#依赖-gt-独立，个人领域的成功" class="headerlink" title="依赖 -&gt; 独立，个人领域的成功"></a>依赖 -&gt; 独立，个人领域的成功</h3><ul><li>积极主动</li><li>以终为始</li><li>要事第一</li></ul><h3 id="独立-gt-互赖，公众领域的成功"><a href="#独立-gt-互赖，公众领域的成功" class="headerlink" title="独立 -&gt; 互赖，公众领域的成功"></a>独立 -&gt; 互赖，公众领域的成功</h3><ul><li>双赢思维</li><li>知彼解己</li><li>统合综效</li></ul><h3 id="螺旋上升"><a href="#螺旋上升" class="headerlink" title="螺旋上升"></a>螺旋上升</h3><ul><li>不断更新</li></ul><h2 id="什么是高效能"><a href="#什么是高效能" class="headerlink" title="什么是高效能"></a>什么是高效能</h2><p><strong>产出与产能平衡的原则是效能的精髓</strong>，放之四海而皆准，不管你是否遵从，它都会存在。它是指导人生的灯塔，是效能的定义和模式，是本书中七个习惯的基础。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第一章-由内而外全面造就自己&quot;&gt;&lt;a href=&quot;#第一章-由内而外全面造就自己&quot; class=&quot;headerlink&quot; title=&quot;第一章 由内而外全面造就自己&quot;&gt;&lt;/a&gt;第一章 由内而外全面造就自己&lt;/h1&gt;&lt;h2 id=&quot;本书要阐述的内容&quot;&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="高效能人士的七个习惯" scheme="https://lilei.pro/tags/%E9%AB%98%E6%95%88%E8%83%BD%E4%BA%BA%E5%A3%AB%E7%9A%84%E4%B8%83%E4%B8%AA%E4%B9%A0%E6%83%AF/"/>
    
  </entry>
  
</feed>
