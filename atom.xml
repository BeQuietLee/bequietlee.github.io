<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>柘个角落</title>
  <icon>https://www.gravatar.com/avatar/bd80dd1283cd0ce8323c050b40cb6f38</icon>
  <subtitle>IF YOU WANT SOMETHING, GO GET IT. PERIOD.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lilei.pro/"/>
  <updated>2019-04-07T03:02:13.085Z</updated>
  <id>https://lilei.pro/</id>
  
  <author>
    <name>Li Lei</name>
    <email>bequietlee@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《高效能人士的七个习惯》第二部分 习惯三 要事第一</title>
    <link href="https://lilei.pro/2019/04/07/Seven-Habbits-4/"/>
    <id>https://lilei.pro/2019/04/07/Seven-Habbits-4/</id>
    <published>2019-04-07T03:00:29.000Z</published>
    <updated>2019-04-07T03:02:13.085Z</updated>
    
    <content type="html"><![CDATA[<p># </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;# &lt;/p&gt;

      
    
    </summary>
    
    
      <category term="高效能人士的七个习惯" scheme="https://lilei.pro/tags/%E9%AB%98%E6%95%88%E8%83%BD%E4%BA%BA%E5%A3%AB%E7%9A%84%E4%B8%83%E4%B8%AA%E4%B9%A0%E6%83%AF/"/>
    
  </entry>
  
  <entry>
    <title>《高效能人士的七个习惯》第二部分 习惯二 以终为始</title>
    <link href="https://lilei.pro/2019/04/07/Seven-Habbits-3/"/>
    <id>https://lilei.pro/2019/04/07/Seven-Habbits-3/</id>
    <published>2019-04-07T02:58:21.000Z</published>
    <updated>2019-04-07T02:59:05.827Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第四章-习惯二-以终为始——自我领导的原则"><a href="#第四章-习惯二-以终为始——自我领导的原则" class="headerlink" title="第四章 习惯二 以终为始——自我领导的原则"></a>第四章 习惯二 以终为始——自我领导的原则</h1><h2 id="设想一段悼词"><a href="#设想一段悼词" class="headerlink" title="设想一段悼词"></a>设想一段悼词</h2><p>请找个僻静的角落，抛开一切杂念，敞开心扉，跟着我走过这段心灵之旅。</p><p>假设你正在前往殡仪馆的路上，要去参加一位至亲的葬礼。抵达之后，居然发现亲朋好友齐聚一堂，是为了向你告别。姑且假定这时亲族代表、友人、同事或社团伙伴，即将上台追述你的生平。请你认真想一想</p><ul><li>你希望人们对你以及你的生活有什么样的评价？</li><li>你希望他们怎样评价你的人格？</li><li>你希望他们回忆起你的哪些成就和贡献？</li><li>你希望对周围人的生活施加过什么样的影响？</li></ul><h2 id="以终为始的定义"><a href="#以终为始的定义" class="headerlink" title="以终为始的定义"></a>以终为始的定义</h2><p>以你的人生目标作为衡量一切的标准，你的一言一行、一举一动，无论发生在何时，都必须遵循这一原则，即由个人最忠实的期许或价值观来决定一切。</p><p>你希望在盖棺定论时获得的评价，才是你心目中真正渴望的成功。</p><h2 id="任何事物都需要两次创造"><a href="#任何事物都需要两次创造" class="headerlink" title="任何事物都需要两次创造"></a>任何事物都需要两次创造</h2><h3 id="第一次创造"><a href="#第一次创造" class="headerlink" title="第一次创造"></a>第一次创造</h3><p>在头脑中构思，即智力上的第一次创造（Mental/First Creation）</p><h3 id="第二次创造"><a href="#第二次创造" class="headerlink" title="第二次创造"></a>第二次创造</h3><p>付诸实践，体力上的第二次创造（Physical/Second Creation）</p><h2 id="主动设计还是被动接受"><a href="#主动设计还是被动接受" class="headerlink" title="主动设计还是被动接受"></a>主动设计还是被动接受</h2><p>“任何事物都是两次创造而成”是个客观原则，但“第一次的创造”未必都是有意的设计。有些人自我意识薄弱，不愿主动设计自己的生活，结果就让影响圈外的人或事控制了自己。这种人的人生方向大多源自个人喜好，不符合客观原则，之所以会被接收，是因为某些人内心脆弱，依赖心理过重，渴望被接纳和获得归属感，向往他人的关怀和爱护，而且一定要别人来肯定自己价值和重要性。</p><h2 id="领导与管理：两次创造"><a href="#领导与管理：两次创造" class="headerlink" title="领导与管理：两次创造"></a>领导与管理：两次创造</h2><p>“以终为始”的另一个原则基础是自我领导，但领导（Leadershi）不同于管理（Management）。领导是第一次的创造，必需先于管理；管理是第二次的创造。</p><p>领导与管理就好比思想与行为。管理关注基层，思考的是“怎样才能有效地把事情做好”；领导关注高层，思考的是“我想成就的是什么事业”。领导是“做正确的事”，管理是“正确地做事”。管理是有效地顺着成功的梯子往上爬，领导则判断这个梯子是否搭在正确的墙上。</p><p>个人生活中的领导意识更为匮乏，很多人连自己的价值观都没有搞清楚，就忙于提高效率，制定目标或完成任务。</p><h2 id="改写人生剧本：成为自己的第一次创造者"><a href="#改写人生剧本：成为自己的第一次创造者" class="headerlink" title="改写人生剧本：成为自己的第一次创造者"></a>改写人生剧本：成为自己的第一次创造者</h2><ul><li>自我意识</li><li>想象力：在心里演练哪些尚未释放的潜能</li><li>良知：遵循自然法则或原则</li></ul><h2 id="个人使命宣言"><a href="#个人使命宣言" class="headerlink" title="个人使命宣言"></a>个人使命宣言</h2><p>以终为始的最有效方法，就是撰写一份个人使命宣言，即人生哲学或基本信念。</p><ul><li>想成为怎样的人（品德）</li><li>想成就什么样的事业（贡献和成就）</li><li>为此奠基的价值观和原则</li></ul><p>对于个人来说，基于正确原则的个人使命宣言也同样是评价一切的标准，成为我们以不变应万变的力量源泉。</p><h2 id="核心区"><a href="#核心区" class="headerlink" title="核心区"></a>核心区</h2><p>制定个人使命宣言必须从影响圈的核心开始，基本的思维定式就在这里，即我们用来观察世界的“透镜”。当我们专注于这个核心并取得丰硕成果时，影响圈就会被扩大，这是最高水平的产能，会提升我们在各生活领域的效能。</p><ul><li>安全感：代表价值观、认同、情感的归属、自尊自重与是否拥有个人的基本能力。</li><li>人生方向：时“地图”的和内心的准绳，人类一次为解释外界事物的理据以及决策与行为的原则和内在标准。</li><li>智慧：是人类对生命的认知、对平衡的感知和对事物间联系的理解，包括判断力、洞察力和理解力，是这些能力的统一体。</li><li>力量：采取行动、达成目标的能力，是做出选择的关键性力量，也包括培育出更有效的习惯以替代旧习惯的能力。</li></ul><h2 id="以原则为中心"><a href="#以原则为中心" class="headerlink" title="以原则为中心"></a>以原则为中心</h2><p>以原则为中心的人会保持冷静和客观，不受情绪或其它因素的干扰，纵观全局——工作需要、家庭需要、其他相关因素以及不同决定的可能后果，深思熟虑后才做出正确选择。</p><h2 id="善用整个大脑"><a href="#善用整个大脑" class="headerlink" title="善用整个大脑"></a>善用整个大脑</h2><p>左脑负责逻辑思考与语言能力，右脑执掌创造力与直觉。左脑处理文字，右脑擅长图像；左脑重局部与分析，右脑重整体与整合。</p><p><strong>拓宽思路</strong>和<strong>心灵演练</strong>是开发右脑的两个途径。</p><h3 id="拓宽思路"><a href="#拓宽思路" class="headerlink" title="拓宽思路"></a>拓宽思路</h3><p>有时，人会因为意外打击而在瞬间从左脑思维变成右脑思维，比如亲人离世、罹患重病、经济危机或陷入困境的时候，我们会扪心自问：什么才是最重要的？我们究竟在追求什么？</p><p>积极主动者不需要这种刺激，就能拓宽思路、自觉转换思维定式。比如设想自己的葬礼，或者银婚及金婚纪念日的情景，邀请你的配偶与你一起来畅想，两人共同的理想婚姻关系应当怎样，怎样通过日常活动来付诸实施？</p><p>你也可以设想自己退休后的情形，那时自己有怎样的贡献和成就，退休后又有什么计划，是否想二次创业？</p><h3 id="心灵演练"><a href="#心灵演练" class="headerlink" title="心灵演练"></a>心灵演练</h3><p>心灵演练与确认施行自我领导不是只要撰写一个使命宣言就完成了，他是一个确立愿景和价值观，并让自己的生活遵从这些重要原则的过程。右脑会在这个过程中帮助你进行心灵演练（Visualization），并对正确行为加以确认（Affirmation）。这会让你的生活更符合使命宣言。</p><p>确认应该包括五个基本要素：个人、积极、果断、可视、情感。例如“发现子女行为不当时，我（个人）能以智慧、爱心、坚定的立场与自制力（积极）及时应对（果断），结果让我深感欣慰（情感）。”</p><h2 id="确定角色和目标"><a href="#确定角色和目标" class="headerlink" title="确定角色和目标"></a>确定角色和目标</h2><p>在撰写使命宣言时，不妨分开不同的角色领域，一一订立目标。事业、生活、政治、信仰等。</p><h2 id="家庭的使命宣言"><a href="#家庭的使命宣言" class="headerlink" title="家庭的使命宣言"></a>家庭的使命宣言</h2><p>每个家庭都有共同的价值观及理念，作为生活的重心，撰写家庭使命宣言正可以凸显这个生活中心，时全家人团结在共同的目标下。</p><h2 id="组织的使命宣言"><a href="#组织的使命宣言" class="headerlink" title="组织的使命宣言"></a>组织的使命宣言</h2><p>一个真正反映每隔成员的共同愿景和价值观的使命宣言，能调动他们的创造力和奉献精神，使他们不再需要旁人的指导、监督和批评，因为他们已经接受了不变的核心原则，接受了企业为之奋斗的共同目标。</p><h2 id="付诸行动"><a href="#付诸行动" class="headerlink" title="付诸行动"></a>付诸行动</h2><ol><li>把你参加葬礼心灵演练时的心得列表整理。</li><li>根据目前理解，写下自己的人生角色。检讨你对目前扮演的角色和自己的生活是否满意。</li><li>每天抽空撰写个人使命宣言。</li><li>阅读各种生活中心，看你的行为符合其中哪种类型？他们是否让你的日常行为有了一定依据？你是否满意？</li><li>为编写使命宣言而手机笔记、引言、想法以及可能有用的各种资料。</li><li>设想近期内可能会从事的某个项目，用心灵演练的原则，写下你希望获得的结果与应采取的步骤。</li><li>向家人呢或同事讲述本章的精华，并建议大家共同拟定家庭或团队的使命宣言。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第四章-习惯二-以终为始——自我领导的原则&quot;&gt;&lt;a href=&quot;#第四章-习惯二-以终为始——自我领导的原则&quot; class=&quot;headerlink&quot; title=&quot;第四章 习惯二 以终为始——自我领导的原则&quot;&gt;&lt;/a&gt;第四章 习惯二 以终为始——自我领导的原则&lt;/
      
    
    </summary>
    
    
      <category term="高效能人士的七个习惯" scheme="https://lilei.pro/tags/%E9%AB%98%E6%95%88%E8%83%BD%E4%BA%BA%E5%A3%AB%E7%9A%84%E4%B8%83%E4%B8%AA%E4%B9%A0%E6%83%AF/"/>
    
  </entry>
  
  <entry>
    <title>《高效能人士的七个习惯》第二部分 习惯一 积极主动</title>
    <link href="https://lilei.pro/2019/04/07/Seven-Habbits-2/"/>
    <id>https://lilei.pro/2019/04/07/Seven-Habbits-2/</id>
    <published>2019-04-07T02:56:26.000Z</published>
    <updated>2019-04-07T02:57:22.680Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第三章-习惯一-积极主动——个人愿景的原则"><a href="#第三章-习惯一-积极主动——个人愿景的原则" class="headerlink" title="第三章 习惯一 积极主动——个人愿景的原则"></a>第三章 习惯一 积极主动——个人愿景的原则</h1><h2 id="自我思维（Self-paradigm）"><a href="#自我思维（Self-paradigm）" class="headerlink" title="自我思维（Self-paradigm）"></a>自我思维（Self-paradigm）</h2><blockquote><p>行有不得，反求诸己</p></blockquote><p>试着跳出自我的框框，把意识转移到屋子的某个角落，然后用心客观地审视自己，站在旁观泽的角度观察自己，描述现在的心情与精神状态，思考你头脑的工作方式，它是否反应灵敏。</p><h2 id="社会之镜（Social-Mirro）"><a href="#社会之镜（Social-Mirro）" class="headerlink" title="社会之镜（Social Mirro）"></a>社会之镜（Social Mirro）</h2><p>社会观点认为，环境与条件对我们起着决定性的作用。我们不否认条件作用的影响巨大，但并不等于承认它凌驾于一切之上，甚至可以决定我们的命运。根据这种看法绘制的社会地图可以分为三种，也被称作揭示人性的三种“决定论”：</p><ol><li>基因决定论（Genetic Determinism）：人的本性由DNA决定，自先祖遗传下来。</li><li>心理决定论（Psychic Determinism）：人的本性由父母的言行决定，即原生家庭论。</li><li>环境决定论（Environmental Determinism）：环境决定人的本性，如周遭的人与事，例如老板、配偶、子女乃至自然环境和经济环境。</li></ol><p>这三种社会地图都已“刺激-回应”理论为基础，来源于巴甫洛夫所做的关于狗的实验，基本观点认为我们会受条件左右，以某一特定方式回应某一特定刺激。</p><h2 id="选择的自由"><a href="#选择的自由" class="headerlink" title="选择的自由"></a>选择的自由</h2><p>人类的自我意识是独立的，能够超脱肉体的束缚，以旁观者的身份审视自己的遭遇。他可以决定外界刺激对自己的影响程度，或者说，在遭遇（刺激）与对遭遇的回应之间，他有选择回应方式的自由和能力。</p><p>即，在刺激与回应之间，人类有选择的自由。这便是“积极主动”的价值。</p><p>责任感（Responsibility）从构词法来说是能够回应（Response-able）的意思，即选择回应的能力，人类应当有营造有利的外在环境的积极性和责任感。积极主动是人的天性，即使生活受到了外界条件的制约，那也是因为我们有意或无意地选择了被外界条件控制，这种选择成为消极被动（Reactive）。</p><h2 id="除非你愿意，否则没人能伤害你"><a href="#除非你愿意，否则没人能伤害你" class="headerlink" title="除非你愿意，否则没人能伤害你"></a>除非你愿意，否则没人能伤害你</h2><p>伤害我们的并非悲惨遭遇本身，而是我们对于悲惨遭遇的回应。尽管这些事的确会让人身心受创或者经济受损，但是品德和本性完全可以不受影响。事实上月痛苦的经历，越能磨练意志，开发潜能，提升自如应对困境的能力，甚至还可能感召他人争取同样的自由。</p><h2 id="聆听自己的语言"><a href="#聆听自己的语言" class="headerlink" title="聆听自己的语言"></a>聆听自己的语言</h2><p>消极被动的人，言语中往往会暴露出推卸责任的意图，例如：</p><ul><li>“我就是这样做事的。”天生如此，爱看不看。</li><li>“他把我气疯了！”责任不在我，是外界因素控制了我的情绪。</li><li>“我根本没时间做。”外界因素——时间扼住了我的咽喉。</li><li>“我只能这样做。”迫于环境（外界因素）</li></ul><p>推卸责任的言语往往会强化宿命论。说者一遍遍被自己洗脑，变得更加自怨自艾，怪罪别人和环境，甚至把星座也扯了进去。</p><h2 id="关注圈与影响圈"><a href="#关注圈与影响圈" class="headerlink" title="关注圈与影响圈"></a>关注圈与影响圈</h2><p>积极主动的人专注于“影响圈”，他们专心做自己力所能及的事，他们的能量是积极的，能够使影响圈不断扩大、扩张和成长。只要我们的焦点在关注权，就等于是允许自己受制于外界条件，自然就不会主动采取必要措施来推动积极变化。</p><p>一个人的关注圈可能会小于影响圈，这说明此人由于自己的缘故，在情感方面缺乏远见和判断力，消极而又自私，全部精力都放在关注圈内。</p><h2 id="三种问题"><a href="#三种问题" class="headerlink" title="三种问题"></a>三种问题</h2><p>可直接控制/可间接控制/无法控制</p><blockquote><p>上帝啊，请赐我勇气，改变那些我能改变的；请赐我胸襟，接收那些我无法改变的；请赐我慧眼，能够分辨这两者。</p></blockquote><h2 id="“如果”和“我可以”"><a href="#“如果”和“我可以”" class="headerlink" title="“如果”和“我可以”"></a>“如果”和“我可以”</h2><p>与关注圈相关的语句多半带有假设性质，“如果”；与影响圈相关的语句多半体现了这个人的品德修养，“我可以”。</p><h2 id="对待错误的态度"><a href="#对待错误的态度" class="headerlink" title="对待错误的态度"></a>对待错误的态度</h2><p>马上承认， 改正并从中吸取教训，这样才能反败为胜。如果不肯承认而后改正，也不丛中吸取教训，等于错上加错，自欺欺人。</p><h2 id="两种直接掌控人生的途径"><a href="#两种直接掌控人生的途径" class="headerlink" title="两种直接掌控人生的途径"></a>两种直接掌控人生的途径</h2><p>一、作出承诺，信守诺言<br>二、确立目标，付诸实践</p><h2 id="付诸行动"><a href="#付诸行动" class="headerlink" title="付诸行动"></a>付诸行动</h2><ol><li>用一整天的时间，听自己和周围的人说话，注意看是否常有“但愿”、“我办不到”、“我不得不”等消极语言出现</li><li>想一想近期是否会发生一些按照以前的习惯拟会消极对待的事情？他是否在你的影响圈之内？你应如何以积极主动的原则应对？在心里演练一下积极的应对方式；提醒自己刺激与回应之间存在空间；想自己承诺，要抓住选择回应的自由</li><li>找出一个工作或生活中令你备感挫折的问题，判断它属于直接控制、间接控制还是无法控制的问题，然后在影响圈内找出解决问题的第一个步骤，并付诸行动</li><li>实行积极主动的原则30天，观察自己的影响圈有何变化</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第三章-习惯一-积极主动——个人愿景的原则&quot;&gt;&lt;a href=&quot;#第三章-习惯一-积极主动——个人愿景的原则&quot; class=&quot;headerlink&quot; title=&quot;第三章 习惯一 积极主动——个人愿景的原则&quot;&gt;&lt;/a&gt;第三章 习惯一 积极主动——个人愿景的原则&lt;/
      
    
    </summary>
    
    
      <category term="高效能人士的七个习惯" scheme="https://lilei.pro/tags/%E9%AB%98%E6%95%88%E8%83%BD%E4%BA%BA%E5%A3%AB%E7%9A%84%E4%B8%83%E4%B8%AA%E4%B9%A0%E6%83%AF/"/>
    
  </entry>
  
  <entry>
    <title>《高效能人士的七个习惯》第一部分 重新探索自我</title>
    <link href="https://lilei.pro/2019/04/07/Seven-Habbits-1/"/>
    <id>https://lilei.pro/2019/04/07/Seven-Habbits-1/</id>
    <published>2019-04-07T02:54:17.000Z</published>
    <updated>2019-04-07T02:55:43.372Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章-由内而外全面造就自己"><a href="#第一章-由内而外全面造就自己" class="headerlink" title="第一章 由内而外全面造就自己"></a>第一章 由内而外全面造就自己</h1><h2 id="本书要阐述的内容"><a href="#本书要阐述的内容" class="headerlink" title="本书要阐述的内容"></a>本书要阐述的内容</h2><p>以原则为中心，以品德为基础，要求“由内而外”地实现个人效能和人际效能。</p><p>由内而外的观点认为个人领域的成功必需先于公众领域的成功；只有先信守对自己的承诺，才能信守对他人的承诺。由内而外是一个持续的更新过程，以主宰人类成长和进步的自然法则为基础，是螺旋向上的，它让我们不断进步，直到实现独立自强与有效的互赖。</p><h1 id="第二章-七个习惯概论"><a href="#第二章-七个习惯概论" class="headerlink" title="第二章 七个习惯概论"></a>第二章 七个习惯概论</h1><h2 id="习惯的引力"><a href="#习惯的引力" class="headerlink" title="习惯的引力"></a>习惯的引力</h2><p>宇宙飞船必须先摆脱强大的地球引力，为此在刚发射的几分钟，即刚升空时的几公里消耗的能量比之后几天几十万公里旅程消耗的能量还要多。习惯也一样有极大的引力，只是许多人不加注意或不肯承认罢了。要根除根深蒂固的不良习惯，仅有一点点毅力，只作一点点改变是不够的。</p><h2 id="习惯的定义"><a href="#习惯的定义" class="headerlink" title="习惯的定义"></a>习惯的定义</h2><p>习惯是知识、技巧、意愿相互交织的结果。</p><ul><li>知识：理论范畴，指点“做什么”及“为何做”</li><li>技巧：告诉“如何做”</li><li>意愿：促使“想要做”</li></ul><h2 id="成熟模式图"><a href="#成熟模式图" class="headerlink" title="成熟模式图"></a>成熟模式图</h2><ul><li>依赖：以“你”为核心</li><li>独立：以“我”为核心</li><li>互赖：以“我们”为核心</li></ul><p>只重独立并不适于互赖的现实生活。只知独立却不懂互赖的人只能称为独个的“生产标兵”，却与“优秀领导”或“最佳合作者”之类的称呼无缘，也不会拥有美满的家庭、婚姻或集体生活。</p><p>互赖是一个更为成熟和高级的概念。生理上互赖的人，可以自力更生，但也明白合作会比单干更有成效；情感上互赖的人，能充分认识自己的价值，但也知道爱心、关怀以及付出的必要性；智力上互赖的人懂得取人之长，补己之短。</p><h2 id="七个习惯"><a href="#七个习惯" class="headerlink" title="七个习惯"></a>七个习惯</h2><h3 id="依赖-gt-独立，个人领域的成功"><a href="#依赖-gt-独立，个人领域的成功" class="headerlink" title="依赖 -&gt; 独立，个人领域的成功"></a>依赖 -&gt; 独立，个人领域的成功</h3><ul><li>积极主动</li><li>以终为始</li><li>要事第一</li></ul><h3 id="独立-gt-互赖，公众领域的成功"><a href="#独立-gt-互赖，公众领域的成功" class="headerlink" title="独立 -&gt; 互赖，公众领域的成功"></a>独立 -&gt; 互赖，公众领域的成功</h3><ul><li>双赢思维</li><li>知彼解己</li><li>统合综效</li></ul><h3 id="螺旋上升"><a href="#螺旋上升" class="headerlink" title="螺旋上升"></a>螺旋上升</h3><ul><li>不断更新</li></ul><h2 id="什么是高效能"><a href="#什么是高效能" class="headerlink" title="什么是高效能"></a>什么是高效能</h2><p><strong>产出与产能平衡的原则是效能的精髓</strong>，放之四海而皆准，不管你是否遵从，它都会存在。它是指导人生的灯塔，是效能的定义和模式，是本书中七个习惯的基础。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第一章-由内而外全面造就自己&quot;&gt;&lt;a href=&quot;#第一章-由内而外全面造就自己&quot; class=&quot;headerlink&quot; title=&quot;第一章 由内而外全面造就自己&quot;&gt;&lt;/a&gt;第一章 由内而外全面造就自己&lt;/h1&gt;&lt;h2 id=&quot;本书要阐述的内容&quot;&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="高效能人士的七个习惯" scheme="https://lilei.pro/tags/%E9%AB%98%E6%95%88%E8%83%BD%E4%BA%BA%E5%A3%AB%E7%9A%84%E4%B8%83%E4%B8%AA%E4%B9%A0%E6%83%AF/"/>
    
  </entry>
  
  <entry>
    <title>友情链接</title>
    <link href="https://lilei.pro/2019/03/10/links/"/>
    <id>https://lilei.pro/2019/03/10/links/</id>
    <published>2019-03-09T23:52:36.000Z</published>
    <updated>2019-03-10T00:07:59.374Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th>Title</th><th>Content</th></tr></thead><tbody><tr><td><a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank" rel="noopener">hexo-theme-indigo</a></td><td>本博客使用的 Hexo 主题</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Title&lt;/th&gt;
&lt;th&gt;Content&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/yscoder/hexo-theme-indigo&quot; 
      
    
    </summary>
    
    
      <category term="工具" scheme="https://lilei.pro/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Java SE 8 Lambda 快速入门</title>
    <link href="https://lilei.pro/2018/11/01/java8-lambda/"/>
    <id>https://lilei.pro/2018/11/01/java8-lambda/</id>
    <published>2018-11-01T09:25:07.000Z</published>
    <updated>2018-11-05T16:18:25.669Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是对<a href="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/Lambda-QuickStart/index.html" target="_blank" rel="noopener">Java SE 8: Lambda Quick Start</a>的翻译，供个人学习Lambda表达式之用。成文日期：2018-11-01，所有以引文出现的文字为笔者阅读过程中添加，非原文内容。<br>强烈建议CET4以上的读者阅读原文。</p></blockquote><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>本文旨在介绍在 Java SE 8 中引进的 Lambda 表达式。</p><h2 id="阅读时间"><a href="#阅读时间" class="headerlink" title="阅读时间"></a>阅读时间</h2><p>大约 1 小时</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Lambda 表达式是 Java SE 8 新引入的重要特性。它提供了通过一个表达式表示指代接口的简洁方法。Lambda 表达式也在遍历、过滤、以及读取数据方面优化了<code>Collection</code>类的使用。此外，新的并发特性提升了多核环境下的程序性能。</p><blockquote><p>总结一下就是三个优点：1.更简洁的匿名类写法，2.更便利的集合类处理，3.多核环境性能优化。</p></blockquote><p>本文首先提供了对 Lambda 表达式的介绍说明，然后介绍匿名内部函数，接着对函数借口和新的 Lambda 语法进行讨论。然后列举出一些常用使用方法模版。</p><p>下节通过对一个搜索场景的讨论，引申出 Lambda 表达式如何优化这种功能实现。然后介绍了一些<code>java.util.function</code>包里面常用的函数接口，如<code>Predicate</code>和<code>Function</code>，并举了一些栗子。</p><p>文末介绍如何通过 Lambda 优化集合类使用。</p><p>提供所有样例源码。</p><h2 id="硬件和软件需求"><a href="#硬件和软件需求" class="headerlink" title="硬件和软件需求"></a>硬件和软件需求</h2><p>以下是硬件和软件需求列表</p><ul><li>JDK 8</li><li>NetBeans 7.4</li></ul><blockquote><p>可以用IDEA代替NetBeans</p></blockquote><h2 id="（运行样例的）先决条件"><a href="#（运行样例的）先决条件" class="headerlink" title="（运行样例的）先决条件"></a>（运行样例的）先决条件</h2><p>要运行样例，你的电脑上必须安装有JDK 8和NetBeans 7.4或更高版本。你可以在<a href="http://openjdk.java.net/projects/lambda/" target="_blank" rel="noopener">the main Lambda site</a>找到下载链接。或者可以直接使用下面的链接。</p><ul><li><a href="https://jdk8.java.net/download.html" target="_blank" rel="noopener">Java Development Kit 8 (JDK8) Early Access</a></li><li><a href="http://netbeans.org/" target="_blank" rel="noopener">NetBeans 7.4 or later</a></li></ul><p><strong>注意：</strong> 安装包适用于所有主流操作系统。本文基于 Linux Mint 13（Ubuntu/Debian）完成。</p><p>安装完成JDK8和NetBeans后。将它们的<code>bin</code>文件夹添加到你的环境变量<code>PATH</code>中。</p><p><strong>注意：</strong> 本文最后更新于 2013 年十二月。</p><blockquote><p>竟然是5年以前的文章了…</p></blockquote><h1 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h1><h2 id="匿名内部类（Anonymous-Inner-Class）"><a href="#匿名内部类（Anonymous-Inner-Class）" class="headerlink" title="匿名内部类（Anonymous Inner Class）"></a>匿名内部类（Anonymous Inner Class）</h2><p>在 Java 中，匿名内部类提供一种实现仅使用一次的类的途径。例如，在标准的 Swing 或者 JavaFX 应用中，需要用一系列的 handler 来处理键盘和鼠标事件。除了为每一个事件单独写一个事件处理类（该类需要实现 ActionListener 接口）这种方式，你可以用以下代码来实现类似需求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JButton testButton = <span class="keyword">new</span> JButton(<span class="string">"Test Button"</span>);</span><br><span class="line">testButton.addActionListener(<span class="keyword">new</span> ActionListener()&#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent ae)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Click Detected by Anon Class"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>除此之外，你需要为每一个事件都写下类似的代码，它们都需要实现<code>ActionListener</code>接口。通过上述匿名内部类的写法，代码似乎变得容易阅读一些。然而这种写法很不优雅，因为有太多无用的模版代码，我们需要的其实只是“在函数里我要做什么事”这个信息。</p><h2 id="函数接口（Functional-Interfaces）"><a href="#函数接口（Functional-Interfaces）" class="headerlink" title="函数接口（Functional Interfaces）"></a>函数接口（Functional Interfaces）</h2><p>定义<code>ActionListener</code>的类代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.awt.event;</span><br><span class="line"><span class="keyword">import</span> java.util.EventListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ActionListener</span> <span class="keyword">extends</span> <span class="title">EventListener</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ActionListener</code>的梨子是一个只含有一个函数声明的接口。在 Java SE 8 中，这种模式的接口被称为“函数接口”。</p><p><strong>注意：</strong> 这种接口之前被称为“Single Abstrace Method type”（单一抽象方法类型）</p><p>在 Java 中使用匿名类实现函数接口是一种常见写法。除了<code>EventListener</code>类以外，像<code>Runnable</code>和<code>Comparator</code>这样的接口也有一样的模式。因此，函数式接口是我们使用 Lambda 表达式的一个重要原因。</p><h2 id="Lambda-表达式语法"><a href="#Lambda-表达式语法" class="headerlink" title="Lambda 表达式语法"></a>Lambda 表达式语法</h2><p>Lambda 可以把匿名内部类的代码从 5 行精简到 1 行，极大的缩减了代码的冗余。如下这种“水平的”解决方案解决了匿名内部类带来的“垂直的”问题。</p><blockquote><p>这里“水平”和“垂直”是指代码块在页面中呈现的形式</p></blockquote><p>一个 Lambda 表达式由三部分构成</p><table><thead><tr><th>Argument List</th><th>Arrow Token</th><th>Body</th></tr></thead><tbody><tr><td>(int x, int y)</td><td>-&gt;</td><td>x + y</td></tr></tbody></table><blockquote><p>这三个部分可以翻译为“参数列表”、“箭头标志”、“函数体”，不过下文仍然以英文称呼，为了加深记忆。</p></blockquote><p>Body 部分可以是一个简单的表达式（expression）或者代码块（statement block）。在上面的模版中，body 中进行了简单的计算和返回。在代码块格式中，body 呈现形式与普通函数写法一样，同样需要一个 return 语句来返回结果给匿名函数的调用者。<code>break</code>和<code>continue</code>关键字在最外层是禁止使用的，不过如果代码里存在循环（loops），则可以使用。如果 body 需要返回一个结果值，每一条控制路径都必需有值返回，或者抛出异常。</p><p>看一下这些栗子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; x + y</span><br><span class="line"></span><br><span class="line">() -&gt; <span class="number">42</span></span><br><span class="line"></span><br><span class="line">(String s) -&gt; &#123; System.out.println(s); &#125;</span><br></pre></td></tr></table></figure><p>第一个表达式读取两个整型参数，<code>x</code>和<code>y</code>，然后返回<code>x+y</code>的结果。第二个表达式不需要参数，使用“表达式”格式的返回结果，值为42。第三个表达式读取字符串参数，然后将它打印在控制台，不返回任何结果。</p><p>有了上面的基础知识，我们再来看一些样例。</p><h1 id="Lambda-样例（Lambda-Examples）"><a href="#Lambda-样例（Lambda-Examples）" class="headerlink" title="Lambda 样例（Lambda Examples）"></a>Lambda 样例（Lambda Examples）</h1><p>这里是一些使用到上面提到的栗子的常见用法。</p><h2 id="Runnable-Lambda"><a href="#Runnable-Lambda" class="headerlink" title="Runnable Lambda"></a>Runnable Lambda</h2><p>你可以用 Lambda 来写一个实现了 Runnable 接口的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">"=== RunnableTest ==="</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Anonymous Runnable</span></span><br><span class="line">    Runnable r1 = <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello world one!"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Lambda Runnable</span></span><br><span class="line">    Runnable r2 = () -&gt; System.out.println(<span class="string">"Hello world two!"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Run em!</span></span><br><span class="line">    r1.run();</span><br><span class="line">    r2.run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在两种场景里，请注意到接口不需要读取参数，也没有返回值。<code>Runnable</code>的 Lambda 表达式使用了代码块模式，将 5 行代码浓缩为 1 行。</p><blockquote><p>“代码块”应为原作者笔误，实际上是“表达式”格式。</p></blockquote><h2 id="Comparator-Lambda"><a href="#Comparator-Lambda" class="headerlink" title="Comparator Lambda"></a>Comparator Lambda</h2><p><code>Comparator</code>类在 Java 中用于给集合排序。在以下的例子中，一个由<code>Person</code>对象构成的<code>ArrayList</code>被按照<code>surName</code>进行排序。以下是<code>Person</code>类的成员变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String givenName;</span><br><span class="line">    <span class="keyword">private</span> String surName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Gender gender;</span><br><span class="line">    <span class="keyword">private</span> String eMail;</span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br></pre></td></tr></table></figure><p>以下代码分别使用了匿名内部类和 Lambda 表达式两种方式生成<code>Comparator</code>进行排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComparatorTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    List&lt;Person&gt; personList = Person.createShortList();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Sort with Inner Class</span></span><br><span class="line">    Collections.sort(personList, <span class="keyword">new</span> Comparator&lt;Person&gt;()&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person p1, Person p2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1.getSurName().compareTo(p2.getSurName());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">"=== Sorted Asc SurName ==="</span>);</span><br><span class="line">    <span class="keyword">for</span>(Person p:personList)&#123;</span><br><span class="line">      p.printName();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Use Lambda instead</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Print Asc</span></span><br><span class="line">    System.out.println(<span class="string">"=== Sorted Asc SurName ==="</span>);</span><br><span class="line">    Collections.sort(personList, (Person p1, Person p2) -&gt; p1.getSurName().compareTo(p2.getSurName()));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(Person p:personList)&#123;</span><br><span class="line">      p.printName();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Print Desc</span></span><br><span class="line">    System.out.println(<span class="string">"=== Sorted Desc SurName ==="</span>);</span><br><span class="line">    Collections.sort(personList, (p1,  p2) -&gt; p2.getSurName().compareTo(p1.getSurName()));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(Person p:personList)&#123;</span><br><span class="line">      p.printName();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>由于 Markdown 不支持代码行数表示，这里的行数请自行体会。</p></blockquote><p>17 - 21 行的排序语句可以被 32 行的 Lambda 表达式精简。注意到第一个 Lambda 表达式声明了传进来的参数类型。第二个 Lambda 表达式则省略了类型声明。Lambda 支持“target typing”（类型自动匹配？），意味着它可以自动从上下文中获取到对象类型信息。因为我们将<code>Comparator</code>应用于泛型集合类（personList），编译器能够自动判断参数类型为<code>Person</code>。</p><h2 id="Listener-Lambda"><a href="#Listener-Lambda" class="headerlink" title="Listener Lambda"></a>Listener Lambda</h2><p>最后我们来看一下<code>ActionListener</code>的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListenerTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    JButton testButton = <span class="keyword">new</span> JButton(<span class="string">"Test Button"</span>);</span><br><span class="line">    testButton.addActionListener(<span class="keyword">new</span> ActionListener()&#123;</span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent ae)</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Click Detected by Anon Class"</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    </span><br><span class="line">    testButton.addActionListener(e -&gt; System.out.println(<span class="string">"Click Detected by Lambda Listner"</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Swing stuff</span></span><br><span class="line">    JFrame frame = <span class="keyword">new</span> JFrame(<span class="string">"Listener Test"</span>);</span><br><span class="line">    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">    frame.add(testButton, BorderLayout.CENTER);</span><br><span class="line">    frame.pack();</span><br><span class="line">    frame.setVisible(<span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 Lambda 表达式作为参数被传入。类型自动匹配可以应用在很多场景中，以下举例说明：</p><ul><li>Variable declarations（变量声明）</li><li>Assignments（赋值）</li><li>Return statements（返回语句）</li><li>Array initializers（数组初始化）</li><li>Method or constructor arguments（方法或构造器参数）</li><li>Lambda expression bodies（Lambda 表达式体）</li><li>Conditional expressions?:（三元运算符?:）</li><li>Cast expressions（类型转换语句）</li></ul><blockquote><p>简单说就是所有为<code>expression</code>的地方，都可以使用 Lambda 表达式，它本身就是一个 expression/statement。</p></blockquote><h2 id="资源下载"><a href="#资源下载" class="headerlink" title="资源下载"></a>资源下载</h2><p>本小节中的 NetBeans 工程样例代码可以在下面下载到</p><p><a href="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/Lambda-QuickStart/examples/LambdaExamples01.zip" target="_blank" rel="noopener">LambdaExamples01.zip</a></p><h1 id="通过-Lambda-表达式优化代码"><a href="#通过-Lambda-表达式优化代码" class="headerlink" title="通过 Lambda 表达式优化代码"></a>通过 Lambda 表达式优化代码</h1><p>在你掌握了前面展示的例子后，本节将介绍如何借助 Lambda 改进你的代码。Lambda 表达式将帮助你轻松实现“Don’t Repeat Yourself(DRY)”原则，并且使你的代码更加简洁易于阅读。</p><h2 id="一个查询的-Case"><a href="#一个查询的-Case" class="headerlink" title="一个查询的 Case"></a>一个查询的 Case</h2><p>一个常见的应用程序场景是，从一个集合中遍历，找出那些符合某种过滤条件的成员。在 2012 年的 JavaOne 大会上，Stuart Marks 和 Mike Duigou 通过格外出色的<a href="http://www.youtube.com/watch?v=bzO5GSujdqI" target="_blank" rel="noopener">Jump-Starting Lambda</a>展示了这种应用场景。给你一个名单列表以及一系列筛选条件，需要找出那些符合条件的人并且自动呼叫他们。这个指南在有一些轻微变更的情况下实现了上述需求。</p><p>在这个例子中，我们需要从以下三个美国群体中提取出消息：</p><ul><li><strong>司机：</strong> 年龄大于 16 岁</li><li><strong>入伍人员：</strong> 男性，18 ~ 25 岁</li><li><strong>飞行员（特指商业飞行员）：</strong> 23 ~ 65 岁</li></ul><p>我们将要实现上述需求，不过不是通过打电话或者发邮件，而是在控制台输出信息。信息内容包括姓名、年龄和联系方式（例如邮件地址或者电话号码）</p><h2 id="Person-类"><a href="#Person-类" class="headerlink" title="Person 类"></a>Person 类</h2><p>属性定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> String givenName;</span><br><span class="line"> <span class="keyword">private</span> String surName;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"> <span class="keyword">private</span> Gender gender;</span><br><span class="line"> <span class="keyword">private</span> String eMail;</span><br><span class="line"> <span class="keyword">private</span> String phone;</span><br><span class="line"> <span class="keyword">private</span> String address;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Person</code>类通过<code>Builder</code>来创建新对象，使用<code>createShortList</code>来创建人员列表。如下方代码片段所示。<strong>注意：</strong> 以下所有样例代码都可以在本节末尾给出的 NetBeans 工程里找到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Person&gt; <span class="title">createShortList</span><span class="params">()</span></span>&#123;</span><br><span class="line">  List&lt;Person&gt; people = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">  people.add(</span><br><span class="line">    <span class="keyword">new</span> Person.Builder()</span><br><span class="line">          .givenName(<span class="string">"Bob"</span>)</span><br><span class="line">          .surName(<span class="string">"Baker"</span>)</span><br><span class="line">          .age(<span class="number">21</span>)</span><br><span class="line">          .gender(Gender.MALE)</span><br><span class="line">          .email(<span class="string">"bob.baker@example.com"</span>)</span><br><span class="line">          .phoneNumber(<span class="string">"201-121-4678"</span>)</span><br><span class="line">          .address(<span class="string">"44 4th St, Smallville, KS 12333"</span>)</span><br><span class="line">          .build() </span><br><span class="line">    );</span><br><span class="line">  </span><br><span class="line">  people.add(</span><br><span class="line">    <span class="keyword">new</span> Person.Builder()</span><br><span class="line">          .givenName(<span class="string">"Jane"</span>)</span><br><span class="line">          .surName(<span class="string">"Doe"</span>)</span><br><span class="line">          .age(<span class="number">25</span>)</span><br><span class="line">          .gender(Gender.FEMALE)</span><br><span class="line">          .email(<span class="string">"jane.doe@example.com"</span>)</span><br><span class="line">          .phoneNumber(<span class="string">"202-123-4678"</span>)</span><br><span class="line">          .address(<span class="string">"33 3rd St, Smallville, KS 12333"</span>)</span><br><span class="line">          .build() </span><br><span class="line">    );</span><br><span class="line">  </span><br><span class="line">  people.add(</span><br><span class="line">    <span class="keyword">new</span> Person.Builder()</span><br><span class="line">          .givenName(<span class="string">"John"</span>)</span><br><span class="line">          .surName(<span class="string">"Doe"</span>)</span><br><span class="line">          .age(<span class="number">25</span>)</span><br><span class="line">          .gender(Gender.MALE)</span><br><span class="line">          .email(<span class="string">"john.doe@example.com"</span>)</span><br><span class="line">          .phoneNumber(<span class="string">"202-123-4678"</span>)</span><br><span class="line">          .address(<span class="string">"33 3rd St, Smallville, KS 12333"</span>)</span><br><span class="line">          .build()</span><br><span class="line">  );</span><br></pre></td></tr></table></figure><h2 id="第一次尝试"><a href="#第一次尝试" class="headerlink" title="第一次尝试"></a>第一次尝试</h2><p>有了上面的<code>Person</code>类，加上定义好的检索条件，你可以写一个<code>RoboContact</code>类。一个可以参考的写法中定义了每种使用场景里的方法：</p><p><code>RoboContactMethods.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.lambda;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> MikeW</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoboContactMethods</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callDrivers</span><span class="params">(List&lt;Person&gt; pl)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(Person p:pl)&#123;</span><br><span class="line">      <span class="keyword">if</span> (p.getAge() &gt;= <span class="number">16</span>)&#123;</span><br><span class="line">        roboCall(p);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">emailDraftees</span><span class="params">(List&lt;Person&gt; pl)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(Person p:pl)&#123;</span><br><span class="line">      <span class="keyword">if</span> (p.getAge() &gt;= <span class="number">18</span> &amp;&amp; p.getAge() &lt;= <span class="number">25</span> &amp;&amp; p.getGender() == Gender.MALE)&#123;</span><br><span class="line">        roboEmail(p);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mailPilots</span><span class="params">(List&lt;Person&gt; pl)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(Person p:pl)&#123;</span><br><span class="line">      <span class="keyword">if</span> (p.getAge() &gt;= <span class="number">23</span> &amp;&amp; p.getAge() &lt;= <span class="number">65</span>)&#123;</span><br><span class="line">        roboMail(p);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">roboCall</span><span class="params">(Person p)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Calling "</span> + p.getGivenName() + <span class="string">" "</span> + p.getSurName() + <span class="string">" age "</span> + p.getAge() + <span class="string">" at "</span> + p.getPhone());</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">roboEmail</span><span class="params">(Person p)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"EMailing "</span> + p.getGivenName() + <span class="string">" "</span> + p.getSurName() + <span class="string">" age "</span> + p.getAge() + <span class="string">" at "</span> + p.getEmail());</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">roboMail</span><span class="params">(Person p)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Mailing "</span> + p.getGivenName() + <span class="string">" "</span> + p.getSurName() + <span class="string">" age "</span> + p.getAge() + <span class="string">" at "</span> + p.getAddress());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，上面列出的方法说明了对不同对象采取的行为（打电话、发电子邮件、发实体邮件）。可以清楚地看出过滤条件和采取的行为。然而，这种设计存在一些缺陷：</p><ul><li>没有践行 DRY 原则<ul><li>每一个方法都是重复的模版</li><li>必须为每个方法重写过滤条件</li></ul></li><li>每个用户场景都需要实现大量的方法（比如今天是打电话给入伍人员，发邮件给飞行员；明天可能就是打电话给飞行员，发邮件给入伍人员）</li><li>代码呆板。如果过滤条件发生改变，不得不改动大量代码。因此，这段代码是难以维护的。</li></ul><h2 id="重构这些方法"><a href="#重构这些方法" class="headerlink" title="重构这些方法"></a>重构这些方法</h2><p>如何修复这个类？可以从过滤条件入手。如果可以把过滤调价提取出一个独立的方法，将会有一些提升。</p><p><code>RoboContactMethods2.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.lambda;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> MikeW</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoboContactMethods2</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callDrivers</span><span class="params">(List&lt;Person&gt; pl)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(Person p:pl)&#123;</span><br><span class="line">      <span class="keyword">if</span> (isDriver(p))&#123;</span><br><span class="line">        roboCall(p);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">emailDraftees</span><span class="params">(List&lt;Person&gt; pl)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(Person p:pl)&#123;</span><br><span class="line">      <span class="keyword">if</span> (isDraftee(p))&#123;</span><br><span class="line">        roboEmail(p);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mailPilots</span><span class="params">(List&lt;Person&gt; pl)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(Person p:pl)&#123;</span><br><span class="line">      <span class="keyword">if</span> (isPilot(p))&#123;</span><br><span class="line">        roboMail(p);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDriver</span><span class="params">(Person p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p.getAge() &gt;= <span class="number">16</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDraftee</span><span class="params">(Person p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p.getAge() &gt;= <span class="number">18</span> &amp;&amp; p.getAge() &lt;= <span class="number">25</span> &amp;&amp; p.getGender() == Gender.MALE;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPilot</span><span class="params">(Person p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p.getAge() &gt;= <span class="number">23</span> &amp;&amp; p.getAge() &lt;= <span class="number">65</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">roboCall</span><span class="params">(Person p)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Calling "</span> + p.getGivenName() + <span class="string">" "</span> + p.getSurName() + <span class="string">" age "</span> + p.getAge() + <span class="string">" at "</span> + p.getPhone());</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">roboEmail</span><span class="params">(Person p)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"EMailing "</span> + p.getGivenName() + <span class="string">" "</span> + p.getSurName() + <span class="string">" age "</span> + p.getAge() + <span class="string">" at "</span> + p.getEmail());</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">roboMail</span><span class="params">(Person p)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Mailing "</span> + p.getGivenName() + <span class="string">" "</span> + p.getSurName() + <span class="string">" age "</span> + p.getAge() + <span class="string">" at "</span> + p.getAddress());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比起上一个例子，这次的过滤条件被封装在单独的方法里。这些判断用的代码可以复用，需求变更时也避免了在类里面进行大范围的修改。然而，仍然存在着大量重复代码，以及必需为每种联系方法（打电话、发电子邮件、发邮件）单独写一个方法。是否有更好的将过滤条件传递给这些联系方法的方式？</p><h1 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h1><p>在 Lambda 表达式问世之前，可采用匿名内部类的方案。例如，一个解决方法是声明一个具有返回布尔值的<code>test</code>方法的<code>MyTest.java</code>类。把过滤条件在这个方法里，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyTest</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更新后的模拟联系方式类如下：</p><p><code>RobocontactAnon.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoboContactAnon</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">phoneContacts</span><span class="params">(List&lt;Person&gt; pl, MyTest&lt;Person&gt; aTest)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(Person p:pl)&#123;</span><br><span class="line">      <span class="keyword">if</span> (aTest.test(p))&#123;</span><br><span class="line">        roboCall(p);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">emailContacts</span><span class="params">(List&lt;Person&gt; pl, MyTest&lt;Person&gt; aTest)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(Person p:pl)&#123;</span><br><span class="line">      <span class="keyword">if</span> (aTest.test(p))&#123;</span><br><span class="line">        roboEmail(p);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mailContacts</span><span class="params">(List&lt;Person&gt; pl, MyTest&lt;Person&gt; aTest)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(Person p:pl)&#123;</span><br><span class="line">      <span class="keyword">if</span> (aTest.test(p))&#123;</span><br><span class="line">        roboMail(p);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">roboCall</span><span class="params">(Person p)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Calling "</span> + p.getGivenName() + <span class="string">" "</span> + p.getSurName() + <span class="string">" age "</span> + p.getAge() + <span class="string">" at "</span> + p.getPhone());</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">roboEmail</span><span class="params">(Person p)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"EMailing "</span> + p.getGivenName() + <span class="string">" "</span> + p.getSurName() + <span class="string">" age "</span> + p.getAge() + <span class="string">" at "</span> + p.getEmail());</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">roboMail</span><span class="params">(Person p)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Mailing "</span> + p.getGivenName() + <span class="string">" "</span> + p.getSurName() + <span class="string">" age "</span> + p.getAge() + <span class="string">" at "</span> + p.getAddress());</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里无疑是有了一些优化，因为只需要 3 个用于进行联系的方法。然而，在实际进行调用时，代码会有一些丑陋。看下面的测试代码：</p><p><code>RoboCallTest03.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.lambda;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> MikeW</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoboCallTest03</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    List&lt;Person&gt; pl = Person.createShortList();</span><br><span class="line">    RoboContactAnon robo = <span class="keyword">new</span> RoboContactAnon();</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">"\n==== Test 03 ===="</span>);</span><br><span class="line">    System.out.println(<span class="string">"\n=== Calling all Drivers ==="</span>);</span><br><span class="line">    robo.phoneContacts(pl, </span><br><span class="line">        <span class="keyword">new</span> MyTest&lt;Person&gt;()&#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Person p)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> p.getAge() &gt;=<span class="number">16</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">"\n=== Emailing all Draftees ==="</span>);</span><br><span class="line">    robo.emailContacts(pl, </span><br><span class="line">        <span class="keyword">new</span> MyTest&lt;Person&gt;()&#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Person p)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> p.getAge() &gt;= <span class="number">18</span> &amp;&amp; p.getAge() &lt;= <span class="number">25</span> &amp;&amp; p.getGender() == Gender.MALE;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">"\n=== Mail all Pilots ==="</span>);</span><br><span class="line">    robo.mailContacts(pl, </span><br><span class="line">        <span class="keyword">new</span> MyTest&lt;Person&gt;()&#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Person p)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> p.getAge() &gt;= <span class="number">23</span> &amp;&amp; p.getAge() &lt;= <span class="number">65</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是“垂直”代码的一个典型案例。这样的代码难以阅读。此外，我们必须为每一种使用场景单独写自定义的过滤条件。</p><h2 id="Lambda-表达式解千愁"><a href="#Lambda-表达式解千愁" class="headerlink" title="Lambda 表达式解千愁"></a>Lambda 表达式解千愁</h2><p>Lambda 表达式可以解决目前为止我们遇到的一切问题。不过，让我们先了解一点别的。</p><p><code>java.uitl.function</code></p><p>在上一个例子中，<code>MyTest</code>函数接口将匿名内部类传递给方法调用。然而，写一个接口并不是必需的。Java SE 8 提供了<code>java.util.function</code>包，其中有一系列标准的函数借口。在这种场景下，<code>Predicate</code>接口符合我们的需求。</p><blockquote><p><code>Predict</code>意为“谓语，断言”，即判断条件的意思</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>test</code>方法接收一个泛型类，返回一个布尔值。这正是我们所需要的过滤场景。下面是模拟联系方式类的最终版本。</p><p><code>RobocontactsLambda.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.lambda;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> MikeW</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoboContactLambda</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">phoneContacts</span><span class="params">(List&lt;Person&gt; pl, Predicate&lt;Person&gt; pred)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(Person p:pl)&#123;</span><br><span class="line">      <span class="keyword">if</span> (pred.test(p))&#123;</span><br><span class="line">        roboCall(p);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">emailContacts</span><span class="params">(List&lt;Person&gt; pl, Predicate&lt;Person&gt; pred)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(Person p:pl)&#123;</span><br><span class="line">      <span class="keyword">if</span> (pred.test(p))&#123;</span><br><span class="line">        roboEmail(p);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mailContacts</span><span class="params">(List&lt;Person&gt; pl, Predicate&lt;Person&gt; pred)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(Person p:pl)&#123;</span><br><span class="line">      <span class="keyword">if</span> (pred.test(p))&#123;</span><br><span class="line">        roboMail(p);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">roboCall</span><span class="params">(Person p)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Calling "</span> + p.getGivenName() + <span class="string">" "</span> + p.getSurName() + <span class="string">" age "</span> + p.getAge() + <span class="string">" at "</span> + p.getPhone());</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">roboEmail</span><span class="params">(Person p)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"EMailing "</span> + p.getGivenName() + <span class="string">" "</span> + p.getSurName() + <span class="string">" age "</span> + p.getAge() + <span class="string">" at "</span> + p.getEmail());</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">roboMail</span><span class="params">(Person p)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Mailing "</span> + p.getGivenName() + <span class="string">" "</span> + p.getSurName() + <span class="string">" age "</span> + p.getAge() + <span class="string">" at "</span> + p.getAddress());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种写法里，只需要三个方法用来模拟联系候选人。Lambda 表达式作为参数被传递给方法，用来过滤需要联系的人员。</p><h2 id="垂直问题迎刃而解"><a href="#垂直问题迎刃而解" class="headerlink" title="垂直问题迎刃而解"></a>垂直问题迎刃而解</h2><p>Lambda 表达式解决了垂直代码的问题，并且更容易重用。来看看新的使用了 Lambda 表达式的测试类。</p><p><code>RoboCallTest04.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.lambda;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> MikeW</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoboCallTest04</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123; </span><br><span class="line"></span><br><span class="line">    List&lt;Person&gt; pl = Person.createShortList();</span><br><span class="line">    RoboContactLambda robo = <span class="keyword">new</span> RoboContactLambda();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Predicates</span></span><br><span class="line">    Predicate&lt;Person&gt; allDrivers = p -&gt; p.getAge() &gt;= <span class="number">16</span>;</span><br><span class="line">    Predicate&lt;Person&gt; allDraftees = p -&gt; p.getAge() &gt;= <span class="number">18</span> &amp;&amp; p.getAge() &lt;= <span class="number">25</span> &amp;&amp; p.getGender() == Gender.MALE;</span><br><span class="line">    Predicate&lt;Person&gt; allPilots = p -&gt; p.getAge() &gt;= <span class="number">23</span> &amp;&amp; p.getAge() &lt;= <span class="number">65</span>;</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">"\n==== Test 04 ===="</span>);</span><br><span class="line">    System.out.println(<span class="string">"\n=== Calling all Drivers ==="</span>);</span><br><span class="line">    robo.phoneContacts(pl, allDrivers);</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">"\n=== Emailing all Draftees ==="</span>);</span><br><span class="line">    robo.emailContacts(pl, allDraftees);</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">"\n=== Mail all Pilots ==="</span>);</span><br><span class="line">    robo.mailContacts(pl, allPilots);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Mix and match becomes easy</span></span><br><span class="line">    System.out.println(<span class="string">"\n=== Mail all Draftees ==="</span>);</span><br><span class="line">    robo.mailContacts(pl, allDraftees);  </span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">"\n=== Call all Pilots ==="</span>);</span><br><span class="line">    robo.phoneContacts(pl, allPilots);    </span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到，我们为每组联系人（allDrivers, allDraftees, allPilots）声明了一个断言（<code>Predicate</code>）。你可以将任何一个断言传给模拟联系的方法。代码简洁易于阅读，并且减少了重复代码。</p><h2 id="资源下载-1"><a href="#资源下载-1" class="headerlink" title="资源下载"></a>资源下载</h2><p>本小节中的 NetBeans 工程样例代码可以在下面下载到</p><p><a href="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/Lambda-QuickStart/examples/RoboCallExample.zip" target="_blank" rel="noopener">RoboCallExample.zip</a></p><h1 id="java-util-function包"><a href="#java-util-function包" class="headerlink" title="java.util.function包"></a><code>java.util.function</code>包</h1><p>上节介绍的<code>Predicate</code>并不是 Java SE 8 所提供的唯一函数接口。开发者可以使用一系列的标准接口帮助开发。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/181101_lambda/6_heroes_more.jpg" alt="像我这么吊的" title="">                </div>                <div class="image-caption">像我这么吊的</div>            </figure><ul><li><code>Predicate</code>：参数对象的某个属性</li><li><code>Consumer</code>：对参数对象执行的某种操作</li><li><code>Function</code>：把 T 转换为 U</li><li><code>Supplieer</code>：提供一个 T 的实例（例如工厂）</li><li><code>UnaryOperator</code>：一个单元运算符，T -&gt; T</li><li><code>BinaryOperator</code>：一个双元运算符，(T, T) -&gt; T</li></ul><p>此外，很多接口都有原始形式（类似上文中的<code>Predicate</code>和人工过滤器这种比较），可以帮助你更好地理解 Lambda 表达式。</p><h2 id="东方取名法以及方法调用"><a href="#东方取名法以及方法调用" class="headerlink" title="东方取名法以及方法调用"></a>东方取名法以及方法调用</h2><p>在写上面一个例子时，我认为<code>Person</code>类应当具备一个灵活的输出系统。一个需求是以西方和东方两种命名方式打印出名字。在西方，名在前，姓在后。在东方则恰好相反。</p><h2 id="老式写法的例子"><a href="#老式写法的例子" class="headerlink" title="老式写法的例子"></a>老式写法的例子</h2><p>这是在未使用 Lambda 表达式时的写法</p><p><code>Person.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printWesternName</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">"\nName: "</span> + <span class="keyword">this</span>.getGivenName() + <span class="string">" "</span> + <span class="keyword">this</span>.getSurName() + <span class="string">"\n"</span> +</span><br><span class="line">           <span class="string">"Age: "</span> + <span class="keyword">this</span>.getAge() + <span class="string">"  "</span> + <span class="string">"Gender: "</span> + <span class="keyword">this</span>.getGender() + <span class="string">"\n"</span> +</span><br><span class="line">           <span class="string">"EMail: "</span> + <span class="keyword">this</span>.getEmail() + <span class="string">"\n"</span> + </span><br><span class="line">           <span class="string">"Phone: "</span> + <span class="keyword">this</span>.getPhone() + <span class="string">"\n"</span> +</span><br><span class="line">           <span class="string">"Address: "</span> + <span class="keyword">this</span>.getAddress());</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printEasternName</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">  System.out.println(<span class="string">"\nName: "</span> + <span class="keyword">this</span>.getSurName() + <span class="string">" "</span> + <span class="keyword">this</span>.getGivenName() + <span class="string">"\n"</span> +</span><br><span class="line">           <span class="string">"Age: "</span> + <span class="keyword">this</span>.getAge() + <span class="string">"  "</span> + <span class="string">"Gender: "</span> + <span class="keyword">this</span>.getGender() + <span class="string">"\n"</span> +</span><br><span class="line">           <span class="string">"EMail: "</span> + <span class="keyword">this</span>.getEmail() + <span class="string">"\n"</span> + </span><br><span class="line">           <span class="string">"Phone: "</span> + <span class="keyword">this</span>.getPhone() + <span class="string">"\n"</span> +</span><br><span class="line">           <span class="string">"Address: "</span> + <span class="keyword">this</span>.getAddress());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你需要两个方法，分别打印西方命名、东方命名</p><h2 id="Function接口"><a href="#Function接口" class="headerlink" title="Function接口"></a><code>Function</code>接口</h2><p><code>Function</code>接口适用于这个问题。它只有一个名为<code>apply</code>的方法，方法签名如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> R <span class="title">apply</span><span class="params">(T t)</span></span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>它接收一个泛型 T 的参数，然后返回一个 R 的对象。对于这个例子，传入<code>Person</code>类型，返回<code>String</code>类型。一个更加灵活的打印方法如下所示：</p><p><code>Person.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">printCuston</span><span class="params">(Function &lt;Person, String&gt; f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f.apply(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这可真简单。方法接收一个<code>Function</code>参数，返回一个字符串。<code>apply</code>方法通过一个 Lambda 表达式返回<code>Person</code>对象的信息。</p><p><code>Function</code>是如何定义的？如下是测试的样例代码。</p><p><code>NameTestNew.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NameTestNew</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">"\n==== NameTestNew02 ==="</span>);</span><br><span class="line">    </span><br><span class="line">    List&lt;Person&gt; list1 = Person.createShortList();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Print Custom First Name and e-mail</span></span><br><span class="line">    System.out.println(<span class="string">"===Custom List==="</span>);</span><br><span class="line">    <span class="keyword">for</span> (Person person:list1)&#123;</span><br><span class="line">        System.out.println(</span><br><span class="line">            person.printCustom(p -&gt; <span class="string">"Name: "</span> + p.getGivenName() + <span class="string">" EMail: "</span> + p.getEmail())</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Define Western and Eastern Lambdas</span></span><br><span class="line">    </span><br><span class="line">    Function&lt;Person, String&gt; westernStyle = p -&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"\nName: "</span> + p.getGivenName() + <span class="string">" "</span> + p.getSurName() + <span class="string">"\n"</span> +</span><br><span class="line">             <span class="string">"Age: "</span> + p.getAge() + <span class="string">"  "</span> + <span class="string">"Gender: "</span> + p.getGender() + <span class="string">"\n"</span> +</span><br><span class="line">             <span class="string">"EMail: "</span> + p.getEmail() + <span class="string">"\n"</span> + </span><br><span class="line">             <span class="string">"Phone: "</span> + p.getPhone() + <span class="string">"\n"</span> +</span><br><span class="line">             <span class="string">"Address: "</span> + p.getAddress();</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    Function&lt;Person, String&gt; easternStyle =  p -&gt; <span class="string">"\nName: "</span> + p.getSurName() + <span class="string">" "</span> </span><br><span class="line">            + p.getGivenName() + <span class="string">"\n"</span> + <span class="string">"Age: "</span> + p.getAge() + <span class="string">"  "</span> + </span><br><span class="line">            <span class="string">"Gender: "</span> + p.getGender() + <span class="string">"\n"</span> +</span><br><span class="line">            <span class="string">"EMail: "</span> + p.getEmail() + <span class="string">"\n"</span> + </span><br><span class="line">            <span class="string">"Phone: "</span> + p.getPhone() + <span class="string">"\n"</span> +</span><br><span class="line">            <span class="string">"Address: "</span> + p.getAddress();   </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Print Western List</span></span><br><span class="line">    System.out.println(<span class="string">"\n===Western List==="</span>);</span><br><span class="line">    <span class="keyword">for</span> (Person person:list1)&#123;</span><br><span class="line">        System.out.println(</span><br><span class="line">            person.printCustom(westernStyle)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Print Eastern List</span></span><br><span class="line">    System.out.println(<span class="string">"\n===Eastern List==="</span>);</span><br><span class="line">    <span class="keyword">for</span> (Person person:list1)&#123;</span><br><span class="line">        System.out.println(</span><br><span class="line">            person.printCustom(easternStyle)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个循环只是打印出名字和电子邮件地址。不过可以把任何的表达式传给<code>printCuston</code>方法。东方命名法和西方命名法使用 Lambda 表达式定义，并且保存在变量中。这些变量接下来被传入最后的两个循环。可以很容易地将 Lambda<br>表达式合并成为<code>Map</code>，用起来更加方便。Lambda 表达式提供了显著的灵活性。</p><h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><p>下面是程序的样例输出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">==== NameTestNew02 ===</span><br><span class="line">===Custom List===</span><br><span class="line">Name: Bob EMail: bob.baker@example.com</span><br><span class="line">Name: Jane EMail: jane.doe@example.com</span><br><span class="line">Name: John EMail: john.doe@example.com</span><br><span class="line">Name: James EMail: james.johnson@example.com</span><br><span class="line">Name: Joe EMail: joebob.bailey@example.com</span><br><span class="line">Name: Phil EMail: phil.smith@examp;e.com</span><br><span class="line">Name: Betty EMail: betty.jones@example.com</span><br><span class="line"></span><br><span class="line">===Western List===</span><br><span class="line"></span><br><span class="line">Name: Bob Baker</span><br><span class="line">Age: 21  Gender: MALE</span><br><span class="line">EMail: bob.baker@example.com</span><br><span class="line">Phone: 201-121-4678</span><br><span class="line">Address: 44 4th St, Smallville, KS 12333</span><br><span class="line"></span><br><span class="line">Name: Jane Doe</span><br><span class="line">Age: 25  Gender: FEMALE</span><br><span class="line">EMail: jane.doe@example.com</span><br><span class="line">Phone: 202-123-4678</span><br><span class="line">Address: 33 3rd St, Smallville, KS 12333</span><br><span class="line"></span><br><span class="line">Name: John Doe</span><br><span class="line">Age: 25  Gender: MALE</span><br><span class="line">EMail: john.doe@example.com</span><br><span class="line">Phone: 202-123-4678</span><br><span class="line">Address: 33 3rd St, Smallville, KS 12333</span><br><span class="line"></span><br><span class="line">Name: James Johnson</span><br><span class="line">Age: 45  Gender: MALE</span><br><span class="line">EMail: james.johnson@example.com</span><br><span class="line">Phone: 333-456-1233</span><br><span class="line">Address: 201 2nd St, New York, NY 12111</span><br><span class="line"></span><br><span class="line">Name: Joe Bailey</span><br><span class="line">Age: 67  Gender: MALE</span><br><span class="line">EMail: joebob.bailey@example.com</span><br><span class="line">Phone: 112-111-1111</span><br><span class="line">Address: 111 1st St, Town, CA 11111</span><br><span class="line"></span><br><span class="line">Name: Phil Smith</span><br><span class="line">Age: 55  Gender: MALE</span><br><span class="line">EMail: phil.smith@examp;e.com</span><br><span class="line">Phone: 222-33-1234</span><br><span class="line">Address: 22 2nd St, New Park, CO 222333</span><br><span class="line"></span><br><span class="line">Name: Betty Jones</span><br><span class="line">Age: 85  Gender: FEMALE</span><br><span class="line">EMail: betty.jones@example.com</span><br><span class="line">Phone: 211-33-1234</span><br><span class="line">Address: 22 4th St, New Park, CO 222333</span><br><span class="line"></span><br><span class="line">===Eastern List===</span><br><span class="line"></span><br><span class="line">Name: Baker Bob</span><br><span class="line">Age: 21  Gender: MALE</span><br><span class="line">EMail: bob.baker@example.com</span><br><span class="line">Phone: 201-121-4678</span><br><span class="line">Address: 44 4th St, Smallville, KS 12333</span><br><span class="line"></span><br><span class="line">Name: Doe Jane</span><br><span class="line">Age: 25  Gender: FEMALE</span><br><span class="line">EMail: jane.doe@example.com</span><br><span class="line">Phone: 202-123-4678</span><br><span class="line">Address: 33 3rd St, Smallville, KS 12333</span><br><span class="line"></span><br><span class="line">Name: Doe John</span><br><span class="line">Age: 25  Gender: MALE</span><br><span class="line">EMail: john.doe@example.com</span><br><span class="line">Phone: 202-123-4678</span><br><span class="line">Address: 33 3rd St, Smallville, KS 12333</span><br><span class="line"></span><br><span class="line">Name: Johnson James</span><br><span class="line">Age: 45  Gender: MALE</span><br><span class="line">EMail: james.johnson@example.com</span><br><span class="line">Phone: 333-456-1233</span><br><span class="line">Address: 201 2nd St, New York, NY 12111</span><br><span class="line"></span><br><span class="line">Name: Bailey Joe</span><br><span class="line">Age: 67  Gender: MALE</span><br><span class="line">EMail: joebob.bailey@example.com</span><br><span class="line">Phone: 112-111-1111</span><br><span class="line">Address: 111 1st St, Town, CA 11111</span><br><span class="line"></span><br><span class="line">Name: Smith Phil</span><br><span class="line">Age: 55  Gender: MALE</span><br><span class="line">EMail: phil.smith@examp;e.com</span><br><span class="line">Phone: 222-33-1234</span><br><span class="line">Address: 22 2nd St, New Park, CO 222333</span><br><span class="line"></span><br><span class="line">Name: Jones Betty</span><br><span class="line">Age: 85  Gender: FEMALE</span><br><span class="line">EMail: betty.jones@example.com</span><br><span class="line">Phone: 211-33-1234</span><br><span class="line">Address: 22 4th St, New Park, CO 222333</span><br></pre></td></tr></table></figure><h2 id="资源下载-2"><a href="#资源下载-2" class="headerlink" title="资源下载"></a>资源下载</h2><p>本小节中的 NetBeans 工程样例代码可以在下面下载到</p><p><a href="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/Lambda-QuickStart/examples/LambdaFunctionExamples.zip" target="_blank" rel="noopener">LambdaFunctionExamples.zip</a></p><h1 id="Lambda-表达式和集合"><a href="#Lambda-表达式和集合" class="headerlink" title="Lambda 表达式和集合"></a>Lambda 表达式和集合</h1><p>上节介绍了<code>Function</code>接口和示例语法。本节我们将看到 Lambda 表达式如何提升<code>Collections</code>类。</p><h2 id="Lambda-表达式和集合-1"><a href="#Lambda-表达式和集合-1" class="headerlink" title="Lambda 表达式和集合"></a>Lambda 表达式和集合</h2><p>到目前为止的例子中，集合类出现的很少。然而，相当一部分 Lambda 表达式的特征改变了我们使用集合类的方式。本节介绍其中的一部分。</p><h2 id="类增强"><a href="#类增强" class="headerlink" title="类增强"></a>类增强</h2><p>司机、飞行员、入伍人员的过滤条件被包装进了<code>SearchCriteria</code>类。</p><p><code>SearchCriteria.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.lambda;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> MikeW</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SearchCriteria</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Predicate&lt;Person&gt;&gt; searchMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">SearchCriteria</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    initSearchMap();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initSearchMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Predicate&lt;Person&gt; allDrivers = p -&gt; p.getAge() &gt;= <span class="number">16</span>;</span><br><span class="line">    Predicate&lt;Person&gt; allDraftees = p -&gt; p.getAge() &gt;= <span class="number">18</span> &amp;&amp; p.getAge() &lt;= <span class="number">25</span> &amp;&amp; p.getGender() == Gender.MALE;</span><br><span class="line">    Predicate&lt;Person&gt; allPilots = p -&gt; p.getAge() &gt;= <span class="number">23</span> &amp;&amp; p.getAge() &lt;= <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    searchMap.put(<span class="string">"allDrivers"</span>, allDrivers);</span><br><span class="line">    searchMap.put(<span class="string">"allDraftees"</span>, allDraftees);</span><br><span class="line">    searchMap.put(<span class="string">"allPilots"</span>, allPilots);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Predicate&lt;Person&gt; <span class="title">getCriteria</span><span class="params">(String PredicateName)</span> </span>&#123;</span><br><span class="line">    Predicate&lt;Person&gt; target;</span><br><span class="line"></span><br><span class="line">    target = searchMap.get(PredicateName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (target == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">"Search Criteria not found... "</span>);</span><br><span class="line">      System.exit(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SearchCriteria <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SearchCriteria();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>本例的编码不是很规范，作为参数的<code>PredicateName</code>应该写为<code>predicateName</code>更严谨。</p></blockquote><p>这个类保存了基于<code>Predicate</code>的搜索过滤条件，你可以在测试用例中使用它们。</p><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>首先登场的是任何集合类都可以使用的<code>forEach</code>方法。这里是一些打印出<code>Person</code>列表的例子。</p><p><code>Test01ForEach.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01ForEach</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    List&lt;Person&gt; pl = Person.createShortList();</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">"\n=== Western Phone List ==="</span>);</span><br><span class="line">    pl.forEach( p -&gt; p.printWesternName() );</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">"\n=== Eastern Phone List ==="</span>);</span><br><span class="line">    pl.forEach(Person::printEasternName);</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">"\n=== Custom Phone List ==="</span>);</span><br><span class="line">    pl.forEach(p -&gt; &#123; System.out.println(p.printCustom(r -&gt; <span class="string">"Name: "</span> + r.getGivenName() + <span class="string">" EMail: "</span> + r.getEmail())); &#125;);</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例 1 展示了一个 Lambda 表达式，它调用<code>printWesternName</code>方法打印出列表里每个人的名字。例 2 展示了一个 <strong>方法调用</strong>。当已经存在对类对象操作的方法时，这种写法可以代替通用 Lambda 表达式的写法。最后，例 3 展示了<code>printCustom</code>方法也可以在这种场景下使用。注意 Lambda 表达式嵌套时，变量名的细小差别。</p><p>你可以用这种方式遍历任何集合。基础结构与增强型<code>for</code>训话类似。然而，一些增强型机制能带来很多好处。</p><h2 id="链式调用与过滤器"><a href="#链式调用与过滤器" class="headerlink" title="链式调用与过滤器"></a>链式调用与过滤器</h2><p>除了遍历集合内元素，你还可以将方法组装成链式。第一个要讲解的方法是<code>filter</code>，它接收一个<code>Predicate</code>类型的参数。</p><p>下面例子在过滤元素后，遍历列表。</p><p><code>Test02Filter.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02Filter</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;Person&gt; pl = Person.createShortList();</span><br><span class="line">    </span><br><span class="line">    SearchCriteria search = SearchCriteria.getInstance();</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">"\n=== Western Pilot Phone List ==="</span>);</span><br><span class="line"></span><br><span class="line">    pl.stream().filter(search.getCriteria(<span class="string">"allPilots"</span>))</span><br><span class="line">      .forEach(Person::printWesternName);</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">    System.out.println(<span class="string">"\n=== Eastern Draftee Phone List ==="</span>);</span><br><span class="line"></span><br><span class="line">    pl.stream().filter(search.getCriteria(<span class="string">"allDraftees"</span>))</span><br><span class="line">      .forEach(Person::printEasternName);</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个和最后一个循环展示了<code>List</code>如何基于过滤条件被过滤。控制台输出如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">=== Eastern Draftee Phone List ===</span><br><span class="line"></span><br><span class="line">Name: Baker Bob</span><br><span class="line">Age: 21  Gender: MALE</span><br><span class="line">EMail: bob.baker@example.com</span><br><span class="line">Phone: 201-121-4678</span><br><span class="line">Address: 44 4th St, Smallville, KS 12333</span><br><span class="line"></span><br><span class="line">Name: Doe John</span><br><span class="line">Age: 25  Gender: MALE</span><br><span class="line">EMail: john.doe@example.com</span><br><span class="line">Phone: 202-123-4678</span><br><span class="line">Address: 33 3rd St, Smallville, KS 12333</span><br></pre></td></tr></table></figure><h3 id="偷点儿懒"><a href="#偷点儿懒" class="headerlink" title="偷点儿懒"></a>偷点儿懒</h3><p>这些特征虽然有价值，但是在已经有了一个完美的<code>for</code>循环语法的情况下，把它们引入集合类的意义何在？通过将集合操作归纳成库，Java 开发者可以在代码上进行更多的优化。首先看一对名词解释。</p><ul><li><strong>懒惰</strong>：在编程领域，懒惰意味着只处理你需要处理的对象。在先前的例子中，最后一个循环是“懒惰”的，因为它只遍历了<code>List</code>被过滤出来的两个<code>Person</code>对象。这样的代码效率更高，因为最后只处理了两个对象，（而非整个列表）。</li><li><strong>主动性</strong>：处理列表中每个元素的代码被称为“主动性强”的。例如，一个增强型<code>for</code>循环遍历整个列表，只为处理 2 个元素，这种方式被认为“主动性”很强。</li></ul><h3 id="stream方法"><a href="#stream方法" class="headerlink" title="stream方法"></a><code>stream</code>方法</h3><p>在先前的代码样例中，你会发现在对列表进行过滤和遍历之前，我们调用了<code>stream</code>方法。这个方法接收<code>Collection</code>类型的参数，返回<code>java.util.stream.Stream</code>类型的结果。一个<code>Stream</code>对象意味着一个元素序列，你可以在上面进行链式操作。默认地，一旦元素被消费了，他们就不再处于 Stream 中。此外，随着调用方法不同，<code>Stream</code>可以用在串行（默认）或者并行的场景中。本节末尾将介绍一个并行的场景。</p><h2 id="变更与运算结果"><a href="#变更与运算结果" class="headerlink" title="变更与运算结果"></a>变更与运算结果</h2><p>如刚才所提到的，<code>Stream</code>在使用完成后就会被丢弃。因此，我们无法通过<code>Stream</code>来对列表中的元素进行修改。然而，如果你想要保存链式处理后的元素呢？你可以将它们存入一个新的集合。如下代码所示：</p><p><code>Test03toList.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test03toList</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    List&lt;Person&gt; pl = Person.createShortList();</span><br><span class="line">    </span><br><span class="line">    SearchCriteria search = SearchCriteria.getInstance();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Make a new list after filtering.</span></span><br><span class="line">    List&lt;Person&gt; pilotList = pl</span><br><span class="line">            .stream()</span><br><span class="line">            .filter(search.getCriteria(<span class="string">"allPilots"</span>))</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">"\n=== Western Pilot Phone List ==="</span>);</span><br><span class="line">    pilotList.forEach(Person::printWesternName);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>collect</code>方法只有一个参数，是<code>Collector</code>类。<code>Collector</code>类用于从处理流的结果中生成一个<code>List</code>或者<code>Set</code>。上例介绍了如何将列表过滤后的结果存成<code>List</code>。</p><h2 id="使用map进行计算"><a href="#使用map进行计算" class="headerlink" title="使用map进行计算"></a>使用<code>map</code>进行计算</h2><p><code>map</code>方法通常和<code>filter</code>搭配使用。这个方法去除类里面的某个属性，然后对它进行操作。如下代码基于年龄字段进行了一系列计算。</p><p><code>Test04Map.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test04Map</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Person&gt; pl = Person.createShortList();</span><br><span class="line">    </span><br><span class="line">    SearchCriteria search = SearchCriteria.getInstance();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Calc average age of pilots old style</span></span><br><span class="line">    System.out.println(<span class="string">"== Calc Old Style =="</span>);</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (Person p:pl)&#123;</span><br><span class="line">      <span class="keyword">if</span> (p.getAge() &gt;= <span class="number">23</span> &amp;&amp; p.getAge() &lt;= <span class="number">65</span> )&#123;</span><br><span class="line">        sum = sum + p.getAge();</span><br><span class="line">        count++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">long</span> average = sum / count;</span><br><span class="line">    System.out.println(<span class="string">"Total Ages: "</span> + sum);</span><br><span class="line">    System.out.println(<span class="string">"Average Age: "</span> + average);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Get sum of ages</span></span><br><span class="line">    System.out.println(<span class="string">"\n== Calc New Style =="</span>);</span><br><span class="line">    <span class="keyword">long</span> totalAge = pl</span><br><span class="line">            .stream()</span><br><span class="line">            .filter(search.getCriteria(<span class="string">"allPilots"</span>))</span><br><span class="line">            .mapToInt(p -&gt; p.getAge())</span><br><span class="line">            .sum();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get average of ages</span></span><br><span class="line">    OptionalDouble averageAge = pl</span><br><span class="line">            .parallelStream()</span><br><span class="line">            .filter(search.getCriteria(<span class="string">"allPilots"</span>))</span><br><span class="line">            .mapToDouble(p -&gt; p.getAge())</span><br><span class="line">            .average();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"Total Ages: "</span> + totalAge);</span><br><span class="line">    System.out.println(<span class="string">"Average Age: "</span> + averageAge.getAsDouble());    </span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">== Calc Old Style ==</span><br><span class="line">Total Ages: 150</span><br><span class="line">Average Age: 37</span><br><span class="line"></span><br><span class="line">== Calc New Style ==</span><br><span class="line">Total Ages: 150</span><br><span class="line">Average Age: 37.5</span><br></pre></td></tr></table></figure><p>这段代码计算列表中所有飞行员的平均年龄。第一个循环展示了老式用<code>for</code>循环的写法。第二个循环使用了<code>map</code>方法获取串流中的每个人的年龄。注意<code>totalAge</code>是一个<code>long</code>类型对象。<code>map</code>方法返回一个<code>IntStream</code>对象，可以对其调用<code>sum</code>方法，这会返回一个<code>long</code>值。</p><p><strong>注意：</strong> 第二次计算平均年龄时，再对所有值求和是多余的。然而，上例中这样写是为了展示<code>sum</code>函数的调用方法。</p><p>最后一个循环基于串流计算平均年龄。注意<code>parallelStream</code>方法，它是 Java 8 中流式计算的并行版本，返回结果也不是简单的<code>double</code>，而是<code>OptionalDouble</code>。</p><blockquote><p><code>parallelStream</code>提供了一种并发处理集合元素的方法，以上文的列表求平均值为例，如果一共有 100 个元素，<code>parallelStream</code>会将任务分为 n 份（n 是线程池的大小，默认为 CPU 核数），每份任务交由单独一个线程处理，最终再汇总这些任务的结果，得出平均值</p></blockquote><h2 id="资源下载-3"><a href="#资源下载-3" class="headerlink" title="资源下载"></a>资源下载</h2><p>本小节中的NetBeans工程样例代码可以在下面下载到</p><p><a href="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/Lambda-QuickStart/examples/LambdaCollectionExamples.zip" target="_blank" rel="noopener">LambdaCollectionExamples.zip</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在本篇指南中，你学会了使用以下技能：</p><ul><li>Java 匿名内部类</li><li>使用 Java SE 8 的 Lambda 表达式代替匿名内部类</li><li>Lambda 表达式的语法</li><li>通过<code>Predicate</code>接口在列表中查找</li><li>通过<code>Function</code>接口处理对象，并得到一个新类型的对象</li><li>Java SE 8 中新增的支持 Lambda 表达式的集合特性</li></ul><h2 id="更多资源"><a href="#更多资源" class="headerlink" title="更多资源"></a>更多资源</h2><p>如果你想要了解更多关于 Lambda 表达式和 Java SE 8 的信息，参考以下链接：</p><ul><li><a href="http://openjdk.java.net/projects/jdk8/" target="_blank" rel="noopener">Java 8</a></li><li><a href="http://openjdk.java.net/projects/lambda/" target="_blank" rel="noopener">Project Lambda</a></li><li><a href="http://cr.openjdk.java.net/~briangoetz/lambda/lambda-state-4.html" target="_blank" rel="noopener">State of the Lambda</a></li><li><a href="http://cr.openjdk.java.net/~briangoetz/lambda/sotc3.html" target="_blank" rel="noopener">State of the Lambda Collections</a></li><li><a href="http://www.youtube.com/watch?v=bzO5GSujdqI" target="_blank" rel="noopener">Jump-Starting Lambda JavaOne 2012(You Tube)</a></li><li>若想要学习更多关于 Java 的内容，请点击<a href="http://www.oracle.com/goto/oll" target="_blank" rel="noopener">Oracle Learning Library</a></li></ul><h2 id="著者"><a href="#著者" class="headerlink" title="著者"></a>著者</h2><ul><li>课程组长：Michael Williams</li><li>QA：Juan Quesada Nunez</li><li>翻译：李磊</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文是对&lt;a href=&quot;https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/Lambda-QuickStart/index.html&quot; target=&quot;_blank&quot; r
      
    
    </summary>
    
    
      <category term="Java" scheme="https://lilei.pro/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>香帅的北大金融学课（二）金融机构</title>
    <link href="https://lilei.pro/2018/09/23/finance-Xiangshuai-week02/"/>
    <id>https://lilei.pro/2018/09/23/finance-Xiangshuai-week02/</id>
    <published>2018-09-23T00:37:54.000Z</published>
    <updated>2018-11-05T16:21:07.134Z</updated>
    
    <content type="html"><![CDATA[<h1 id="货币与信用"><a href="#货币与信用" class="headerlink" title="货币与信用"></a>货币与信用</h1><p>银行体系在整个社会经济中，处于枢纽地位。国家通过银行体系进行信用创造，调控经济，这是现代经济运行的一个最重要特征。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/180923_finance/银行货币信用扩张机制.png" alt="银行货币信用扩张机制" title="">                </div>                <div class="image-caption">银行货币信用扩张机制</div>            </figure><h2 id="货币的背后是国家信用"><a href="#货币的背后是国家信用" class="headerlink" title="货币的背后是国家信用"></a>货币的背后是国家信用</h2><p>货币的真名叫做“法定货币”，也就是国家赋予某个银行（比如中央银行）的一种特许权力而发行的，它背后的关键是国家信用。布雷顿森林会议上确立了美元在国际货币体系中“锚”的地位，美元成为了国际计价结算的储备货币，变成了国际货币体系的中心。现代的货币是信用货币，货币价值的浮动完全取决于一个国家的实力和其他国家对于这个国家的信心。</p><p>所以说没有国家信用加持的货币，即使可以完成计价、储藏、交换的功能，它也不能够成为通用的货币——比特币最根本的缺陷来源于此，像比特币这样去中心化的货币，要取代各国央行发行的法定货币，还是路漫漫其修远兮。</p><h2 id="存款准备金率和“降准”"><a href="#存款准备金率和“降准”" class="headerlink" title="存款准备金率和“降准”"></a>存款准备金率和“降准”</h2><p>前面讲到银行与国家强强联合，共同铸造了当代信用社会。国家通过银行体系，调控整个社会的信用规模和经济冷热。我们经常在电视新闻里听到“降息”、“降准”这样的词汇，“息”指的是基础利率，“准”指的是存款准备金率。</p><h3 id="什么是存款准备金率"><a href="#什么是存款准备金率" class="headerlink" title="什么是存款准备金率"></a>什么是存款准备金率</h3><p>储户要把钱存到银行里，银行再放贷出去，然后形成企业、个人的各种贷款，支持消费生产。但是，<strong>每天都有不同的储户有提现的要求，所以银行必须留存一小部分钱出来应付储户提现的需求，这部分钱就叫做存款准备金，这个留存的比例就叫存款准备金率。</strong></p><h3 id="存款准备金率如何生效的呢？"><a href="#存款准备金率如何生效的呢？" class="headerlink" title="存款准备金率如何生效的呢？"></a>存款准备金率如何生效的呢？</h3><p>假如小明有 100 块钱，他可以把这 100 块钱存到银行里，当时的存款准备金率是 10%，意味着银行必须预留出 100 块钱的 10%，也就是 10 块钱的现金，来预备应付小明的提现需求。去掉这 10% 后，银行可以把剩下的 90 块钱通过贷款的方式发放给小红。那么市面上一共有多少货币流通的，是 100（小明）+ 90（小红）= 190 元。小红同样可以选择把这 90 块钱存进银行，银行则在保留了 90 * 10% = 9 元的存款准备金后，将剩余 81 元发放出去……最终计算下来，小明持有的 100 元钱，经过层层转化，流动到社会中的钱可以达到 1000 元，整整扩张了 10 倍。这就是存款准备金的威力。</p><p>平时新闻里总是听到，基础货币（M0），广义货币（M2）这种词。在这个例子里，100 元就是基础货币，1000 元就是广义货币，央行发行的这个货币就叫基础货币，在 10% 的存款准备金率下，通过商业银行体系的循环之后，社会上的货币供应量扩张了整整 10 倍。<strong>这个倍数其实你算一下，就是存款准备金率的倒数 10，所以也叫货币乘数。</strong></p><p>存款准备金制度是国家宏观上把控货币扩张的手段，<strong>银行放贷的意愿，我们个人、企业的现金持有量</strong>，都会影响到货币扩张的机制。</p><h2 id="基准利率和“加息”"><a href="#基准利率和“加息”" class="headerlink" title="基准利率和“加息”"></a>基准利率和“加息”</h2><p>现代经济运行最重要的逻辑，就是国家通过银行体系，来调控整个社会的信用规模和经济冷热。其中，<strong>存款准备金制度</strong> 和 <strong>基准利率</strong> 是两个最重要的调控手段。它们为什么重要呢？<strong>存款准备金制度主要是控制了资金的量，而基准利率调整的是资金的价格</strong>。</p><h2 id="什么是基准利率"><a href="#什么是基准利率" class="headerlink" title="什么是基准利率"></a>什么是基准利率</h2><p>基准利率就是一个市场上利率水平的风向标。各个金融机构，都根据这个标准来确定自己的贷款和存款利率。政府如果担心经济过热的话，就会加息，也就是提高利率进行收缩。如果想要刺激经济，就会采取降息的措施。</p><p>加息和降息的尺度其实非常难把握，过猛的加息可能会导致经济的突然崩盘，而过度的降息可能会导致经济泡沫。</p><h2 id="学金融为什么要先了解宏观背景"><a href="#学金融为什么要先了解宏观背景" class="headerlink" title="学金融为什么要先了解宏观背景"></a>学金融为什么要先了解宏观背景</h2><ul><li>世界上从来就不存在独立的微观金融现象，它的背后一定有某种宏观层面的逻辑或者推动力。</li><li>我们中国市场是一个强政府指导下的逐步开放的金融市场，所以政府在这个市场的影响力是很深的。</li><li>从宏观视角来理解微观金融现象，最后才能做出适合自己的金融决策。</li></ul><h2 id="学习金融的三个阶段"><a href="#学习金融的三个阶段" class="headerlink" title="学习金融的三个阶段"></a>学习金融的三个阶段</h2><ol><li>概念、术语通关，也就是说在这个阶段，你会接触到大量的金融术语，然后理解这些词语——降准、降息、影子银行、IPO、PE、VC，你得把握这些词的概念，然后建立一个自己对金融市场的体感，这是第一个阶段。</li><li>框架通关。这就是说，要求你建立一个金融思考的框架。我们现在面临的是一个信息爆炸的时代，市场上其实错误的信息是很多的，比如说你经常会听到什么“货币超发”、“货币战争”这些词语，这里面有很多的逻辑硬伤。在概念通关的基础上，你要学着建立一个自己的金融思维的框架，辨别这些信息。</li><li>实操通关，这就是要求你运用金融框架来解决问题，在这个阶段，我会给你一些模拟的宏观环境，让你置身在一个具体的场景里面，这个时候你要开始运用自己在前面学到的很多知识进行判断，进行操作、投资、商业决策、金融运作等等。</li></ol><hr><h1 id="银行与理财"><a href="#银行与理财" class="headerlink" title="银行与理财"></a>银行与理财</h1><h2 id="银行躺着赚钱的秘密"><a href="#银行躺着赚钱的秘密" class="headerlink" title="银行躺着赚钱的秘密"></a>银行躺着赚钱的秘密</h2><blockquote><p>2017年全球最赚钱的5家公司，中国占了其中4家，分别是工农中建四大行。去年招行平均薪水46万，上海银行45万。</p></blockquote><p>从2003年到2012年这十年，被称为“中国银行业的黄金十年”。</p><h3 id="银行利润来源"><a href="#银行利润来源" class="headerlink" title="银行利润来源"></a>银行利润来源</h3><ul><li>3/4，存贷差</li><li>1/4，银行投资，通道费用</li></ul><p>银行解决了资金匹配上的规模、期限和风险问题，所以它会产生大量收益。</p><h3 id="为什么在中国会发生“黄金十年”？"><a href="#为什么在中国会发生“黄金十年”？" class="headerlink" title="为什么在中国会发生“黄金十年”？"></a>为什么在中国会发生“黄金十年”？</h3><ol><li>金融准入门槛高，牌照控制严格，而且国家在2000年以后对存款利率实行严格管制，在2012年利率市场化之前，利率一直维持在3%左右</li><li>国家经济高速增长的十年，投资机会多、利润高，产生大量的贷款需求</li></ol><h3 id="银行业贫富分化的新业态"><a href="#银行业贫富分化的新业态" class="headerlink" title="银行业贫富分化的新业态"></a>银行业贫富分化的新业态</h3><p>由于准入门槛降低（银行个数从2000年的40家发展到4000家）、利率市场化，在马太效应下，银行业两极分化，四大行依旧是巨头，股份制银行各辟蹊径，城商行状态欠佳。所有银行都赚钱的好日子过去了。</p><h2 id="货币基金和银行"><a href="#货币基金和银行" class="headerlink" title="货币基金和银行"></a>货币基金和银行</h2><h3 id="银行间货币市场"><a href="#银行间货币市场" class="headerlink" title="银行间货币市场"></a>银行间货币市场</h3><p><strong>银行间货币市场</strong>：银行会有资金短缺和盈余的时候，所以会互相借钱，称为银行间的货币拆借，形成银行间市场。它是一个大额的、短期的资金拆借市场。</p><p><strong>货币基金</strong> 就是美国70年代利率管制下的金融创新、投资银行通过募集资金、投入银行间货币市场来获取利润。货币基金的出现是美国金融自由化的一个标志性事件。</p><p>对老百姓来说，货币基金提供了一个加入高收益的银行间货币市场的途径，让一小部分利润从银行流回老百姓手中。对银行来说，货币基金为其敲响了警钟，促使银行推出更多的货币基金产品。</p><h3 id="货币基金收益率"><a href="#货币基金收益率" class="headerlink" title="货币基金收益率"></a>货币基金收益率</h3><p>货币基金利率的上下浮动，主要是跟随银行间市场波动。市面上的钱越紧张（钱荒），货币市场越火热，货币基金收益率越高。反之，市面上钱越多，货币基金利率越低。</p><h2 id="银行非保本理财产品"><a href="#银行非保本理财产品" class="headerlink" title="银行非保本理财产品"></a>银行非保本理财产品</h2><h3 id="影子银行"><a href="#影子银行" class="headerlink" title="影子银行"></a>影子银行</h3><p>银行收到严格的监管，它有绕开监管的冲动。在中国的银行金融体系中，银行占据着绝对主导地位，因为只有银行能吸收存款，募资也比其他机构容易得多。中国240万亿的金融总资产里面，银行占了90%以上。</p><ul><li>银行受到监管多，募资能力强。</li><li>其他金融机构钱少，受到监管宽松。</li></ul><p>信托、基金这些机构通过银行募集资金，把这些钱投到当时利润最高的行业和市场中去，绕开监管，大家一起赚钱，这些业务就是影子银行。最典型的就是银行和信托联手的“银信合作”业务，2010年的房地产市场，2014年的股票证券市场，都有银行和信托、券商合作的因素。</p><p>中国的影子银行就是一个金融机构和金融监管之间猫捉老鼠的游戏。</p><p>在这些业务中，银行充当通道作用，但是如果项目失败，银行不负有保本责任。</p><h3 id="判别非保本理财产品是否靠谱的四个基本原则"><a href="#判别非保本理财产品是否靠谱的四个基本原则" class="headerlink" title="判别非保本理财产品是否靠谱的四个基本原则"></a>判别非保本理财产品是否靠谱的四个基本原则</h3><ol><li>在产品说明书上要特别注意产品的投向，如果它偷网的是现金贷、小额贷、消费贷这类的产品，在当前的大背景下要非常谨慎</li><li>如果是银行代销，意味着银行充当的只是中间人角色，你不会知道产品最后投到哪里，信息不对称太大，难以把握，不建议投资</li><li>注意募资方信息，不要被名头唬到，要对产品本身做一些研究和了解</li><li>如果利率过高就要小心，但是怎样判断利率过高？可以根据基准利率做判断，比如当前半年期基准贷款利率是4.35%，五年期以上的是4.9%，在这以上上浮10%、20%都是正常的范畴。5%的银行理财产品收益并不算太高</li></ol><h3 id="什么样的货币基金值得买"><a href="#什么样的货币基金值得买" class="headerlink" title="什么样的货币基金值得买"></a>什么样的货币基金值得买</h3><p>中国市场上有5万多亿的资金都在货币基金上，一共300多种产品，怎样挑选安全、收益率更高的？</p><h4 id="挑选货币基金的两大原则"><a href="#挑选货币基金的两大原则" class="headerlink" title="挑选货币基金的两大原则"></a>挑选货币基金的两大原则</h4><p><strong>安全性与流动性原则——挑选散户比例高的货币基金</strong></p><p>机构型的货基，申购赎回都非常频繁，散户经常反应过慢，会受到资金量大的机构影响。这种基金由于机构频繁购买赎回产生的流动性风险，成为“基金挤兑”（Fund Run），这会导致基金波动很大，不够稳健。</p><p>如果一个货基的散户利率达到70%以上，就可以认为是散户型基金，流动性风险就非常低了。出于收益率考虑，这个标准可以放宽到60%。</p><p><strong>收益率原则——挑选规模适中的货币基金</strong></p><p>货基的收益率和它的货基规模，呈现一个倒U型的关系，基金规模太小（&lt;50亿）或者太大（&gt;1000亿）都会导致收益率过低。挑选货基时应当挑选100亿到400亿这样中等规模的基金。</p><p>以下是香帅团队在2018年初根据以上原则挑选出的几支基金。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/180923_finance/一些值得购买的基金.jpeg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="货币基金申购赎回的三个小窍门"><a href="#货币基金申购赎回的三个小窍门" class="headerlink" title="货币基金申购赎回的三个小窍门"></a>货币基金申购赎回的三个小窍门</h4><ol><li>避开T+2、T+3的基金，因为这会对基金流动性造成一定损失</li><li>基金交易按照工作日来计算，周五不买入，周四不赎回。如果在周五买入，T+1型基金应当在周六赎回，而周六非工作日，就只能在下周一赎回，变成了T+3型基金。“周四不赎回”是因为你如果在周四赎回了，就会变成“周五买入”</li><li>货币基金的投资方向应该是一个短期的货币工具，市场上资金的紧张与否是货基收益率的关键，资金越紧张，收益率越高。一般来说月末、季末、年中、年底时，市场上货币最紧张，在这些时候购买货基也是收益率相对比较高的。</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/180923_finance/货基选择2原则3窍门.jpeg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="一些在线购买货币基金的渠道"><a href="#一些在线购买货币基金的渠道" class="headerlink" title="一些在线购买货币基金的渠道"></a>一些在线购买货币基金的渠道</h4><ul><li>天天基金</li><li>好买基金</li><li>数米基金</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;货币与信用&quot;&gt;&lt;a href=&quot;#货币与信用&quot; class=&quot;headerlink&quot; title=&quot;货币与信用&quot;&gt;&lt;/a&gt;货币与信用&lt;/h1&gt;&lt;p&gt;银行体系在整个社会经济中，处于枢纽地位。国家通过银行体系进行信用创造，调控经济，这是现代经济运行的一个最重要特征。&lt;
      
    
    </summary>
    
    
      <category term="金融学" scheme="https://lilei.pro/tags/%E9%87%91%E8%9E%8D%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>香帅的北大金融学课（一）金融世界观</title>
    <link href="https://lilei.pro/2018/09/09/finance-Xiangshuai-week01/"/>
    <id>https://lilei.pro/2018/09/09/finance-Xiangshuai-week01/</id>
    <published>2018-09-09T03:59:01.000Z</published>
    <updated>2018-09-22T14:45:15.784Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>学习“得到App”中《香帅的北大金融学课》笔记</p></blockquote><h1 id="第一周：金融的本质"><a href="#第一周：金融的本质" class="headerlink" title="第一周：金融的本质"></a>第一周：金融的本质</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/180909_finance/金融的本质.jpg" alt="金融的本质" title="">                </div>                <div class="image-caption">金融的本质</div>            </figure><p>金融并不是高高在上、只存在于银行家和证券分析师口中的神秘事物，它与每一个普通人息息相关，不论是菜贩、打工者、服务员，只要你活在时间的河流中，就一定会与金融发生这样那样的关系。</p><h2 id="金融的第一定理——时间的价值"><a href="#金融的第一定理——时间的价值" class="headerlink" title="金融的第一定理——时间的价值"></a>金融的第一定理——时间的价值</h2><blockquote><p>时间就是金钱</p></blockquote><p>时间是可以被换算成金钱的，我们每个人拥有的时间数量是相同的，上帝给每个人的时间一个基础定价（质量），我们再利用各自选择的金融工具，放大/缩小各自拥有的时间价值。这在金融学里被称作“货币的时间价值”（time value of money）。</p><p>金融为时间定价，我们这些购买金融产品、做出金融决策的人，就是购买了不同的未来价值。</p><h2 id="金融的第二定理——资金的集聚"><a href="#金融的第二定理——资金的集聚" class="headerlink" title="金融的第二定理——资金的集聚"></a>金融的第二定理——资金的集聚</h2><p>人类面临两个约束：时间和资金，经济学上将资金的约束称为“稀缺”。越是伟大的事物，越需要资金的<strong>快速集聚</strong>和<strong>有效配置</strong>，这种功能只有金融可以实现。金融帮助我们突破时间和地域的限制，进行快速有效的资金集聚。</p><h2 id="金融的第三定理——分散风险"><a href="#金融的第三定理——分散风险" class="headerlink" title="金融的第三定理——分散风险"></a>金融的第三定理——分散风险</h2><p>金融使人类对风险的承受能力突破地域和时间限制，拓展人类经济活动范围</p><ul><li>保险将个体承受的风险分散到社会群体之间</li><li>股票起到的作用是利益共享、风险共担。</li><li>风投、创投让社会分担创业创新的风险</li></ul><h2 id="辩证看待金融世界观"><a href="#辩证看待金融世界观" class="headerlink" title="辩证看待金融世界观"></a>辩证看待金融世界观</h2><p>金融赋能人类，帮助我们扩大时间价值、进行资金的集聚，分散风险。金融同样也有负面的作用，比如<strong>马太效应</strong>和<strong>道德风险</strong>。</p><p>金融的基础知识可以分为以下六个板块</p><ul><li>金融机构：银行、投行、基金的起源、功能、运作模式，以及背后的金融学逻辑</li><li>金融工具：股票、债券、金融衍生品的本质和特征，金融机构如何开拓市场，金融交易制度</li><li>投资者决策：资产配置、证券选择、非理性决策</li><li>公司决策：筹资的时机和方法，上市时机，分红策略，股权激励</li><li>金融的监管、创新和危机：“监管、创新、危机”的金融周期</li><li>科技金融：金融行业未来的发展，互联网，区块链，比特币</li></ul><p>金融学带来金融思维，它让我们学会权衡风险和收益，不仅投资金钱，更是投资人生。</p><hr><h1 id="第二周-金融市场的历史演化过程"><a href="#第二周-金融市场的历史演化过程" class="headerlink" title="第二周 金融市场的历史演化过程"></a>第二周 金融市场的历史演化过程</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/180909_finance/金融市场的历史演化.jpeg" alt="金融市场的历史演化" title="">                </div>                <div class="image-caption">金融市场的历史演化</div>            </figure><h2 id="中国金融市场的制度根源——中央货币财政体系"><a href="#中国金融市场的制度根源——中央货币财政体系" class="headerlink" title="中国金融市场的制度根源——中央货币财政体系"></a>中国金融市场的制度根源——中央货币财政体系</h2><p><strong>所有的金融市场都不是凭空出现的，它的形成背后都有一个强大的历史制度根源。</strong></p><p>中国的金融市场是从一个中央集权的帝国内部演化来的，早期的金融发达也来源于这样的封建专制制度，国家垄断了金融行业，经济生活国有化，可以集中力量办大事。</p><p>这种经济制度的缺点是民间信用极其脆弱，民众的融资需求得不到满足，造成中国金融市场很多乱象。</p><h2 id="欧美金融市场的演化——以银行为中心，分权制衡下的信用体系"><a href="#欧美金融市场的演化——以银行为中心，分权制衡下的信用体系" class="headerlink" title="欧美金融市场的演化——以银行为中心，分权制衡下的信用体系"></a>欧美金融市场的演化——以银行为中心，分权制衡下的信用体系</h2><p>欧美的金融市场也不是一开始就像现在这样成熟，而是从11世纪以后慢慢发展起来的</p><p>圣殿骑士团奠定欧洲银行业基础 -&gt; 意大利银行业、荷兰股票证券、英法银行业逐渐形成分权制衡信用体系 -&gt; 美国的金融立国，称为世界上最发达的金融市场。我们现在所看到的欧美信用社会，是由于欧洲分权制衡的形态所决定的。</p><p>历史不能依靠简单的拿来主义，它是一个路径相依的过程。</p><h2 id="金融机构用于消除金融市场上的信息不对称"><a href="#金融机构用于消除金融市场上的信息不对称" class="headerlink" title="金融机构用于消除金融市场上的信息不对称"></a>金融机构用于消除金融市场上的信息不对称</h2><p>金融市场上交易的是“信用”、“未来”，是看不见摸不到的抽象物品，存在巨大的<strong>信息不对称</strong>，金融中介的存在就是为了消除信息不对称。各种审计机构、会计师事务所、券商银行都属于金融中介。</p><p>没有金融中介机构，金融市场是无法运行的，金融市场的高度中介化是必然的结果。</p><hr><h1 id="延展话题：个人资产配置的生命周期"><a href="#延展话题：个人资产配置的生命周期" class="headerlink" title="延展话题：个人资产配置的生命周期"></a>延展话题：个人资产配置的生命周期</h1><ul><li>青年时期：最大的优势是时间，加大实物资产配置，以时间换空间，增大年轻时期资本积累</li><li>壮年时期：现金收入高，风险承受能力强。应该加大风险资产配置；身份角色的转换，需要资产的多元化配置</li><li>老年时期：未来时间变少，风险承受能力减弱，加大安全资产配置，同时加大流动性资产配置，保障现金流</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;学习“得到App”中《香帅的北大金融学课》笔记&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;第一周：金融的本质&quot;&gt;&lt;a href=&quot;#第一周：金融的本质&quot; class=&quot;headerlink&quot; title=&quot;第一周：金融的本质&quot;&gt;&lt;/a&gt;第
      
    
    </summary>
    
    
      <category term="金融学" scheme="https://lilei.pro/tags/%E9%87%91%E8%9E%8D%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>深入理解 Java 虚拟机（三）垃圾收集器与内存分配策略</title>
    <link href="https://lilei.pro/2018/08/15/JVM-Note-03/"/>
    <id>https://lilei.pro/2018/08/15/JVM-Note-03/</id>
    <published>2018-08-15T09:26:32.000Z</published>
    <updated>2018-08-30T10:03:04.408Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本章介绍垃圾收集器的设计思路、算法以及常见实现，同时介绍为对象分配空间时采取的策略。</p></blockquote><h1 id="垃圾收集（Garbage-Collection）"><a href="#垃圾收集（Garbage-Collection）" class="headerlink" title="垃圾收集（Garbage Collection）"></a>垃圾收集（Garbage Collection）</h1><p>GC 的历史比 Java 久远，1960 年诞生于 MIT 的 Lisp 是第一门真正使用内存动态分配和垃圾回收技术的语言。不论是什么语言，在设计 GC 时都必须要解决以下三个问题：</p><ul><li>哪些内存需要回收（Who）</li><li>什么时候回收（When）</li><li>如何回收（How）</li></ul><p>也许你要问，虚拟机已经为我们完成了内存回收的工作，目前内存的动态分配与回收技术已经相当成熟，一切都进入了“自动化”时代，我们为什么还要去了解 GC 和内存分配呢？答案很简单，当我们需要排查各种内存溢出、泄漏问题时，当垃圾收集称为系统达到更高并发量的瓶颈时，就必须要对这些“自动化”的技术进行必要的监控和调节。</p><p>在上一章的学习中，我们了解到 JVM 的内存可以划分为线程私有部分（虚拟机栈、本地方法栈、程序计数器）和公有部分（堆、方法区），其中线程私有部分所申请的内存，随着线程运行结束而销毁，在这个区域的内存分配和回收具备确定性。公有部分的方法区，其分配多少内存在编译期间也可以确认，因此，需要考虑内存回收的区域主要是 Java 堆，堆中的对象是运行时创建的，它们的创建和回收都是动态的，这是垃圾收集器关注的区域。</p><h1 id="对象已死吗？"><a href="#对象已死吗？" class="headerlink" title="对象已死吗？"></a>对象已死吗？</h1><h2 id="引用计数器法"><a href="#引用计数器法" class="headerlink" title="引用计数器法"></a>引用计数器法</h2><p>引用计数器法（Reference Counting）是一种实现起来很简单的判断对象是否存活的方法。原理是当出现一个对对象的引用时，计数器 +1；当引用失效时，计数器 -1，计数器值为 0 则表示对象已死。它的优点是实现简单，判定效率高，在大部分情况下都是不错的算法，也有很多著名的应用案例：</p><ul><li>M$ 的 COM（Component Object Model）技术</li><li>试用 AS3 的 FlashPlayer</li><li>Python</li><li>Squirrel</li></ul><p>引用计数器发存在循环引用的问题，因此主流 Java 虚拟机没有选用这种方法来管理内存。</p><h2 id="可达性分析法"><a href="#可达性分析法" class="headerlink" title="可达性分析法"></a>可达性分析法</h2><p>主流商用程序语言（Java、C#、Lisp）使用可达性分析（Reachability Analysis）方法来判定对象是否存活：</p><ol><li>从一系列 GC Roots 节点开始向下搜索，搜索走过的路径称为引用链（Reference Chain）</li><li>当一个对象到 GC Roots 没有任何引用链相连（不可达）时，证明此对象是不可用的</li></ol><p>在 Java 中的 GC Roots 有以下几种</p><ul><li>虚拟机栈（栈帧中的本地变量表）引用的对象</li><li>本地方法栈中 JNI 引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li></ul><p>可见 GC Roots 节点主要有全局性引用和执行上下文这两个来源。</p><h2 id="JDK-1-2-后的几种引用"><a href="#JDK-1-2-后的几种引用" class="headerlink" title="JDK 1.2 后的几种引用"></a>JDK 1.2 后的几种引用</h2><p>在 Java 1.2 之前，对“引用”的定义很传统：如果 reference 类型的数据中存储的数值代表的是另一块内存的起始地址，就称为这块内存代表着一个引用。这种定义很纯粹但是太过狭隘，一个对象在这种定义下只有被引用或者没有被引用两种状态。我们希望描述这样一类对象：当内存空间还足够时，则能保存在内存之中；如果内存空间在进行 GC 后还是非常紧张，则可以抛弃这些对象。在 JDK 1.2 之后，Java 对引用的概念进行了扩充，将引用分为“强软弱虚”四种：</p><ul><li>强引用（Strong Reference）：指在程序代码之中普遍存在的，类似“Object obj = new Object()”这类的引用，只要强引用还存在，垃圾收集器 <strong>永远不会</strong> 回收掉被引用的对象</li><li>软引用（Soft Reference）：用来描述一些 <strong>还有用但非必需</strong> 的对象，对于软引用关联的对象，在系统将要发生内存溢出异常之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收还没有足够的内存，则会抛出 <strong>内存溢出异常</strong></li><li>弱引用（Weak Reference）：用来描述 <strong>非必需</strong> 对象，被弱引用关联的对象只能生存到下一次垃圾回收发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象</li><li>虚引用（Phantom Reference）：也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用获取对象实例。为一个对象设置虚引用关联的唯一目的就是能在它被收集器回收时收到一个系统通知</li></ul><h2 id="两次标记宣告对象死亡"><a href="#两次标记宣告对象死亡" class="headerlink" title="两次标记宣告对象死亡"></a>两次标记宣告对象死亡</h2><p>对于在可达性分析中被判断为“不可达”的对象，有一次进行自救的机会，要真正宣告一个对象死亡，需要经历两次标记过程：</p><ol><li>第一次标记：对象在可达性分析中被标记为“不可达”</li><li>第二次筛选：判断此对象是否有必要执行 finalize() 方法，以下两个条件满足其一时，可认为是“有必要”，a. 对象覆盖了 finalize() 方法；b. 对象的 finalize() 方法未被调用过</li></ol><p>对象被判断为“有必要执行 finalize()”时，是其最后一次自救机会，它会被放置在一个名为<code>F-Queue</code>的队列之中，并在稍后由一个虚拟机自动建立的、低优先级的 Finalizer 线程去执行 finalize() 方法，对象进行自救的唯一手段是在 finalize() 方法中建立与 GC Roots 的连接，譬如把自己（this 关键字）赋值给某个类变量或者对象的成员变量，这样会使得对象被移除出“即将回收”集合；换言之，如果这时候对象仍然未能自救，则会迎来死亡的命运。</p><p>需要注意的是，<strong>任何一个对象的 finalize() 方法只会被系统自动调用一次</strong>。在编码中我们应当尽量避免使用<code>finalize()</code>方法，因为它的运行代价高昂，不确定性大，并且无法保证各个对象的调用顺序。</p><h2 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h2><p>方法区（在 HotSpot 虚拟机中被称为“永久代”）也可以进行垃圾收集（虽然 Java 虚拟机规范中明确表示可以不要求在方法区实现垃圾收集）。不过在方法区中进行收集的“性价比”通常很低，在堆中常规应用进行一次垃圾收集一般可以回收 70%～95% 的空间，而永久代的垃圾收集效率远低于此。</p><p>永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。</p><p><strong>废弃常量</strong> 的回收与 Java 堆中对象回收十分类似，以字面量回收为例，假如一个字符串“abc”已经进入了常量池中，但是当前系统没有任何一个 String 对象是叫做“abc”的，也没有在其他任何地方引用了这个字面量，如果这时发生内存回收，在必要的情况下，“abc”常量会被清除出常量池。</p><p><strong>无用的类</strong> 的判断则要稍微复杂一些，需要同时满足以下三个条件，才“可以”被回收，注意不是“一定”而是“可以”</p><ul><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例</li><li>加载该类的 ClassLoader 已经被回收</li><li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li></ul><p>HotSpot 虚拟机提供了<code>-Xnoclassgc</code>参数进行控制无用的类回收。</p><h1 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h1><h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h2><p>最基本的收集算法是标记-清除（Mark-Sweep）算法，分为两个阶段：</p><ol><li>标记出所有需要回收的对象</li><li>统一回收所有被标记的对象</li></ol><p>标记-清除算法的示意图如下</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/180815_jvm_03/标记清除.jpeg" alt="标记清除" title="">                </div>                <div class="image-caption">标记清除</div>            </figure><p>标记-清除算法主要不足有两个</p><ol><li>效率问题，标记和清除的效率都不高</li><li>空间问题，清楚之后会产生大量不连续的内存碎片</li></ol><h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><p>复制（Copying）算法主要目的是解决效率问题，它将可用内存平均分为两个半区，每次只使用其中一个半区，在进行垃圾回收时，将仍存活的对象复制到另半区上，然后清空刚刚使用的半区。复制算法的实现简单运行高效，不足是空间利用率太低，只使用了一半的内存。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/180815_jvm_03/复制.jpg" alt="复制" title="">                </div>                <div class="image-caption">复制</div>            </figure><p>现在的商业虚拟机都采用复制算法来回收<strong>新生代</strong>，IBM 研究表明新生代中的对象多达 98% 是朝生夕死的，所以不需要按照 1:1 的比例来划分内存。而是将内存分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中一块 Survivor 空间（称为 From Survivor），在回收时将存活对象复制到另一块 Survivor 空间（称为 To Survivor），并清理掉 Eden 以及 From Survivor 空间。HotSpot 虚拟机默认对 Eden 和 Survivor 空间分配比例为 8:1。</p><p>当 GC 过程中发现 To Survivor 空间不够用时，需要依赖其他内存（老年代）进行分配担保（Handle Promotion）。</p><h2 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h2><p>复制算法对于对象存活率高的场景并不适用，因为需要频繁进行复制操作；并且它还需要额外空间进行分配担保。因此，在老年代中通常不使用复制算法进行内存回收，而是使用的标记-整理（Mark-Compact）算法：</p><ol><li>标记过程与“标记-清除”算法相同，先是标记出仍然存活的对象</li><li>把所有存活对象向一端移动</li><li>清理掉端边界以外的内存</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/180815_jvm_03/标记整理.png" alt="标记整理" title="">                </div>                <div class="image-caption">标记整理</div>            </figure><h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>当代商业虚拟机采用的都是分代收集算法（Generational Collection），将 Java 堆分为新生代和老年代，根据各个年代的特点采用最合适的收集算法。</p><ul><li>新生代：对象存活周期短，每次垃圾收集时有大量对象死去，只有少量存活，使用<strong>复制</strong>算法</li><li>老年代：对象存活周期长，存活率高，没有额外空间对它进行分配担保，采用<strong>标记-清除</strong>或者<strong>标记-整理</strong>算法</li></ul><h1 id="HotSpot-的算法实现"><a href="#HotSpot-的算法实现" class="headerlink" title="HotSpot 的算法实现"></a>HotSpot 的算法实现</h1><p>在虚拟机上实现之前所述的算法时，必需对算法的执行效率有严格考量，才能保证虚拟机高效运行。</p><h2 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h2><p>之前讲到作为 GC Roots 的区域主要是全局性引用（常量、类静态属性）和执行上下文（栈帧中的本地变量），很多应用仅仅方法区就有数百兆，如果逐个检查引用，必然会消耗很多时间。</p><p>此外，可达性分析对执行时间的敏感还体现在 <strong>GC 停顿</strong> 上，因为可达性分析必须在一个能确保一致性的快照中进行（分析过程中对象引用关系不可以发生变化），GC 时必须停顿所有的 Java 执行线程（称为 Stop The World）。</p><p>目前所有主流虚拟机采用的都是准确式 GC，当执行系统停顿下来时，虚拟机有办法知道，哪些地方存放着对象引用。在 HotSpot 实现中，使用一组称为 <strong>OopMap</strong> 的数据结构达成这个目的。在类加载完成时，HotSpot 把对象内什么偏移量上是什么类型的数据计算出来，在 JIT 编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。</p><h2 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h2><p>在 OopMap 协助下，HotSpot 可以快速且准确地完成 GC Roots 的枚举，然而存在一个很现实的问题：可能导致引用关系变化，或者说 OopMap 内容变化的指令非常多，如果为每一条指令都生成对应的 OopMap，将需要大量的额外空间，导致 GC 的空间成本非常高。</p><p>HotSpot 处理的方法是，并没有为每一条指令都生成 OopMap，只是在“特定的位置”记录这些信息，这些位置称为安全点（Safepoint），即程序执行时并非在所有地方都能停顿下来开始 GC，只有在到达安全点时才暂停。安全点的选定基本上是以程序“是否具有让程序长时间执行的特征”为标准进行选定的——因为每条指令执行的时间都非常短暂，程序不太可能因为指令流长度太长这个原因而过长时间运行。（<span style="color:red">这部分不理解</span>）</p><p>对于 Safepoint 另一个需要考虑的点是如何在 GC 时让所有线程都运行到安全点上停顿下来，这里有两种方案：</p><ul><li>抢先式中断（Preemptive Suspension）：GC 发生时中断所有线程，如果有线程中断地方不处于安全点，则让该线程运行至安全点。现在几乎没有虚拟机采用抢先式中断来暂停线程从而响应 GC 事件。</li><li>主动式中断（Voluntary Suspension）：当 GC 需要中断时，设置一个标志位。各个线程执行时主动轮询这个标志，发现中断标志为真时就自己中断挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。</li></ul><h2 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h2><p>Safepoint 机制保证程序执行时进入 GC 的可行性，但是，当程序不执行的时候（即没有分配 CPU 事件，例如线程处于 Sleep 状态或者 Blocked 状态），线程无法响应 JVM 的中断请求，无法轮询自然无法运行至安全点再中断挂起，<strong>安全区域</strong> （Safe Region）就是用来解决这种问题的。</p><blockquote><p>安全区域是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始 GC 都是安全的。可以把 Safe Region 看作是扩展了的 Safepoint。</p></blockquote><ul><li>当线程执行到 Safe Region 中的代码时，首先标识自己已经进入了 Safe Region</li><li>当这段时间里 JVM 需要发起 GC 时，对于标识自己为 Safe Region 状态的线程认为它是安全状态</li><li>当线程需要离开 Safe Region 时，检查系统是否已经完成了根节点枚举，如果完成则线程继续执行，否则等待直至收到可以安全离开 Safe Region 的信号为止</li></ul><h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><p>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。下图展示了 7 种作用于不同分代的垃圾收集器，存在连线的垃圾收集器可以搭配使用。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/180815_jvm_03/hotspot垃圾收集器.jpg" alt="HotSpot垃圾收集器" title="">                </div>                <div class="image-caption">HotSpot垃圾收集器</div>            </figure><h2 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h2><ul><li>最基本、发展历史最悠久的收集器</li><li>单线程，进行垃圾收集时必须暂停其他所有工作线程（Stop The World）</li><li>是虚拟机运行在 Client 模式下默认的 <strong>新生代收集器</strong>，在用户的桌面场景应用中，分配给虚拟机的内存一半不会很大，收集几十兆乃至一两百兆的新生代，停顿时间可以控制在 100 毫秒之内，可以接受</li><li>对于单个 CPU 的情况，没有线程交互的开销，可以获得最高的单线程收集效率</li></ul><h2 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h2><ul><li>Serial 收集器的多线程版本</li><li>许多运行在 Server 模式下的虚拟机首选的新生代收集器</li><li>只有它可以与 CMS（Concurrent Mark Sweep）收集器配合工作</li><li>在单 CPU 环境中，效率不如 Serial 收集器；默认开启的收集线程数与 CPU 数量相同</li></ul><h2 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h2><ul><li>新生代收集器，采用复制算法</li><li>关注点在于 <strong>达到可控制的吞吐量（Throughput）</strong>，<code>吞吐量 = 运行用户代码时间/(运行用户代码时间 + 垃圾收集时间)</code>，是一个百分数</li><li>停顿时间短的收集器（例如 CMS）适合与用户交互的程序；吞吐量高的收集器（例如 Parallel）适合后台运算而不需要太多交互的程序</li><li><strong>自适应调节策略</strong>：虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整参数以提供最合适的停顿时间或者最大的吞吐量</li></ul><h2 id="Serail-Old-收集器"><a href="#Serail-Old-收集器" class="headerlink" title="Serail Old 收集器"></a>Serail Old 收集器</h2><ul><li>Serial 收集器的老年代版本，单线程，“标记-整理”算法</li><li>主要意义在于给 Client 模式下的虚拟机使用</li></ul><h2 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h2><ul><li>Parallel Scanvenge 收集器的老年代版本，多线程，“标记-整理”算法</li><li>吞吐量优先：Parallel Scanvenge + Parallel Old</li></ul><h2 id="CMS（Concurrent-Mark-Sweep）收集器"><a href="#CMS（Concurrent-Mark-Sweep）收集器" class="headerlink" title="CMS（Concurrent Mark Sweep）收集器"></a>CMS（Concurrent Mark Sweep）收集器</h2><ul><li>以获取最短回收停顿时间为目标，应用于网站以及 B/S 系统的服务端，注重服务响应速度，希望停顿时间最短</li><li>基于“标记-清除”算法，收集过程分为四步</li></ul><ol><li>初始标记（CMS initial mark），标记 GC Roots 能直接关联到的对象</li><li>并发标记（CMS concurrent mark），进行 GC Roots Tracing</li><li>重新标记（CMS remark），修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录</li><li>并发清除（CMS concurrent sweep）</li></ol><ul><li>初始标记、重新标记这两个过程需要 Stop The World</li><li>有三个明显缺点</li></ul><ol><li>对 CPU 资源非常敏感，并发阶段会占用一部分线程（或者说 CPU 资源）导致用户程序变慢，吞吐量降低。CMS 默认启动的回收线程数是（CPU数量 + 3）/4，当 CPU 不足 4 个时，对用户程序影响可能变得很大</li><li>无法处理浮动垃圾（Floating Garbage），可能出现“Concurrent Mode Failute”而导致另一次 Full GC 发生。“浮动垃圾”是指并发清理阶段所产生的垃圾，必须为这部分垃圾提前预留空间，以供并发收集时程序运作使用</li><li>因为采用的是“标记-清理”算法，当空间碎片过多时，无法分配大对象，CMS 收集器提供<code>-XX:+UseCMSCompactAtFullCollection</code>参数，用来在 FullGC 时开启压缩</li></ol><h2 id="G1（Garbage-First）-收集器"><a href="#G1（Garbage-First）-收集器" class="headerlink" title="G1（Garbage-First） 收集器"></a>G1（Garbage-First） 收集器</h2><ul><li>JDK 1.7 正式推出（7u4），面向服务端应用</li><li><strong>特点</strong>：并行与并发，分代收集，空间整合，可预测的停顿</li><li><strong>过程</strong>：将 Java 堆划分为多个大小相等的独立区域（Region），避免在整个 Java 堆中进行全区域的垃圾收集，而是追踪哥哥 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小及回收所需时间的经验值），在后台维护一个悠闲列表，每次根据允许的收集时间，优先回收价值最大的 Region（也是 Garbage-First 名字由来）</li><li>分为 4 个步骤</li></ul><ol><li>初始标记</li><li>并发标记</li><li>最终标记</li><li>筛选回收</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本章介绍垃圾收集器的设计思路、算法以及常见实现，同时介绍为对象分配空间时采取的策略。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;垃圾收集（Garbage-Collection）&quot;&gt;&lt;a href=&quot;#垃圾收集（Garbage-Collec
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://lilei.pro/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JVM" scheme="https://lilei.pro/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>深入理解 Java 虚拟机（二）JVM 内存区域与内存溢出异常</title>
    <link href="https://lilei.pro/2018/08/09/JVM-Note-02/"/>
    <id>https://lilei.pro/2018/08/09/JVM-Note-02/</id>
    <published>2018-08-09T07:30:23.000Z</published>
    <updated>2018-08-10T04:33:46.292Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本章从概念上介绍 Java 虚拟机内存的各个区域，从作用、服务对象、可能产生的问题几个方面进行讲解。</p></blockquote><h1 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h1><p>根据《Java 虚拟机运行规范》的规定，Java 虚拟机所管理的内存将会包括以下几个运行时区域：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/180809_jvm_02/虚拟机数据分区.png" alt="虚拟机数据分区" title="">                </div>                <div class="image-caption">虚拟机数据分区</div>            </figure> <ul><li>线程私有：程序计数器，虚拟机栈，本地方法栈</li><li>线程共享：堆，方法区</li></ul><h2 id="程序计数器（Program-Counter-Register）"><a href="#程序计数器（Program-Counter-Register）" class="headerlink" title="程序计数器（Program Counter Register）"></a>程序计数器（Program Counter Register）</h2><p>程序计数器是一块较小的内存空间，可以看作是当前线程执行的字节码行号指示器，JVM 通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能。</p><p>程序计数器空间是私有的，原因在于 Java 虚拟机是通过线程轮流切换并分配处理器时间来实现的多线程，为了线程切换后能恢复到正确的执行位置，每个线程都需要一个独立的程序计数器。</p><ul><li>如果线程正在执行 Java 方法，则程序计数器记录的是虚拟机字节码指令地址</li><li>如果线程正在执行 Native 方法，则程序计数器值为空（Undefined）</li></ul><p>程序计数器是唯一一个在 Java 虚拟机规范中不会发生 OutOfMemoryError 的区域。</p><h2 id="Java-虚拟机栈（Java-Virtual-Machine-Stacks）"><a href="#Java-虚拟机栈（Java-Virtual-Machine-Stacks）" class="headerlink" title="Java 虚拟机栈（Java Virtual Machine Stacks）"></a>Java 虚拟机栈（Java Virtual Machine Stacks）</h2><p>描述 Java 方法执行的内存模型：每个方法在执行时都会创建一个栈帧（Stack Frame），用于存储局部变量表、操作数栈、动态链接、方法出口等信息。方法运行从开始到结束，对应的是栈帧在虚拟机栈中入栈及出栈的过程。以下着重介绍<strong>局部变量表</strong>。</p><p>局部变量表存放以下类型的变量，其中 64 位长度的 long 和 double 类型数据会占用 2 个局部变量空间（Slot），其余数据类型只占据 1 个。</p><ul><li>编译期已知的各种基本数据类型：boolean、byte、char、short、int、float、long、double</li><li>对象引用：reference 类型，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置</li><li>returnAddress 类型：指向字节码指令地址</li></ul><p>局部变量表所需的内促农建在编译期间完成分配，在方法运行期间不会更改局部变量表的大小。</p><p>在 Java 虚拟机规范中，对这个区域规定了两种异常情况：</p><ol><li>StackOverflowError: 线程请求的栈深度大于虚拟机所允许的深度</li><li>OutOfMemoryError: 虚拟机栈进行动态扩展时无法申请到足够的内存</li></ol><h2 id="本地方法栈（Native-Method-Stack）"><a href="#本地方法栈（Native-Method-Stack）" class="headerlink" title="本地方法栈（Native Method Stack）"></a>本地方法栈（Native Method Stack）</h2><p>类似于虚拟机栈，只不过本地方法栈是为本地方法服务。同样会抛出 StackOverflowError 和 OutOfMemoryError。</p><h2 id="Java-堆（Heap）"><a href="#Java-堆（Heap）" class="headerlink" title="Java 堆（Heap）"></a>Java 堆（Heap）</h2><p>是 Java 虚拟机所管理的内存中最大的一块区域，被所有线程共享。堆存在的唯一意义是存放对象实例，在 Java 虚拟机规范中的表述是“所有的对象和数组都要在堆上分配”。但是随着 JIT 编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致这一规则不再那么绝对。GC 就是对堆上的对象进行回收。堆区域空间不足会导致 OOM。</p><h2 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h2><p>也是线程共享的区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。别名 Non-Heap。HotSpot 虚拟机设计团队选择把 GC 分代收集扩展至方法区，导致也有人称呼方法区为“永久代”（Permanent Generation），但这并不是一个好的实践，会导致内存溢出问题，而且极少数的方法会因为这个原因而在不同虚拟机上产生不同表现。</p><p>垃圾收集行为在方法区是较少出现的，而且回收率不高，回收目标主要是针对常量池的回收和对类型的卸载。</p><p><strong>运行时常量池（Runtime Constant Pool）</strong> 是方法区的一部分，Class 文件除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期间生成的各种字面量和符号引用。可能会抛出 OOM 异常。</p><h2 id="直接内存（Direct-Memory）"><a href="#直接内存（Direct-Memory）" class="headerlink" title="直接内存（Direct Memory）"></a>直接内存（Direct Memory）</h2><p>直接内存不是 JVM 运行时数据区的一部分，JDK 1.4 中新加入了 NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的 I/O 方式，可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆的 DirectByteBuffer 对象作为这块内存的引用进行操作。从而避免在 Java 堆和 Native 堆中来回复制护具，在一些场景中显著提高性能。使用不当会有 OOM 异常。</p><h1 id="HotSpot-虚拟机对象探秘"><a href="#HotSpot-虚拟机对象探秘" class="headerlink" title="HotSpot 虚拟机对象探秘"></a>HotSpot 虚拟机对象探秘</h1><p>基于实用优先原则，以 HotSpot 虚拟机为例，学习在它在 Java 堆中对象分配、布局和访问的全过程。</p><h2 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h2><p>在语言层面上，对象创建只需要<code>new</code>关键字即可完成。但是在虚拟机中，这一过程背后实际上并不那么简单。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/180809_jvm_02/并不简单.jpg" alt="并不简单" title="">                </div>                <div class="image-caption">并不简单</div>            </figure> <h3 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h3><p>虚拟机收到一条<code>new</code>指令时，首先去检查指令参数能否在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有，则会进行相应的类加载过程。</p><h3 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h3><p>对象所需内存大小在类加载完成后即可完全确定，为对象分配内存的操作相当于从堆中划分出一块可使用的区域。有两种分配方式：</p><ul><li>指针碰撞 (Bump the Pointer）：当 Java 堆中的内存是绝对规整的，用过的内存和空闲的内存分两边存放，并且有指针指向明确的界限，此时分配内存只需要将指针移动与对象大小相同距离即可。Serial、ParNew 等带 Compact 过程的收集器采用这种方法。</li><li>空闲列表（Free List）：当内存不规整、用过的内存和空闲的内存交叉排列时，需要由虚拟机维护一个列表记录哪些内存块是可用的，分配时为对象寻找一块足够大的区域并更新列表。CMS 这种基于 Mark-Sweep 算法的收集器采用这种方法。</li></ul><p>除了划分可用空间外，还需要考虑移动指针带来的并发问题。解决并发问题有两个方案：</p><ul><li>对分配内存空间的动作进行同步处理，虚拟机采用 CAS 配上失败重试的方法保证更新操作的原子性</li><li>把内存分配的动作按照线程划分在不同空间进行，每个线程在 Java 堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）。线程在各自的 TLAB 上为对象分配内存，只有当 TLAB 用尽并分配新的 TLAB 时，才需要同步锁定。</li></ul><p>内存分配完成后，虚拟机会讲所分配到的内存空间都初始化为零值。</p><h3 id="对象设置"><a href="#对象设置" class="headerlink" title="对象设置"></a>对象设置</h3><p>虚拟机会设置对象信息（对象是哪个类的实例、如何找到类的元数据信息、哈希码、GC 分代年龄），这些信息保存在对象头（Object Header）中。</p><h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><p>在以上步骤都完成后，开始对象创建，即执行<code>&lt;init&gt;</code>方法，将对象按照构造函数进行初始化，这样一个真正可用的对象才算完全产生出来。</p><h2 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h2><p>在 HotSpot 虚拟机中，对象在内存中存储的布局分为三块：对象头（Header）、实例数据（Instance Data）、对齐填充（Padding）。</p><p><strong>对象头</strong> 包括两部分信息</p><ul><li>对象自身运行时数据，如哈希码（HashCode）、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等。这部分数据长度在 32 位和 64 位虚拟机中分别是 32bit 和 64bit，官方称它为“Mark Word”。是一个非固定的数据结构。</li><li>类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。如果对象是 Java 数组，还需要一块用于记录数组长度的数据。</li></ul><p><strong>实例数据</strong> 是对象真正存储的有效信息，也就是各种类型字段内容。存储顺序受虚拟机分配策略参数（FieldsAllocationStyle）和字段在 Java 代码中定义顺序影响。</p><ol><li>HotSpot 虚拟机默认分配策略是 longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers），相同宽度的字段总被分配到一起</li><li>在满足上一条件的前提下，在父类中定义的变量会出现在子类之前。如果 CompactFields 参数值为 true，则子类中较窄的变量也可能会插入到父类变量空隙之中。</li></ol><p><strong>对齐填充</strong> 不是必须存在的，因为 HotSpot 虚拟机内存管理系统要求对象起始地址必须是 8 字节的整数倍，因此当 <strong>实例数据</strong> 部分没有对齐时，就要通过对齐填充来补齐。</p><h2 id="对象访问定位"><a href="#对象访问定位" class="headerlink" title="对象访问定位"></a>对象访问定位</h2><p>JVM 栈中保存的是 reference 数据，指向存放在堆中的对象，对象的访问（定位）方式取决于虚拟机具体实现，主流的有句柄和直接指针两种，它们各有优劣。</p><h3 id="句柄"><a href="#句柄" class="headerlink" title="句柄"></a>句柄</h3><p>Java 堆中划分出一块内存来作为句柄池，reference 中保存的是句柄地址，句柄中包含对象实例数据与类型数据各自的具体地址信息。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/180809_jvm_02/句柄.jpeg" alt="句柄" title="">                </div>                <div class="image-caption">句柄</div>            </figure> <p><strong>优点</strong> reference 中保存的是稳定的句柄地址，在对象被移动（比如 GC）时只会改变句柄中实例数据指针的地址， reference 本身不变。在对象频繁异动的场景里性能更好。</p><h3 id="直接指针"><a href="#直接指针" class="headerlink" title="直接指针"></a>直接指针</h3><p>Java 堆对象头重保存类型数据信息，reference 直接指向对象地址。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/180809_jvm_02/直接指针.jpeg" alt="直接指针" title="">                </div>                <div class="image-caption">直接指针</div>            </figure> <p><strong>优点</strong> 速度更快，节省了一次指针定位开销，在对象频繁访问的场景里性能更好。HotSpot VM 使用的是直接指针方式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本章从概念上介绍 Java 虚拟机内存的各个区域，从作用、服务对象、可能产生的问题几个方面进行讲解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;运行时数据区域&quot;&gt;&lt;a href=&quot;#运行时数据区域&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://lilei.pro/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JVM" scheme="https://lilei.pro/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>深入理解 Java 虚拟机（一）走近 Java</title>
    <link href="https://lilei.pro/2018/08/09/JVM-Note-01/"/>
    <id>https://lilei.pro/2018/08/09/JVM-Note-01/</id>
    <published>2018-08-09T00:45:15.000Z</published>
    <updated>2018-08-09T07:30:01.476Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近阅读周志明的《深入理解 Java 虚拟机 JVM 高级特性与最佳实践》，以读书笔记的形式记录下所学所得，先给自己定个小目标，完成10篇笔记。</p></blockquote><blockquote><p>世界上并没有完美的程序，但我们并不因此而沮丧，因为写程序本来就是一个不断追求完美的过程。</p></blockquote><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Java 不仅仅是一门编程语言，更是一个由一系列计算机软件和规范形成的技术体系，这个技术体系提供了完整的用于软件开发和跨平台部署的支持环境。它有一系列优点：</p><ul><li>拥有一门结构严谨、面向对象的编程语言</li><li>摆脱硬件平台束缚，实现“一次编写，处处运行”</li><li>提供相对安全的内存管理和访问机制，避免了绝大部分内存泄露和指针越界</li><li>实现热点代码检测和运行时编译及优化，使得 Java 应用能随着运行时间的增加而获取更高的性能</li><li>有一套完善的应用程序接口，还有无数第三方类库实现各种功能</li></ul><h1 id="Java-技术体系"><a href="#Java-技术体系" class="headerlink" title="Java 技术体系"></a>Java 技术体系</h1><p><strong>按照组成部分来分</strong>，Sun 官方定义的 Java 技术体系包括以下几个方面内容</p><ul><li>Java 程序设计语言</li><li>各种硬件平台上的 Java 虚拟机</li><li>Class 文件格式</li><li>Java API 类库</li><li>来自商业机构和开源社区的第三方 Java 类库</li></ul><p><strong>JDK（Java Development Kit）</strong>：Java 程序设计语言 + Java 虚拟机 + Java API 类库，是支持 Java 程序开发的最小环境</p><p><strong>JRE（Java Runtime Environment）</strong>：Java 虚拟机 + Java SE API，支持Java 程序运行的最小环境</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/180809_jvm_01/Java技术体系.png" alt="Java技术体系所包含的内容" title="">                </div>                <div class="image-caption">Java技术体系所包含的内容</div>            </figure><p><strong>按照所服务的领域来分</strong>，Java 技术体系可以分为4个平台</p><ul><li>Java Card：支持一些 Java 小程序（Applets）运行在小内存设备上的平台</li><li>Java ME（Micro Edition）：支持 Java 程序运行在移动终端（手机、PDA）平台，对 Java API 有所精简，并加入了针对移动终端的支持，旧称 J2ME</li><li>Java SE（Standard Edition）：支持面向桌面级应用（如 Windows 下的应用程序）的 Java 平台，提供完整的 Java 核心 API，旧称 J2SE</li><li>Java EE（Enterprise Edition）：支持面向多层架构的企业应用（如 ERP、CRM）的 Java 平台，除了提供 Java SE API 外，还对其做了大量补充以及部署支持，旧称 J2EE</li></ul><h1 id="Java-发展史"><a href="#Java-发展史" class="headerlink" title="Java 发展史"></a>Java 发展史</h1><ol><li>1991 年 4 月，Oak（橡树）出现，目的在于开发一种能够在各种消费型电子产品（机顶盒、冰箱、收音机）上运行的程序架构，是为 Java 前身</li><li>1995 年，Oak 正式更名为 Java，并且在 SunWorld 大会上正式发布 1.0 版本，同时提出“Write Once，Run Everywhere”口号</li><li>1998 年，发布里程碑式的 1.2 版本，Sun 在这个版本中将 Java 按照服务领域拆分为三个方向：J2SE, J2ME, J2EE，并且第一次内置了 JIT 编译器，以及内置 Classic、HotSpot、Exact 三种 VM</li><li>2002 年，发布第一个真正成熟的版本 1.4，同年出现 .NET</li><li>2009 年，发布 1.7，代号 Dolphin 海豚</li></ol><h1 id="实践：编译-JDK"><a href="#实践：编译-JDK" class="headerlink" title="实践：编译 JDK"></a>实践：编译 JDK</h1><p>时间原因没有进行进行编译，只是把源码下载下来，日后有需要会补上</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;最近阅读周志明的《深入理解 Java 虚拟机 JVM 高级特性与最佳实践》，以读书笔记的形式记录下所学所得，先给自己定个小目标，完成10篇笔记。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;世界上并没有完美的程序，但我们并不
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://lilei.pro/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JVM" scheme="https://lilei.pro/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>本周总结 20180723 ~ 20180729</title>
    <link href="https://lilei.pro/2018/07/30/weekly-20180723-20180729/"/>
    <id>https://lilei.pro/2018/07/30/weekly-20180723-20180729/</id>
    <published>2018-07-30T11:02:20.000Z</published>
    <updated>2018-08-15T09:10:32.898Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>你的痛苦是因为，包裹你心智的外壳，正在破裂毁伤。<br>你必须经历痛苦，正如果壳必须破裂，果仁才见阳光。</p></blockquote><p>刚刚度过七月的最后一周，这一周自己往返跑了两次杭州，一共面了5家公司，其中两家现场，三家电面。七月的杭州气温达到三十七度，比上海平均高出四五度，顶着烈日奔波在城东城西，这样的经历，还真是难得啊。</p><h1 id="求职"><a href="#求职" class="headerlink" title="求职"></a>求职</h1><h2 id="现场：Rokid，海拍客"><a href="#现场：Rokid，海拍客" class="headerlink" title="现场：Rokid，海拍客"></a>现场：Rokid，海拍客</h2><p>Rokid 位于西溪湿地艺术家集合村里，环境相当不错，就是找起来有些麻烦。第一轮是客户端主管面试，考察网络知识多，比如设计一个登陆模块，如何发送 https 请求，设计一个 http 协议的实现，多线程同时向一个 Socket 里写数据，断点续传等等；第二轮是 Research 部门负责人面试，基本没有针对算法问什么，还是项目上的问题，大概是因为自己算法太弱；第三轮 HRBP 面，聊了聊 Rokid 的竞争力在哪儿。给我的感觉是这家创业公司很有朝气，办公环境是开放式的，不远处的办公区一直有人在讨论问题。团队是做 SDK 集成、智能眼镜的软件开发，跟我之前在依图做的有一些类似。但我认为可穿戴设备目前还没有一个不可替代的应用场景，你能想到的功能，似乎都可以用手机满足，做 SDK 这种东西，技术难度有限，对个人能力提升不太看好。</p><p>海拍客靠近西溪湿地北门，去的那天有雨。第一轮技术面，第二轮 CTO 面，第三轮 HRBP 面。</p><h2 id="电面：阿里天猫，海康威视，八维通"><a href="#电面：阿里天猫，海康威视，八维通" class="headerlink" title="电面：阿里天猫，海康威视，八维通"></a>电面：阿里天猫，海康威视，八维通</h2><h1 id="积累"><a href="#积累" class="headerlink" title="积累"></a>积累</h1><h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><h1 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h1><ol><li>去面试，去和别人沟通</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;你的痛苦是因为，包裹你心智的外壳，正在破裂毁伤。&lt;br&gt;你必须经历痛苦，正如果壳必须破裂，果仁才见阳光。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;刚刚度过七月的最后一周，这一周自己往返跑了两次杭州，一共面了5家公司，其中两家现场，三家电面。七月的
      
    
    </summary>
    
    
      <category term="周报" scheme="https://lilei.pro/tags/%E5%91%A8%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>面试知识整理 2018.07.29</title>
    <link href="https://lilei.pro/2018/07/29/interview-180729/"/>
    <id>https://lilei.pro/2018/07/29/interview-180729/</id>
    <published>2018-07-29T04:48:48.000Z</published>
    <updated>2018-07-29T04:50:22.478Z</updated>
    
    <content type="html"><![CDATA[<h1 id="有什么手段可以减少APK体积"><a href="#有什么手段可以减少APK体积" class="headerlink" title="有什么手段可以减少APK体积"></a>有什么手段可以减少APK体积</h1><h1 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h1><h1 id="插件化"><a href="#插件化" class="headerlink" title="插件化"></a>插件化</h1><h1 id="Get-和-Post-区别"><a href="#Get-和-Post-区别" class="headerlink" title="Get 和 Post 区别"></a>Get 和 Post 区别</h1><h1 id="LeakCanary-检查内存泄漏的原理"><a href="#LeakCanary-检查内存泄漏的原理" class="headerlink" title="LeakCanary 检查内存泄漏的原理"></a>LeakCanary 检查内存泄漏的原理</h1><h1 id="创建一个对象-new-Object-时内部流程"><a href="#创建一个对象-new-Object-时内部流程" class="headerlink" title="创建一个对象/new Object 时内部流程"></a>创建一个对象/new Object 时内部流程</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;有什么手段可以减少APK体积&quot;&gt;&lt;a href=&quot;#有什么手段可以减少APK体积&quot; class=&quot;headerlink&quot; title=&quot;有什么手段可以减少APK体积&quot;&gt;&lt;/a&gt;有什么手段可以减少APK体积&lt;/h1&gt;&lt;h1 id=&quot;模块化&quot;&gt;&lt;a href=&quot;#模块
      
    
    </summary>
    
    
      <category term="Android" scheme="https://lilei.pro/tags/Android/"/>
    
      <category term="面试" scheme="https://lilei.pro/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>西虹市首富</title>
    <link href="https://lilei.pro/2018/07/28/hello-mr-billionaire/"/>
    <id>https://lilei.pro/2018/07/28/hello-mr-billionaire/</id>
    <published>2018-07-28T14:24:56.000Z</published>
    <updated>2018-07-28T14:49:11.037Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>不给我生一百个孩子你都对不起我！</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/180728_hello_mr_billinaire/hello_mr_billionaire.jpg" alt="JVM" title="">                </div>                <div class="image-caption">JVM</div>            </figure><p>开心麻花很擅长抓住平凡人的心里的爽点，和网络小说的套路一样，资质平平屡遭白眼的男主角，机缘巧合之下得到一笔巨大的财富/绝世的武功，一路干翻仇家，将曾经不把他放在眼里的对头们一一踩在脚下。最后举目四顾遗世独立，感到无敌是多么寂寞，甘愿自废武功散尽家财，做回一个普通人。</p><p>《夏洛特烦恼》是这样，《西虹市首富》也如此。</p><p>十亿人民币，首富口中的“小目标”x10，普通人一辈子别说赚这么多钱，能见到一次恐怕都是三生有幸。所以开心麻花拍了这样一部电影，让我们这些平凡人看到，原来十亿人民币可以堆满两百平的屋子，原来有钱人可以吃饭不吃主食只吃龙虾松茸，原来有钱人可以请到王力宏为他开一场私人演唱会，原来有钱人做的决策就算狗屁不通也能让他的钱越滚越多……</p><p>以后老子也是见过十亿人民币的人了，十亿人民币，现金。</p><p>不论情怀还是包袱，这部电影比起《夏洛特烦恼》都落于下风，除了王力宏的出场，让影院里响起一片惊叹之声。我个人对开心麻花几部电影的排名是：</p><ol><li>《夏洛特烦恼》</li><li>《驴得水》</li><li>《西红柿首富》</li><li>《羞羞的铁拳》</li></ol><p>2018.07.28@上影徐汇日月光店</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;不给我生一百个孩子你都对不起我！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                
      
    
    </summary>
    
    
      <category term="电影" scheme="https://lilei.pro/tags/%E7%94%B5%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>我不是药神</title>
    <link href="https://lilei.pro/2018/07/27/dying-to-survive/"/>
    <id>https://lilei.pro/2018/07/27/dying-to-survive/</id>
    <published>2018-07-27T09:38:47.000Z</published>
    <updated>2018-07-27T14:13:25.481Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我希望今后会越来越好，我相信会的。</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/180727_dying_to_survive/吕受益.webp" alt="吕受益" title="">                </div>                <div class="image-caption">吕受益</div>            </figure><p>如果没有事先从朋友圈里得到铺垫，在看电影前半段，直到徐峥扮演的程勇来到吕受益家中做客时，自己几乎要以为这是一部类似“X囧”的喜剧片。不论从节奏、台词和剧情上来看，都太像了。浑不吝的保健品店老板，戴着蛤蟆镜鬼头鬼脑让人想不起他是病人的吕受益，满嘴英文一本正经的老神父，还有夜店女王这个颜值担当，以及无口黄毛小酷哥。多好的西天取经五人组。</p><p>但徐峥毕竟是徐峥，拍过《心花路放》这种喜剧外壳的公路文艺片。他有野心，更有能力。</p><p>于是在看到警察突袭白血病人旅馆，拘留了一屋子人，却没有一个供出程勇，老人白发苍苍，向警官哭诉着被疾病剥夺的一切时，我第一次眼眶湿润了。在突如其来的疾病面前，你引以为傲的学识、事业、金钱、地位都脆弱不堪一击。去年有一篇在朋友圈疯传的长文，《流感侵袭下的北京中产阶级》，深深地揭露了这种无力的现状。</p><p>为了升职加薪，为了KPI，为了买房上车，为了下一代，为了不比同龄人落后，为了别人的期待目光，为了过上自己想要的生活。你夜以继日熬秃了发际线熬深了近视眼熬出了小肚腩所换来的一切，在一场疾病面前轰然倒塌，瓦砾遍地。</p><p>以前自己总会有这种想法，现代医学虽然延长了人类的寿命，但在它的庇护下，人类自身机体的抵抗力反而下降，变得如同温室中的花朵般更加脆弱易折。</p><p>我们从病床上赤条条地来，也终将在病床上赤条条地离开，带不走任何一样东西。</p><p>最终徐峥被警车押运走，警官吩咐开车的同伴放慢速度，看到街边送行的白血病人纷纷摘下口罩，去世的吕受益和黄毛浩子也出现在人群中，我第二次流泪。</p><p>君以国士待我，我必以国士报之。</p><p>病魔无情，人间有爱。其实倘若人间无爱，病魔也就无从可怕，不自爱，则身体发肤，皆可毁伤；不爱人，则漠视生命，天性凉薄。可人活着，不就是仗着心底总有一些不可割舍的爱么？</p><p>由爱故生忧，由爱故生怖，若离于爱者，无忧亦无怖。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;我希望今后会越来越好，我相信会的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
               
      
    
    </summary>
    
    
      <category term="电影" scheme="https://lilei.pro/tags/%E7%94%B5%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>缝纫机乐队</title>
    <link href="https://lilei.pro/2018/07/27/city-of-rock/"/>
    <id>https://lilei.pro/2018/07/27/city-of-rock/</id>
    <published>2018-07-27T09:01:06.000Z</published>
    <updated>2018-07-27T09:32:51.727Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>心里还有那口气儿，惦记的是每天什么时候开始；卸下那口气儿，惦记的是每天什么时候结束。 ​</p></blockquote><p><a href="https://www.xiami.com/song/1796823294" target="_blank" rel="noopener">都选C - 虾米音乐</a></p><p>虽然娜扎很美，但我认为乔杉才是本片的演技、笑点乃至颜值担当。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/180727_city_of_rock/乔杉.jpeg" alt="保健哥" title="">                </div>                <div class="image-caption">保健哥</div>            </figure><p>剧情中有一段是老吉他手拿出当年的电吉他擦拭，乔杉盛赞这是吉他界的柳岩，想要摸一摸结果被老吉他手一巴掌扇掉。大鹏在一旁嘲讽道“柳岩那是谁都能摸的么？”。看到这里会心一笑，曾经拍《屌丝男士》时，大鹏没少与柳岩演对手戏。</p><p>大鹏强行为自己和娜扎安排的感情线，不仅对剧情推进毫无帮助，而且真的很尬。</p><p>岳云鹏扮演的钢琴家，虽然说不出喜感在哪，但让人一看到他那张圆脸，就忍不住想笑，也许这就是祖师爷赏饭吃吧。那一句“女人啊，你的名字是贪婪”硬生生地将整部电影的文学水平拔高了一厘米。</p><p>尽管它在豆瓣上的评分不到7，大抵属于“拍的不差，但也算不上多好”的水平。但我偏偏喜欢，自己大概本就是个俗人吧。</p><p>看这部电影的时候，正坐在 K8402 杭州 - 上海南 的加1车厢里，求职中第三次往返于杭州上海，这天面试了第十家公司。</p><p>看了，笑了，哭了，够了。揣着那口气儿，生活仍要继续。</p><p>P.S. 集安市，隶属吉林省通化市，位于吉林东南部，与朝鲜一江之隔。已列入旅游名单。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;心里还有那口气儿，惦记的是每天什么时候开始；卸下那口气儿，惦记的是每天什么时候结束。 ​&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.xiami.com/song/1796823294&quot; target=&quot;_b
      
    
    </summary>
    
    
      <category term="电影" scheme="https://lilei.pro/tags/%E7%94%B5%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>面试知识整理 2018.07.26</title>
    <link href="https://lilei.pro/2018/07/26/interview-180726/"/>
    <id>https://lilei.pro/2018/07/26/interview-180726/</id>
    <published>2018-07-26T04:51:20.000Z</published>
    <updated>2018-08-08T02:18:21.188Z</updated>
    
    <content type="html"><![CDATA[<h1 id="谈谈-SparseArray"><a href="#谈谈-SparseArray" class="headerlink" title="谈谈 SparseArray"></a>谈谈 SparseArray</h1><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>使用 Key-Value 保存对象的集合，类似 HashMap，但只允许使用 int 型的 Key</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>（优点）内存效率高，避免自动装箱，避免了使用 Entry 来构建数据结构，int 4 bytes，Integer 16 bytes</li><li>（缺点）使用二分法查找对象，在数据体量大（more than hundreds of items）的场景下查找/插入/删除效率不如 HashMap</li><li>删除过程优化：先标记 item，待 GC 时真正删除</li></ul><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><ul><li>随机插入：put(int, x)，会替换掉已有的对象</li><li>顺序插入：append(int, x)，当 Key 比目前所有的都要大时执行效率更高，否则同 put</li><li>随机删除：delete(int)，删除 Key 对应的对象</li><li>顺序删除：removeAt(int)，删除第 N 项</li><li>范围删除：removeAtRange(int, int)</li><li>随机访问：get(int)，根据 Key 获取 Value，如果没有则返回 null</li><li>顺序访问：valueAt(int)</li><li>遍历：keyAt(int)，获取第 n 位的 key；valueAt(int)，获取第 n 位 key 对应的 value；indexOfKey(int)，获取 key 的 index；indexOfValue(int)，获取 value 的 index</li></ul><h2 id="源码阅读"><a href="#源码阅读" class="headerlink" title="源码阅读"></a>源码阅读</h2><p>成员变量部分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object DELETED = <span class="keyword">new</span> Object(); <span class="comment">// 删除对象时，并非真正删除，而是将 Value 替换成 DELETE 对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> mGarbage = <span class="keyword">false</span>; <span class="comment">// 标示是否需要进行 gc</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] mKeys;</span><br><span class="line"><span class="keyword">private</span> Object[] mValues;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mSize;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SparseArray</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">10</span>); <span class="comment">// 默认长度是10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用 append, put, size 等方法时会触发 GC，是一个逐项复制的过程，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = mSize;</span><br><span class="line">    <span class="keyword">int</span> o = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] keys = mKeys;</span><br><span class="line">    Object[] values = mValues;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        Object val = values[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (val != DELETED) &#123; <span class="comment">// 判断是否已经标记</span></span><br><span class="line">            <span class="keyword">if</span> (i != o) &#123;</span><br><span class="line">                keys[o] = keys[i];</span><br><span class="line">                values[o] = val;</span><br><span class="line">                values[i] = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            o++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mGarbage = <span class="keyword">false</span>;</span><br><span class="line">    mSize = o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>put 过程，核心是先判断有没有同一个 key 存在，有则替换，没有的话，再判断是否目标位置刚好被 DELETED 标记，最后才进行加项操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, E value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = ContainerHelpers.binarySearch(mKeys, mSize, key); <span class="comment">// 二分查找 key 的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123; <span class="comment">// 如果已经有同一个 key</span></span><br><span class="line">        mValues[i] = value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        i = ~i; <span class="comment">// 求异或</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &lt; mSize &amp;&amp; mValues[i] == DELETED) &#123; <span class="comment">// 目标位置项目已经标记 DELETE，可以直接替换</span></span><br><span class="line">            mKeys[i] = key;</span><br><span class="line">            mValues[i] = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mGarbage &amp;&amp; mSize &gt;= mKeys.length) &#123; <span class="comment">// 需要寻找新的位置，此时先 gc</span></span><br><span class="line">            gc();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Search again because indices may have changed.</span></span><br><span class="line">            i = ~ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key); <span class="comment">// 运用 System.arraycopy 进行添加（有必要则扩容）</span></span><br><span class="line">        mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);</span><br><span class="line">        mSize++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>delete 过程，先二分查找到目标位置，标记 DELETED，不直接删除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mValues[i] != DELETED) &#123;</span><br><span class="line">            mValues[i] = DELETED;</span><br><span class="line">            mGarbage = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Handler-内部原理，HandlerThread-与普通-Thread-区别"><a href="#Handler-内部原理，HandlerThread-与普通-Thread-区别" class="headerlink" title="Handler 内部原理，HandlerThread 与普通 Thread 区别"></a>Handler 内部原理，HandlerThread 与普通 Thread 区别</h1><h2 id="Handler-的两个用途"><a href="#Handler-的两个用途" class="headerlink" title="Handler 的两个用途"></a>Handler 的两个用途</h2><ol><li>管理消息/任务队列，可以控制立即执行或者延迟执行</li><li>调度任务在不同线程运行f</li></ol><h2 id="主要概念"><a href="#主要概念" class="headerlink" title="主要概念"></a>主要概念</h2><ul><li>Handler：消息分发器，一个 Handler 里面会关联一个 MessageQueue，这个 MessageQueue 来自当前线程的 Looper</li><li>Looper：消息循环器，从 MQ 里面不断取出消息运行。非 UI 线程是没有默认创建 Looper 的，需要人工调用 prepare 和 loop 来启动 Looper。被声明为 ThreadLocal，每一个线程独立拥有</li><li>Message：消息单元，内部用消息池管理，默认 capacity = 50</li><li>MessageQueue：消息队列，单链表，每个消息入队时会带上一个运行时间 when，根据这个 when 将其放入队列中相应的位置（早执行的放在队首），整个队列是按照运行时间排序的</li></ul><h2 id="原理流程概述"><a href="#原理流程概述" class="headerlink" title="原理流程概述"></a>原理流程概述</h2><p>创建 Handler 时会关联当前线程 Looper 中的 MQ，当用 Handler 对象发送消息时，消息会进入 MQ，经 Looper 轮询取出后进行处理，处理时会调用所实现的 handleMessage 方法。</p><h2 id="UI-线程创建-Looper"><a href="#UI-线程创建-Looper" class="headerlink" title="UI 线程创建 Looper"></a>UI 线程创建 Looper</h2><ol><li>ActivityThread 在 main 方法里通过 Looper.prepareMainLooper() 创建主 Looper，并将其存入 ThreadLocal 变量中。同时将它另存一份作为主线程 Looper，供其他线程访问。</li><li>在 main 方法最后通过 looper.loop() 启动轮询</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line">        ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">        thread.attach(<span class="keyword">false</span>);</span><br><span class="line">        Looper.loop();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Handler-发送消息的流程"><a href="#Handler-发送消息的流程" class="headerlink" title="Handler 发送消息的流程"></a>Handler 发送消息的流程</h2><p>构造过程中取出当前线程持有的 Looper，并保存其 MQ 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">        mLooper = Looper.myLooper();</span><br><span class="line">        mQueue = mLooper.mQueue;</span><br><span class="line">        mCallback = callback;</span><br><span class="line">        mAsynchronous = async;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>handler通过sendMessage(msg) 将消息发出，消息最终走向 queue.enqueueMessage(msg, uptimeMillis) 进入队列，同时将当前 Handler 以 target 保存在消息对象中，当 Looper 轮询时，会取出 target 用于处理消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">        msg.target = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">        <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Message msg = queue.next(); <span class="comment">// 取出消息，无消息则阻塞</span></span><br><span class="line">          <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;  <span class="keyword">return</span>;   &#125;</span><br><span class="line">        msg.target.dispatchMessage(msg);<span class="comment">//发送消息 其中target就是Handler</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>dispatchMessage 最终会调到 Handler 中实现的 handleMessage</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            handleCallback(msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            handleMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="HandlerThread"><a href="#HandlerThread" class="headerlink" title="HandlerThread"></a>HandlerThread</h2><p>构造函数里创建了自己的 Looper 并且开启轮询，普通 Thread 不含 Looper</p><h1 id="Picasso-VS-Glide"><a href="#Picasso-VS-Glide" class="headerlink" title="Picasso VS Glide"></a>Picasso VS Glide</h1><table><thead><tr><th>项目</th><th>Picasso</th><th>Glide</th></tr></thead><tbody><tr><td>图片格式</td><td>ARGB8888</td><td>RGB_565</td></tr><tr><td>缓存</td><td>原图尺寸</td><td>显示尺寸</td></tr><tr><td>GIF</td><td>不支持</td><td>支持</td></tr><tr><td>video</td><td>不支持</td><td>支持</td></tr><tr><td>Library size</td><td>100K</td><td>500K</td></tr><tr><td>Methods count</td><td>500</td><td>2500</td></tr></tbody></table><h1 id="View-的绘制过程"><a href="#View-的绘制过程" class="headerlink" title="View 的绘制过程"></a>View 的绘制过程</h1><p>一个 Activity 的窗口页面，可以分为PhoneWindow、DecorView、TitleBar &amp; ContentView 几个层级</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/180726_interview/window.png" alt="window.png" title="">                </div>                <div class="image-caption">window.png</div>            </figure><p>整个 View 树的绘图流程在 ViewRootImpl.performTraversals() 方法中，它主要做的事情是根据之前设置的状态，判断是否需要重新计算视图大小（measure）、是否需要重新放置视图位置（layout）以及是否需要重新绘制（draw），代码如下</p><ul><li>measure：测量，指测量 View 的宽高</li><li>layout：布局，指确定在父容器中的位置坐标</li><li>draw：绘制并显示</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//最外层的根视图的widthMeasureSpec和heightMeasureSpec由来</span></span><br><span class="line">        <span class="comment">//lp.width和lp.height在创建ViewGroup实例时等于MATCH_PARENT</span></span><br><span class="line">        <span class="keyword">int</span> childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);</span><br><span class="line">        <span class="keyword">int</span> childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);</span><br><span class="line">        ......</span><br><span class="line">        mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">        ......</span><br><span class="line">        mView.layout(<span class="number">0</span>, <span class="number">0</span>, mView.getMeasuredWidth(), mView.getMeasuredHeight());</span><br><span class="line">        ......</span><br><span class="line">        mView.draw(canvas);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/180726_interview/perform_traversals.png" alt="perform_traversals" title="">                </div>                <div class="image-caption">perform_traversals</div>            </figure><h2 id="measure-过程分析"><a href="#measure-过程分析" class="headerlink" title="measure 过程分析"></a>measure 过程分析</h2><p>整个 View 树从根 View 开始，递归进行 measure</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/180726_interview/measure.png" alt="measure.png" title="">                </div>                <div class="image-caption">measure.png</div>            </figure><p>View.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * This is called to find out how big a view should be. The parent</span></span><br><span class="line"><span class="comment"> * supplies constraint information in the width and height parameters.</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * The actual measurement work of a view is performed in</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #onMeasure(int, int)&#125;, called by this method. Therefore, only</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #onMeasure(int, int)&#125; can and must be overridden by subclasses.</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> widthMeasureSpec Horizontal space requirements as imposed by the</span></span><br><span class="line"><span class="comment"> *        parent</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> heightMeasureSpec Vertical space requirements as imposed by the</span></span><br><span class="line"><span class="comment"> *        parent</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #onMeasure(int, int)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//final方法，子类不可重写</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//回调onMeasure()方法</span></span><br><span class="line">    onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//View的onMeasure默认实现方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</span><br><span class="line">            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MeasureSpec 的语义是父 View 对子 View 在长宽上的约束，有三种取值</p><ul><li>EXACTLY：不管子 View 想多大，它只能这么大</li><li>AT_MOST：最大只能这么大</li><li>UNSPECIFIED：不加约束，子 View 想多大就多大</li></ul><p>measure 过程主要就是从顶层父 View 向子 View 递归调用 view.measure 方法（measure中 又回调 onMeasure 方法）的过程。具体 measure 核心主要有如下几点</p><ul><li>View的measure方法是final的，不允许重载，View子类只能重载onMeasure来完成自己的测量逻辑。</li><li>最顶层DecorView测量时的MeasureSpec是由ViewRootImpl中getRootMeasureSpec方法确定的（LayoutParams宽高参数均为MATCH_PARENT，specMode是EXACTLY，specSize为物理屏幕大小）。</li><li>ViewGroup类提供了measureChild，measureChild和measureChildWithMargins方法，简化了父子View的尺寸计算。</li><li>只要是ViewGroup的子类就必须要求LayoutParams继承子MarginLayoutParams，否则无法使用layout_margin参数。</li><li>View的布局大小由父View和子View共同决定。</li><li>使用View的getMeasuredWidth()和getMeasuredHeight()方法来获取View测量的宽高，必须保证这两个方法在onMeasure流程之后被调用才能返回有效值。</li></ul><h2 id="layout-过程分析"><a href="#layout-过程分析" class="headerlink" title="layout 过程分析"></a>layout 过程分析</h2><p>View.performTraversals 在 measure 之后，会执行 layout 过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    mView.layout(<span class="number">0</span>, <span class="number">0</span>, mView.getMeasuredWidth(), mView.getMeasuredHeight());</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>layout() 方法有四个参数，分别是 left、top、right、bottom，表示当前 View 相对 Parent 的四个坐标。layout 过程也是一个递归的过程：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/180726_interview/layout.png" alt="layout.png" title="">                </div>                <div class="image-caption">layout.png</div>            </figure><p>View.layout 方法实际上会调用到 onLayout 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//实质都是调用setFrame方法把参数分别赋值给mLeft、mTop、mRight和mBottom这几个变量</span></span><br><span class="line">    <span class="comment">//判断View的位置是否发生过变化，以确定有没有必要对当前的View进行重新layout</span></span><br><span class="line">    <span class="keyword">boolean</span> changed = isLayoutModeOptical(mParent) ?</span><br><span class="line">            setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</span><br><span class="line">    <span class="comment">//需要重新layout</span></span><br><span class="line">    <span class="keyword">if</span> (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</span><br><span class="line">        <span class="comment">//回调onLayout</span></span><br><span class="line">        onLayout(changed, l, t, r, b);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>layout 也是从顶层父 View 向子 View 的递归调用 layout 方法的过程，即父 View 根据上一步 measure 子 View 所得到的布局大小和布局参数，将子 View 放在合适的位置上。具体 layout 核心主要有以下几点：</p><ul><li>View.layout方法可被重载，ViewGroup.layout为final的不可重载，ViewGroup.onLayout为abstract的，子类必须重载实现自己的位置逻辑</li><li>measure操作完成后得到的是对每个View经测量过的measuredWidth和measuredHeight，layout操作完成之后得到的是对每个View进行位置分配后的mLeft、mTop、mRight、mBottom，这些值都是相对于父View来说的</li><li>凡是layout_XXX的布局属性基本都针对的是包含子View的ViewGroup的，当对一个没有父容器的View设置相关layout_XXX属性是没有任何意义的</li><li>使用View的getWidth()和getHeight()方法来获取View测量的宽高，必须保证这两个方法在onLayout流程之后被调用才能返回有效值</li></ul><h2 id="draw-过程分析"><a href="#draw-过程分析" class="headerlink" title="draw 过程分析"></a>draw 过程分析</h2><p>performTraverls 在 layout 后会进行 draw 的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">final</span> Rect dirty = mDirty;</span><br><span class="line">    ......</span><br><span class="line">    canvas = mSurface.lockCanvas(dirty);</span><br><span class="line">    ......</span><br><span class="line">    mView.draw(canvas);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>draw 也是一个递归的过程</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/180726_interview/draw.png" alt="draw.png" title="">                </div>                <div class="image-caption">draw.png</div>            </figure><ul><li>如果该View是一个ViewGroup，则需要递归绘制其所包含的所有子View。</li><li>View默认不会绘制任何内容，真正的绘制都需要自己在子类中实现。</li><li>View的绘制是借助onDraw方法传入的Canvas类来进行的。</li><li>区分View动画和ViewGroup布局动画，前者指的是View自身的动画，可以通过setAnimation添加，后者是专门针对ViewGroup显示内部子视图时设置的动画，可以在xml布局文件中对ViewGroup设置layoutAnimation属性（譬如对LinearLayout设置子View在显示时出现逐行、随机、下等显示等不同动画效果）。</li><li>在获取画布剪切区（每个View的draw中传入的Canvas）时会自动处理掉padding，子View获取Canvas不用关注这些逻辑，只用关心如何绘制即可。</li><li>默认情况下子View的ViewGroup.drawChild绘制顺序和子View被添加的顺序一致，但是你也可以重载ViewGroup.getChildDrawingOrder()方法提供不同顺序。</li></ul><h3 id="参考：Android应用层View绘制流程与源码分析"><a href="#参考：Android应用层View绘制流程与源码分析" class="headerlink" title="参考：Android应用层View绘制流程与源码分析"></a>参考：<a href="https://blog.csdn.net/yanbober/article/details/46128379" target="_blank" rel="noopener">Android应用层View绘制流程与源码分析</a></h3><h1 id="类加载过程-ClassLoader机制"><a href="#类加载过程-ClassLoader机制" class="headerlink" title="类加载过程/ClassLoader机制"></a>类加载过程/ClassLoader机制</h1><h1 id="Apk-打包过程"><a href="#Apk-打包过程" class="headerlink" title="Apk 打包过程"></a>Apk 打包过程</h1><h1 id="ListView-和-RecyclerView-原理"><a href="#ListView-和-RecyclerView-原理" class="headerlink" title="ListView 和 RecyclerView 原理"></a>ListView 和 RecyclerView 原理</h1><h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><p>考虑性能时一般从以下几个角度</p><ul><li>内存优化</li><li>UI优化（布局、绘制）</li><li>速度优化（线程、网络）</li><li>电量优化</li><li>启动优化</li></ul><h2 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h2><p>内存优化是为了解决内存溢出（OOM）的问题，内存溢出通常有两个原因</p><ul><li>使用不当造成的内存泄漏，内存无法释放</li><li>虽然不属于泄漏，但一些代码逻辑不当，导致消耗大量内存，难以及时释放</li></ul><p>内存泄漏</p><p>常见原因与处理方法</p><ol><li>单例模式里使用了 Activity 的 Context，导致其生命周期延长至整个应用使用周期，应该使用 ApplicationContext</li><li>非静态内部类持有 Activity 对象引用，应该改成静态内部类，同时使用 ApplicationContext；以上两步说明尽量不要使用 Activity 的 Context，而是应当用 ApplicationContext</li><li>Handler 持有 Activity 对象引用，同样应该改成静态，并使用弱引用，并在 Activity 的 onDestroy 方法里清空 Handler 消息，<code>mHandler.removeCallbacksAndMessages(null);</code></li><li>线程进行耗时操作，导致 Activity 没释放，应当使用弱引用，并且在 Activity 的 onDestroy 方法里 cancel 掉线程</li><li>占有系统资源后没有关闭，在使用完 BraodcastReceiver,ContentObserver,File,Cursor,Stream,Bitmap,Animation 等资源时，一定要在 Activity 中的 onDestry 中及时的关闭、注销或者释放内存。</li></ol><h3 id="参考：Android中五种常见内存泄漏原因"><a href="#参考：Android中五种常见内存泄漏原因" class="headerlink" title="参考：Android中五种常见内存泄漏原因"></a>参考：<a href="https://blog.csdn.net/qq_35373333/article/details/74909811" target="_blank" rel="noopener">Android中五种常见内存泄漏原因</a></h3><p>常用工具</p><ul><li>Heap SnapShot</li><li>Heap Viewer</li><li>LeakCanary</li><li>MAT</li><li>TraceView（Device Monitor）</li></ul><p>消耗大量内存：通常加载 Bitmap 时会发生这种情况，解决思路是</p><ul><li>加载单张图片时候进行压缩，或者使用缩略图</li><li>控制每次加载的数量</li><li>加载多张图片时，滑动过程中不进行加载，仅在滑动完成后加载</li></ul><h2 id="UI优化（布局、绘制）"><a href="#UI优化（布局、绘制）" class="headerlink" title="UI优化（布局、绘制）"></a>UI优化（布局、绘制）</h2><p>Android 屏幕刷新的频率是 60fps，意味着每一帧的绘制必须要在 16ms 内完成，如果 UI 绘制超过了 16ms，在体验上就会出现卡顿。</p><p>以下罗列造成 App 卡顿的一些原因</p><ol><li>在 UI 线程里进行轻微耗时操作</li><li>布局 Layout 过于复杂，无法在 16ms 内完成渲染</li><li>动画执行次数过多，导致 CPU 或 GPU 负载过高</li><li>View 过度绘制，屏幕某些像素在一帧时间内绘制多次，CPU 或 GPU 负载过高</li><li>View 频繁触发 measure 和 layout，累计耗时过多，频繁渲染造成负载过高</li><li>内存频繁 GC，导致阻塞渲染操作</li><li>冗余资源和逻辑导致运行缓慢</li><li>ANR</li></ol><p>UI优化，通常是指布局优化和 View 绘制优化</p><h3 id="布局优化"><a href="#布局优化" class="headerlink" title="布局优化"></a>布局优化</h3><p>在“开发者选项”里可以打开“过度绘制开关”，从而查看当前页面 View 是否存在过绘，红色表示层级最多（4+），浅紫色表示层级最低（1），如下所示。找到那些过绘的部分，在布局文件里减少它们的背景，比如把底层 View 的背景设置成透明。同时，尽量减少 ViewGroup 嵌套的情况，通常 LinearLayout 会比 RelativeLayout 的层级要少。还有一点就是要使用设备对应分辨率的资源文件，并不是图片越清晰就越好。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/180726_interview/overdraw.png" alt="Overdraw" title="">                </div>                <div class="image-caption">Overdraw</div>            </figure><p>在“开发者模式”里面还有另一项相关的设置，叫做“GPU呈现模式分析”，可以将渲染时间以条形图📊的方式显示在屏幕底部，同时 16ms 的基准线也会以绿色绘制在屏幕中央。条形图中同一个条形的不同颜色表示绘制不同阶段</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/180726_interview/呈现模式分析.png" alt="呈现模式分析" title="">                </div>                <div class="image-caption">呈现模式分析</div>            </figure><h3 id="绘制优化"><a href="#绘制优化" class="headerlink" title="绘制优化"></a>绘制优化</h3><p>主要是针对自定义 View 里面的代码编写，在 onDraw 这一步要尽量减少开销，因为 onDraw 方法是实时执行的，在一帧内会执行多次。因此，在 onDraw 中要避免出现以下两种情况</p><ul><li>创建局部对象，这会导致占用大量内存，频繁 GC</li><li>执行耗时操作，出现循环，这会占用 CPU 时间</li></ul><p>过度绘制优化，使用对应分辨率的资源文件</p><h2 id="速度优化（线程、网络）"><a href="#速度优化（线程、网络）" class="headerlink" title="速度优化（线程、网络）"></a>速度优化（线程、网络）</h2><h3 id="线程优化"><a href="#线程优化" class="headerlink" title="线程优化"></a>线程优化</h3><p>需要在子线程进行耗时操作，避免阻塞主线程</p><ul><li>HandlerThread：拥有自己 Looper 的线程类，可以在这个线程里进行耗时操作，然后通知主线程</li><li>AsyncTask：见下面一节“AsyncTask 知识点”</li><li>IntentService：运行在独立线程的 Service，原理是创建一个 HandlerThread，然后在 onStart 时把消息丢给 Handler 处理</li><li>ThreadPool：用 Executor、ThreadPoolExecutor 来管理线程</li></ul><h3 id="网络优化"><a href="#网络优化" class="headerlink" title="网络优化"></a>网络优化</h3><p>网络优化主要是从时间、速度、成功率几个角度来进行，对于提高速度，比较典型的是请求图片的场景</p><ul><li>使用WebP格式，能比 JPG 节约25%～35%的流量，比 PNG 节约80%流量</li><li>使用缩略图</li></ul><p>另外一些网络优化的知识点</p><ul><li>对网络请求进行缓存，若请求数据仍在有效期内则直接使用缓存，不走网络</li><li>减少 GPS 定位使用，条件允许则多用网络定位</li><li>下载过程中使用断点续传</li><li>刷新数据时采用局部刷新，少用全局刷新</li></ul><h2 id="电量优化"><a href="#电量优化" class="headerlink" title="电量优化"></a>电量优化</h2><ul><li>需要进行网络请求时，先判断网络当前状态</li><li>批量处理网络请求</li><li>在同时有wifi和移动数据的情况下，我们应该直接屏蔽移动数据的网络请求</li><li>减少后台任务</li></ul><h2 id="启动优化"><a href="#启动优化" class="headerlink" title="启动优化"></a>启动优化</h2><p>根据应用启动时候的状态，可以分为冷启动、热启动、暖启动三种，其中冷启动的耗时最长，对用户体验影响最大，因此谈启动优化主要是从冷启动的角度给出优化建议。</p><p>冷启动初始时，系统完成三个任务</p><ol><li>启动和加载应用</li><li>创建应用进程</li><li>显示启动视图（白屏）</li></ol><p>当应用进程创建完毕后，开始创建应用</p><ol><li>创建应用对象</li><li>启动主线程 (MainThread)</li><li>创建 Main Activity</li><li>加载视图 (Inflating views)</li><li>渲染布局 (Laying out)</li><li>执行初始绘制</li></ol><p>冷启动优化</p><ul><li>减少首页使用的资源，懒加载</li><li>优化首页布局，减少层级，不绘制不可见的 UI，而是使用 ViewStub 对象在适当的时间布局绘制</li><li>在闪屏页（Fragment）预先加载</li></ul><h1 id="AsyncTask-知识点"><a href="#AsyncTask-知识点" class="headerlink" title="AsyncTask 知识点"></a>AsyncTask 知识点</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>是为了解决 UI 线程无法进行耗时操作的问题而应用的一种 API，通常处理短时耗时任务（长时任务建议使用 Executor、ThreadPoolExecutor、FutureTask），有四个方法需要覆盖</p><ul><li>onPreExecute()，在 UI 线程调用，进行任务运行前的准备工作</li><li>doInBackground(Params…)，在后台线程运行，读取 execute 传来的参数，运行过程中可以通过 publishProgress(Progress…) 来发布进度信息，进度信息会以 onProgressUpdate(Progress…) 回调的方式通知 UI 线程</li><li>onProgressUpdate(Progress…)，在 UI 线程调用，接收进度信息</li><li>onPostExecute(Result)，在 UI 线程调用，接受任务运行结果</li></ul><h2 id="变更历史"><a href="#变更历史" class="headerlink" title="变更历史"></a>变更历史</h2><ul><li>最初问世，采用单线程模型，所有任务串行执行</li><li>DONUT（1.6），采用线程池模型，并发运行</li><li>HONEYCOMB（3.0），又改回单线程模型，为了简化使用，避免并发带来的同步问题</li></ul><h2 id="内部原理（API-26）"><a href="#内部原理（API-26）" class="headerlink" title="内部原理（API 26）"></a>内部原理（API 26）</h2><ol><li>AsyncTask 无参构造函数里会创建一个任务对象 mWorker（在其中执行 doInBackground），一个任务完成回调对象 mFuture，同时获取到 UI 线程的 Looper，用来在任务完成后通知 UI 线程</li><li>维护单例 SERIAL_EXECUTOR，用来串行执行任务</li><li>调用 AsyncTask.execute 时，会进入 executeOnExecutor 方法，在其内部先调用 onPreExecute，然后通过 executor 运行 mWorker，由 SERIAL_EXECUTOR 保证了串行运行，真正运行任务的是 THREAD_POOL_EXECUTOR</li><li>在任务完成后，通过 UI 线程的 Looper 通知 UI 线程</li></ol><h1 id="一个关于类的静态变量归属的问题"><a href="#一个关于类的静态变量归属的问题" class="headerlink" title="一个关于类的静态变量归属的问题"></a>一个关于类的静态变量归属的问题</h1><p>父类有一个 protected 的静态变量 foo，基于父类 A 创建两个子类 B1 和 B2</p><ul><li>如果 B1 和 B2 不声明变量 foo，那么它们使用的 foo 是同一个，来自父类 A</li><li>如果 B1 和 B2 都声明变量 foo，那么它们使用各自的变量</li></ul><p>简单概括就是说静态变量与类绑定，demo 如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// case 1</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">int</span> foo = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B1</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B2</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">A b1 = <span class="keyword">new</span> B1();</span><br><span class="line">A b2 = <span class="keyword">new</span> B2();</span><br><span class="line">System.out.println(<span class="string">"b1.foo = "</span> + b1.foo + <span class="string">"&amp; b2.foo = "</span> + b2.foo); <span class="comment">// b1.foo = 0 &amp; b2.foo = 0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// case 2</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">int</span> foo = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B1</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> foo = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B2</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> foo = <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">A b1 = <span class="keyword">new</span> B1();</span><br><span class="line">A b2 = <span class="keyword">new</span> B2();</span><br><span class="line">System.out.println(<span class="string">"b1.foo = "</span> + b1.foo + <span class="string">"&amp; b2.foo = "</span> + b2.foo); <span class="comment">// b1.foo = 100 &amp; b2.foo = 200</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;谈谈-SparseArray&quot;&gt;&lt;a href=&quot;#谈谈-SparseArray&quot; class=&quot;headerlink&quot; title=&quot;谈谈 SparseArray&quot;&gt;&lt;/a&gt;谈谈 SparseArray&lt;/h1&gt;&lt;h2 id=&quot;用法&quot;&gt;&lt;a href=&quot;#用法&quot;
      
    
    </summary>
    
    
      <category term="Android" scheme="https://lilei.pro/tags/Android/"/>
    
      <category term="面试" scheme="https://lilei.pro/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>美团技术沙龙第39期：新思路打造移动端高效研发体系 小记</title>
    <link href="https://lilei.pro/2018/07/21/dianping-meituan-mobile-share-0721/"/>
    <id>https://lilei.pro/2018/07/21/dianping-meituan-mobile-share-0721/</id>
    <published>2018-07-21T05:37:13.000Z</published>
    <updated>2018-07-25T09:34:57.937Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>偶然在美团技术团队公众号里看到有这个分享，主讲人是周辉、虞惠文、蒋国宝等人，内容基本上是移动研发专场，遂过来凑个热闹。时间是7月21日13:30~17:30，地点田林路200号华鑫天地</p></blockquote><h1 id="时间表"><a href="#时间表" class="headerlink" title="时间表"></a>时间表</h1><table><thead><tr><th>内容</th><th>主讲人</th></tr></thead><tbody><tr><td>Picasso在大众点评首页的应用</td><td>虞惠文@美团Android开发工程师</td></tr><tr><td>移动前后端开发解耦</td><td>林晨@美团后端技术专家</td></tr><tr><td>打造稳定、灵活、高效的运营配置平台</td><td>蒋国宝@美团后端技术架构师</td></tr><tr><td>移动持续集成实践</td><td>何智聪@美团iOS技术专家</td></tr></tbody></table><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>13:44，还未开始，全是年轻的脸庞，未见故人。大概故人们不屑于这种程度的技术分享吧，他们就算来，也应该是站在讲台上，而非听众席。</p><h1 id="周校长开场词"><a href="#周校长开场词" class="headerlink" title="周校长开场词"></a>周校长开场词</h1><p>介绍了一下目前大众点评移动团队的规模和业务内容，base 在上海，100 人。曾经自己也是这个团队的一员，想想竟有些唏嘘。</p><h1 id="Picasso-在大众点评首页的应用"><a href="#Picasso-在大众点评首页的应用" class="headerlink" title="Picasso 在大众点评首页的应用"></a>Picasso 在大众点评首页的应用</h1><h2 id="痛点"><a href="#痛点" class="headerlink" title="痛点"></a>痛点</h2><p>首页改版多是视觉变更，需要快速上线验证，然而传统的开发发布流程太迟滞，难以实时看到效果。例如，首页十个金刚位入口，需要调整其中某一个，更换图标、文字、角标，并且快速验证，倘若走传统的“开发-测试-发布”流程，显然不能满足产品经理“越快看到效果越好”的需求。这是就需要有一个动态化框架，支持实时对这些进行修改。</p><h2 id="技术需求"><a href="#技术需求" class="headerlink" title="技术需求"></a>技术需求</h2><ul><li>需要一个动态化框架，在运行时决定需要展示的内容。</li><li>性能达到 Native 水准</li></ul><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>进行设计的时候，没有选择 RN，原因如下</p><ol><li>稳定性差</li><li>技术栈切换成本高</li><li>双端不对齐，某些特性只支持单端</li></ol><p>所采取的设计思路是“服务端下发数据（data）和视图规则（layout）”，data 和 layout 会被计算成 PModel，其中包含了该视图被渲染至屏幕上的全部信息。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/180721_dp_mobile/DP_Picasso.png" alt="Picasso构思" title="">                </div>                <div class="image-caption">Picasso构思</div>            </figure><p>同时采用预计算&amp;缓存，降低绘制时的开销，提高绘制速度。</p><p>预计算是指 PModel 包含了该视图所有尺寸信息，在随后渲染过程中的 measure 和 layout 这两步直接取用这些信息，而不需要再次计算。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/180721_dp_mobile/DP_Picasso_PreCalc.png" alt="预计算" title="">                </div>                <div class="image-caption">预计算</div>            </figure><p>缓存是指缓存了 PModel，而非 Data（需要再次计算 PModel）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/180721_dp_mobile/DP_Picasso_Cache.png" alt="缓存" title="">                </div>                <div class="image-caption">缓存</div>            </figure><h1 id="移动开发前后端解耦实践"><a href="#移动开发前后端解耦实践" class="headerlink" title="移动开发前后端解耦实践"></a>移动开发前后端解耦实践</h1><blockquote><p>主要介绍了点评内部在前后端开发联调测试过程中使用的几个工具，主要是 AppMock（前身是 wendong.dp）、移动之家。的确有了这些工具，对于移动端开发的同学来说是极大的福音，离开点评之后深感如此。</p></blockquote><h2 id="痛点-1"><a href="#痛点-1" class="headerlink" title="痛点"></a>痛点</h2><ul><li>接口管理困难 ———— 那么多的接口和数据格式，用什么管理呢？Excel文档？Wiki？聊天工具？不一致怎么办，出了锅谁来背？</li><li>移动端接口数据黑盒 ———— 想要查看接口数据，只能借助 Charles 这样的代理工具，使用复杂不说，还几乎无法进行定制。</li><li>前后端接口数据依赖 ———— 约好联调时间，难免遇到各种情况发生 delay，测得越晚，风险越大。</li><li>测试工作量 ———— 生成测试数据不仅累的一批，还毫无成就感。</li></ul><h2 id="接口管理困难"><a href="#接口管理困难" class="headerlink" title="接口管理困难"></a>接口管理困难</h2><ul><li>接口数据模型化</li><li>接口更新可通知</li><li>接口多维度管理</li></ul><p>通过“移动之家（mobile.dp）”进行接口注册，注册过程中需要明确标明接口数据结构和类型，注册完成之后，会有代码自动生成工具生成对应平台（Web、App、Server）的代码。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/180721_dp_mobile/DP_自动生成接口代码.png" alt="自动生成接口代码" title="">                </div>                <div class="image-caption">自动生成接口代码</div>            </figure><h2 id="前后端交互黑盒"><a href="#前后端交互黑盒" class="headerlink" title="前后端交互黑盒"></a>前后端交互黑盒</h2><p>由于网络环境复杂（3G、4G、WIFI），加上数据通常有加密序列化，想要实时查看接口数据信息通常要大费周章。这里介绍了 AppMock 的主要功能和原理，是在 APP 的网络层对请求进行重定向。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/180721_dp_mobile/DP_APPMOCK.png" alt="AppMock" title="">                </div>                <div class="image-caption">AppMock</div>            </figure><h2 id="前后端接口和数据依赖"><a href="#前后端接口和数据依赖" class="headerlink" title="前后端接口和数据依赖"></a>前后端接口和数据依赖</h2><p>后端同学测试接口：提供 APIReader 工具，可以在网页中组合参数，模拟客户端发送请求，测试后端接口<br>前端同学测试应用：AppMock 自动 mock response</p><h1 id="测试工作量"><a href="#测试工作量" class="headerlink" title="测试工作量"></a>测试工作量</h1><p>自动化测试(Appium) + 自动化Mock，Mock 工具可以存储用例，这部分不细讲。</p><p>最后是 AppMock 和业内类似工具的对比</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/180721_dp_mobile/DP_AppMock对比.png" alt="对比" title="">                </div>                <div class="image-caption">对比</div>            </figure><h1 id="打造稳定、灵活、高效的运营配置平台"><a href="#打造稳定、灵活、高效的运营配置平台" class="headerlink" title="打造稳定、灵活、高效的运营配置平台"></a>打造稳定、灵活、高效的运营配置平台</h1><p>简单的说就是设计一个“可以设计显示规则”的平台，同时讨论了如何满足测试场景（建立测试用户名单）、如何降低中央节点负载（SDK方案）。</p><h1 id="移动持续集成实践"><a href="#移动持续集成实践" class="headerlink" title="移动持续集成实践"></a>移动持续集成实践</h1><p>这部分没听，直接跑路去找卫鹏和小凡吃小龙虾去了。</p><h1 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h1><p>有高兴也有惋惜，高兴的是，自己从2012年加入大众点评，当年那么生涩的自己得到了不少老同事的包容和宽宥，有些人虽然再未见到过，但他们所开发出来的优秀工具却造福了很多同事，能与这些人共事，是我一生的荣幸；同时，分享现场这么多年轻朝气的面孔，表明点评团队依然充满了吸引力和号召力。惋惜的是自己没有在点评的5年里，全力汲取他人的养分，白白辜负了这么好的土壤。</p><p>点评只是我毕业后的第一所大学，而社会是第二所。</p><p>望各自安好，一别两宽。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;偶然在美团技术团队公众号里看到有这个分享，主讲人是周辉、虞惠文、蒋国宝等人，内容基本上是移动研发专场，遂过来凑个热闹。时间是7月21日13:30~17:30，地点田林路200号华鑫天地&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;时间表&quot;&gt;
      
    
    </summary>
    
    
      <category term="Android" scheme="https://lilei.pro/tags/Android/"/>
    
      <category term="点评" scheme="https://lilei.pro/tags/%E7%82%B9%E8%AF%84/"/>
    
  </entry>
  
  <entry>
    <title>面试知识整理 2018.07.09</title>
    <link href="https://lilei.pro/2018/07/09/interview-180709/"/>
    <id>https://lilei.pro/2018/07/09/interview-180709/</id>
    <published>2018-07-09T10:00:17.000Z</published>
    <updated>2018-08-06T06:09:28.648Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HashMap-和-HashTable-区别"><a href="#HashMap-和-HashTable-区别" class="headerlink" title="HashMap 和 HashTable 区别"></a>HashMap 和 HashTable 区别</h2><p>相同点</p><ul><li>都是以 Key - Value 的形式存放键值对</li></ul><p>不同点</p><ul><li>null 支持：HashMap 允许 null key 和 null value，HashTable 不允许</li><li>并发特性：HashMap 线程不安全，效率高，HashTable 线程安全，效率低</li><li>默认长度和扩容方式：HashMap 默认长度 16，扩容 2n，HashTable 默认长度 11，扩容 2n+1</li><li>父类：HashMap 父类 AbstractMap，其子类还有 ConcurrentHashMap、LinkedHashMap 等，HashTable 父类 Dictionary，子类有 Properties</li></ul><p>结论</p><ul><li>不需要考虑线程安全，用 HashMap</li><li>需要考虑线程安全，用 ConcurrentHashMap</li></ul><h2 id="JVM-垃圾回收机制-GC"><a href="#JVM-垃圾回收机制-GC" class="headerlink" title="JVM 垃圾回收机制/GC"></a>JVM 垃圾回收机制/GC</h2><p>含义：由 JVM 自动回收那些不再使用的对象，清理内存</p><p>意义：程序员不需要人工管理内存，减少开发成本，提高开发效率</p><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>对象实例存在于 Java 堆中</p><p>Java 中对对象的引用分成“强软弱虚”</p><ul><li>强引用，最普遍的引用，只要有强引用存在，对象就不会被回收</li><li>软引用，SoftReference，当 GC 时，如果内存不足，会被回收</li><li>弱引用，WeakReference，当 GC 时，不论内存是否足够，都被回收</li><li>虚引用，PhantomReference，不影响对象的生命周期，在任何时刻都可能被回收</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] arge)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//强引用</span></span><br><span class="line">        Object object = <span class="keyword">new</span> Object();</span><br><span class="line">        Object[] objects = <span class="keyword">new</span> Object[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//软引用</span></span><br><span class="line">        SoftReference&lt;String&gt; stringSoftReference = <span class="keyword">new</span> SoftReference&lt;&gt;(<span class="keyword">new</span> String(<span class="string">"SoftReference"</span>));</span><br><span class="line">        System.out.println(stringSoftReference.get());</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(stringSoftReference.get()); <span class="comment">//手动GC,这时内存充足,对象没有被回收</span></span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//弱引用</span></span><br><span class="line">        WeakReference&lt;String&gt; stringWeakReference = <span class="keyword">new</span> WeakReference&lt;&gt;(<span class="keyword">new</span> String(<span class="string">"WeakReference"</span>));</span><br><span class="line">        System.out.println(stringWeakReference.get());</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(stringWeakReference.get()); <span class="comment">//手动gc,这时,返回null,对象已经被回收</span></span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//虚引用</span></span><br><span class="line">        <span class="comment">//虚引用主要用来跟踪对象被垃圾回收器回收的活动。</span></span><br><span class="line">        <span class="comment">//虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。</span></span><br><span class="line">        <span class="comment">//当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中</span></span><br><span class="line">        ReferenceQueue&lt;String&gt; stringReferenceQueue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">        PhantomReference&lt;String&gt; stringPhantomReference = <span class="keyword">new</span> PhantomReference&lt;&gt;(<span class="keyword">new</span> String(<span class="string">"PhantomReference"</span>), stringReferenceQueue);</span><br><span class="line">        System.out.println(stringPhantomReference.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引用计数器"><a href="#引用计数器" class="headerlink" title="引用计数器"></a>引用计数器</h3><p>每个对象拥有一个计数器，当它被引用时，计数器 +1，引用释放时，计数器 -1，当计数器为 0 时，表示可以回收。</p><p>存在的问题是循环引用。为了解决这个问题，又引入了“可达性”（GC Roots Tracing）的概念，目前主流的 JVM 都采用了这种计数。简单说，就是从根部开始向下搜索，如果对象无法被触及，则认为是可以回收的，这种对象称为“不可达对象”。</p><p>看一下 JVM 运行时的内存结构：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/180709_interview/jvm.png" alt="JVM" title="">                </div>                <div class="image-caption">JVM</div>            </figure><p>GC Roots 包括</p><ul><li>虚拟机栈的栈帧中的引用对象（来自局部变量表）</li><li>方法区静态属性实体引用的对象</li><li>方法区的常量引用对象</li><li>本地方法栈中 JNI 引用的对象</li><li>存活 Thread 引用的对象</li></ul><p>在根搜索算法中，要真正宣告一个对象死亡，至少要经历两次标记过程：</p><ul><li>如果对象在进行根搜索后发现没有与 GC Roots 相连接的引用链，那它会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize() 方法</li><li>当对象没有覆盖 finalize() 方法，或 finalize() 方法已经被虚拟机调用过，虚拟机将这两种情况都视为没有必要执行</li><li>如果该对象被判定为有必要执行 finalize() 方法，那么这个对象将会被放置在一个名为 F-Queue 队列中，并在稍后由一条由虚拟机自动建立的、低优先级的 Finalizer 线程去执行 finalize() 方法</li><li>finalize() 方法是对象逃脱死亡命运的最后一次机会（因为一个对象的finalize() 方法最多只会被系统自动调用一次）, 稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果要在finalize（）方法中成功拯救自己，只要在finalize() 方法中让该对象重引用链上的任何一个对象建立关联即可。而如果对象这时还没有关联到任何链上的引用，那它就会被回收掉</li></ul><h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><h4 id="标记-清除-算法"><a href="#标记-清除-算法" class="headerlink" title="标记-清除 算法"></a>标记-清除 算法</h4><p>分为“标记”和“清除”两部，首先标记出需要回收的对象，然后在第二步清除它们。是最基础的回收算法，后续算法都是基于它的基础上进行改进。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/180709_interview/标记清除.png" alt="标记-清除" title="">                </div>                <div class="image-caption">标记-清除</div>            </figure><ul><li>效率问题：需要两次扫描</li><li>空间问题：产生大量内存碎片</li></ul><h4 id="复制-算法"><a href="#复制-算法" class="headerlink" title="复制 算法"></a>复制 算法</h4><p>将可用内存平均分为2块，每次只使用其中的一块。当一块内存使用完成后，将存活对象复制到另一块内存中，然后清空。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/180709_interview/复制.png" alt="复制" title="">                </div>                <div class="image-caption">复制</div>            </figure><p>优点</p><ul><li>每次只操作一块内存，分配时无需要考虑内存碎片情况，只移动指针即可，实现简单，运行高效</li></ul><p>缺点</p><ul><li>利用率问题：可用内存少了一半</li><li>效率问题：老生代对象由于存活率高，频繁复制</li></ul><h4 id="标记-压缩-算法"><a href="#标记-压缩-算法" class="headerlink" title="标记-压缩 算法"></a>标记-压缩 算法</h4><p>标记后，将所有存活对象向一端移动</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/180709_interview/标记压缩.png" alt="标记-压缩" title="">                </div>                <div class="image-caption">标记-压缩</div>            </figure><p>优点</p><ul><li>对于老年代，会逐渐移动到头部</li></ul><p>缺点</p><ul><li>新生代对象多的话，会频繁移动</li></ul><h4 id="分代收集-算法"><a href="#分代收集-算法" class="headerlink" title="分代收集 算法"></a>分代收集 算法</h4><p>对新生代采用复制算法（Minor GC），老年代采用标记压缩算法（Major GC），全部回收称为 Full GC。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/180709_interview/分代收集.png" alt="分代收集" title="">                </div>                <div class="image-caption">分代收集</div>            </figure><ul><li>年轻代: 是所有新对象产生的地方.年轻代被分为3个部分(Enden区和两个Survivor区,也叫From和To),当Eden区被对象填满时,就会执行Minor GC,并把所有存活下来的对象转移到其中一个survivor区(Form),Minor GC同样会检查存活下来的对象,并把它们转移到另一个survivor区(To),这样在一段时间内,总会有一个空的survivor区,经过多次GC周期后，仍然存活下来的对象会被转移到年老代内存空间,常这是在年轻代有资格提升到年老代前通过设定年龄阈值来完成的,需要注意，Survivor的两个区是对称的,没先后关系,from和to是相对的.</li><li>老年代: 在年轻代中经历了N次回收后仍然没有被清除的对象,就会被放到年老代中,都是生命周期较长的对象.对于年老代,则会执行Major GC,来清理.在某些情况下,则会触发Full GC,来清理整个堆内存</li><li>元空间: 堆外的一部分内存,通常直接使用的是系统内存,用于存放运行时常量池,等内容,垃圾回收对应元空间来说没有明显的影响</li></ul><h4 id="参考：jvm-垃圾回收"><a href="#参考：jvm-垃圾回收" class="headerlink" title="参考：jvm - 垃圾回收"></a>参考：<a href="https://my.oschina.net/wangkang80/blog/1559071" target="_blank" rel="noopener">jvm - 垃圾回收</a></h4><h2 id="使用OkHttp同时发送3个请求，token过期如何处理"><a href="#使用OkHttp同时发送3个请求，token过期如何处理" class="headerlink" title="使用OkHttp同时发送3个请求，token过期如何处理"></a>使用OkHttp同时发送3个请求，token过期如何处理</h2><blockquote><p>这是面试威佩时的一道面试题</p></blockquote><p>这与发几个请求无关，解决问题的点在于发现 token 过期后如何自动获取 token 并重发请求，也就是，<strong>静默自动登录，然后继续请求</strong>。解决思路是在拦截器链中增加一个 TokenInterceptor，判断返回状态是否为验证失效。</p><ol><li>发送请求给服务端</li><li>根据返回状态码判断是否 token 过期</li><li>如果过期，则调取同步接口获取新 token</li><li>使用新 token 发送请求</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"TokenInterceptor"</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Request request = chain.request();</span><br><span class="line">    Response response = chain.proceed(request);</span><br><span class="line">    Log.d(TAG, <span class="string">"response.code="</span> + response.code());</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//根据和服务端的约定判断token过期</span></span><br><span class="line">    <span class="keyword">if</span> (isTokenExpired(response)) &#123;</span><br><span class="line">      Log.d(TAG, <span class="string">"自动刷新Token,然后重新请求数据"</span>);</span><br><span class="line">      <span class="comment">//同步请求方式，获取最新的Token</span></span><br><span class="line">      String newToken = getNewToken();</span><br><span class="line">      <span class="comment">//使用新的Token，创建新的请求</span></span><br><span class="line">      Request newRequest = chain.request()</span><br><span class="line">          .newBuilder()</span><br><span class="line">          .header(<span class="string">"Authorization"</span>, <span class="string">"Basic "</span> + newToken)</span><br><span class="line">          .build();</span><br><span class="line">      <span class="comment">//重新请求</span></span><br><span class="line">      <span class="keyword">return</span> chain.proceed(newRequest);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 根据Response，判断Token是否失效</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isTokenExpired</span><span class="params">(Response response)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (response.code() == <span class="number">301</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 同步请求方式，获取最新的Token</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> String <span class="title">getNewToken</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 通过获取token的接口，同步请求接口</span></span><br><span class="line">    String newToken = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">return</span> newToken;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是面试官问的“三个请求同时发送”，那么可以在 token 上增加一个时间戳，通过这个时间戳可以判断该 token 是否为更新过后的。那么，在 A、B、C 三个请求同时发出时，当 A 发现 token 过期并更新 token 后，B 和 C 可以读取新的 token 发送请求，而不必再向服务端获取新的 token。</p><h3 id="一点点反思"><a href="#一点点反思" class="headerlink" title="一点点反思"></a>一点点反思</h3><p>面有赞的那一天自己刚刚撸过 OkHttp 的源码，还写了文字总结，但是被问到这道题时仍然一脸懵逼。问题在于对 OkHttp 以 Interceptor 为核心的根本思想没有把握，其实这道题是稍微有一点小花招。低配版的问法是“如何解决 token 过期”，这就很容易联想到 Interceptor（其实也不容易），高配版才是问“同时三个请求”，需要结合同步来解决。</p><h3 id="参考-Android-OkHttp实现全局过期token自动刷新示例"><a href="#参考-Android-OkHttp实现全局过期token自动刷新示例" class="headerlink" title="参考 Android OkHttp实现全局过期token自动刷新示例"></a>参考 <a href="https://www.jb51.net/article/137444.htm" target="_blank" rel="noopener">Android OkHttp实现全局过期token自动刷新示例</a></h3><h2 id="RecyclerView"><a href="#RecyclerView" class="headerlink" title="RecyclerView"></a>RecyclerView</h2><p>同样是威佩的面试题</p><blockquote><p>The RecyclerView widget is a more advanced and flexible version of ListView.</p></blockquote><p>RecyclerView 支持多种 Layout，如 LinearLayout、GridLayout。使用 RecyclerView 时需要继承 RecyclerView.ViewHolder 类，如果数据发生变化，调用 RecyclerView.Adapter.notify…() 方法。示例代码如下：</p><p>gradle</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation &apos;com.android.support:recyclerview-v7:27.1.1&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>布局文件，没啥特别的，除了需要声明一个 Scrollbar 的方向</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="comment">&lt;!-- A RecyclerView with some commonly used attributes --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">android.support.v7.widget.RecyclerView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/my_recycler_view"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:scrollbars</span>=<span class="string">"vertical"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>Activity，跟 ListView 不同点在：</p><ul><li>如果 RecyclerView 的尺寸不会发生变化，要调用<code>setHasFixedSize(true)</code>来提高性能</li><li>要根据布局设置 LayoutManager</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RecyclerView mRecyclerView;</span><br><span class="line">    <span class="keyword">private</span> RecyclerView.Adapter mAdapter;</span><br><span class="line">    <span class="keyword">private</span> RecyclerView.LayoutManager mLayoutManager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.my_activity);</span><br><span class="line">        mRecyclerView = (RecyclerView) findViewById(R.id.my_recycler_view);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// use this setting to improve performance if you know that changes</span></span><br><span class="line">        <span class="comment">// in content do not change the layout size of the RecyclerView</span></span><br><span class="line">        mRecyclerView.setHasFixedSize(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// use a linear layout manager</span></span><br><span class="line">        mLayoutManager = <span class="keyword">new</span> LinearLayoutManager(<span class="keyword">this</span>);</span><br><span class="line">        mRecyclerView.setLayoutManager(mLayoutManager);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// specify an adapter (see also next example)</span></span><br><span class="line">        mAdapter = <span class="keyword">new</span> MyAdapter(myDataset);</span><br><span class="line">        mRecyclerView.setAdapter(mAdapter);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Adapter，与 ListView 的写法差异较大。</p><ul><li>需要继承自 RecyclerView.Adapter&lt;MyAdapter.ViewHolder&gt;</li><li>必须声明一个静态内部类 ViewHolder</li><li>重载 onCreateViewHolder 方法，需要生成布局，初始化 ViewHolder 并返回</li><li>重载 onBindViewHolder 方法，这一步是将 ViewHolder 中的 View 都赋予正确的数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAdapter</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">Adapter</span>&lt;<span class="title">MyAdapter</span>.<span class="title">ViewHolder</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] mDataset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Provide a reference to the views for each data item</span></span><br><span class="line">    <span class="comment">// Complex data items may need more than one view per item, and</span></span><br><span class="line">    <span class="comment">// you provide access to all the views for a data item in a view holder</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewHolder</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">ViewHolder</span> </span>&#123;</span><br><span class="line">        <span class="comment">// each data item is just a string in this case</span></span><br><span class="line">        <span class="keyword">public</span> TextView mTextView;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ViewHolder</span><span class="params">(TextView v)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(v);</span><br><span class="line">            mTextView = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Provide a suitable constructor (depends on the kind of dataset)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyAdapter</span><span class="params">(String[] myDataset)</span> </span>&#123;</span><br><span class="line">        mDataset = myDataset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create new views (invoked by the layout manager)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> MyAdapter.<span class="function">ViewHolder <span class="title">onCreateViewHolder</span><span class="params">(ViewGroup parent,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                   <span class="keyword">int</span> viewType)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// create a new view</span></span><br><span class="line">        TextView v = (TextView) LayoutInflater.from(parent.getContext())</span><br><span class="line">                .inflate(R.layout.my_text_view, parent, <span class="keyword">false</span>);</span><br><span class="line">        ...</span><br><span class="line">        ViewHolder vh = <span class="keyword">new</span> ViewHolder(v);</span><br><span class="line">        <span class="keyword">return</span> vh;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Replace the contents of a view (invoked by the layout manager)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBindViewHolder</span><span class="params">(ViewHolder holder, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// - get element from your dataset at this position</span></span><br><span class="line">        <span class="comment">// - replace the contents of the view with that element</span></span><br><span class="line">        holder.mTextView.setText(mDataset[position]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return the size of your dataset (invoked by the layout manager)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getItemCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mDataset.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LayoutManager"><a href="#LayoutManager" class="headerlink" title="LayoutManager"></a>LayoutManager</h3><p>Android Support Library 自带的有三种，你也可以通过继承 RecyclerView.LayoutManager 来实现自己的布局。</p><ul><li>LinearLayoutManager，一维线性列表，同 ListView</li><li>GridLayoutManager，网格列表，同 GridView</li><li>StaggeredGridLayotManager，瀑布流列表，列之间有错位</li></ul><h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><p>Item 变化的时候，RecyclerView 使用 animator 来改变外观，animator 继承自 RecyclerView.ItemAnimator。</p><h3 id="List-Item-Selection"><a href="#List-Item-Selection" class="headerlink" title="List-Item Selection"></a>List-Item Selection</h3><p>这部分略，日后写 Demo 补充</p><h3 id="RecyclerView-几大重要成员"><a href="#RecyclerView-几大重要成员" class="headerlink" title="RecyclerView 几大重要成员"></a>RecyclerView 几大重要成员</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/180709_interview/recyclerview_components.jpeg" alt="RecyclerView Components" title="">                </div>                <div class="image-caption">RecyclerView Components</div>            </figure><h3 id="RecyclerView-缓存"><a href="#RecyclerView-缓存" class="headerlink" title="RecyclerView 缓存"></a>RecyclerView 缓存</h3><ul><li>内部两级缓存</li><li>划出界面的 ViewHolder 会被放入 Cache（一级缓存），容量为2。Cache 中的对象都是同种 ViewType。</li><li>从 Cache 中被清除的对象，会被放入 RecycledViewPool，容量为5。RecycledViewPool 中的对象按照 ViewType 分类。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/180709_interview/recyclerview_cache.webp" alt="RecyclerView Cache" title="">                </div>                <div class="image-caption">RecyclerView Cache</div>            </figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://developer.android.com/guide/topics/ui/layout/recyclerview" target="_blank" rel="noopener">RecycyerView - Developers</a></li><li><a href="https://mp.weixin.qq.com/s?src=3&amp;timestamp=1531269425&amp;ver=1&amp;signature=FWpjJw5RhmTc*7UKCIha2t9LR*Hpr*knccH5aD2iiD7suxuKZgREroUCYpvcJxeOaz3lJbk4Ht4MmjXZAHcp-x1Ui7EAekMj8i1-hWpBwyd1YhGg7wx15pshQwnTTm7Dvan5LJDoOJvNoPatOjSrFePotNTHk1ON6c*6K1OZm40=" target="_blank" rel="noopener">深入浅出 RecyclerView</a></li></ul><h2 id="微信的“分享”页面使用的是哪种启动模式"><a href="#微信的“分享”页面使用的是哪种启动模式" class="headerlink" title="微信的“分享”页面使用的是哪种启动模式"></a>微信的“分享”页面使用的是哪种启动模式</h2><p>这是面试有赞时，面试官提问的第一道题目。直觉告诉我 Standard 和 SingleTop 都不适用，但是并不能从 SingleInstance 和 SingleTask 中选出一个合适的来，这一块是知识盲区，以前根本没有从实用的角度来考虑这问题，都是死记硬背启动模式。</p><p>本质上还是考察启动模式的应用场景。</p><h3 id="SingleInstance"><a href="#SingleInstance" class="headerlink" title="SingleInstance"></a>SingleInstance</h3><p>与外部应用共享的页面，一般设置成这种启动模式，也就是作为外部App调用自己客户端程序的入口。这是为了方便其它应用的 Activity 调起本应用。同时，由于 SingleInstance 会单独起一个 Task，当用户操作完成该页面后，点击返回按钮，会自动退回到外部应用。在使用时应该注意声明<code>taskAffinity</code>，以便在任务管理中看到新 Task。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">".SingleInstanceActivity"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">"singleInstance launchMode"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:launchMode</span>=<span class="string">"singleInstance"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="SingleTask"><a href="#SingleTask" class="headerlink" title="SingleTask"></a>SingleTask</h3><p>一个 Task 内只允许有一个 SingleTask 的 Activity，启东时如果 Task 内已经有了同 Activity，则会将其上所有的 Activity 按照生命流程进行销毁，同时调用该 Activity 的<code>onNewIntent</code>方法。适合的应用场景是应用内部统一入口，比如浏览器首页、商户详情页等。同样，需要声明<code>taskAffinity</code>以保证它会新起一个 Task。</p><h3 id="SingleTop"><a href="#SingleTop" class="headerlink" title="SingleTop"></a>SingleTop</h3><p>同样，如果 Task 顶已经有了同一个 Activity，会调用<code>onNewIntent</code>传入参数。</p><p>应用场景：</p><ul><li>点击“通知”后打开的详情页面</li><li>浏览器搜索结果页，带有关键词输入框</li></ul><h3 id="Standard"><a href="#Standard" class="headerlink" title="Standard"></a>Standard</h3><p>应用于可以打开多个实例的页面，比如与不同人的聊天页面，撰写邮件页面等。</p><h3 id="场景：应用进程被杀后再次启动"><a href="#场景：应用进程被杀后再次启动" class="headerlink" title="场景：应用进程被杀后再次启动"></a>场景：应用进程被杀后再次启动</h3><p>设想一个这样的应用场景：用户在使用你的应用时，突然接收到一个微信消息，他跳转到微信后，你的应用被切换至后台运行。该用户在微信中翻阅了朋友圈、查看一些视频，以及进行了其它很多吃内存的操作，导致系统内存紧张，这时你的应用进程被杀死。但是由于Android系统仍然会保持 Task 栈的内容，所以用户在“最近应用”里仍然是可以看到你的应用的。此时如果用户通过“最近应用”切换回你的应用（进程已经被杀死），极易发生异常导致闪退。</p><p>异常原因在于当进程被杀死后，所有的静态常量值会被清空，如果在此时使用并且未经检查，很容易出现 NPE 等异常。常规解决方法是在 onSaveInstance 里面对变量进行保存，然后在 onRestoreInstance 里恢复变量值。缺点是工作量大，代码冗长。</p><p>此时的一个解决思路是对于进程被杀死的情况，如果再次启动，则跳转回应用首页（这点需要获取产品经理同意），随后的一切等同于首次启动。</p><p>相应的技术思路是，将首页启动模式声明为 SingleTask，同时写一个 BaseActivity，它里面有一个 getAppStatus 方法用来判断应用是否处于回收后重新启动的状态，判断方法是读取一个静态 int 类型变量 appStatus，它默认值是 KILLED，在每一个子 Activity 的 onCreate 方法里将其设置成 NORMAL 值。这样一旦被回收，它就会变成 KILLED，就可以在 BaseActivity.onCreate 里通过对这个变量的判断，决定是不是要重新回到首页。</p><h3 id="参考：如何让你的app在后台被干掉后优雅的启动"><a href="#参考：如何让你的app在后台被干掉后优雅的启动" class="headerlink" title="参考：如何让你的app在后台被干掉后优雅的启动"></a>参考：<a href="http://www.apkbus.com/blog-964080-78423.html" target="_blank" rel="noopener">如何让你的app在后台被干掉后优雅的启动</a></h3><h2 id="IntentService-实现原理"><a href="#IntentService-实现原理" class="headerlink" title="IntentService 实现原理"></a>IntentService 实现原理</h2><p>通过<code>startService(Intent)</code>来启动一个 IntentService，它内部有一个工作队列（Worker Thread），在工作线程内运行，不会影响 UI 线程。IntentService 是一个抽象类，继承它时必须实现<code>onHandleIntent</code>方法。</p><ul><li>普通 Service 由于运行在 UI 线程，无法进行耗时操作，IntentService 解决了这个问题</li><li>运行完成后，IntentService 会自动停止</li></ul><p>从原理上讲，IntentService 是创建了一个 HandlerThread，然后用 thread.getLooper() 赋给 Handler，这个 Handler 接收 onStart 时传来的 Intent，并以此 Intent 调用你所覆盖的 onHandleIntent 方法。任务完成后，可以用广播或者 EventBus 等手段通知调用者。</p><h3 id="参考：IntentService的原理和实例分析"><a href="#参考：IntentService的原理和实例分析" class="headerlink" title="参考：IntentService的原理和实例分析"></a>参考：<a href="https://www.jianshu.com/p/4dd46616564d" target="_blank" rel="noopener">IntentService的原理和实例分析</a></h3><h2 id="HTTP-请求和响应头的格式"><a href="#HTTP-请求和响应头的格式" class="headerlink" title="HTTP 请求和响应头的格式"></a>HTTP 请求和响应头的格式</h2><p>有赞和威佩都问到了这一题。</p><p>HTTP的头域包括通用头，请求头，响应头和实体头四个部分。每个头域由一个域名，冒号（:）和域值三部分组成。域名是大小写无关的，域值前可以添加任何数量的空格符，头域可以被扩展为多行，在每行开始处，使用至少一个空格或制表符。</p><h3 id="通用头"><a href="#通用头" class="headerlink" title="通用头"></a>通用头</h3><p>通用头域包含请求和响应消息都支持的头域，通用头域包含Cache-Control、Connection、Date、Pragma、Transfer-Encoding、Upgrade、Via。</p><h3 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h3><p>请求消息的第一行为下面的格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Method　SP　Request-URI　SP　HTTP-Version　CRLF</span><br></pre></td></tr></table></figure><p>请求头域允许客户端向服务器传递关于请求或者关于客户机的附加信息。请求头域可能包含下列字段Accept、Accept-Charset、Accept- Encoding、Accept-Language、Authorization、From、Host、If-Modified-Since、If- Match、If-None-Match、If-Range、If-Range、If-Unmodified-Since、Max-Forwards、 Proxy-Authorization、Range、Referer、User-Agent。</p><h3 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h3><p>响应消息的第一行为下面的格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP-Version　SP　Status-Code　SP　Reason-Phrase　CRLF</span><br></pre></td></tr></table></figure><p>常见错误码</p><ul><li>1xx:信息响应类，表示接收到请求并且继续处理</li><li>2xx:处理成功响应类，表示动作被成功接收、理解和接受</li><li>3xx:重定向响应类，为了完成指定的动作，必须接受进一步处理</li><li>4xx:客户端错误，客户请求包含语法错误或者是不能正确执行</li><li>5xx:服务端错误，服务器不能正确执行一个正确的请求</li></ul><h3 id="实体信息"><a href="#实体信息" class="headerlink" title="实体信息"></a>实体信息</h3><p>请求消息和响应消息都可以包含实体信息，实体信息一般由实体头域和实体组成。实体头域包含关于实体的原信息，实体头包括Allow、Content-Base、Content-Encoding、Content-Language、 Content-Length、Content-Location、Content-MD5、Content-Range、Content-Type、 Etag、Expires、Last-Modified、extension-header。</p><h2 id="MVP-中对-Presenter-如何进行测试"><a href="#MVP-中对-Presenter-如何进行测试" class="headerlink" title="MVP 中对 Presenter 如何进行测试"></a>MVP 中对 Presenter 如何进行测试</h2><h3 id="各层单元测试选型"><a href="#各层单元测试选型" class="headerlink" title="各层单元测试选型"></a>各层单元测试选型</h3><p>各层由于特性不同，所采用的测试工具也不一样</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/180709_interview/mvp_ut.png" alt="JVM" title="">                </div>                <div class="image-caption">JVM</div>            </figure><ul><li>Model层：涉及数据库操作，依赖 Android 环境，使用 AndroidJUnitRunner 测试</li><li>View层：涉及 UI，使用 Espresso 进行测试</li><li>Presenter层：不需要 Android 环境，纯 JAVA 代码，使用 JUnit 测试</li></ul><p>MVP 的一大优点就是将数据、视图、逻辑解耦，从而可以对其中某一角色进行单独测试。然而，想要对 Presenter 进行测试，就必须回答以下几个问题：</p><ol><li>测试过程要避免通过网络或者本地存储产生脏数据，因此必须对数据层接口进行 Mock</li><li>为了提高执行效率，并且 Presenter 本身是视图无关的，因此测试用例应该可以脱离真机/模拟器独立运行，也就是说，要有对 View 的Mock</li><li>如何检验 Presenter 的各个方法运行成功了</li></ol><p>我们以 Demo 中对 AddEditTaskPresenter 的测试为例，看参考答案是怎样的，对应的类是<code>AddEditTaskPresenterTest.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mock</span></span><br><span class="line"><span class="keyword">private</span> TasksRepository mTasksRepository;</span><br></pre></td></tr></table></figure><p>这里直接使用 Mockito 的<code>@Mock</code>注解来声明，需要注意的是要在测试用例运行之前通过<code>MockitoAnnotations.initMocks(this)</code>进行注入。如此这般解决了数据层 Mock 的问题。</p><p>对 View 的注入也一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mock</span></span><br><span class="line"><span class="keyword">private</span> AddEditTaskContract.View mAddEditTaskView;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setupMocksAndView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Mockito has a very convenient way to inject mocks by using the @Mock annotation. To</span></span><br><span class="line">    <span class="comment">// inject the mocks in the test the initMocks method needs to be called.</span></span><br><span class="line">    MockitoAnnotations.initMocks(<span class="keyword">this</span>); <span class="comment">// 注入 Mock 对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// The presenter wont't update the view unless it's active.</span></span><br><span class="line">    when(mAddEditTaskView.isActive()).thenReturn(<span class="keyword">true</span>); <span class="comment">// 这段代码的含义是“当 isActive 被调用时，直接返回 true”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们看如何检验 Presenter 里面各个方法调用成功，选一个比较复杂的涉及到回调的场景，也就是获取单个 Task，这是一个异步回调接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">populateTask_callsRepoAndUpdatesView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Task testTask = <span class="keyword">new</span> Task(<span class="string">"TITLE"</span>, <span class="string">"DESCRIPTION"</span>);</span><br><span class="line">    <span class="comment">// Get a reference to the class under test</span></span><br><span class="line">    mAddEditTaskPresenter = <span class="keyword">new</span> AddEditTaskPresenter(testTask.getId(),</span><br><span class="line">            mTasksRepository, mAddEditTaskView, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// When the presenter is asked to populate an existing task</span></span><br><span class="line">    mAddEditTaskPresenter.populateTask(); <span class="comment">// 这里会调用 Repository 里面的 getTask 方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Then the task repository is queried and the view updated</span></span><br><span class="line">    <span class="comment">// 验证调用到了 getTask 方法，并且将回调赋给 mGetTaskCallbackCaptor，后面可以对 captor 自由触发回调</span></span><br><span class="line">    verify(mTasksRepository).getTask(eq(testTask.getId()), mGetTaskCallbackCaptor.capture());</span><br><span class="line">    assertThat(mAddEditTaskPresenter.isDataMissing(), is(<span class="keyword">true</span>)); <span class="comment">// 这时候还没有加载成功 task</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Simulate callback</span></span><br><span class="line">    mGetTaskCallbackCaptor.getValue().onTaskLoaded(testTask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证 View 里面相应方法得到调用</span></span><br><span class="line">    verify(mAddEditTaskView).setTitle(testTask.getTitle());</span><br><span class="line">    verify(mAddEditTaskView).setDescription(testTask.getDescription());</span><br><span class="line">    assertThat(mAddEditTaskPresenter.isDataMissing(), is(<span class="keyword">false</span>)); <span class="comment">// 此时加载成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上，可以理解对 Presenter 进行单元测试的验证流程就是“调用 Presenter 里面的某个方法 -&gt; 将回调暂存 -&gt; 验证 View 里面相应的方法被执行 -&gt; 给回调赋值，验证回调”</p><h2 id="屏幕物理尺寸，像素，dp，px，sp"><a href="#屏幕物理尺寸，像素，dp，px，sp" class="headerlink" title="屏幕物理尺寸，像素，dp，px，sp"></a>屏幕物理尺寸，像素，dp，px，sp</h2><p>物理尺寸：这个很好理解，就是屏幕长多少mm，宽多少mm。但通常不会直接说长宽，而是用“xx英寸”表示，比如我的小米5x就是5.5英寸，这里的5.5英寸指的是对角线长度，1英寸 ≈ 2.54cm，5.5英寸 ≈ 13.97cm ≈ 14cm，市面上如今 90% 以上的手机都是 16:9 的，所以可以列出方程 (16x)^2 + (9x)^2 = 14^2，解方程得到 x = 0.76cm，得出小米5x屏幕物理尺寸为长 12.16cm，宽 6.84cm。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/180709_interview/5x_screen_size.jpg" alt="5x屏幕尺寸" title="">                </div>                <div class="image-caption">5x屏幕尺寸</div>            </figure><p>分辨率/像素：从上图里看到，5x宽高为 1080px * 1920px，对于这样的手机通常称其分辨率为 1080p。像素的概念比较容易理解，一个像素就是液晶屏的一个最小发光单元，8-bit 游戏常被称为像素游戏，因为像素颗粒通常比较大，图像有方块感。</p><p>物理尺寸与分辨率没有必然的关系。</p><p>像素密度：Pixels Per Inch，PPI，也称为 Dots Per Inch（DPI）。每英寸上排列的像素个数，这个“每英寸”是长还是宽呢？都不是，是指对角线。通过勾股定理计算，1080*1920 分辨率的屏幕，其对角线像素数为 2203p，那么小米5x的 PPI 就是 2203/5.5 = 400。像素密度越高，锯齿感越低，显示越精细。</p><p>倍率和逻辑像素：iPhone 3gs 和 4s，物理尺寸都是 3.5 英寸，3gs 的分辨率是 320x480，4s 的分辨率则是 640x960，4s 的像素密度是 3gs 的两倍，单个像素尺寸是 3gs 的一半。但是在显示中，这两个设备的显示效果却是一样的，原因在于 4s 用 2x2 个像素合并成 1 个像素，如下图。这使得同样的图片在 4s 上显示更加清晰。然而这对图片源文件有要求，必须使用带有“@2x”后缀的图片，系统会自动将其用于 4s 设备上。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/180709_interview/ip_3gs_4s.png" alt="3gs 4s" title="">                </div>                <div class="image-caption">3gs 4s</div>            </figure><p>上面讲的是苹果的处理方法，对于 Android 这并不太适用，因为 Android 设备的分辨率实在太多了。因此划分为多种尺寸，如下。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/180709_interview/Android_dpi.png" alt="Android DPI" title="">                </div>                <div class="image-caption">Android DPI</div>            </figure><p>以 160DPI（mdpi） 为基准，倍率为一倍，其它密度以此计算。在 160DPI的情况下，1px = 1dp。</p><ul><li>ldpi [0.75倍]</li><li>mdpi [1倍]</li><li>hdpi [1.5倍]</li><li>xhdpi [2倍]</li><li>xxhdpi [3倍]</li><li>xxxhdpi [4倍]</li></ul><p>所以为了保证准确高效的沟通，无论是在标注图还是在日常沟通中，设计人员与开发人员都需要尽量以逻辑像素尺寸来描述和理解界面，真正决定显示效果的，是逻辑像素尺寸。然而并不是所有 Android 设备的逻辑像素尺寸都一致，比如两种常见的屏幕480×800和1080×1920，它们分别属于hdpi和xxhdpi。除以各自倍率1.5倍和3倍，得到逻辑像素为320×533和360×640。很显然，后者更宽更高，能显示更多内容。</p><p>px：pixels,像素，屏幕上实际的像素点单位</p><p>dp：device independent pixels, 设备独立像素，安卓专用长度单位，以160ppi屏幕为标准，则 1dp=1px。dp*ppi/160=px</p><p>sp：scaled pixels,放大像素，安卓专用字体单位，以160ppi屏幕为标准，字体大小为100%时，则1dp=1px</p><p>Android 一般以 360x640 的逻辑尺寸来设计 UI</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/180709_interview/Android_Screen_Size.png" alt="Android常见屏幕尺寸与DPI" title="">                </div>                <div class="image-caption">Android常见屏幕尺寸与DPI</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;HashMap-和-HashTable-区别&quot;&gt;&lt;a href=&quot;#HashMap-和-HashTable-区别&quot; class=&quot;headerlink&quot; title=&quot;HashMap 和 HashTable 区别&quot;&gt;&lt;/a&gt;HashMap 和 HashTable 
      
    
    </summary>
    
    
      <category term="Android" scheme="https://lilei.pro/tags/Android/"/>
    
      <category term="面试" scheme="https://lilei.pro/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>OkHttp 源码学习</title>
    <link href="https://lilei.pro/2018/07/06/okhttp/"/>
    <id>https://lilei.pro/2018/07/06/okhttp/</id>
    <published>2018-07-06T07:36:57.000Z</published>
    <updated>2018-07-09T08:29:07.757Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>OkHttp 是由 Square 发布的 HTTP Client，用于处理 HTTP 请求。<br>用官网的描述就是，An HTTP &amp; HTTP/2 client for Android and Java applications.</p></blockquote><h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><ul><li>支持 HTTP/2，多个连接可以共用一个 Socket</li><li>连接池可以减少延迟（非 HTTP/2）</li><li>GZIP 压缩减少流量</li><li>Response 缓存</li><li>重定向和重试</li></ul><h1 id="OkHttp-的用法"><a href="#OkHttp-的用法" class="headerlink" title="OkHttp 的用法"></a>OkHttp 的用法</h1><h2 id="同步请求"><a href="#同步请求" class="headerlink" title="同步请求"></a>同步请求</h2><p>需要在 AsyncTask 或者起线程来进行，调用<code>execute()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">doRequest</span><span class="params">(String param)</span> </span>&#123;</span><br><span class="line">Request.Builder builder = <span class="keyword">new</span> Request.Builder();</span><br><span class="line">builder.url(param);</span><br><span class="line">Request request = builder.build();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Response response = client.newCall(request).execute();</span><br><span class="line">    <span class="keyword">return</span> response.body().string();</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h2><p>调用<code>enqueue()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"></span><br><span class="line">Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">        .url(url)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">client.newCall(request).enqueue(<span class="keyword">new</span> Callback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call call, IOException e)</span> </span>&#123;</span><br><span class="line">        call.cancel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call call, Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> String myResponse = response.body().string();</span><br><span class="line"></span><br><span class="line">        MainActivity.<span class="keyword">this</span>.runOnUiThread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                txtString.setText(myResponse);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="设置-Header-和参数"><a href="#设置-Header-和参数" class="headerlink" title="设置 Header 和参数"></a>设置 Header 和参数</h2><p>在 URL 构建过程中通过<code>addQueryParameter</code>设置参数，在 Request 构建过程中设置 Header</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HttpUrl.Builder urlBuilder = HttpUrl.parse(<span class="string">"https://httpbin.org/get).newBuilder();</span></span><br><span class="line"><span class="string">urlBuilder.addQueryParameter("</span>website<span class="string">", "</span>www.journaldev.com<span class="string">");</span></span><br><span class="line"><span class="string">urlBuilder.addQueryParameter("</span>tutorials<span class="string">", "</span>android<span class="string">");</span></span><br><span class="line"><span class="string">String url = urlBuilder.build().toString();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Request request = new Request.Builder()</span></span><br><span class="line"><span class="string">.header("</span>Authorization<span class="string">", "</span>replace <span class="keyword">this</span> text with your token<span class="string">")</span></span><br><span class="line"><span class="string">.url(url)</span></span><br><span class="line"><span class="string">.build();</span></span><br></pre></td></tr></table></figure><h2 id="post-请求"><a href="#post-请求" class="headerlink" title="post 请求"></a>post 请求</h2><p>需要声明<code>MediaType</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String postUrl= <span class="string">"https://reqres.in/api/users/"</span>;</span><br><span class="line"><span class="keyword">public</span> String postBody=<span class="string">"&#123;\n"</span> +</span><br><span class="line">        <span class="string">"    \"name\": \"morpheus\",\n"</span> +</span><br><span class="line">        <span class="string">"    \"job\": \"leader\"\n"</span> +</span><br><span class="line">        <span class="string">"&#125;"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MediaType JSON = MediaType.parse(<span class="string">"application/json; charset=utf-8"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postRequest</span><span class="params">(String postUrl,String postBody)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"></span><br><span class="line">    RequestBody body = RequestBody.create(JSON, postBody);</span><br><span class="line"></span><br><span class="line">    Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">            .url(postUrl)</span><br><span class="line">            .post(body)</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    client.newCall(request).enqueue(<span class="keyword">new</span> Callback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call call, IOException e)</span> </span>&#123;</span><br><span class="line">            call.cancel();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call call, Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            Log.d(<span class="string">"TAG"</span>,response.body().string());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h1><p>我认为 OkHttp 的核心是以分层的思想链式处理网络请求。所有处理的代码都位于<code>XXXInterceptor</code>中，一共有6个这样的 Interceptor，接口如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">  <span class="function">Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException</span>; <span class="comment">// 处理当前层的请求</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图来源于 Piasy 的博客，很好地描述了 OkHttp 发送网络请求到处理完成的过程。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/180706_okhttp/okhttp_flow.png" alt="flow" title="">                </div>                <div class="image-caption">flow</div>            </figure><h1 id="关键类讲解"><a href="#关键类讲解" class="headerlink" title="关键类讲解"></a>关键类讲解</h1><ul><li><p>RetryAndFollowUpInterceptor，处理请求失败重试以及重定向（30X）</p></li><li><p>BridgeInterceptor，对 Request 和 Response 进行封装，主要是写 Header，Gzip 解压缩等操作</p></li><li><p>CacheInterceptor，缓存，很棒的磁盘缓存设计，维护一个日志文件来进行缓存的恢复重建</p></li><li><p>ConnectInterceptor，管理与目标的连接，采用策略模式，有 HTTP(HTTP/1.1) 和 HTTP/2 两种策略，关键类<code>StreamAllocation</code></p></li><li><p>CallServerInterceptor，数据交换，将数据传送给服务器，从服务器拉取数据。写请求头 -&gt; 写请求体 -&gt; 获取响应头 -&gt; 获取响应体</p></li></ul><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="构建器模式"><a href="#构建器模式" class="headerlink" title="构建器模式"></a>构建器模式</h2><p>构建器模式可以减少冗长的构造函数，并且可以在设置参数时进行检查。OKHttpClient.java、Request.java 这些类里面都用到了 Builder 模式，简单写一个模版</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> A a;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Foo</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = builder.a;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.a = <span class="string">"a"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">a</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.a = a;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Foo <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Foo(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>策略模式体现面向接口编程的概念，将具体实现与接口剥离，减少耦合性。ContentInterceptor 里面的 HttpCodec 接口就是这样的，有 HTTP/1 和 HTTP/2 两种实现。</p><h2 id="责任链模式（chain-of-responbility）"><a href="#责任链模式（chain-of-responbility）" class="headerlink" title="责任链模式（chain of responbility）"></a>责任链模式（chain of responbility）</h2><p>责任链模式包含了一系列对象，以及一系列处理指令。这些对象共同构成了一个链表，链表中的每一环都有一系列指令，链表中的对象经过逐级递归处理后，生成最终结果。可以向处理链的末尾添加新的处理指令。Interceptor.Chain 所采用的模式，每一层都处理各自的职责，按照链式递归调用。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>OkHttp 的代码复杂程度让人头大，我不敢说自己已经摸清了这个框架，有很多地方值得深入挖掘，比如基于日志 Cache 的实现细节，责任链模式的设计。下一课题：Retrofit。学习过程中参考了简书上“被代码淹没的小伙子”<a href="https://www.jianshu.com/p/37e26f4ea57b" target="_blank" rel="noopener">okhttp源码分析</a>系列文章，感谢原作者。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;OkHttp 是由 Square 发布的 HTTP Client，用于处理 HTTP 请求。&lt;br&gt;用官网的描述就是，An HTTP &amp;amp; HTTP/2 client for Android and Java applications.&lt;/p
      
    
    </summary>
    
    
      <category term="Android" scheme="https://lilei.pro/tags/Android/"/>
    
      <category term="源码学习" scheme="https://lilei.pro/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
