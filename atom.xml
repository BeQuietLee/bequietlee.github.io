<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>柘个角落</title>
  <icon>https://www.gravatar.com/avatar/bd80dd1283cd0ce8323c050b40cb6f38</icon>
  <subtitle>IF YOU WANT SOMETHING, GO GET IT. PERIOD.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lilei.pro/"/>
  <updated>2020-03-16T15:13:20.424Z</updated>
  <id>https://lilei.pro/</id>
  
  <author>
    <name>Li Lei</name>
    <email>bequietlee@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>通关Jetpack之 Data Binding：第2课 接口纵览</title>
    <link href="https://lilei.pro/2020/03/16/Go-through-jetpack-data-binding-L2/"/>
    <id>https://lilei.pro/2020/03/16/Go-through-jetpack-data-binding-L2/</id>
    <published>2020-03-16T15:18:48.000Z</published>
    <updated>2020-03-16T15:13:20.424Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是《通关Jetpack》系列的第2篇文章</p></blockquote><blockquote><p>我没什么能耐，不能给你们更好的生活，唯一能做的，是挡在你们前边。——《误杀》</p></blockquote><p>在上一篇文章中，通过实例介绍了Data Binding的概念和用法，本篇文章则从更丰富的细节上介绍Data Binding的种种用法。</p><p>##创建Data Binding的两种方式</p><p>在代码里，如果要获取到Data Binding对象，有2种方式</p><h3 id="方式一：一步到位的DataBindingUtil。"><a href="#方式一：一步到位的DataBindingUtil。" class="headerlink" title="方式一：一步到位的DataBindingUtil。"></a>方式一：一步到位的<code>DataBindingUtil</code>。</h3><p>在<code>onCreate</code>中，可以同时完成设置布局文件+创建Binding对象两个动作。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">    <span class="keyword">val</span> binding: ActivityMainBinding = DataBindingUtil.setContentView(</span><br><span class="line">            <span class="keyword">this</span>, R.layout.activity_main)</span><br><span class="line">    binding.user = User(<span class="string">"Test"</span>, <span class="string">"User"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者在<code>Fragment</code>、<code>ListView</code>或者<code>RecyclerView</code>的初始方法中。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> listItemBinding = DataBindingUtil.inflate(layoutInflater, R.layout.list_item, viewGroup, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure><h3 id="方式二：单独使用LayoutInflater"><a href="#方式二：单独使用LayoutInflater" class="headerlink" title="方式二：单独使用LayoutInflater"></a>方式二：单独使用<code>LayoutInflater</code></h3><p>如果已经调用了<code>setContentView()</code>，则可以在之后单独使用<code>inflate</code>方法来获取Binding对象。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> binding: ActivityMainBinding = ActivityMainBinding.inflate(getLayoutInflater())</span><br></pre></td></tr></table></figure><p>对于<code>Fragment</code>、<code>ListView</code>或者<code>RecyclerView</code>也同理。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> listItemBinding = ListItemBinding.inflate(layoutInflater, viewGroup, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure><h2 id="表达式用法"><a href="#表达式用法" class="headerlink" title="表达式用法"></a>表达式用法</h2><h3 id="可以在布局文件中使用的表达式"><a href="#可以在布局文件中使用的表达式" class="headerlink" title="可以在布局文件中使用的表达式"></a>可以在布局文件中使用的表达式</h3><p>可以在布局文件中使用丰富的表达式，列举如下，暂不举例。</p><ul><li>数学运算符 <code>+ - / * %</code></li><li>字符串拼接 <code>+</code></li><li>逻辑算式 <code>&amp;&amp; ||</code></li><li>二元运算符 <code>&amp; | ^</code></li><li>一元运算符 <code>+ - ! ~</code></li><li>三目运算符 <code>?:</code></li><li>移位运算 <code>&gt;&gt; &gt;&gt;&gt; &lt;&lt;</code></li><li>比较运算 <code>== &gt; &lt; &gt;= &lt;=</code>（注意在xml中需要将<code>&lt;</code>转义写为<code>&amp;lt;</code>）</li><li><code>instanceof</code></li><li>小括号 <code>()</code></li><li>字面量 字符、字符串、数字以及<code>null</code></li><li>类型转换</li><li>方法调用</li><li>属性读取</li><li>数组读取 <code>[]</code></li></ul><h3 id="NULL则替换"><a href="#NULL则替换" class="headerlink" title="NULL则替换"></a>NULL则替换</h3><p>NULL则替换表达式（<code>??</code>）很好用，可以避免很多NPE的场景。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// NULL则替换</span><br><span class="line">android:text="@&#123;user.displayName ?? user.lastName&#125;"</span><br><span class="line">// 等价于</span><br><span class="line">android:text="@&#123;user.displayName != null ? user.displayName : user.lastName&#125;"</span><br></pre></td></tr></table></figure><h3 id="读取属性值"><a href="#读取属性值" class="headerlink" title="读取属性值"></a>读取属性值</h3><p>其实对于 a. public属性 b. 带有getter的属性 c. 可观测的属性<code>ObservableField</code>，它们在xml里的读取写法都是相同的，都是<code>对象.属性</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:text="@&#123;user.name&#125;"</span><br></pre></td></tr></table></figure><h3 id="读取同一布局文件里其它的View"><a href="#读取同一布局文件里其它的View" class="headerlink" title="读取同一布局文件里其它的View"></a>读取同一布局文件里其它的View</h3><blockquote><p>尽管很少用到，但还是介绍一下。</p></blockquote><p>比如我有两个TextView，id无分别是<code>text_view_name</code>和<code>text_view_nickname</code>，在第二个TextView里可以访问第一个TextView的文本，则可以这么写，需要留意的就是会自动将id转为驼峰命名。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">...</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">"@&#123;textViewName.text&#125;"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">...</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="集合的写法"><a href="#集合的写法" class="headerlink" title="集合的写法"></a>集合的写法</h3><p>在xml里同样可以使用集合Data，并通过<code>[]</code>来获取集合中特定的元素。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">type</span>=<span class="string">"android.util.SparseArray"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">type</span>=<span class="string">"java.util.Map"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">type</span>=<span class="string">"java.util.List"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"list"</span> <span class="attr">type</span>=<span class="string">"List&amp;lt;String&gt;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"sparse"</span> <span class="attr">type</span>=<span class="string">"SparseArray&amp;lt;String&gt;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"map"</span> <span class="attr">type</span>=<span class="string">"Map&amp;lt;String, String&gt;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"index"</span> <span class="attr">type</span>=<span class="string">"int"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"key"</span> <span class="attr">type</span>=<span class="string">"String"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">…</span><br><span class="line">android:text="@&#123;list[index]&#125;"</span><br><span class="line">…</span><br><span class="line">android:text="@&#123;sparse[index]&#125;"</span><br><span class="line">…</span><br><span class="line">android:text="@&#123;map[key]&#125;"</span><br></pre></td></tr></table></figure><h3 id="String字面量"><a href="#String字面量" class="headerlink" title="String字面量"></a>String字面量</h3><p>在xml文件中，如果要使用双引号<code>&quot;</code>，则可以将外部的双引号替换为单引号<code>&#39;</code>。或者在应当使用双引号的地方使用反引号。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 单引号替代双引号 --&gt;</span></span><br><span class="line">android:text='@&#123;map["firstName"]&#125;'</span><br><span class="line"><span class="comment">&lt;!-- 反引号替代双引号 --&gt;</span></span><br><span class="line">android:text="@&#123;map[`firstName`]&#125;"</span><br></pre></td></tr></table></figure><h3 id="引用静态资源"><a href="#引用静态资源" class="headerlink" title="引用静态资源"></a>引用静态资源</h3><p>引用多个静态资源的语法如下。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">android:padding="@&#123;larege ? @dimen/largePadding : @dimen/smallPadding&#125;"</span><br><span class="line">android:text="@&#123;@string/nameFormat(firstName, lastName)&#125;"</span><br><span class="line">android:text="@&#123;@plurals/banana(bananaCount)&#125;"</span><br></pre></td></tr></table></figure><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><p>Data binding允许你为View绑定各种各样的事件处理函数，作为布局文件里的一项属性，大部分命名格式为<code>android:onXXXX</code>，对应的View接口为<code>View.OnXXXXListener</code>。有两种方式处理事件。</p><ul><li>方法引用：在表达式中使用方法签名。Data Binding会将方法与对象包装成一个Listener并设置给View。</li><li>监听绑定：Lambda表达式，Data Binding对此同样生成一个Listener，供事件触发时调用。</li></ul><h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p>就像你可以为<code>onClick</code>指明绑定的方法一样，也可以为View的各种事件绑定ViewModel中的方法。在编译时会对此进行检查，如果方法不存在，或是签名错误，则直接报错。“方法引用”会在编译时创建一个Listener，相应的，“监听绑定”则在事件触发时才创建Listener。一个方法引用绑定的例子如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHandlers</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onClickFriend</span><span class="params">(view: <span class="type">View</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们希望在<code>onClick</code>时触发<code>onClickFriend</code>方法，则写法如下。注意：表达式中的签名与类文件里面方法签名必须完全一致。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"handlers"</span> <span class="attr">type</span>=<span class="string">"com.example.MyHandlers"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">type</span>=<span class="string">"com.example.User"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:orientation</span>=<span class="string">"vertical"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">TextView</span> <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:text</span>=<span class="string">"@&#123;user.firstName&#125;"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:onClick</span>=<span class="string">"@&#123;handlers::onClickFriend&#125;"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="监听绑定"><a href="#监听绑定" class="headerlink" title="监听绑定"></a>监听绑定</h3><p>监听绑定的自由度更大，它允许你运行任意的代码。限制之处则在于，方法的返回值必须与表达式期望的值相匹配。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Presneter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onSaveClick</span><span class="params">(task: <span class="type">Task</span>)</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以将以上方法绑定在View的<code>onClick</code>上面。因为这里多了<code>task</code>参数，故无法使用方法引用来写。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"task"</span> <span class="attr">type</span>=<span class="string">"com.android.example.Task"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"presenter"</span> <span class="attr">type</span>=<span class="string">"com.android.example.Presenter"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:onClick</span>=<span class="string">"@&#123;() -&gt; presenter.onSaveClick(task)&#125;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果需要用到View本身，则可以使用<code>android:onClick=&quot;@{(view) -&gt; presenter.onSaveClick(task)}&quot;</code>。如果处理函数里也要用到View，则函数签名写作。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Presenter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onSaveClick</span><span class="params">(view: <span class="type">View</span>, task: <span class="type">Task</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以为方法增加更多的参数，比如对于<code>CheckBox</code>的<code>isChecked</code>属性。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Presenter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onCompletedChanged</span><span class="params">(task: <span class="type">Task</span>, completed: <span class="type">Boolean</span>)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">CheckBox</span> <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span> <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:onCheckedChanged</span>=<span class="string">"@&#123;(cb, isChecked) -&gt; presenter.completeChanged(task, isChecked)&#125;"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>对于返回值非void的情况，函数签名必须匹配。比如<code>onLongClick</code>方法，要返回<code>boolean</code>类型的值，表示事件是否被消费。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Presenter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onLongClick</span><span class="params">(view: <span class="type">View</span>, task: <span class="type">Task</span>)</span></span>: <span class="built_in">Boolean</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:onLongClick="@&#123;(theView) -&gt; presenter.onLongClick(theView, task)&#125;"</span><br></pre></td></tr></table></figure><p>也可以在表达式里使用三目运算符，用<code>void</code>表示不响应事件。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:onClick="@&#123;(v) -&gt; v.isVisible() ? doSomething() : void&#125;"</span><br></pre></td></tr></table></figure><p>忠告：把复杂的业务逻辑放在Kotlin/Java代码中处理，而非xml表达式。</p><h2 id="导入、变量与引入"><a href="#导入、变量与引入" class="headerlink" title="导入、变量与引入"></a>导入、变量与引入</h2><ul><li>导入（Imports）：在xml中引入外部类</li><li>变量（Variables）：声明在xml中使用的变量</li><li>引入（Incluces）：帮助我们构建更加复杂的UI</li></ul><h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><p>在<code>&lt;data&gt;</code>块进行导入，导入后就可以在xml表达式里使用相应的类。如下例的<code>View</code>类。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">type</span>=<span class="string">"android.view.View"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:text</span>=<span class="string">"@&#123;user.lastName&#125;"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:visibility</span>=<span class="string">"@&#123;user.isAdult ? View.VISIBLE : View.GONE&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>可以在表达式中进行强制类型转换，如把<code>user.connection</code>强转为<code>User</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:text</span>=<span class="string">"@&#123;((User)(user.connection)).lastName&#125;"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>在import后，可以在表达式中使用静态方法。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">type</span>=<span class="string">"com.example.MyStringUtils"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">type</span>=<span class="string">"com.example.User"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:text</span>=<span class="string">"@&#123;MyStringUtils.capitalize(user.lastName)&#125;"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>作为Data Binding类库的默认行为，<code>java.lang.*</code>已经自动引入。</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>声明变量，从而在表达式中引用这些变量，变量的赋值来自于Binding对象。对于同名的<code>portrait</code>和<code>landscape</code>布局文件，它们的变量声明会进行合并，因此注意在处理这种场景时，不要发生命名冲突。对于未赋值的变量，在运行时会取它们的默认值：<code>0</code>、<code>false</code>、<code>null</code>等等。</p><p>Data Binding类库同样内置了<code>context</code>变量，供调用者在表达式中使用，它等价于<code>View.getContext()</code>。</p><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>在进行复杂UI构件时，如果用到了<code>include</code>标签，可以将变量从父布局传递给子布局。如下例，<code>user</code>对象被传递给了子布局。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:bind</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">type</span>=<span class="string">"com.example.User"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:orientation</span>=<span class="string">"vertical"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">include</span> <span class="attr">layout</span>=<span class="string">"@layout/name"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">bind:user</span>=<span class="string">"@&#123;user&#125;"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">include</span> <span class="attr">layout</span>=<span class="string">"@layout/contact"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">bind:user</span>=<span class="string">"@&#123;user&#125;"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是，Data Binding并不支持<code>merge</code>标签，试图在<code>merge</code>过程中传递变量是无效的。</p><p>【未完待续】</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;这是《通关Jetpack》系列的第2篇文章&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;我没什么能耐，不能给你们更好的生活，唯一能做的，是挡在你们前边。——《误杀》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在上一篇文章中，
      
    
    </summary>
    
    
      <category term="Kotlin" scheme="https://lilei.pro/tags/Kotlin/"/>
    
      <category term="Jetpack" scheme="https://lilei.pro/tags/Jetpack/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 协程基础课 04.协程原理小探——从包装异步请求为同步说起</title>
    <link href="https://lilei.pro/2020/03/16/kotlin-coroutines-04/"/>
    <id>https://lilei.pro/2020/03/16/kotlin-coroutines-04/</id>
    <published>2020-03-16T15:14:41.000Z</published>
    <updated>2020-03-16T15:15:56.907Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是《Kotlin 协程基础课》的第4篇，也是最后一篇文章。</p></blockquote><blockquote><p>我不在意十年后的自己是什么样子，我在意的是，十年后的我怎么看现在的自己。</p></blockquote><p>协程是强大的工具，通过前面三篇文章我们介绍了什么是协程、如何使用协程、协程里的CoroutineContext到底是个什么玩意儿。本文是《Kotlin协程基础课》系列的最后一篇文章，将从原理上进行简要的介绍。</p><h1 id="从混合开发说起"><a href="#从混合开发说起" class="headerlink" title="从混合开发说起"></a>从混合开发说起</h1><p>对Java开发者而言，“回调”是再常见不过的概念了。从各种SDK到我们自己开发的代码，处处充满了回调。某个任务需要长时间执行，同时我们希望能在任务完成时得到通知，在函数参数里加上一个回调对象，用以收取结果，是十分常见的解决方案。</p><h2 id="一个回调Demo"><a href="#一个回调Demo" class="headerlink" title="一个回调Demo"></a>一个回调Demo</h2><p>我们假设有个耗时计算任务，sleep指定时间然后返回数值，代码如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 耗时函数，将运算结果在回调中返回</span></span><br><span class="line"><span class="comment">// 只能在工作线程里调用</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">calcSlowly</span><span class="params">(inp: <span class="type">Int</span>, callback: <span class="type">CalcTaskCallback</span>&lt;<span class="type">Int</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        println(<span class="string">"calcSlowly inp=<span class="variable">$inp</span> in thread: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">        <span class="keyword">val</span> result = inp * <span class="number">1000</span>L</span><br><span class="line">        Thread.sleep(result)</span><br><span class="line">        callback.onSuccess(result.toInt())</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        println(<span class="string">"Fail to calc"</span>)</span><br><span class="line">        callback.onFailure(<span class="number">-1</span>, <span class="string">"Fail"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了获取计算的结果，我们传入了<code>callback</code>参数，用以接收计算结果，或者异常信息。</p><p>调用它的代码样例如下，用一个匿名内部对象接收回调：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">execCalcTaskAsync</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Thread(Runnable &#123;</span><br><span class="line">        calcSlowly(<span class="number">3</span>, <span class="keyword">object</span> : CalcTaskCallback&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(result: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">                println(<span class="string">"onSuccess, result=<span class="variable">$result</span>, in thread: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(code: <span class="type">Int</span>, msg: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">                println(<span class="string">"onFailure, code=<span class="variable">$code</span>, msg=<span class="variable">$msg</span>, in thread: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;).start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种回调写法在Java中再常见不过了。但是它却有着不小的隐患：</p><ol><li>嵌套太多，成为“回调地狱”；</li><li>传入的callback如果是Activity会引起泄露；</li><li>代码阅读起来不直观。</li></ol><p>这几个隐患不详述了，接下来看看在Kotlin中如何将异步回调转换为同步请求。</p><h2 id="将异步转化为同步"><a href="#将异步转化为同步" class="headerlink" title="将异步转化为同步"></a>将异步转化为同步</h2><p>通过协程的<code>suspendCoroutine</code>关键字，可以将异步回调转换为同步调用，上例改写方法如下，</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 包装异步为同步</span></span><br><span class="line">suspend <span class="function"><span class="keyword">fun</span> <span class="title">calcSlowlySync</span><span class="params">(inp: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> =</span><br><span class="line">    suspendCoroutine &#123; cont -&gt;</span><br><span class="line">        calcSlowly(inp, <span class="keyword">object</span>: CalcTaskCallback&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(result: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">                cont.resume(result)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(code: <span class="type">Int</span>, msg: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">                cont.resumeWithException(Exception(<span class="string">"code=<span class="variable">$code</span>, msg=<span class="variable">$msg</span>"</span>))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>改写之后，就可以在协程内部愉快地使用这个同步方法进行耗时计算了。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">launch(Dispatchers.DEFAULT) &#123;</span><br><span class="line">    <span class="keyword">val</span> result = calcSlowlySync(<span class="number">100</span>)</span><br><span class="line">    println(<span class="string">"result=<span class="variable">$result</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="suspendCoroutine是如何工作的"><a href="#suspendCoroutine是如何工作的" class="headerlink" title="suspendCoroutine是如何工作的"></a>suspendCoroutine是如何工作的</h1><p>todo</p><hr><p>原始代码<code>MainCoroutine.kt</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        <span class="keyword">val</span> job = GlobalScope.launch &#123;</span><br><span class="line">            <span class="keyword">val</span> result = calcSlowly(<span class="number">123</span>)</span><br><span class="line">            println(<span class="string">"result = <span class="variable">$result</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        job.join()</span><br><span class="line">    &#125;</span><br><span class="line">    print(<span class="string">"FINISH"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 延时计算</span></span><br><span class="line"><span class="keyword">private</span> suspend <span class="function"><span class="keyword">fun</span> <span class="title">calcSlowly</span><span class="params">(inp: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> = withContext(Dispatchers.Default) &#123;</span><br><span class="line">    delay(<span class="number">1000</span>L)</span><br><span class="line">    inp * <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译后生成4个文件</p><ol><li>MainCoroutineKt.class，</li><li>MainCoroutineKt$main$1.class</li><li>MainCoroutineKt$main$1$job$1.class</li><li>MainCoroutineKt$calcSlowly$2.class</li></ol><h1 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h1><h1 id="混合开发，从把异步请求转换为同步说起"><a href="#混合开发，从把异步请求转换为同步说起" class="headerlink" title="混合开发，从把异步请求转换为同步说起"></a>混合开发，从把异步请求转换为同步说起</h1><h2 id="异步接口"><a href="#异步接口" class="headerlink" title="异步接口"></a>异步接口</h2><h2 id="转换同步"><a href="#转换同步" class="headerlink" title="转换同步"></a>转换同步</h2><h1 id="协程内部如何将异步转换为同步"><a href="#协程内部如何将异步转换为同步" class="headerlink" title="协程内部如何将异步转换为同步"></a>协程内部如何将异步转换为同步</h1><h2 id="suspendCoroutine"><a href="#suspendCoroutine" class="headerlink" title="suspendCoroutine"></a>suspendCoroutine</h2><h2 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;这是《Kotlin 协程基础课》的第4篇，也是最后一篇文章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;我不在意十年后的自己是什么样子，我在意的是，十年后的我怎么看现在的自己。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;协
      
    
    </summary>
    
    
      <category term="Kotlin" scheme="https://lilei.pro/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>通关Jetpack之 Data Binding：第1课 需求实战</title>
    <link href="https://lilei.pro/2020/03/16/Go-through-jetpack-data-binding-L1/"/>
    <id>https://lilei.pro/2020/03/16/Go-through-jetpack-data-binding-L1/</id>
    <published>2020-03-16T15:08:48.000Z</published>
    <updated>2020-03-16T15:10:43.566Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是《通关Jetpack》系列的第1篇文章</p></blockquote><blockquote><p>有些人沦为平庸，有的人金玉其外、败絮其中。可未来某一天，不经意间你会遇到一个彩虹般绚丽的人，从此以后，其他人就不过是匆匆浮云。</p></blockquote><h2 id="Data-Binding是什么"><a href="#Data-Binding是什么" class="headerlink" title="Data Binding是什么"></a>Data Binding是什么</h2><p>在学习一项新知识、新技能之前，必须问的问题是这门技术是什么、将为我们带来什么有益的改变。我们来看一下Data Binding。</p><h3 id="Data-Binding是什么-1"><a href="#Data-Binding是什么-1" class="headerlink" title="Data Binding是什么"></a>Data Binding是什么</h3><p>Data Binding是由Google推出的一个库（Library），用来解决数据变化与UI显示同步的问题。</p><p>Data Binding常常与MVVM一同出现，这并不意味着它们是同一类东西。MVVM是设计模式/编程思想，ViewModel是其中一个组成部分。而Data Binding则是实现这门思想的一种工具。</p><h3 id="Data-Binding将为我们带来怎样的改变"><a href="#Data-Binding将为我们带来怎样的改变" class="headerlink" title="Data Binding将为我们带来怎样的改变"></a>Data Binding将为我们带来怎样的改变</h3><p>做应用开发，很大一部分精力都用于处理UI和数据的同步问题。在传统实现方式里，数据从服务器返回了，此时要手动调用<code>updateView</code>一类的方法更新UI；同样，当用户操作UI上的元素时，会通过<code>Listener</code>等监听，更新到内存的数据中——这是逻辑式写法，而Data Binding则是通过声明式的写法，将数据-UI解耦，从而可以简化控制流，让我们把注意力集中在复杂的业务逻辑上，而非UI同步。</p><p>我们首先从<a href="https://codelabs.developers.google.com/codelabs/android-databinding" target="_blank" rel="noopener">codelab</a>的实例入手，学习如何使用Data Binding。然后会深入介绍Data Binding的API，最后则是从原理角度阐述它是如何工作的。预计分成3篇文章。</p><h2 id="假想一种需求场景"><a href="#假想一种需求场景" class="headerlink" title="假想一种需求场景"></a>假想一种需求场景</h2><p>以这样一个App为例，它需要显示一段静态的文本（左侧），以及可点击的<strong>LIKE</strong>按钮（右侧），点击该按钮时会提升欢迎度数值并实时显示在UI上，最后，欢迎度数值每达到一个阶段，会在屏幕右侧显示不同阶段的图片。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://codelabs.developers.google.com/codelabs/android-databinding/img/94376396329952d2.png" alt="sample app" title="">                </div>                <div class="image-caption">sample app</div>            </figure><h3 id="没有Data-Binding时的写法"><a href="#没有Data-Binding时的写法" class="headerlink" title="没有Data Binding时的写法"></a>没有Data Binding时的写法</h3><p>首先是没有使用Data Binding时，传统的MVVM写法，已省略无关代码。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SimpleViewModel.kt</span></span><br><span class="line"><span class="comment">// ViewModel，对应页面上的静态部分、动态部分以及点击监听函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleViewModel</span> : <span class="type">ViewModel</span></span>() &#123;</span><br><span class="line">    <span class="keyword">val</span> name = <span class="string">"Grace"</span></span><br><span class="line">    <span class="keyword">val</span> lastName = <span class="string">"Hopper"</span></span><br><span class="line">    <span class="keyword">var</span> likes = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 点击监听函数</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onLike</span><span class="params">()</span></span> &#123;</span><br><span class="line">        likes++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不同阶段的欢迎度，基于like数计算</span></span><br><span class="line">    <span class="keyword">val</span> popularity: Popularity</span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">when</span> &#123;</span><br><span class="line">                likes &gt; <span class="number">9</span> -&gt; Popularity.STAR</span><br><span class="line">                likes &gt; <span class="number">4</span> -&gt; Popularity.POPULAR</span><br><span class="line">                <span class="keyword">else</span> -&gt; Popularity.NORMAL</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PlainOldActivity.kt，UI层</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlainOldActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Activity当中维护一个成员变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> viewModel <span class="keyword">by</span> lazy &#123; ViewModelProviders.of(<span class="keyword">this</span>).<span class="keyword">get</span>(SimpleViewModel::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>) &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line"></span><br><span class="line">        setContentView(R.layout.plain_activity)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 缺点1：当数据发生变化时，需要手动更新UI</span></span><br><span class="line">        updateName()</span><br><span class="line">        updateLikes()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缺点2：在UI类中包含业务逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onLike</span><span class="params">(view: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">        viewModel.onLike()</span><br><span class="line">        updateLikes()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缺点3：太多的findViewById</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">updateName</span><span class="params">()</span></span> &#123;</span><br><span class="line">        findViewById&lt;TextView&gt;(R.id.plain_name).text = viewModel.name</span><br><span class="line">        findViewById&lt;TextView&gt;(R.id.plain_lastname).text = viewModel.lastName</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缺点4：多次调用findViewById</span></span><br><span class="line">    <span class="comment">// 缺点5：包含未经测试的逻辑</span></span><br><span class="line">    <span class="comment">// 缺点6：即使数据未发生变化，也会更新View</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">updateLikes</span><span class="params">()</span></span> &#123;</span><br><span class="line">        findViewById&lt;TextView&gt;(R.id.likes).text = viewModel.likes.toString()</span><br><span class="line">        findViewById&lt;ProgressBar&gt;(R.id.progressBar).progress =</span><br><span class="line">            (viewModel.likes * <span class="number">100</span> / <span class="number">5</span>).coerceAtMost(<span class="number">100</span>)</span><br><span class="line">        <span class="keyword">val</span> image = findViewById&lt;ImageView&gt;(R.id.imageView)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> color = getAssociatedColor(viewModel.popularity, <span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">        ImageViewCompat.setImageTintList(image, ColorStateList.valueOf(color))</span><br><span class="line"></span><br><span class="line">        image.setImageDrawable(getDrawablePopularity(viewModel.popularity, <span class="keyword">this</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getAssociatedColor</span><span class="params">(popularity: <span class="type">Popularity</span>, context: <span class="type">Context</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getDrawablePopularity</span><span class="params">(popularity: <span class="type">Popularity</span>, context: <span class="type">Context</span>)</span></span>: Drawable? &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么简单一个页面，光是列出来的缺点就有6条之多，无法想象当业务逻辑复杂起来后，代码将会增长到何种程度。接下来，让我们看看Data Binding如何解决上述问题的。</p><h3 id="静态数据绑定UI"><a href="#静态数据绑定UI" class="headerlink" title="静态数据绑定UI"></a>静态数据绑定UI</h3><p>gradle从1.5.0版本开始支持data binding首先需要在project的<code>build.gradle</code>文件里打开开关，</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">...</span><br><span class="line">    dataBinding &#123;</span><br><span class="line">        enabled <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比于普通布局，data binding布局文件在最外层增加了<code>&lt;layout&gt;</code>标签，<code>&lt;layout&gt;</code>标签内部则由<code>&lt;data&gt;</code>标签和原布局组成。对于需要重构成data binding的布局文件，将鼠标选中最外层布局，会自动提示 <strong>Convert to data binding layout</strong>。一个data binding布局如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag"><span class="attr">...</span></span></span><br></pre></td></tr></table></figure><p><code>&lt;data&gt;</code>标签中的变量，可以在布局文件里进行调用，也支持简单的表达式，比如<code>if...else...</code>、类型转换、字符串拼接。表达式的格式为<code>@{...}</code>。虽然表达式很强大，但是不要滥用，否则会使布局文件过于复杂，难以维护。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">android:text="@&#123;String.valueOf(index + 1)&#125;"</span><br><span class="line">android:visibility="@&#123;age <span class="tag">&lt; <span class="attr">13</span> ? <span class="attr">View.GONE</span> <span class="attr">:</span> <span class="attr">View.VISIBLE</span>&#125;"</span></span><br><span class="line"><span class="tag"><span class="attr">android:transitionName</span>=<span class="string">'@&#123;"image_" + id&#125;'</span></span></span><br></pre></td></tr></table></figure><p>基于上述知识，我们为属性name和last name声明变量。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">type</span>=<span class="string">"String"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"lastName"</span> <span class="attr">type</span>=<span class="string">"String"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br></pre></td></tr></table></figure><p>从而可以在布局文件中直接使用它们。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/plain_name"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">"@&#123;name&#125;"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>目前为止已经完成了布局文件的编写，需要一个时机，将数据塞给布局文件，可以在<code>onCreate</code>里做这件事。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onCreate</span></span><br><span class="line">setConetntView(R.layout.plain_activity)</span><br><span class="line"><span class="keyword">val</span> binding: PlainActivityBinding = DataBindingUtil.setContgentView(<span class="keyword">this</span>, R.layout.plain_activity)</span><br><span class="line">binding.name = <span class="string">"Lei"</span></span><br><span class="line">binding.lastName = <span class="string">"Li"</span></span><br></pre></td></tr></table></figure><p>如此即可，不需要<code>findViewById</code>、<code>setText</code>，甚至不关心UI里到底是TextView还是EditText甚至自定义控件，要做的事情只是给成员变量赋值。处理完了静态文本，接下来看看如何响应UI的点击LIKE事件。要知道，这里我们同样也不用<code>findViewById</code>以及<code>setOnClickListener</code>的。</p><p>首先回忆一下最早的点击事件处理方式——在布局文件中，<code>onClick=onLike</code>，这样自动关联起来Activity中的<code>onLike</code>方法，虽然直观，但带来的后果就是绑死了布局文件与Activity，根本无法复用。其实Data Binding的处理方式与此类似，只不过它增加了一个<strong>ViewModel</strong>层。</p><blockquote><p>在计算机软件领域，没有什么问题是增加一个中间层不能解决的，如果就，那就加两层。</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">            <span class="attr">name</span>=<span class="string">"viewmodel"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">type</span>=<span class="string">"com.example.android.databinding.basicsample.data.SimpleViewModel"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>&lt;data&gt;</code>中不再是简单的String，而是一个<strong>SimpleViewModel</strong>类型对象，该类在上文中可以看到，它包含<code>name</code>、<code>lastName</code>字段，以及一个处理LIKE++事件的<code>onLike</code>方法。有了这个<code>viewmodel</code>对象，就可以在接下来的布局里面这样使用了。且比上种写法更好的地方在于，编译器会检查<code>onLike</code>方法是否存在，如果不存在则编译时就会异常。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/plain_name"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">"@&#123;viewmodel.name&#125;"</span></span></span><br><span class="line"><span class="tag"><span class="attr">...</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/plain_lastname"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">"@&#123;viewmodel.lastName&#125;"</span></span></span><br><span class="line"><span class="tag"><span class="attr">...</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:onClick</span>=<span class="string">"@&#123;() -&gt; viewmodel.onLike()&#125;"</span></span></span><br><span class="line"><span class="tag"><span class="attr">...</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>对于<code>viewmodel</code>的赋值，则在<strong>onCreate</strong>里面直接<code>binding.viewmodel = viewModel</code>就可以。但是如果我们把<code>likes</code>属性绑定到布局文件的某个TextView上（注意这里不要直接让<code>android:text=&quot;@{viewmodel.lines}&quot;</code>，因为这会导致运行时读取id=0的字符串资源，从而异常），会发现即使通过<code>onLike()</code>增长了LIKE，但在UI上并没有体现，LIKE数始终显示为0。这是因为目前为止我们进行的绑定都是<strong>静态</strong>且<strong>单向</strong>绑定，下一节我们将学习双向绑定，从而让LIKES的数目实时显示在UI上。</p><h3 id="双向Data-Binding的写法"><a href="#双向Data-Binding的写法" class="headerlink" title="双向Data Binding的写法"></a>双向Data Binding的写法</h3><p>所谓“双向”Data Binding，是指对于View而言，在初始化时可以自动从data里获取数据，对于data而言，当它们的值发生变化时，能自动通知UI显示相应数值。对于这种发生变化时能通知UI的数据，称之为具有“可观察性”，即<strong>observable</strong>。有多重途径生成一个可观察的对象，比如<code>observable classes</code>、<code>observable fields</code>，以及最通用也最好用的<code>LiveData</code>。声明可观察对象的方式如下。带有前置下划线<code>_</code>的变量为私有变量，是可变的，不对外进行暴露。每个私有变量都拥有一个<code>LiveData&lt;T&gt;</code>类型的接口变量，用于提供给布局文件读取。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> _name = MutableLiveData(<span class="string">"Ada"</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> _lastName = MutableLiveData(<span class="string">"Lovelace"</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> _likes =  MutableLiveData(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> name: LiveData&lt;String&gt; = _name</span><br><span class="line"><span class="keyword">val</span> lastName: LiveData&lt;String&gt; = _lastName</span><br><span class="line"><span class="keyword">val</span> likes: LiveData&lt;<span class="built_in">Int</span>&gt; = _likes</span><br></pre></td></tr></table></figure><p>同时需要在Activity的<code>onCreate()</code>方法中，为<code>binding</code>对象的<code>lifecycleOwner</code>赋值（为Activity）。如果不做这一步，数据的变化就无法被观测到。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(SavedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    binding.lifecycleOwner = <span class="keyword">this</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于<code>popularity</code>，同样将其声明为<code>LiveData</code>类型。这里注意，并没有私有的<code>_popularity</code>，因为它的值实际上是根据<code>likes</code>计算得到的。因此通过<code>Transformations.map()</code>操作，从一个<code>MutableLiveData</code>类型的<code>_likes</code>对象计算出<code>LiveData</code>类型的<code>popularity</code>。关于<code>Transformation</code>的使用，可以看<a href="https://developer.android.com/reference/android/arch/lifecycle/Transformations" target="_blank" rel="noopener">这篇文章</a>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// popularity is exposed as LiveData using a Transformation instead of a @Bindable property.</span></span><br><span class="line"><span class="keyword">val</span> popularity: LiveData&lt;Popularity&gt; = Transformations.map(_likes) &#123;</span><br><span class="line">    <span class="keyword">when</span> &#123;</span><br><span class="line">        it &gt; <span class="number">9</span> -&gt; Popularity.STAR</span><br><span class="line">        it &gt; <span class="number">4</span> -&gt; Popularity.POPULAR</span><br><span class="line">        <span class="keyword">else</span> -&gt; Popularity.NORMAL</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，在<code>onLike()</code>中我们直接修改<code>_likes</code>的值，就会 通知到UI自动发生调整了。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">onLike</span><span class="params">()</span></span> &#123;</span><br><span class="line">    _likes.value = (_likes.value ?: <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处简单介绍下其实现原理，Data Binding库里面包含众多Adapters（适配器），见<a href="https://android.googlesource.com/platform/frameworks/data-binding/+/master/extensions/baseAdapters/src/main/java/android/databinding/adapters/" target="_blank" rel="noopener">源码</a>。对于xml布局文件里的UI组件，需要设置的属性均声明了相应的<strong>静态</strong>设值方法，比如对于<code>TextView</code>的<code>android:text</code>属性，就有如下<code>setText(TextView, CharSequence)</code>方法。当text值发生变更时，就会调用到这个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BindingAdapter</span>(<span class="string">"android:text"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setText</span><span class="params">(TextView view, CharSequence text)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Some checks removed for clarity</span></span><br><span class="line">    view.setText(text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时还剩下两点功能没有完成，分别是LIKE按钮下方的进度条没有实时增加，以及LIKE图片没有更新。先看进度条相关的事项。对于进度条有3点需求，分别是：</p><ol><li>当LIKES=0时，进度条隐藏</li><li>当LIKES增加时，进度条实时增长，且每5个LIKE一个循环，进度条归零</li><li>当进度条拉满时，颜色变深</li></ol><p>这些需求都可以通过自定义<code>BindingAdapter</code>来实现，它可以为xml元素创建任意的自定义属性，并通过代码读取该属性，进而对xml元素原生的属性进行修改。在任意包下创建一个<code>BindingAdapters.kt</code>文件（不要担心路径，因为编译时会自动识别注解），借助于Kotlin的顶层函数，可以不声明<code>BindingAdapter</code>类而直接写函数。我们为所有的<code>View</code>创建一个<code>app:hideIfZero</code>属性，控制当该属性为0时隐藏UI元素。</p><p><em>当LIKES=0时，进度条隐藏</em></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BindingAdapter(<span class="meta-string">"app:hideIfZero"</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">hideIfZero</span><span class="params">(view: <span class="type">View</span>, number: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    view.visibility = <span class="keyword">if</span> (number == <span class="number">0</span>) View.GONE <span class="keyword">else</span> View.VISIBLE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后在xml布局文件中将该属性与<code>viewmodel.likes</code>进行绑定，这样当likes=0时，进度条就会自动隐藏。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ProgressBar</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/progressBar"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:hideIfZero</span>=<span class="string">"@&#123;viewmodel.likes&#125;"</span></span></span><br><span class="line"><span class="tag"><span class="attr">...</span></span></span><br></pre></td></tr></table></figure><p><em>当LIKES增加时，进度条实时增长，且每5个LIKE一个循环，进度条归零</em></p><p>参考上面的<code>hideIfZero</code>属性，我们这次同样用自定义<code>BindingAdapter</code>来实现。不同之处在于，这次我们需要同时读取两个属性，在<code>@BindingAdapter</code>注解里面，通过字符串数组<code>[&quot;app:progressScaled&quot;, &quot;android:max&quot;]</code>来声明，同时<code>requireAll = true</code>表示必须两个属性都在xml得到声明时，才会调用该方法进行处理。如果有任一个没有赋值，则不进行方法。与之相对应的<code>requiredAll = false</code>则对至少一个属性进行相应，对于没有声明的属性会使用其默认值。</p><p><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.ranges/coerce-at-most.html" target="_blank" rel="noopener">coerceAtMost</a>是Kotlin提供的扩展函数，表示“最大不超过<code>max</code>”。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BindingAdapter(value = [<span class="meta-string">"app:progressScaled"</span>, <span class="meta-string">"android:max"</span>], requireAll = true)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setProgress</span><span class="params">(progressBar: <span class="type">ProgressBar</span>, likes: <span class="type">Int</span>, max: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    progressBar.progress = (likes * max / <span class="number">5</span>).coerceAtMost(max)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相应地，在布局文件中声明<code>app:progressScaled</code>和<code>android:max</code>两个属性。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ProgressBar</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/progressBar"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:hideIfZero</span>=<span class="string">"@&#123;viewmodel.likes&#125;"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:progressScaled</span>=<span class="string">"@&#123;viewmodel.likes&#125;"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:max</span>=<span class="string">"@&#123;100&#125;"</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br></pre></td></tr></table></figure><p><em>当进度条拉满时，颜色变深</em></p><p>如果前面的知识都已经掌握，这里也就不难了。我们声明一个自定义属性<code>app:progressTint</code>，表示会影响到progressBar的外显颜色，输入为popularity，方法内部先根据popularity计算出color（注意这里使用到的Context为View的Context），然后再将其设置到progressBar的<code>progressTintList</code>属性上。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BindingAdapter(<span class="meta-string">"app:progressTint"</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">tintPopularity</span><span class="params">(view: <span class="type">ProgressBar</span>, popularity: <span class="type">Popularity</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> color = getAssociatedColor(popularity, view.context)</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">        view.progressTintList = ColorStateList.valueOf(color)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后还有一个功能，是根据不同的popularity显示不同的图片，可以把它当做课后作业，参考答案<a href="https://codelabs.developers.google.com/codelabs/android-databinding/#9" target="_blank" rel="noopener">在这里</a>。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://codelabs.developers.google.com/codelabs/android-databinding" target="_blank" rel="noopener">https://codelabs.developers.google.com/codelabs/android-databinding</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;这是《通关Jetpack》系列的第1篇文章&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;有些人沦为平庸，有的人金玉其外、败絮其中。可未来某一天，不经意间你会遇到一个彩虹般绚丽的人，从此以后，其他人就不过是匆匆浮云。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Kotlin" scheme="https://lilei.pro/tags/Kotlin/"/>
    
      <category term="Jetpack" scheme="https://lilei.pro/tags/Jetpack/"/>
    
  </entry>
  
  <entry>
    <title>一文带你读懂compileSdkVersion、minSdkVersion与targetSdkVersion</title>
    <link href="https://lilei.pro/2020/03/16/Android-SDK-versions/"/>
    <id>https://lilei.pro/2020/03/16/Android-SDK-versions/</id>
    <published>2020-03-16T14:42:30.000Z</published>
    <updated>2020-03-16T14:48:38.039Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ul><li>Thanks for saving me. - Don’t waster it. Don’t waste your life.</li></ul></blockquote><h1 id="全文思维导图"><a href="#全文思维导图" class="headerlink" title="全文思维导图"></a>全文思维导图</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/20200306_android_sdk_versions/几种SdkVersion.png" alt="结构脉络" title="">                </div>                <div class="image-caption">结构脉络</div>            </figure><h1 id="问题产生的背景"><a href="#问题产生的背景" class="headerlink" title="问题产生的背景"></a>问题产生的背景</h1><p>Android 是一个不断更新演进的系统，犹记得自己最初一部手机是在百脑汇购买的Samsung I9001，Android2.3系统 —— GINGERBREAD，现在几乎听不到这个词了。</p><p>在版本迭代的过程中，Google会不断引入新的接口、并且为App增加新的限制。一方面是由于硬件和软件技术更新，为用户&amp;开发者提供了更强大的能力，比如陀螺仪、人脸识别等；另一方面是不断演进和强化的安全隐私需求。</p><p>对于开发者而言，自然希望自己的App的受众范围越大越好，不仅是当前市面上已有的系统版本，甚至对于未来将要推出的版本也一并可以兼容。由此便引出了以下三个问题，这三个问题是开发者必须解决的，如何解决呢？借助Google提供的能力来完成。</p><ol><li>开发者写的代码是基于哪个版本的API —— 对应的是compileSdkVersion</li><li>开发者提供的apk最低可以运行在什么版本的系统 —— 对应的是minSdkVersion</li><li>开发者提供的apk是以哪个系统版本作为目标来开发的 —— 对应的是targetSdkVersion</li></ol><h1 id="解决系统版本适配和限制的问题"><a href="#解决系统版本适配和限制的问题" class="headerlink" title="解决系统版本适配和限制的问题"></a>解决系统版本适配和限制的问题</h1><p>接下来我们逐个分析以上三个需求。</p><h2 id="开发者写的代码是基于哪个版本的API：compileSdkVersion"><a href="#开发者写的代码是基于哪个版本的API：compileSdkVersion" class="headerlink" title="开发者写的代码是基于哪个版本的API：compileSdkVersion"></a>开发者写的代码是基于哪个版本的API：compileSdkVersion</h2><p>首先作为开发者，在编写代码时一定会调用系统API，而不同系统版本提供的API是有区别的，比如有的接口在某一版本之前一直是<code>private</code>的，直到某一版本时被开发成<code>public</code>。开发者如何告诉编译器自己写的代码是基于哪个版本呢？这时就要用到<code>compileSdkVersion</code>了。</p><p>使用compileSdkVersion，最直接的目的是在编译过程中使用指定版本的SDK进行编译，在此之前，在编写代码的时候，如果调用了高于compileSdkVersion的API，编译器会给出出错提示。需要注意的是compileSdkVersion只存在于编译前的阶段，在编译的生成物apk里是看不到任何与其相关信息的。</p><p>另一个限制是，compileSdkVersion需要与Support Library Version首位匹配。比如你用的Support Library是<code>23.1.1</code>版本的，那么compileSdkVersion一定要是<code>23</code>。</p><p>对compileSdkVersion的使用建议是，总使用当前最新的compileSdkVersion，一方面可以调用最新的系统接口，防止未来某一时刻老接口被废弃后不得不修改代码，变被动为主动。另一方面能够享受到最新SDK带来的编译速度提升。</p><h2 id="开发者提供的apk最低可以运行在什么版本的系统：minSdkVersion"><a href="#开发者提供的apk最低可以运行在什么版本的系统：minSdkVersion" class="headerlink" title="开发者提供的apk最低可以运行在什么版本的系统：minSdkVersion"></a>开发者提供的apk最低可以运行在什么版本的系统：minSdkVersion</h2><p>“能够运行在市面上所有的系统版本上”是开发者一个美好的愿望，但实际上，随着Google不断推陈出新，老版本在市场上的占有量越来越小。可以参考Google的<a href="https://developer.android.com/about/dashboards/index.html" target="_blank" rel="noopener">Dashboard</a>，它统计的规则是一周内访问Google Play的系统版本分布，可以看到4.4及更早版本加起来已经不到10%。</p><p>当市面上老版本占有量趋近于无的时候，我们就不必为适配老版本写专门的代码了，这样能够减少适配工作，从而把开发者宝贵的精力投入到更有价值的新功能实现上。</p><p>在项目中我们用minSdkVersion来说明自己的app最低可以运行在什么版本的系统上。在Google Play、vivo应用商店、游戏中心等应用分发系统中会检测本机版本，若低于应用声明的minSdkVersion就会提示用户，甚至直接拒绝安装，因为即使装上也无法使用。</p><p>在边写代码过程中，你可以使用任何不低于compileSdkVersion的API，但是当你使用的API高于minSdkVersion时，就必须在代码里显示地进行版本判断，否则编译器/Lint工具会提示你。</p><p>另一个限制是，主工程的minSdkVerison不低于其所有依赖库的版本。举例说明：如果项目里同时使用了如下依赖</p><ol><li>support(min=4)</li><li>glide(min=7)</li><li>google play(min=9)</li></ol><p>那么主工程的minSdkVersion就应当为9。该限制可以违背，需要人为保证安全，设置方法为在AndroidManifest里声明tools:overrideLibrary。这样做是有风险的，还是以上例说明，你不能在4的系统版本上调用glide接口，否则一定会报错。必须在代码逻辑里面保证这一点。</p><p>对minSdkVersion的使用建议是，开发过程中若使用到了高于minSdkVersion的API，一定要进设备版本判断；其次在声明这个属性时，参考你应用的目标用户群体系统版本分布，这是一个权衡的过程，你希望应用的覆盖面更广，还是应用的特性更新。</p><h2 id="开发者提供的apk是以哪个系统版本作为目标来开发的：targetSdkVersion"><a href="#开发者提供的apk是以哪个系统版本作为目标来开发的：targetSdkVersion" class="headerlink" title="开发者提供的apk是以哪个系统版本作为目标来开发的：targetSdkVersion"></a>开发者提供的apk是以哪个系统版本作为目标来开发的：targetSdkVersion</h2><p>到了本文要介绍的三个<code>SdkVersion</code>中最有趣的部分——targetSdkVersion。考虑这样一种需求，开发者基于5.0的API开发（即compileSdkVersion=5.0），当app发布时候，Google已经发布了Android 6.0，此时当然希望原App不需要任何改动就可以运行在6.0系统的手机上，通常是Google在6.0的SDK里做了这个兼容。</p><p>拿6.0（API=23）的权限限制举例，Google希望在6.0开始控制App滥用权限的情况，列出了一些必须动态申请的敏感权限。这对手机用户而言是百利而无一害的事，而对开发者而言，如果不能及时修改代码，就会面临App不可用甚至无法上架Google Play的情况下。假如你作为一名应用开发者，日常有1000w的活跃用户，而由于手机系统升级，这1000w用户无法使用之前的App了；而你又恰好在度假中，无法及时修改更新，这将是一个灾难。</p><p>针对上面的具体例子，可以通过在gradle文件里声明<code>targetSdkVersion=21</code>来告诉操作系统，App的代码是面向Android 5.0系统编写的，没有考虑动态权限的问题。这样的APK即使被安装在系统版本为6.0的手机上，也会依照之前的行为来运行，即在安装时申请所有必须权限，而非运行时动态申请。</p><blockquote><p>AOSP里有很多<code>getApplicationInfo().targetSdkVersion &lt; Buid.XXXX</code>样式的代码，就是用来判断<code>targetSdkVersion</code>的</p></blockquote><p>使用targetSdkVersion还有一个好处，你可以使用更高版本的API，且不需要关注行为变更。</p><p>也许你会觉得，作为一名顽固恋旧的开发者，我就不要升级targetSdkVersion，Google好像也拿我没有办法。事实上并非如此，如果targetSdkVersion过低的话，Google、手机厂商都有权利拒绝上架你的App。</p><p>对开发者选择targetSdkVersion的建议是，尽量保持最新的版本，以防应用市场把你的应用下架。升级targetSdkVersion后一定要进行针对性的测试。</p><h1 id="学以致用"><a href="#学以致用" class="headerlink" title="学以致用"></a>学以致用</h1><p>了解这几个版本的含义之后，就要看看如何应用了。通常我们的项目是用gradle管理依赖的，我们需要在根project中声明这几个版本。</p><h2 id="Gradle配置"><a href="#Gradle配置" class="headerlink" title="Gradle配置"></a>Gradle配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion 23</span><br><span class="line">    buildToolsVersion 23.1.1</span><br><span class="line">    // ... other config</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        minSdkVersion 20</span><br><span class="line">        targetSdkVersion 28</span><br><span class="line">        // ... other config</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>android</code>标签下的配置只会在编译期间生效，<code>defaultConfig</code>标签下的设置会打入最终的Apk中。</p><h2 id="版本高低关系"><a href="#版本高低关系" class="headerlink" title="版本高低关系"></a>版本高低关系</h2><p>通常的版本关系是<strong>min&lt;=target&lt;=compile</strong>，最理想的状态则是<strong>min&lt;=target==compile</strong>，其中compile时刻保持最新。</p><h1 id="targetSdkVersion适配指南"><a href="#targetSdkVersion适配指南" class="headerlink" title="targetSdkVersion适配指南"></a>targetSdkVersion适配指南</h1><p>从Android 6.0开始，每一个版本升级，<a href="https://developer.android.com/distribute/best-practices/develop/target-sdk" target="_blank" rel="noopener">Google都会发布适配指南</a>，将其整理成思维导图。</p><h2 id="适配思维导图大纲"><a href="#适配思维导图大纲" class="headerlink" title="适配思维导图大纲"></a>适配思维导图大纲</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/20200306_android_sdk_versions/targetAPI适配.png" alt="targetSdkVersion适配" title="">                </div>                <div class="image-caption">targetSdkVersion适配</div>            </figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://medium.com/androiddevelopers/picking-your-compilesdkversion-minsdkversion-targetsdkversion-a098a0341ebd" target="_blank" rel="noopener">Picking your compileSdkVersion, minSdkVersion, targetSdkVersion</a></li><li><a href="https://www.race604.com/android-targetsdkversion/" target="_blank" rel="noopener">targetSdkVersion原理</a></li><li><a href="https://developer.android.com/guide/topics/manifest/uses-sdk-element.html#ApiLevels" target="_blank" rel="noopener">API与英文名、系统版本对照表</a></li><li><a href="https://developer.android.com/about/dashboards" target="_blank" rel="noopener">dashboards</a></li><li><a href="https://developer.android.com/distribute/best-practices/develop/target-sdk" target="_blank" rel="noopener">Google target API 版本升级说明</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Thanks for saving me. - Don’t waster it. Don’t waste your life.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;全文思维导图&quot;&gt;&lt;a href=&quot;#全文思
      
    
    </summary>
    
    
      <category term="Android" scheme="https://lilei.pro/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin让接口写法如此简单</title>
    <link href="https://lilei.pro/2020/03/16/Kotlin-made-Interface-so-much-better/"/>
    <id>https://lilei.pro/2020/03/16/Kotlin-made-Interface-so-much-better/</id>
    <published>2020-03-16T14:38:49.000Z</published>
    <updated>2020-03-16T14:40:06.628Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是对Medium上<a href="https://proandroiddev.com/kotlin-made-interface-so-much-better-bbeaa59abdd7" target="_blank" rel="noopener">Kotlin made Interface so much better</a>一文的翻译，内容偏基础。</p></blockquote><p>在Java中，“接口”一开始是作为一项新的编程特性被提出的。它描述了一种“可以是”关系，而非“一定是”。这也使得它可以用于多重继承（例如，某物可以是许多特性的集合，但只能是某个事物。译者注：猫可以同时具有喵喵叫和会爬树两种属性，但猫只能是猫，不可能是狗）。</p><p>然而，正如我们所见到的，直到Java7（Java7是Android工程师主要的开发语言。译者注：原文写于2018年10月），接口仍然有很多缺点，这些缺点使得接口变得很难用，以至于一些人宁愿用回抽象类。</p><p>接着我们迎来了Kotlin，我将在本文为大家展示Kotlin在继承关系中的强大能力。</p><h1 id="Kotlin扩展接口能力"><a href="#Kotlin扩展接口能力" class="headerlink" title="Kotlin扩展接口能力"></a>Kotlin扩展接口能力</h1><h2 id="在Java中"><a href="#在Java中" class="headerlink" title="在Java中"></a>在Java中</h2><p>在Java7中，接口自己不能包含方法实现，因此对于接口实现类而言，必须实现接口中的所有方法。</p><p>这是一个麻烦，它削弱了接口的可扩展能力。</p><p>假设我们有如下的<code>Movable</code>接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Movable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">legsCount</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Horse</span> <span class="keyword">implements</span> <span class="title">Movable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">legsCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>突然我们发现除了统计腿的数量，还需要统计翅膀的数量。所以我们增加了<code>wingsCount()</code>方法。</p><p>对于所有实现了<code>Movable</code>接口的类，这是一个坏消息，因为它们必须修改代码以适配接口变更。例如，<code>Horse</code>必须修改如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Movable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">legsCount</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">wingsCount</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Horse</span> <span class="keyword">implements</span> <span class="title">Movable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">legsCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">wingsCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在Kotlin中"><a href="#在Kotlin中" class="headerlink" title="在Kotlin中"></a>在Kotlin中</h2><p>一开始我们有</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Movable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">legsCount</span><span class="params">()</span></span> : <span class="built_in">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Horse</span> : <span class="type">Movable &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">legsCount</span><span class="params">()</span></span> = <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后我们可以轻松地扩展它</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Movable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">legsCount</span><span class="params">()</span></span> : <span class="built_in">Int</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">wingsCount</span><span class="params">()</span></span> : <span class="built_in">Int</span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125; <span class="comment">// 注意这里可以为方法提供默认实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Horse</span> : <span class="type">Movable &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">legsCount</span><span class="params">()</span></span> = <span class="number">4</span> <span class="comment">// 实现类不需进行任何变动</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>甚至可以做的更加复杂，而<code>Horse</code>类不需要因此进行任何改动！</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Movable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">legsCount</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">wingsCount</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">canFly</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123; <span class="keyword">return</span> wingsCount() &gt; <span class="number">1</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">canWalk</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123; <span class="keyword">return</span> legsCount() &gt; <span class="number">1</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Horse</span> : <span class="type">Movable &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">legsCount</span><span class="params">()</span></span> = <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Kotlin使接口真正地“可覆写”"><a href="#Kotlin使接口真正地“可覆写”" class="headerlink" title="Kotlin使接口真正地“可覆写”"></a>Kotlin使接口真正地“可覆写”</h1><p>剑桥大辞典里对于“override”的定义是</p><blockquote><p>to decide against or refuse to accept a previous decision, an order, a person, etc.</p></blockquote><p>在Java世界中，接口没有覆写任何东西。</p><p>但是在Kotlin世界里，见如下例子</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Movable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">legsCount</span><span class="params">()</span></span> : <span class="built_in">Int</span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">wingsCount</span><span class="params">()</span></span> : <span class="built_in">Int</span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">canFly</span><span class="params">()</span></span> : <span class="built_in">Boolean</span> &#123; <span class="keyword">return</span> wingsCount() &gt; <span class="number">1</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">canWalk</span><span class="params">()</span></span> : <span class="built_in">Boolean</span> &#123; <span class="keyword">return</span> legsCount() &gt; <span class="number">1</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Horse</span> : <span class="type">Movable &#123;</span></span></span><br><span class="line">    <span class="keyword">var</span> isSick = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">legsCount</span><span class="params">()</span></span> = <span class="number">4</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">canWalk</span><span class="params">()</span></span> : <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isSick) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.canWalk()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们让<code>isSick = true</code>，那么无论这个生物有多少条腿，<code>canWalk()</code>方法都会返回<code>false</code>。嗯，真正意义上的“覆写”。</p><h1 id="Kotlin使接口更像一个对象"><a href="#Kotlin使接口更像一个对象" class="headerlink" title="Kotlin使接口更像一个对象"></a>Kotlin使接口更像一个对象</h1><p>在Java世界（我认为包括Java8和9），接口并不允许包含常量之外的任何属性。</p><p>充其量我们可以声明一个变量的存取方法，例如<code>legsCount()</code>。</p><h2 id="在Kotlin中-1"><a href="#在Kotlin中-1" class="headerlink" title="在Kotlin中"></a>在Kotlin中</h2><p>Kotlin允许接口中包含属性。</p><p>比起这种写法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Movable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">legsCount</span><span class="params">()</span></span>: <span class="built_in">Int</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">canWalk</span><span class="params">()</span></span> = legsCount() &gt; <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Horse</span> : <span class="type">Movable &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">legsCount</span><span class="params">()</span></span> = <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以将其简化成</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Movable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> legsCount : <span class="built_in">Int</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">canWalk</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> = legsCount &gt; <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Horse</span> : <span class="type">Movable &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> legsCount = <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在接口中使用属性有一些局限，它不可以有backfield属性，意味着它不可变。所以它仍然是无状态的。</p></blockquote><blockquote><p>此外，不允许在接口中为属性赋初值。</p></blockquote><h1 id="Kotlin使接口更好地为组合服务"><a href="#Kotlin使接口更好地为组合服务" class="headerlink" title="Kotlin使接口更好地为组合服务"></a>Kotlin使接口更好地为组合服务</h1><p>你也许听说过“组合胜过继承”原则。Kotlin让它变得更加简单。</p><p>假设你有<code>Horse</code>和<code>Dog</code>。它们都是有4条腿的动物。</p><p>一种写法如下</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Movable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> legsCount : <span class="built_in">Int</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">canWalk</span><span class="params">()</span></span> = legsCount &gt; <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Horse</span> : <span class="type">Movable &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> legsCount = <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> : <span class="type">Movable &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> legsCount = <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法太繁琐，具体表现在如下地方</p><ul><li>在每一个实现类里都重复<code>override val legsCount = 4</code>的代码段</li><li>如果我们有更多要覆写的方法，或者更多4条腿的类，我们必须重复做一样的事</li><li>未来某一天，如果我们必须把<code>4</code>改成<code>four</code>，或者增加更多功能……</li></ul><p>这将是一个灾难。太难扩展了。</p><h2 id="也许我们可以利用类的继承关系？"><a href="#也许我们可以利用类的继承关系？" class="headerlink" title="也许我们可以利用类的继承关系？"></a>也许我们可以利用类的继承关系？</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Movable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> legsCount: <span class="built_in">Int</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">canWalk</span><span class="params">()</span></span> = legsCount &gt; <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">FourLegged</span> : <span class="type">Movable &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> legsCount = <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Horse</span> : <span class="type">FourLegged</span></span>()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> : <span class="type">FourLegged</span></span>()</span><br></pre></td></tr></table></figure><p>但是这种写法违背了“组合胜于继承”原则。<code>Horse</code>和<code>Dog</code>不仅仅是<code>FourLegged</code>，也可以是其他什么东西，这种写法让他们不可扩展成为其他类型（例如：<code>Pet</code>）。</p><p>这是不可扩展的☹️</p><h2 id="让我们用组合代替继承（传统写法）"><a href="#让我们用组合代替继承（传统写法）" class="headerlink" title="让我们用组合代替继承（传统写法）"></a>让我们用组合代替继承（传统写法）</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Movable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> legsCount: <span class="built_in">Int</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">canWalk</span><span class="params">()</span></span> = legsCount &gt; <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">object</span> FourLegged : Movable &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> legsCount = <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Horse</span> : <span class="type">Movable &#123;</span></span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> movable = FourLegged</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> legsCount</span><br><span class="line">    <span class="keyword">get</span>() = movable.legsCount</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> : <span class="type">Movable &#123;</span></span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> movable = FourLegged</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> legsCount</span><br><span class="line">    <span class="keyword">get</span>() = movable.legsCount</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不知道你怎么想，我并不喜欢这种写法，所以让我们稍事改动…</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Movable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> legsCount: <span class="built_in">Int</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">canWalk</span><span class="params">()</span></span> = legsCount &gt; <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">object</span> FourLegged : Movable &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> legsCount = <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">MovableImpl</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> movable: Movable) : Movable &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> legsCount</span><br><span class="line">        <span class="keyword">get</span>() = movable.legsCount</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Horse</span> : <span class="type">MovableImpl</span></span>(FourLegged)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> : <span class="type">MovableImpl</span></span>(FourLegged)</span><br></pre></td></tr></table></figure><p>现在这种写法要好一些，因为它的扩展性更好，假设未来我们同时有<code>FourLegged</code>和<code>TwoLegged</code>，我们可以很方便地替换它们。</p><p>但是我仍然不喜欢这种写法，因为我不得不继承自类<code>MovableImpl</code>。所幸我们有Kotlin，我们看下Kotlin如何处理此类问题…</p><h2 id="Kotlin的方式：使用By代理简化组合写法"><a href="#Kotlin的方式：使用By代理简化组合写法" class="headerlink" title="Kotlin的方式：使用By代理简化组合写法"></a>Kotlin的方式：使用By代理简化组合写法</h2><p>在Kotlin的接口写法中，我们可以使用<code>By</code>关键字轻松实现代理模式。来看看</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Movable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> legsCount: <span class="built_in">Int</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">canWalk</span><span class="params">()</span></span> = legsCount &gt; <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> FourLegged : Movable &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> legsCount = <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Horse</span> : <span class="type">Movable by FourLegged</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> : <span class="type">Movable by FourLegged</span></span></span><br></pre></td></tr></table></figure><p>太棒了！🤩。相信你也看得出这种写法的好处。</p><p>如果你想对“组合胜于继承”有更深入的了解，可以阅读以下这篇文章：</p><p><a href="https://proandroiddev.com/composition-over-inheritance-in-kotlin-way-fe341159bf1c" target="_blank" rel="noopener">Composition over inheritance in Kotlin way</a></p><h1 id="Kotlin使接口更好地实现多重继承"><a href="#Kotlin使接口更好地实现多重继承" class="headerlink" title="Kotlin使接口更好地实现多重继承"></a>Kotlin使接口更好地实现多重继承</h1><p>在Java7中使用多重继承是一件痛苦的事，因为我们不得不实现所有的接口，并覆写其中全部方法。</p><blockquote><p>译者注：原文这里用的是<strong>inherit from all interfaces</strong>，可见原作者对“继承”和“实现”并不是严格区分。实际上在Java中不可以“多重继承”（对抽象类而言），而应当是“多重实现”（对接口而言）。</p></blockquote><p>即使这样做，也无法从父类中继承任何属性。（当然了，Java的接口里是不允许有非常量属性的）</p><h2 id="在Kotlin中-2"><a href="#在Kotlin中-2" class="headerlink" title="在Kotlin中"></a>在Kotlin中</h2><p>借助于By代理，我们来看看下面这个例子</p><p>假设我们的动物接口有两个属性</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Movable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> legsCount: <span class="built_in">Int</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">canWalk</span><span class="params">()</span></span> = legsCount &gt; <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Pet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> name: String</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">liveInhouse</span><span class="params">()</span></span> = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们提供一些更具体的内容（也就是接口实现），以便于我们可以使新创建的类使用这些具体内容（代理）。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> FourLegged : Movable &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> legsCount = <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InHousePet</span></span>(<span class="keyword">override</span> <span class="keyword">val</span> name: String) : Pet &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">liveInHouse</span><span class="params">()</span></span> = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们可以创建<code>Cat</code>类了，它是一个<code>FourLegged</code>动物，并且也是<code>InHousePet</code>。所以为了同时继承这两点，我们采用如下写法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CatBy</span></span>(name: String) :</span><br><span class="line">    Pet <span class="keyword">by</span> InHousePet(name), Movable <span class="keyword">by</span> FourLegged</span><br></pre></td></tr></table></figure><p>只要你愿意，可以增加更多的属性</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">classCatBy(name: String, trainer: Trainer):</span><br><span class="line">        Pet <span class="keyword">by</span> InHousePet(name),</span><br><span class="line">        Movable <span class="keyword">by</span> FourLegged,</span><br><span class="line">        Trainable <span class="keyword">by</span> Professional(trainer)</span><br></pre></td></tr></table></figure><p>或者，你也可以覆写其中的值，只要你愿意！</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">classCatBy(name: String, trainer: Trainer):</span><br><span class="line">        Pet <span class="keyword">by</span> InHousePet(name),</span><br><span class="line">        Movable <span class="keyword">by</span> FourLegged,</span><br><span class="line">        Trainable <span class="keyword">by</span> Professional(trainer) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> legsCount: <span class="built_in">Int</span></span><br><span class="line">        <span class="keyword">get</span>() = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">liveInHouse</span><span class="params">()</span></span> = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>感觉自己像是在写C++🤪</p><hr><h1 id="译后感"><a href="#译后感" class="headerlink" title="译后感"></a>译后感</h1><p>在Kotlin的接口中可以声明只读属性，其实就相当于Java的<code>getXXX</code>方法，只不过通过Kotlin一贯的<code>get/set</code>省略写法进行了简化。</p><p><code>by</code>关键字用于代理，是Kotlin里面中阶的知识，我们可以为一个接口声明一个代理对象，从而分散目标类的职责。</p><p>在其它方面，Kotlin中的接口写法相比于Java并没有本质上的改动。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;这是对Medium上&lt;a href=&quot;https://proandroiddev.com/kotlin-made-interface-so-much-better-bbeaa59abdd7&quot; target=&quot;_blank&quot; rel=&quot;noopene
      
    
    </summary>
    
    
      <category term="Kotlin" scheme="https://lilei.pro/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>本周知识积累[2020/03] ViewPager使用指南；Kotlin单例写法；MediaPlayer状态机</title>
    <link href="https://lilei.pro/2020/03/03/weekly-2020-03-01/"/>
    <id>https://lilei.pro/2020/03/03/weekly-2020-03-01/</id>
    <published>2020-03-03T05:08:02.000Z</published>
    <updated>2020-03-04T12:03:01.482Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我们一路奋斗，不是为了改变世界，而是为了不被世界改变。</p></blockquote><h2 id="ViewPager使用指南"><a href="#ViewPager使用指南" class="headerlink" title="ViewPager使用指南"></a>ViewPager使用指南</h2><p><a href="https://abhiandroid.com/materialdesign/viewpager" target="_blank" rel="noopener">ViewPager</a> 是Android SDK提供的用于实现左右滑动切换页面效果的控件，接入非常简单，可以实现如下图的效果。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/20200303_weekly/ViewPager-In-Android.gif" alt="ViewPager" title="">                </div>                <div class="image-caption">ViewPager</div>            </figure><p>自顶向下地看，一个完整的包含ViewPager的页面由以下几个对象构成。</p><ul><li>Host：容器页面，可以是Activity，或者Fragment</li><li>ViewPager：关联到页面上的一个View，可以左右滑动切换子页面</li><li>Adapter：ViewPager内部用以获取每个子页面的适配器，参考RecyclerView/ListView的Adapter</li><li>SubFragment：ViewPager内嵌的子页面</li></ul><p>让我们逐个分析（Host就是一个普通页面，略过不提，SubFragment也一样，与常见写法没有区别，同样略过）</p><h3 id="ViewPager"><a href="#ViewPager" class="headerlink" title="ViewPager"></a>ViewPager</h3><p>相当于一个ViewGroup容器，使用的时候，首先在xml布局里声明<code>android.support.v4.view.ViewPager</code>，接着在代码里通过<code>findViewById</code>获取到这个ViewPager，并为其设置Adapter。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mViewPager = findViewById(R.id.view_pager)</span><br><span class="line"><span class="comment">// 这里需要传入一个FragmentManager，可见ViewPager内部是以Fragment作为每个子页面呈现方式的</span></span><br><span class="line">mViewPager.adapter = YourAdapterClass(supportFragmentManager)</span><br></pre></td></tr></table></figure><p>在使用ViewPager时，往往需要对当前选中页面的行为进行监听，比如当用户左右滑动切换页面时，对应地改变标题栏的文字，对应的是<code>addOnPageChangeListener</code>接口，注意这里是<code>add</code>并非<code>set</code>，意味着不要对同一个对象多次调用，否则会多次触发。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ViewPager.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addOnPageChangeListener</span><span class="params">(@NonNull OnPageChangeListener listener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mOnPageChangeListeners == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mOnPageChangeListeners = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    mOnPageChangeListeners.add(listener);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnPageChangeListener</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 页面发生位移时调用，既包含用户手指拖动，也包含页面自身的动画移动。参数是位移的百分比和像素值，可以用来进行一些计算</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onPageScrolled</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">float</span> positionOffset, <span class="keyword">int</span> positionOffsetPixels)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 页面被选中时调用，动画也许并没有结束，参数是被选中页面的index</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onPageSelected</span><span class="params">(<span class="keyword">int</span> position)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 页面状态发生变化时调用，不特指哪一个页面，而是所有页面。</span></span><br><span class="line">    <span class="comment">// 有三种状态：IDLE（页面静止，无动作）、DRAGGING（用户拖动中）、SETTING（用户已放手，页面归位中）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onPageScrollStateChanged</span><span class="params">(<span class="keyword">int</span> state)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口还是比较简单的，同时，如果我们只关注三个回调中的一个（往往是<code>onPageSelected</code>），可以用另一个内部类来创建监听对象，以减少样板代码，<code>SimpleOnPageChangeListener</code>同样位于<code>ViewPager.java</code>中。</p><p>这是很好的一种编程思想，对于包含多个回调函数的监听接口，增加一个内部类，为每个回调函数创建一个空函数，在使用时只覆写业务需要的接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleOnPageChangeListener</span> <span class="keyword">implements</span> <span class="title">OnPageChangeListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageScrolled</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">float</span> positionOffset, <span class="keyword">int</span> positionOffsetPixels)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// This space for rent</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageSelected</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// This space for rent</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageScrollStateChanged</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// This space for rent</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Hint</strong>：如果要在<code>onPageSelected</code>回调里获取相应的SubFragment，不要使用<code>Adapter.getItem</code>，它会返回一个新创建的Fragment。应当调用的方法是<code>Adapter.instantiateItem</code>，这会返回已创建的Fragment，参考Stack Overflow上面的<a href="https://stackoverflow.com/questions/17685787/access-a-method-of-a-fragment-from-the-viewpager-activity" target="_blank" rel="noopener">这个问题</a>。</p><h3 id="Adapter"><a href="#Adapter" class="headerlink" title="Adapter"></a>Adapter</h3><p>有两种Adapter，FragmentPagerAdapter和FragmentStatePagerAdapter，简单地说，如果你的ViewPager只包含3到4个固定的页面，则使用FragmentPagerAdapter；如果有很多个页面，则使用FragmentStatePagerAdapter。</p><p>这里以FragmentStatePagerAdapter为例，介绍Adapter的写法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FragmentStatePagerAdapter.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FragmentStatePagerAdapter</span> <span class="keyword">extends</span> <span class="title">PagerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...some code...</span></span><br><span class="line">    <span class="comment">// 这里创建Fragment并返回</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Fragment <span class="title">getItem</span><span class="params">(<span class="keyword">int</span> position)</span></span>;</span><br><span class="line">    <span class="comment">// ...some code...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PagerAdapter.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PagerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...some code...</span></span><br><span class="line">    <span class="comment">// 返回Fragment总个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// ...some code...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见最简单的FragmentStatePagerAdapter只需要实现<code>getItem</code>和<code>getCount</code>两个方法。值得一提的是，如果需要在创建SubFragment时传递一些参数，用以下写法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Fragment时传入Arg_0</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getItem</span><span class="params">(position: <span class="type">Int</span>)</span></span>: Fragment &#123;</span><br><span class="line">    <span class="keyword">val</span> frag = YourFragmentClass()</span><br><span class="line">    frag.arguments = Bundle().apply &#123;</span><br><span class="line">        putString(ARG_0, some_value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... some code ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Fragment的onViewCreated里读取参数</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    arguments?.takeIf &#123; it.containsKey(ARG_0) &#125;?.apply &#123;</span><br><span class="line">        <span class="keyword">val</span> someValue = getString(ARG_0)</span><br><span class="line">        <span class="comment">// ... some code ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Activity-传递大数据"><a href="#Activity-传递大数据" class="headerlink" title="- Activity 传递大数据"></a>- Activity 传递大数据</h2><p>在使用Intent进行Activity之间的跳转时，系统提供了<code>putExtra</code>用于参数传递，如下例。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// caller activity</span></span><br><span class="line"><span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>, TheNextActivity::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">i.putExtra(ARG_0, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// called activity</span></span><br><span class="line"><span class="keyword">val</span> param = intent.extras?.getInt(ARG_0)</span><br></pre></td></tr></table></figure><p>如果传递的参数不是基础类型，而是列表，则使用<code>putExtra(String, Parcelable)</code>和<code>getParcelableExtra(String)</code>做相应的存取。</p><p>然而，实际上很多人并不知道，通过Intent传递的参数，是有大小限制的。当我们传递占内存非常大的数据，如1000个元素的列表、Bitmap等等时，稍不注意，就会出现<code>TransactionTooLargeException</code>，从异常名就可以看出，这是由于参数过大引起的。究其原因，是因为ActivityManagerService内部使用了Binder通信机制，其事务缓冲区限制了传输数据的大小。Binder事务缓冲区的大小为1MB，而且，这1MB还不是独享的，意味着有时尽管传递的数据没有超出1MB，也会触发异常。</p><p>那么，对于需要传递大量数据的场景，有哪些方案？</p><h3 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> Singleton &#123;</span><br><span class="line">    <span class="keyword">var</span> items: List&lt;Foo&gt;? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> largeImg: Bitmap? = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不需要过多解释，注意不要出现内存泄漏，以及单例无法在进程之间共享。</p><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><p>利用网络、数据库、文件、SharedPreference等方式，将数据持久化保存，随后在新页面读取。优点是保存后可以跨进程甚至跨应用、跨平台使用，缺点则是效率低下，读写时没有控制好事务会发生异常。</p><h3 id="使用EventBus"><a href="#使用EventBus" class="headerlink" title="使用EventBus"></a>使用EventBus</h3><p>在《阿里巴巴Android开发手册》中写到：“Activity 间的数据通信，对于数据量比较大的，避免使用 Intent + Parcelable 的方式，可以考虑 EventBus 等替代方案，以免造成 TransactionTooLargeException。”</p><p>由于EventBus滥用会导致代码结构混乱，因此个人不推荐。</p><p><strong>参考资料</strong>：<a href="https://juejin.im/post/5d8de547e51d45781f73bacc" target="_blank" rel="noopener">https://juejin.im/post/5d8de547e51d45781f73bacc</a></p><h2 id="Kotlin单例写法"><a href="#Kotlin单例写法" class="headerlink" title="- Kotlin单例写法"></a>- Kotlin单例写法</h2><p>单例模式是日常开发中最常使用到的设计模式，一个良好的单例模式实现应当兼顾代码性能与调用简便两个方面。在Java中我们通过“双锁”或者“静态内部类”来实现单例模式，相比之下我更喜欢静态内部类的写法，《Effective Java》一书的作者也是这样认为的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 样例代码，来自 wiki：https://en.wikipedia.org/wiki/Initialization-on-demand_holder_idiom</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Something</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Something</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Something INSTANCE = <span class="keyword">new</span> Something();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Something <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LazyHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="无参数写法"><a href="#无参数写法" class="headerlink" title="无参数写法"></a>无参数写法</h3><p>今天主要讨论Kotlin的单例写法，在Kotlin中，单例被上升到了语言层面，关键字<code>object</code>可以用来声明一个不需要参数的单例对象。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> SomeSingleton &#123;</span><br><span class="line">    init &#123;</span><br><span class="line">        <span class="comment">// 在这里添加初始化代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>借助于JVM加载类的过程，它编译后的等效Java代码也是线程安全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上述Kotlin代码的Java等价版本</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeSingleton</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> SomeSingleton INSTANCE;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">SomeSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      INSTANCE = (SomeSingleton)<span class="keyword">this</span>;</span><br><span class="line">      System.out.println(<span class="string">"init complete"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">      <span class="keyword">new</span> SomeSingleton();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有参数写法"><a href="#有参数写法" class="headerlink" title="有参数写法"></a>有参数写法</h3><p>有时我们需要在单例初始化时传入一些参数，比如<code>Glide.with(Context)</code>，此时<code>object</code>关键字就捉襟见肘了。在<a href="https://stackoverflow.com/questions/40398072/singleton-with-parameter-in-kotlin" target="_blank" rel="noopener">Stack Overflow这个问题</a>下面可以学习到，借助伴生对象的“伪静态方法”，能达到传入初始化参数的目的。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UsersDatabase</span> : <span class="type">RoomDatabase</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Volatile</span> <span class="keyword">private</span> <span class="keyword">var</span> INSTANCE: UsersDatabase? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getInstance</span><span class="params">(context: <span class="type">Context</span>)</span></span>: UsersDatabase =</span><br><span class="line">            INSTANCE ?: synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">                INSTANCE ?: buildDatabase(context).also &#123; INSTANCE = it &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">buildDatabase</span><span class="params">(context: <span class="type">Context</span>)</span></span> =</span><br><span class="line">            Room.databaseBuilder(context.applicationContext,</span><br><span class="line">                    UsersDatabase::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>, <span class="type">"Sample.db")</span></span></span><br><span class="line">                    .build()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上这种写法，需要关注以下几点。</p><ol><li>单例成员<code>INSTANCE</code>需要有<code>@Volatile</code>声明，以保证对象唯一</li><li><code>synchronized</code>加锁防止重复初始化</li><li>借助<code>also</code>返回原对象</li></ol><p>如果代码里只有一个单例类要实现，上面这种写法就足够了。但是，若有很多个单例类，这种写法产生的样板代码可不少。是不是可以把样板代码逻辑抽出，一次书写，多处调用？答案是肯定的。</p><h3 id="有参数写法，Write-Once，Use-Many"><a href="#有参数写法，Write-Once，Use-Many" class="headerlink" title="有参数写法，Write Once，Use Many"></a>有参数写法，Write Once，Use Many</h3><p>首先区分上述实现方式里，可变的部分与不变的部分，思路是把不变的部分抽象成流程，把可变的部分提取作为参数。</p><p>不变的部分是检查、维护、调用构建函数，将其抽出一个类，这个类一定是用于被继承，因此我们将其声明为<code>open</code>，通过lambda表达式参数<code>constructor</code>，开放出构建对象的能力</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SingletonHolder.kt</span></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span>&lt;<span class="type">out T, in A</span>&gt;</span>(<span class="keyword">private</span> <span class="keyword">val</span> <span class="keyword">constructor</span>: (A) -&gt; T) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Volatile</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> instance: T? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getInstance</span><span class="params">(arg: <span class="type">A</span>)</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">when</span> &#123;</span><br><span class="line">            instance != <span class="literal">null</span> -&gt; instance!!</span><br><span class="line">            <span class="keyword">else</span> -&gt; synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) instance = <span class="keyword">constructor</span>(arg)</span><br><span class="line">                instance!!</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，有一个类需要增加单例实现，并且其构造函数需要一个<code>Context</code>类型的参数，我们只需要在其内部声明一个伴生对象，继承自<code>SingletonHolder&lt;MyManager, Context&gt;</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyManager.kt</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyManager</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>(context: Context) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> : SingletonHolder&lt;MyManager, Context&gt;(::MyManager)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对单例的调用者而言，写法与Java无异。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyManager.getInstance(context).doSomething()</span><br></pre></td></tr></table></figure><p>怎么样，是不是与Glide的<code>Glide.with(context).load(img_url)</code>完全一致？Bravo！</p><p><strong>参考资料</strong></p><ul><li><a href="https://medium.com/@BladeCoder/kotlin-singletons-with-argument-194ef06edd9e" target="_blank" rel="noopener">https://medium.com/@BladeCoder/kotlin-singletons-with-argument-194ef06edd9e</a></li><li><a href="https://stackoverflow.com/questions/40398072/singleton-with-parameter-in-kotlin" target="_blank" rel="noopener">https://stackoverflow.com/questions/40398072/singleton-with-parameter-in-kotlin</a></li></ul><h2 id="Vimium的页面检索技巧"><a href="#Vimium的页面检索技巧" class="headerlink" title="Vimium的页面检索技巧"></a>Vimium的页面检索技巧</h2><p>在使用浏览器时，有时我们会打开很多个页面，此时如果想要在打开的页面里找到特定页面，往往需要从头翻到尾，十分之麻烦。Vimium考虑到了这一点，并为我们提供快捷键<code>T</code>解决。这个功能属于<strong>Vomnibar</strong>功能集，是Vimium提供的一组页面新建、搜索快捷键，一共有5个。</p><ul><li><code>o</code>，在当前Tab打开URL、书签或浏览历史</li><li><code>O</code>，新建Tab打开URL、书签或浏览历史</li><li><code>b</code>，在当前Tab打开书签</li><li><code>B</code>，新建Tab打开书签</li><li><code>T</code>，也就是刚刚介绍过的，在已打开的Tab中进行搜索</li></ul><p>（顺带提一下，Sublime的copy line快捷键是<code>Ctrl+Shift+D</code>，在写着一段时用到的。）</p><h2 id="使用默认参数简化自定义View的构造函数"><a href="#使用默认参数简化自定义View的构造函数" class="headerlink" title="使用默认参数简化自定义View的构造函数"></a>使用默认参数简化自定义View的构造函数</h2><p>在编写自定义View的类时，如果自定义View继承自<code>android.view.View</code>，通常需要覆写多个构造函数，以支持View的多种构建方式。这种处理不仅麻烦，还带来大量样板代码，稀释了我们的代码质量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// View.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">View</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">View</span><span class="params">(Context context, @Nullable AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">View</span><span class="params">(Context context, @Nullable AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(context, attrs, defStyleAttr, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">View</span><span class="params">(Context context, @Nullable AttributeSet attrs, <span class="keyword">int</span> defStyleAttr, <span class="keyword">int</span> defStyleRes)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>联想到Kotlin函数的默认参数功能，是不是可以将其应用在这种场景中呢？答案当然是可以。结合<code>@JvmOverloads</code>注解和默认参数，写法如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomView</span> <span class="meta">@JvmOverloads</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">    context: Context,</span><br><span class="line">    attrs: AttributSet? = <span class="literal">null</span>,</span><br><span class="line">    defStyle: <span class="built_in">Int</span> = <span class="number">0</span>,</span><br><span class="line">    defStyleRes: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">    ) : View(context, attrs, defStyle, defStyleRes) &#123;</span><br><span class="line">        <span class="comment">// class body</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在此基础上，借助<code>init{ ... }</code>代码块，可以执行自定义的初始化代码。</p><p><strong>参考</strong>：<a href="https://stackoverflow.com/questions/20670828/how-to-create-constructor-of-custom-view-with-kotlin" target="_blank" rel="noopener">https://stackoverflow.com/questions/20670828/how-to-create-constructor-of-custom-view-with-kotlin</a></p><h2 id="MediaPlayer状态机"><a href="#MediaPlayer状态机" class="headerlink" title="MediaPlayer状态机"></a>MediaPlayer状态机</h2><p>MediaPlayer是Android SDK提供的音视频播放组件，尽管目前有更优秀的IJKPlayer、EXOPlayer等开源项目，MediaPlayer作为功能单一、接口清晰的播放器，有其值得学习的意义。一切故事，从一张状态机图片开始。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/20200303_weekly/mediaplayer_state_diagram.gif" alt="状态机" title="">                </div>                <div class="image-caption">状态机</div>            </figure><p><strong>图例说明</strong>：<code>单箭头</code>表示同步调用，<code>双箭头</code>表示异步调用，双层椭圆（仅End）表示终结态。</p><p>这张图乍一看像是一团乱麻，其实可以按照播放前、播放中、播放后的阶段进行区分。</p><h3 id="播放前"><a href="#播放前" class="headerlink" title="播放前"></a>播放前</h3><ul><li>以<code>Prepared</code>为界，之前的状态都可以认为是“播放前”</li><li>通过<code>new</code>创建一个播放器，或者对已有播放器调用<code>reset</code>，均可以得到一个处于<code>Idle</code>状态的播放器。不过这两种方式有一个显著区别，即对<code>Idle</code>态播放器调用<code>getCurrentPosition()</code>, <code>getDuration()</code>, <code>getVideoHeight()</code>, <code>getVideoWidth()</code>, <code>setAudioAttributes()</code>, <code>setLooping()</code>, <code>setVolume()</code>, <code>pause()</code>, <code>start()</code>, <code>stop()</code>, <code>seekTo()</code>, <code>prepare()</code>, <code>prepareAsync()</code>方法时，如果是新构建的播放器，不会抛出任何一场，而如果是通过<code>reset</code>得到的<code>Idle</code>播放器，则会进入<code>OnErrorListener.onError()</code>回调</li><li>播放器在开始播放前，必须进入<code>Prepared</code>态。有两种方法，分别是同步的<code>prepare()</code>和异步的<code>prepareAsync()</code>。同步方法的返回是很快的，几乎是瞬间。对于异步调用，可以通过<code>setOnPreparedListener()</code>设置监听</li><li>当播放器处于<code>Prepared</code>态时，可以设置音量、屏幕常亮、循环播放等属性</li></ul><h3 id="播放中"><a href="#播放中" class="headerlink" title="播放中"></a>播放中</h3><ul><li>播放过程可能因为各种原因发生异常，诸如不支持的音视频格式、受损的文件、分辨率过高、解码超市等等原因，或者是对于播放器调用了不属于其状态的方法。在这些错误发生时，会走到<code>OnErrorListener.onError()</code>回调中，因此在播放前设置监听<code>setOnErrorListener()</code>是非常重要的</li><li>设置<code>onError</code>监听并不能避免播放器进入<code>Error</code>态，只是在进入时发出程序可以观测到的监听事件</li><li>如果在错误的状态调用<code>prepare()</code>, <code>prepareAsync()</code>, <code>setDatasource()</code>，会导致<code>IllegalStateException</code></li><li>基于上一条，在调用<code>setDatasource</code>以及它的众多重载方法时，必须捕获<code>IllegalArgumentException</code>和<code>IOException</code></li><li>通过<code>start()</code>启动播放，通过<code>isPlaying()</code>判断当前是否处于播放中，可以在<code>start()</code>后继续调用<code>start()</code>，但这不会产生任何影响</li><li>在开始播放后，可以通过<code>setOnBufferingUpdateListener()</code>监听视频缓冲进度</li><li>对于播放中的视频，调用<code>pause()</code>进入<code>Paused</code>态，这是一个略微有延迟（seconds）的调用，意味着<code>isPlaying()</code>可能不会立即反映当前状态，反之亦然</li><li>对于<code>Started</code>, <code>Paused</code>, <code>Prepared</code>, <code>PlaybackCompleted</code>态的播放器调用<code>stop()</code>，使其进入<code>Stopped</code>态；对于<code>Stopped</code>态的播放器，必须使其再次进入<code>Prepared</code>态后，方可用于播放</li><li>与<code>start()</code>一样，多次调用<code>stop()</code>不会产生任何影响</li><li>用<code>seekTo()</code>设置播放进度，这是一个异步方法，<code>OnSeekComplete.onSeekComplete()</code>用于监听；可以在<code>Prepared</code>, <code>Paused</code>, <code>PlaybackCompleted</code>多个态调用，且调用<code>seekTo()</code>后播放器仍保持原状态，同时改变当前帧；相应的，<code>getCurrentPosition()</code>可以返回当前的播放进度</li></ul><h3 id="播放后"><a href="#播放后" class="headerlink" title="播放后"></a>播放后</h3><ul><li>一旦播放器不再使用，建议立即调用<code>release()</code>释放资源，此后播放器进入<code>End</code>态，且再也无法通过任何方法使其恢复</li><li>如果设置了Looping，播放完成后会保持<code>Started</code>态，否则会进入<code>OnCompletionListener</code>回调，并进入<code>PlaybackCompleted</code>态</li></ul><h3 id="播放器的权限要求"><a href="#播放器的权限要求" class="headerlink" title="播放器的权限要求"></a>播放器的权限要求</h3><p>视需求而定，可能需要<code>WAKE_LOCK</code>以及<code>Internet</code>权限。</p><h3 id="线程限制"><a href="#线程限制" class="headerlink" title="线程限制"></a>线程限制</h3><p>必须在UI线程创建播放器，只有这样才能正常收到为播放器设置的各种回调。</p><p><strong>参考</strong>：<a href="https://developer.android.com/reference/android/media/MediaPlayer" target="_blank" rel="noopener">https://developer.android.com/reference/android/media/MediaPlayer</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;我们一路奋斗，不是为了改变世界，而是为了不被世界改变。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;ViewPager使用指南&quot;&gt;&lt;a href=&quot;#ViewPager使用指南&quot; class=&quot;headerlink&quot; title=&quot;View
      
    
    </summary>
    
    
      <category term="Android" scheme="https://lilei.pro/tags/Android/"/>
    
      <category term="每周积累" scheme="https://lilei.pro/tags/%E6%AF%8F%E5%91%A8%E7%A7%AF%E7%B4%AF/"/>
    
  </entry>
  
  <entry>
    <title>本周知识积累[2020/02] RecyclerView布局预览；Uri对象常用操作；轻松创建MainDispatcher与Deferred</title>
    <link href="https://lilei.pro/2020/02/28/weekly-2020-02-01/"/>
    <id>https://lilei.pro/2020/02/28/weekly-2020-02-01/</id>
    <published>2020-02-28T01:00:37.000Z</published>
    <updated>2020-03-04T12:03:34.320Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>In case of I don’t see you. Good afternoon, good evening and good night.</p></blockquote><h2 id="在xml预览中查看RecyclerView布局"><a href="#在xml预览中查看RecyclerView布局" class="headerlink" title="在xml预览中查看RecyclerView布局"></a>在xml预览中查看RecyclerView布局</h2><p>在功能开发的前期，我们做好布局后，希望可以在IDE的xml预览里查看效果。在使用到RecyclerView时，看到的往往是item 0、item 1、item 2这样的占位文字，如下左图所示。如果我们想查看设计好的item布局（如下右），应当如何做呢？</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/20200228_weekly/RecyclerView预览.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>可以使用<strong>tools</strong>的命名空间。</p><blockquote><p><code>tools</code> namespace enables design-time features (such as which layout to show in a fragment) or compile-time behaviors (such as which shrinking mode to apply to your XML resources) It is really powerful feature that is developing and allows you not compile code every time to see changes.</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 样例代码 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- AndroidX --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.recyclerview.widget.RecyclerView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:layoutManager</span>=<span class="string">"androidx.recyclerview.widget.GridLayoutManager"</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line">&lt;!-- support --&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">android.support.v7.widget.RecyclerView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:layoutManager</span>=<span class="string">"android.support.v7.widget.GridLayoutManager"</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line">    &lt;!-- common --&gt;</span><br><span class="line">    xmlns:android="http://schemas.android.com/apk/res/android"</span><br><span class="line">    xmlns:tools="http://schemas.android.com/tools"</span><br><span class="line">    android:layout_width="match_parent"</span><br><span class="line">    android:layout_height="match_parent"</span><br><span class="line">    tools:itemCount="5"</span><br><span class="line">    tools:listitem="@layout/item_video"</span><br><span class="line">    tools:orientation="horizontal"</span><br><span class="line">    tools:scrollbars="horizontal"</span><br><span class="line">    tools:spanCount="2" /&gt;</span><br></pre></td></tr></table></figure><p><strong>参考</strong> <a href="https://stackoverflow.com/questions/29929963/is-there-a-way-to-show-a-preview-of-a-recyclerviews-contents-in-the-android-stu" target="_blank" rel="noopener">https://stackoverflow.com/questions/29929963/is-there-a-way-to-show-a-preview-of-a-recyclerviews-contents-in-the-android-stu</a></p><h2 id="Uri对象的基本操作"><a href="#Uri对象的基本操作" class="headerlink" title="Uri对象的基本操作"></a>Uri对象的基本操作</h2><p>不属于新知识，做网络请求开发时经常会遇到，以前每次碰到时都是现查的，不知道是不是年纪大了记忆力下降的缘故 :-( 这里整理作为备忘。</p><p>Uri是不可变对象，构建出来后即不可修改。</p><p>Uri采用构建器模式进行构建。</p><p>初始化一个Uri.Builder对象：<code>Uri.parse(SAMPLE_URL).buildUpon()</code>，如下例</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> uriBuilder = Uri.parse(<span class="string">"https://www.google.com"</span>).buildUpon()</span><br></pre></td></tr></table></figure><p>进行UTF8编码：<code>encode(String s)</code></p><p>增加参数：<code>appendQueryParameter(&quot;key&quot;, &quot;value&quot;)</code></p><p>分开设置协议和主机：<code>scheme(&quot;https&quot;)</code>，<code>authority(&quot;www.google.com&quot;)</code></p><p>举例说明，如果想要构建如下的URL地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.myawesomesite.com/turtles/types?type=1&amp;sort=relevance#section-name</span><br></pre></td></tr></table></figure><p>则使用以下代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Uri.Builder builder = <span class="keyword">new</span> Uri.Builder();</span><br><span class="line">builder.scheme(<span class="string">"https"</span>)</span><br><span class="line">    .authority(<span class="string">"www.myawesomesite.com"</span>)</span><br><span class="line">    .appendPath(<span class="string">"turtles"</span>)</span><br><span class="line">    .appendPath(<span class="string">"types"</span>)</span><br><span class="line">    .appendQueryParameter(<span class="string">"type"</span>, <span class="string">"1"</span>)</span><br><span class="line">    .appendQueryParameter(<span class="string">"sort"</span>, <span class="string">"relevance"</span>)</span><br><span class="line">    .fragment(<span class="string">"section-name"</span>);</span><br><span class="line">String myUrl = builder.build().toString();</span><br></pre></td></tr></table></figure><p><strong>参考</strong></p><ul><li><a href="https://developer.android.com/reference/android/net/Uri" target="_blank" rel="noopener">https://developer.android.com/reference/android/net/Uri</a></li><li><a href="https://developer.android.com/reference/android/net/Uri.Builder" target="_blank" rel="noopener">https://developer.android.com/reference/android/net/Uri.Builder</a></li></ul><h2 id="轻松创建MainDispatcher与Deferred"><a href="#轻松创建MainDispatcher与Deferred" class="headerlink" title="轻松创建MainDispatcher与Deferred"></a>轻松创建MainDispatcher与Deferred</h2><h3 id="构建主线程调度器"><a href="#构建主线程调度器" class="headerlink" title="构建主线程调度器"></a>构建主线程调度器</h3><p>Dispatcher/调度器是协程上下文里很重要的一个元素，它决定了代码运行在哪个线程中。尤其是做Android开发时，经常需要把UI操作发送给主线程进行，像ViewModel就为我们提供了MainDispatcher。</p><p>如果当前没有MainDispatcher，需要手动创建时，要怎么方便地进行构建呢？Kotlin在<code>Handler</code>类上新增了一个扩展函数<code>asCoroutineDispatcher()</code>，用法如下</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> mainDispatcher = Handler(Looper.getMainLooper()).asCoroutineDispatcher()</span><br></pre></td></tr></table></figure><p>只要通过MainLooper就可以构建出主线程调度器了，是不是很方便。</p><h3 id="构建即时Deferred对象"><a href="#构建即时Deferred对象" class="headerlink" title="构建即时Deferred对象"></a>构建即时Deferred对象</h3><p>Deferred是一种泛型，在协程中用于表示耗时操作结果，当我们需要取值时，通过<code>Deferred.await()</code>即可。它有点类似Java中的<code>Future</code>，表示一种“进行中的操作，即将返回结果”。</p><p>构建Deferred对象有两种方法，一种是通过<code>async</code>的携程构建器，另一种是今天要介绍的方法，对于已知的值（比如 10），可以直接用<code>CompletableDeferred(10)</code>来创建一个Deferred对象，你可以直接把它用在任何需要Deferred对象的地方，取值时则会直接返回10。</p><p><strong>参考</strong> <a href="https://stackoverflow.com/questions/53273361/how-to-return-deferred-with-the-instant-results" target="_blank" rel="noopener">https://stackoverflow.com/questions/53273361/how-to-return-deferred-with-the-instant-results</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;In case of I don’t see you. Good afternoon, good evening and good night.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;在xml预览中查看RecyclerView布局&quot;&gt;
      
    
    </summary>
    
    
      <category term="Android" scheme="https://lilei.pro/tags/Android/"/>
    
      <category term="每周积累" scheme="https://lilei.pro/tags/%E6%AF%8F%E5%91%A8%E7%A7%AF%E7%B4%AF/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 协程基础课 03.揭开协程上下文CoroutineContext的神秘面纱</title>
    <link href="https://lilei.pro/2019/12/13/kotlin-coroutines-03/"/>
    <id>https://lilei.pro/2019/12/13/kotlin-coroutines-03/</id>
    <published>2019-12-13T14:40:28.000Z</published>
    <updated>2019-12-13T14:41:37.280Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>限定目的，能使人生变得简洁。</p></blockquote><h1 id="协程上下文是个啥？"><a href="#协程上下文是个啥？" class="headerlink" title="协程上下文是个啥？"></a>协程上下文是个啥？</h1><p>CoroutineContext，译作“协程上下文”，在协程中是非常重要的概念。你可能会比较好奇，为什么之前都没有注意到它的存在呢？因为协程框架已经为我们包装得非常好了。让我们来看一下<code>launch</code>和<code>async</code>两个函数的签名：</p><h2 id="launch"><a href="#launch" class="headerlink" title="launch"></a>launch</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">launch</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    context: <span class="type">CoroutineContext</span> = EmptyCoroutineContext,</span></span></span><br><span class="line"><span class="function"><span class="params">    start: <span class="type">CoroutineStart</span> = CoroutineStart.DEFAULT,</span></span></span><br><span class="line"><span class="function"><span class="params">    onCompletion: <span class="type">CompletionHandler</span>? = <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.()</span></span> -&gt; <span class="built_in">Unit</span></span><br><span class="line">): Job</span><br></pre></td></tr></table></figure><h2 id="async"><a href="#async" class="headerlink" title="async"></a>async</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> CoroutineScope.<span class="title">async</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    context: <span class="type">CoroutineContext</span> = EmptyCoroutineContext,</span></span></span><br><span class="line"><span class="function"><span class="params">    start: <span class="type">CoroutineStart</span> = CoroutineStart.DEFAULT,</span></span></span><br><span class="line"><span class="function"><span class="params">    onCompletion: <span class="type">CompletionHandler</span>? = <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.()</span></span> -&gt; T</span><br><span class="line">): Deferred&lt;T&gt;</span><br></pre></td></tr></table></figure><p>可以看到这两个函数的第一个参数都是<code>CoroutineContext</code>类型的。所有协程构建函数（如<code>launch</code>和<code>async</code>）都是以<code>CoroutineScope</code>的扩展函数的形式被定义的，而<code>CoroutineScope</code>接口唯一的成员就是<code>CoroutineContext</code>类型。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CoroutineScope</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The context of this scope.</span></span><br><span class="line"><span class="comment">     * Context is encapsulated by the scope and used for implementation of coroutine builders that are extensions on the scope.</span></span><br><span class="line"><span class="comment">     * Accessing this property in general code is not recommended for any purposes except accessing the [Job] instance for advanced usages.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * By convention, should contain an instance of a [job][Job] to enforce structured concurrency.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> coroutineContext: CoroutineContext</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>协程上下文是协程必备的组成部分，它管理了协程的线程绑定、生命周期、异常处理和调试功能，接下来我们分析上下文具体的结构组成。</p><h1 id="协程上下文的结构"><a href="#协程上下文的结构" class="headerlink" title="协程上下文的结构"></a>协程上下文的结构</h1><blockquote><p>It is an indexed set of Element instances. An indexed set is a mix between a set and a map. Every element in this set has a unique Key. Keys are compared by reference.</p></blockquote><p>CoroutineContext接口跟Map很类似，具有如下特点：</p><ul><li>有序Map</li><li>Key唯一</li><li>类型安全</li></ul><p>##跟Map类似，为什么不直接用Map</p><p>那么我们为什么不直接用Map来实现呢？参考下面一段代码，它用Map实现了类似CoroutineContext的功能</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typealias CoroutineContext = Map&lt;CoroutineContext.Key&lt;*&gt;, CoroutineContext.Element&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(key: <span class="type">CoroutineContext</span>.<span class="type">Key</span>&lt;*&gt;)</span></span>: CoroutineContext.Element?</span><br></pre></td></tr></table></figure><p>如果使用这种实现，我们每次调用<code>get</code>之后，必须用显式的类型转换，才能得到想要的<code>Element</code>类型。而CoroutineContext则通过泛型（CoroutineContext的Key即带有类型信息）为我们解决了类型转换的痛点：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;E : Element&gt;</span> <span class="title">get</span><span class="params">(key: <span class="type">Key</span>&lt;<span class="type">E</span>&gt;)</span></span>: E?</span><br></pre></td></tr></table></figure><h1 id="在CoroutineContext上可进行的操作"><a href="#在CoroutineContext上可进行的操作" class="headerlink" title="在CoroutineContext上可进行的操作"></a>在CoroutineContext上可进行的操作</h1><p>CoroutineContext并未实现标准的集合接口，因此无法使用<code>iterator()</code>等集合标准操作。它有独特的一套操作。</p><h2 id="“拼装”上下文对象"><a href="#“拼装”上下文对象" class="headerlink" title="“拼装”上下文对象"></a>“拼装”上下文对象</h2><p>对CoroutineContext来说，最重要的操作是<code>plus</code>，<code>plus</code>操作用于把两个CoroutineContext对象合并成一个。合并时有一个优先级规则：<code>plus</code>右侧对象的属性会覆盖左侧对象中的同名属性。</p><blockquote><p>[The plus operator] returns a context containing elements from this context and elements from other context. The elements from this context with the same key as in the other one are dropped.</p></blockquote><h2 id="Element即是CoroutineContext"><a href="#Element即是CoroutineContext" class="headerlink" title="Element即是CoroutineContext"></a>Element即是CoroutineContext</h2><p>我们知道CoroutineContext中的Value是Element，其实Element本身也是继承于CoroutineContext。这样做的好处是，当我们只有一个CoroutineContext.Element对象时，也可以把它作为一个CoroutineContext来使用，这种一般称之为<strong>singleton context</strong>。</p><h2 id="空对象"><a href="#空对象" class="headerlink" title="空对象"></a>空对象</h2><p>除了<strong>singleton context</strong>，还有一种特殊的上下文对象，<code>EmptyCoroutineContext</code>。它不含有任何Element，因此，当使用<code>plus</code>连接符连接一个<code>EmptyCoroutineContext</code>和另一个上下文对象时，总是得到与另一个上下文对象相同的对象。</p><h1 id="认识一下那些Elements"><a href="#认识一下那些Elements" class="headerlink" title="认识一下那些Elements"></a>认识一下那些Elements</h1><p>如果我们想要查看CoroutineContext里都可以包含哪些Elements，可以搜索CoroutineContext.Key接口的实现，因为CoroutineContext是一个保存类型确定元素的Map。经过搜索后，我们发现以下几个典型Element：</p><h2 id="指定执行线程：ContinuationInterceptor"><a href="#指定执行线程：ContinuationInterceptor" class="headerlink" title="指定执行线程：ContinuationInterceptor"></a>指定执行线程：ContinuationInterceptor</h2><p>用于处理协程挂载在线程上的逻辑，抽象类<strong>CoroutineDispatcher</strong>实现了该接口，一般常用的Dispatcher都会继承于<strong>CoroutineDispatcher</strong>。</p><h2 id="层级关系管理：Job"><a href="#层级关系管理：Job" class="headerlink" title="层级关系管理：Job"></a>层级关系管理：Job</h2><p>用于管理任务层级，处理任务父子关系。</p><ul><li>手动终止父Job时，其中的子Job也被终止</li><li>当所有子Job运行结束时，父Job才可以运行结束</li></ul><h2 id="处理异常：CoroutineExceptionHandler"><a href="#处理异常：CoroutineExceptionHandler" class="headerlink" title="处理异常：CoroutineExceptionHandler"></a>处理异常：CoroutineExceptionHandler</h2><p>如果你在构建协程时使用了无法传递异常的构建器，如<code>launch</code>和<code>actor</code>，当异常发生时，需要有一个异常处理器来处理它。<code>CoroutineExceptionHandler</code>就是充当这样的异常处理器。</p><h2 id="名字：CoroutineName"><a href="#名字：CoroutineName" class="headerlink" title="名字：CoroutineName"></a>名字：CoroutineName</h2><p>协程的别名，一般是用于调试，以区分多个协程。</p><p>上述Element内部都以伴生对象的形式定义了相应的Key，可以通过<code>coroutineContext[element type name]</code>的形式方便地获取到Element对象。比如<code>coroutineContext[Job]</code>会返回Job或者null（如果没有Job）。</p><h1 id="协程构建过程中的CoroutineContext"><a href="#协程构建过程中的CoroutineContext" class="headerlink" title="协程构建过程中的CoroutineContext"></a>协程构建过程中的CoroutineContext</h1><p>前面讲过<code>CoroutineScope</code>实际上是一个<code>CoroutineContext</code>的封装，当我们需要启动一个协程时，会在<code>CoroutineScope</code>的实例上调用构建函数，如<code>async</code>和<code>launch</code>。在构建函数中，一共出现了3个CoroutineContext：</p><ul><li><strong>inherited context</strong>：从<code>CoroutineScope</code>中继承得到的上下文对象</li><li><strong>context argument</strong>：构建函数中传入的第一个参数，默认为<code>EmptyCoroutineContext</code></li><li><strong>coroutine context</strong>：挂起代码块（lambda函数）运行时的上下文对象</li></ul><p>如果我们查看协程构建函数<code>async</code>和<code>launch</code>的源码，会发现它们第一行都是如下代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> newContext = newCoroutineContext(context)</span><br></pre></td></tr></table></figure><p>再进一步查看：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CoroutineContext.kt</span></span><br><span class="line"><span class="meta">@ExperimentalCoroutinesApi</span></span><br><span class="line"><span class="keyword">public</span> actual <span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">newCoroutineContext</span><span class="params">(context: <span class="type">CoroutineContext</span>)</span></span>: CoroutineContext &#123;</span><br><span class="line">    <span class="keyword">val</span> combined = coroutineContext + context</span><br><span class="line">    <span class="keyword">val</span> debug = <span class="keyword">if</span> (DEBUG) combined + CoroutineId(COROUTINE_ID.incrementAndGet()) <span class="keyword">else</span> combined</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (combined !== Dispatchers.Default &amp;&amp; combined[ContinuationInterceptor] == <span class="literal">null</span>)</span><br><span class="line">        debug + Dispatchers.Default <span class="keyword">else</span> debug</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就比较清晰了：构建器函数内部进行了一个CoroutineContext拼接操作，plus的左值是<code>CoroutineScope</code>内部的<code>CoroutineContext</code>，右值是作为构建函数参数的<code>CoroutineContext</code>。根据我们前面讲到的拼接操作，左值具有更高的优先级。</p><p>此外，抽象类<code>AbstractCoroutineScope</code>实现了<code>CoroutineScope</code>和<code>Job</code>接口，大部分CoroutineScope的实现都继承自<code>AbstractCoroutineScope</code>，意味着他们同时也是一个<code>Job</code>。可以得到：<strong>coroutine context = parent context + coroutine job</strong>。</p><h1 id="Elements默认值"><a href="#Elements默认值" class="headerlink" title="Elements默认值"></a>Elements默认值</h1><p>对于上述4个Elements，如果既没有显示指明，则会取相应的默认值：</p><ul><li>ContinuationInterceptor：默认值为<code>Dispatchers.Default</code>，基于线程池实现，线程数目=CPU数目，且最少为2支</li><li>Job：默认值为null，在这种情况下，协程是孤儿（没有父协程，无法被父协程取消，例如<code>GlobalScope</code>）</li><li>CoroutineExceptionHandler：它的情况比较复杂，当异常发生时，若没有指定<code>CoroutineExceptionHandler</code>，会使用全局的异常处理器，在全局异常处理器中调用当前线程的<code>uncaughtExceptionHandler</code>。代码如下：</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CoroutineExceptionHandlerImpl.kt</span></span><br><span class="line"><span class="keyword">internal</span> actual <span class="function"><span class="keyword">fun</span> <span class="title">handleCoroutineExceptionImpl</span><span class="params">(context: <span class="type">CoroutineContext</span>, exception: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// use additional extension handlers</span></span><br><span class="line">    <span class="keyword">for</span> (handler <span class="keyword">in</span> handlers) &#123;</span><br><span class="line">        handler.handleException(context, exception)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// use thread's handler</span></span><br><span class="line">    <span class="keyword">val</span> currentThread = Thread.currentThread()</span><br><span class="line">    currentThread.uncaughtExceptionHandler.uncaughtException(currentThread, exception)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Name：默认为“coroutine”</li></ul><p>对于上述默认值，用代码实现起来也并不复杂：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> defaultExceptionHandler = CoroutineExceptionHandler &#123; ctx, t -&gt;</span><br><span class="line">    ServiceLoader.load(</span><br><span class="line">        serviceClass, </span><br><span class="line">        serviceClass.classLoader</span><br><span class="line">    ).forEach&#123;</span><br><span class="line">        it.handleException(ctx, t)</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.currentThread().let &#123; </span><br><span class="line">        it.uncaughtExceptionHandler.uncaughtException(it, exception)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoroutineContext</span></span>(</span><br><span class="line">        <span class="keyword">val</span> continuationInterceptor: ContinuationInterceptor = </span><br><span class="line">                Dispatchers.Default,</span><br><span class="line">        <span class="keyword">val</span> parentJob: Job? = </span><br><span class="line">                <span class="literal">null</span>,</span><br><span class="line">        <span class="keyword">val</span> coroutineExceptionHandler: CoroutineExceptionHandler = </span><br><span class="line">                defaultExceptionHandler,</span><br><span class="line">        <span class="keyword">val</span> name: CoroutineName = </span><br><span class="line">                CoroutineName(<span class="string">"coroutine"</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="用例浅析"><a href="#用例浅析" class="headerlink" title="用例浅析"></a>用例浅析</h1><p>上述4个Elements中，最重要的是Dispatcher和Job两个，我们来看一些例子。</p><h2 id="Global-Scope-Context"><a href="#Global-Scope-Context" class="headerlink" title="Global Scope Context"></a>Global Scope Context</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GlobalScope.launch &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全局Scope使用全默认的4个Elements，意味着它使用<code>Dispatchers.Default</code>和为空的<code>Job</code>（无法通过父Job取消）。</p><h2 id="Fully-Qualified-Context"><a href="#Fully-Qualified-Context" class="headerlink" title="Fully Qualified Context"></a>Fully Qualified Context</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">launch(</span><br><span class="line">        Dispatchers.Main + </span><br><span class="line">                Job() + </span><br><span class="line">                CoroutineName(<span class="string">"HelloCoroutine"</span>) + </span><br><span class="line">                CoroutineExceptionHandler &#123; _, _ -&gt; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全限定Context，即全部显式指定具体值的Elements。不论你用哪一个<code>CoroutineScope</code>构建该协程，它都具有一致的表现，不会受到<code>CoroutineScoipe</code>任何影响。</p><h2 id="CoroutineScope-Context"><a href="#CoroutineScope-Context" class="headerlink" title="CoroutineScope Context"></a>CoroutineScope Context</h2><p>这里我们基于Activity生命周期实现一个CoroutineScope：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ScopedAppActivity</span>:<span class="type"></span></span></span><br><span class="line">        AppCompatActivity(),</span><br><span class="line">        CoroutineScope</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> job: Job</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> coroutineContext: CoroutineContext</span><br><span class="line">        <span class="keyword">get</span>() = job + Dispatchers.Main <span class="comment">// 注意这里使用+拼接CoroutineContext</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        job = Job()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">        job.cancel()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Dispatcher：使用<code>Dispatcher.Main</code>，以在UI线程进行绘制</li><li>Job：在<code>onCreate</code>时构建，在<code>onDestroy</code>时销毁，所有基于该CoroutineContext创建的协程，都会在Activity销毁时取消，从而避免Activity泄露的问题</li></ul><h2 id="临时指定参数"><a href="#临时指定参数" class="headerlink" title="临时指定参数"></a>临时指定参数</h2><p>前面数次提到过，CoroutineContext的参数主要有两个来源：从scope中继承+参数指定。我们可以用<code>withContext</code>便捷地指定某个参数启动子协程，例如我们想要在协程内部执行一个无法被取消的子协程：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">withContext(NonCancellable) &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="读取协程上下文参数"><a href="#读取协程上下文参数" class="headerlink" title="读取协程上下文参数"></a>读取协程上下文参数</h2><p>可以通过顶级挂起只读属性<code>coroutineContext</code>获取协程上下文参数，它位于 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/coroutine-context.html" target="_blank" rel="noopener">kotlin-stdlib / kotlin.coroutines / coroutineContext</a>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">"Running in <span class="subst">$&#123;coroutineContext[CoroutineName]&#125;</span>"</span>)</span><br></pre></td></tr></table></figure><h2 id="Nested-Context"><a href="#Nested-Context" class="headerlink" title="Nested Context"></a>Nested Context</h2><p>内嵌上下文切换是指：在协程A内部构建协程B时，B会自动继承A的Dispatcher，如果没有注意这一点，很容易发生诸如“主线程执行耗时操作”的错误。</p><p>我们可以在调用<code>async</code>时加入Dispatcher参数，以切换到工作线程。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的做法，在主线程中直接调用async，若耗时过长则阻塞UI</span></span><br><span class="line">GlobalScope.launch(Dispatchers.Main) &#123;</span><br><span class="line">    <span class="keyword">val</span> deferred = async &#123;</span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的做法，在工作线程执行协程任务</span></span><br><span class="line">GlobalScope.launch(Dispatchers.Main) &#123;</span><br><span class="line">    <span class="keyword">val</span> deferred = async(Dispatchers.Default) &#123;</span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul><li>协程上下文环境参数可以用加号<code>+</code>拼接，左值优先</li><li>上下文环境可以继承</li><li>上下文环境可以单独制定参数</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>本文的70%都翻译总结自Medium上的这篇文章，写的非常棒，建议有英文阅读能力的同学直接阅读原文</p><ul><li><a href="https://proandroiddev.com/demystifying-coroutinecontext-1ce5b68407ad" target="_blank" rel="noopener">Demystifying CoroutineContext</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;限定目的，能使人生变得简洁。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;协程上下文是个啥？&quot;&gt;&lt;a href=&quot;#协程上下文是个啥？&quot; class=&quot;headerlink&quot; title=&quot;协程上下文是个啥？&quot;&gt;&lt;/a&gt;协程上下文是个啥？&lt;
      
    
    </summary>
    
    
      <category term="Kotlin" scheme="https://lilei.pro/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 协程基础课 02.suspend函数</title>
    <link href="https://lilei.pro/2019/12/10/kotlin-coroutines-02/"/>
    <id>https://lilei.pro/2019/12/10/kotlin-coroutines-02/</id>
    <published>2019-12-10T14:41:39.000Z</published>
    <updated>2019-12-10T14:42:46.058Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是《Kotlin 协程基础课》的第2篇文章。</p></blockquote><blockquote><p>Everyone must choose one of two pains: The pain of discipline or the pain of regret. Choose WISELY.</p></blockquote><p>在上篇文章里我们学习了如何通过协程简化耗时操作的写法，其中有一个关键字<code>suspend</code>，用于在定义函数时进行声明。本篇文章将对suspend进行进一步介绍，旨在学会它的含义和用法。</p><h1 id="suspend限定词的含义"><a href="#suspend限定词的含义" class="headerlink" title="suspend限定词的含义"></a>suspend限定词的含义</h1><p><strong>suspend</strong>，翻译过来就是<strong>中断，挂起</strong>，跟<strong>public、static</strong>等关键字相同，用在函数声明前，表示这是一个“挂起函数”。</p><p>挂起函数只能在协程或另一个挂起函数中被调用，如果你在非协程中使用到了挂起函数，会看到编译器有如下报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error: Kotlin: Suspend functions are only allowed to be called from a coroutine or another suspend function</span><br></pre></td></tr></table></figure><p>前面用到的<code>delay</code>就是一个挂起函数。<strong>suspend</strong>关键字表明函数内部进行了耗时操作，可以是计算密集型的CPU任务，也可以是网络、磁盘操作密集型的IO任务。基本上可以看做“但凡用callback实现的回调函数，都能用一个相对应的挂起函数实现”。</p><p>所以我们使用<strong>suspend</strong>关键字的时机就非常明确了：当函数要进行耗时操作时，就把它声明为<code>suspend</code>。</p><h1 id="suspend做了什么事"><a href="#suspend做了什么事" class="headerlink" title="suspend做了什么事"></a>suspend做了什么事</h1><p><em>方便起见，后续用“挂起”指代“suspend”。</em></p><p>作为及物动词，“挂起”应当有一个宾语，这里“挂起”的对象是<strong>协程</strong>。接下来我们对挂起的过程中发生了什么一探究竟，记住下面这句话：</p><p><strong>“挂起”是指协程从它当前线程脱离，切换到另一个线程运行。</strong>当线程运行到<code>suspend</code>函数时，会暂时挂起这个函数及后续代码的执行。这里涉及到两个角色：线程和协程。</p><h2 id="线程的行为"><a href="#线程的行为" class="headerlink" title="线程的行为"></a>线程的行为</h2><p>当线程运行到“挂起”代码块时，会跳出当前的代码块，不再执行后续代码。接下来线程会做什么呢？</p><p>如果它是一个后台线程：</p><ul><li>要么无事可做，被系统回收</li><li>要么被调度执行别的后台任务</li></ul><p>跟Java线程池里的线程在工作结束之后的表现完全一样：<strong>回收或者再利用</strong>。</p><p>如果它是Android主线程：</p><ul><li>继续UI刷新工作</li></ul><h2 id="协程的行为"><a href="#协程的行为" class="headerlink" title="协程的行为"></a>协程的行为</h2><p>上面讲到线程运行到挂起代码块时，会暂时退出当前代码块的执行。那么，剩余的协程代码在哪里得到执行呢？答案就在挂起函数的实现中——即我们为挂起函数指定的线程。</p><p><code>withContext</code>函数可以指定协程代码的运行线程，常见的Dispatcher有Main、IO、Default。协程从挂起的地方开始，切换到这些线程之中的一个继续运行，当运行完毕时，会<strong>自动切换回原线程执行</strong>。</p><p>在协程的源码里，“自动切换回来”是通过<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines.experimental/-continuation/resume.html" target="_blank" rel="noopener">resume</a>实现的。挂起函数之所以必须在协程中调用，就是因为协程框架会自动帮我们处理这个自动切换的过程。</p><h2 id="suspend-不会真正操作挂起"><a href="#suspend-不会真正操作挂起" class="headerlink" title="suspend 不会真正操作挂起"></a>suspend 不会真正操作挂起</h2><p>并不是声明了<code>suspend</code>后，线程运行到该位置，就自动进行挂起切换的，参照下面一个例子，挂起函数仍然运行在主线程中。为什么没有切换线程？因为编译器根本不知道要往哪里切，需要我们在编码时明确告诉它，这个挂起函数要切换到哪一个线程继续运行。我们可以用<code>withContext</code>指明待切换的线程。在实现一个挂起函数时，仅仅加上<code>suspend</code>关键字是不够的，必须在函数内部直接或间接地调用协程框架自带的<code>suspend</code>函数。</p><p><code>suspend</code>只是一个提醒，它只有一个效果，就是限制函数只能在协程里调用，如果在非协程里使用了<code>suspend</code>函数，则编译不通过。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 仍然运行在Main</span></span><br><span class="line">suspend <span class="function"><span class="keyword">fun</span> <span class="title">suspendingPrint</span><span class="params">()</span></span> &#123;</span><br><span class="line">  println(<span class="string">"Thread: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">I/System.<span class="keyword">out</span>: Thread: main</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行在IO</span></span><br><span class="line">suspend <span class="function"><span class="keyword">fun</span> <span class="title">suspendingPrint</span><span class="params">()</span></span> = withContext(Dispatchers.IO) &#123;</span><br><span class="line">  println(<span class="string">"Thread: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="如何写一个suspend函数"><a href="#如何写一个suspend函数" class="headerlink" title="如何写一个suspend函数"></a>如何写一个suspend函数</h1><p>最简单的方式是：</p><ol><li>声明函数为<code>suspend</code></li><li>使用<code>withContext</code>指定目标线程，或者在函数内部调用另一个<code>suspend</code>函数</li></ol><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文介绍了协程中最常见的关键字<code>suspend</code>的含义和用法，阅读完本文后你应当掌握：</p><ul><li>挂起函数运行时的表现</li><li>什么情况下使用挂起函数</li><li>如何写一个简单的挂起函数</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://juejin.im/post/5da81352f265da5b774fc39d" target="_blank" rel="noopener">掘金-扔物线</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;这是《Kotlin 协程基础课》的第2篇文章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Everyone must choose one of two pains: The pain of discipline or t
      
    
    </summary>
    
    
      <category term="Kotlin" scheme="https://lilei.pro/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 协程基础课 01.协程的基本概念与用法</title>
    <link href="https://lilei.pro/2019/11/17/kotlin-coroutines-01/"/>
    <id>https://lilei.pro/2019/11/17/kotlin-coroutines-01/</id>
    <published>2019-11-17T00:57:40.000Z</published>
    <updated>2019-12-03T14:27:46.210Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是《Kotlin 协程基础课》的第1篇文章。</p></blockquote><blockquote><p>正因为她觉得一切都无所谓，所以生活给她什么，她便接受什么。少年时代，她觉得选择为时过早，而现在已是青年，她又觉得改变为时过晚。</p></blockquote><h1 id="系列基础课前言"><a href="#系列基础课前言" class="headerlink" title="系列基础课前言"></a>系列基础课前言</h1><p>对于Kotlin学习而言，要想从“入门”走到“精通”，协程（Coroutines）是必须迈过去的一道坎。接下来一周时间，我会在之前零散学习的基础上，总结成一系列基础课文章，作为对协程的阶段性学习小结。文章目录如下：</p><ul><li>01.协程的基本概念与用法</li><li>02.非阻塞式挂起（suspend）函数</li><li>03.理解协程的域（Scope）和调度器（Dispatcher）</li><li>04.用AAC&amp;协程优化Android架构设计</li></ul><h1 id="什么是协程"><a href="#什么是协程" class="headerlink" title="什么是协程"></a>什么是协程</h1><p>但凡学一门新知识，总是离不开5w1h。说起“协程”，很多人第一反应是2号线北新泾那家做旅游的互联网公司，不过，此“协程”非彼“携程”，协程（Coroutines）并不是一个新的概念，它的年纪要比Kotlin语言大得多。“协程 Coroutines”源自 Simula 和 Modula-2 语言，这个术语早在 1958 年就被 Melvin Edward Conway 发明并用于构建汇编程序，说明协程是一种编程思想，并不局限于特定的语言。目前很多现代语言都有协程的实现，比如Go、JavaScript、C#等。</p><p>协程作为一种编程思想，目的是简化并行代码编写，可以让我们以同步的方式写异步逻辑。对于Kotlin而言，“协程”一词是指实现了协程思想的一系列API的总称。Kotlin协程的底层实现是线程。</p><h1 id="没有协程的日子里"><a href="#没有协程的日子里" class="headerlink" title="没有协程的日子里"></a>没有协程的日子里</h1><p>由于Android是单一UI线程的框架，势必要进行很多UI线程以外的耗时操作，在协程之前，我们通常用这些技术来实现诸如网络请求、数据库读写等功能：</p><ul><li>AsyncTask：是Android原生的异步任务写法，写过的人就知道它有多难用，业务逻辑被分散在前中后三个方法里，冗长的boilerplate代码。更有甚者，一旦发生嵌套，光是一层层回调就能把人搞疯掉。</li><li>Thread：直接开线程并不是一种好的设计，只有新手才这么干。</li><li>ThreadPool or ExecutorService：这比<code>new Thread</code>好一些，但同样要处理UI、工作线程切换的问题，以及无法避免的回调。</li><li>Handler：一个工作线程的Handler用来处理耗时任务，处理完成后丢给主线程Handler，简单、直接、朴实无华。</li></ul><p>这时协程（Coroutines）来了，为我们推翻回调地狱、样板代码、内存泄漏、线程切换几座大山，Android开发者终于翻身农奴把歌唱，敢叫日月换新天。</p><h1 id="第一个协程Demo"><a href="#第一个协程Demo" class="headerlink" title="第一个协程Demo"></a>第一个协程Demo</h1><h2 id="用Thread-sleep模拟耗时操作"><a href="#用Thread-sleep模拟耗时操作" class="headerlink" title="用Thread.sleep模拟耗时操作"></a>用Thread.sleep模拟耗时操作</h2><p>在本文我们暂且不谈Android环境，在更通用的环境下展现协程的用法。首先我们模拟一个耗时操作与非耗时操作混合的场景，看下面一段代码，它在<code>main</code>函数里依次打印<code>one two three</code>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    println(<span class="string">"one"</span>)</span><br><span class="line">    println(<span class="string">"two"</span>)</span><br><span class="line">    println(<span class="string">"three"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时有另一个函数，它会耗时3s后，打印出参数在控制台。我们用直白的<code>Thread.sleep</code>来进行延时模拟。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printDelayed</span><span class="params">(msg: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    Thread.sleep(<span class="number">3000</span>)</span><br><span class="line">    println(msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后将主程序的<code>print(two)</code>改为耗时任务。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    println(<span class="string">"one"</span>)</span><br><span class="line">    printDelayed(<span class="string">"two"</span>)</span><br><span class="line">    println(<span class="string">"three"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后，输出如下，非常符合预期。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">three</span><br><span class="line">// 这里等待3s</span><br><span class="line">two</span><br></pre></td></tr></table></figure><h2 id="用delay模拟耗时操作"><a href="#用delay模拟耗时操作" class="headerlink" title="用delay模拟耗时操作"></a>用delay模拟耗时操作</h2><p>Kotlin的协程库提供了另一种延时的API，<code>delay</code>，我们把原来的<code>Thread.sleep</code>替换为<code>delay</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printDelayed</span><span class="params">(msg: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    delay(<span class="number">3000</span>L)</span><br><span class="line">    println(msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时Android Studio会在<code>delay</code>处提示错误：<em>suspend function delay should be called only from a coroutine or another suspend function</em>。翻译过来就是“delay是一个挂起函数，它只能在协程中、或者另一个挂起函数里面被调用”。我们把程序整体改写一下。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">suspend <span class="function"><span class="keyword">fun</span> <span class="title">printDelayed</span><span class="params">(msg: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    delay(<span class="number">3000</span>L)</span><br><span class="line">    println(msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">print123Blocking</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    println(<span class="string">"one"</span>)</span><br><span class="line">    printDelayed(<span class="string">"two"</span>)</span><br><span class="line">    println(<span class="string">"three"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    print123Blocking()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后发现程序的输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">// 等待3s</span><br><span class="line">two</span><br><span class="line">three</span><br></pre></td></tr></table></figure><p>为什么不是132而是123呢，要从<code>runBlocking</code>的定义说起。它会“新起一个协程运行后续代码，并且在该协程的运行过程中阻塞原线程（在demo中是主线程），直至协程运行结束”。而在协程运行时是按照代码顺序逐行运行的。所以打印出来的是123而非132。</p><h2 id="为runBlocking指定运行线程"><a href="#为runBlocking指定运行线程" class="headerlink" title="为runBlocking指定运行线程"></a>为runBlocking指定运行线程</h2><p>我们在<code>print123blocking</code>方法里打印出当前线程名。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">print123Blocking</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    println(<span class="string">"one - in thread: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">    printDelayed(<span class="string">"two - in thread: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">    println(<span class="string">"three - in thread: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">one - in thread: main @coroutine#1</span><br><span class="line">two - in thread: main @coroutine#1</span><br><span class="line">three - in thread: main @coroutine#1</span><br></pre></td></tr></table></figure><p>可见这个方法是在当前（main）线程里运行的，并且同属于<code>@coroutine#1</code>。</p><p>我们可以为<code>runBlocking</code>指定运行的线程，在协程的语言里，使用<code>Dispatcher</code>来表明这一概念。我们改写一下<code>print123Blocking</code>方法，使用<code>Dispatcher.Default</code>打印1和2。样例代码与系统输出如下，可见我们为其指定了Dispatcher的代码段运行在另一个线程里，且打印顺序仍然为123，这就是<strong>Blocking</strong>的厉害之处。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">print123Blocking</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking(Dispatchers.Default) &#123;</span><br><span class="line">        println(<span class="string">"one - in thread: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">        printDelayed(<span class="string">"two - in thread: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"three - in thread: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">one - in thread: DefaultDispatcher-worker-1 @coroutine#1</span><br><span class="line">two - in thread: DefaultDispatcher-worker-1 @coroutine#1</span><br><span class="line">// 此处等待3s</span><br><span class="line">three - in thread: main</span><br></pre></td></tr></table></figure><h2 id="如何利用协程打印出132"><a href="#如何利用协程打印出132" class="headerlink" title="如何利用协程打印出132"></a>如何利用协程打印出132</h2><h3 id="全局后台线程：GlobalScope-launch"><a href="#全局后台线程：GlobalScope-launch" class="headerlink" title="全局后台线程：GlobalScope.launch"></a>全局后台线程：GlobalScope.launch</h3><p>可以在blocking域中使用<code>GlobalScope.launch{ ... }</code>来指定后台线程运行任务，我们基于此将原有代码改造一下。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">print123Blocking</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        println(<span class="string">"one - in thread: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">        printDelayed(<span class="string">"two - in thread: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"three - in thread: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的输出是不可知的，有可能是以下两种情况，只打印3或者打印31，这是什么原因呢？因为我们是在后台全局线程中启动的“打印12任务”，后台线程是不会阻止主线程运行结束的，所以2是肯定打不出来，而1能否打印出来就看运行时线程调度情况了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// case 1</span><br><span class="line">three - in thread: main @coroutine#1</span><br><span class="line">one - in thread: DefaultDispatcher-worker-1 @coroutine#2</span><br><span class="line">// case 2</span><br><span class="line">three - in thread: main @coroutine#1</span><br></pre></td></tr></table></figure><h3 id="等待任务完成"><a href="#等待任务完成" class="headerlink" title="等待任务完成"></a>等待任务完成</h3><p>我们可以简单粗暴地使用<code>delay</code>来等待后台任务完成。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">print123Blocking</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        println(<span class="string">"one - in thread: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">        printDelayed(<span class="string">"two - in thread: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"three - in thread: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">    delay(<span class="number">4000</span>L) <span class="comment">// 因为我们知道printDelayed会延迟3秒，故这里等待4秒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">three - in thread: main @coroutine#1</span><br><span class="line">one - in thread: DefaultDispatcher-worker-1 @coroutine#2</span><br><span class="line">two - in thread: DefaultDispatcher-worker-1 @coroutine#2</span><br></pre></td></tr></table></figure><p>但是这种处理方法非常丑陋，而且这个<code>delay</code>的时长很难设置，设置长了吧，会导致无用的等待浪费时间；设置短了吧，有可能在后台线程输出之前就结束任务，有没有更优雅的写法呢？答案是有的，<code>job.join()</code>为我们提供了等待任务完成的功能，代码如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">print123Blocking</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> job = GlobalScope.launch &#123;</span><br><span class="line">        println(<span class="string">"one - in thread: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">        printDelayed(<span class="string">"two - in thread: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"three - in thread: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">    job.join()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义Dispatcher"><a href="#自定义Dispatcher" class="headerlink" title="自定义Dispatcher"></a>自定义Dispatcher</h2><p>Dispatcher为协程的运行指定了线程，常见Dispatchers如下：</p><ul><li>Dispatcher.IO：进行IO密集型操作，如数据库读写、文件读写、网络交互</li><li>Dispatcher.Default：进行CPU密集型操作，如列表排序、JSON解析、DiffUtils</li><li>Dispatcher.Main：仅存在于Android框架，调用<code>suspend</code>方法、进行UI操作、更新LiveData</li></ul><p>看到这里你可能已经理解了，Dispatcher其实就是线程的另一种表现形式，我们甚至可以自定义一个Dispatcher：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">print123Blocking</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    println(<span class="string">"one - in thread: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">    <span class="keyword">val</span> customDispatcher = Executors.newFixedThreadPool(<span class="number">2</span>).asCoroutineDispatcher()</span><br><span class="line">    launch(customDispatcher) &#123;</span><br><span class="line">        printDelayed(<span class="string">"two - in thread: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"three - in thread: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">    (customDispatcher.executor <span class="keyword">as</span> ExecutorService).shutdown() <span class="comment">// ！主动停止，否则线程会一直运行下去</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下（在play.kotlin上面总是超时不知道为啥），意味着我们完全可以高度定制Dispatcher的实现，虽然大部分时间使用默认的Dispatcher就已足够。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">one - from thread main</span><br><span class="line">three - from thread main</span><br><span class="line">two - from thread pool-1-thread-1</span><br></pre></td></tr></table></figure><h2 id="有返回值的suspend函数"><a href="#有返回值的suspend函数" class="headerlink" title="有返回值的suspend函数"></a>有返回值的suspend函数</h2><p>最后一部分内容是跟Android开发密切相关的，大部分时间我们需要通过网络、数据库进行一些读取数据耗时操作，函数会有返回值，我们模拟一个网络操作，它读取一个<code>startNum</code>参数，等待1s延时后，返回<code>startNum * 10</code>。通过 <code>async { ... }.await()</code> 可以获取耗时函数的返回值，代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟1s延时网络操作</span></span><br><span class="line">suspend <span class="function"><span class="keyword">fun</span> <span class="title">calculateHardThings</span><span class="params">(startNum: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">  delay(<span class="number">1000</span>)</span><br><span class="line">  println(<span class="string">"result: <span class="subst">$&#123;result&#125;</span>, in thread: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">  <span class="keyword">return</span> startNum * <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用延时操作，分别await，耗时共3s</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">exampleAsyncAwait</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">  <span class="keyword">val</span> startTime = System.currentTimeMillis()</span><br><span class="line">  <span class="keyword">val</span> deferred1 = async &#123; calculateHardThings(<span class="number">10</span>) &#125;.await()</span><br><span class="line">  <span class="keyword">val</span> deferred2 = async &#123; calculateHardThings(<span class="number">20</span>) &#125;.await()</span><br><span class="line">  <span class="keyword">val</span> deferred3 = async &#123; calculateHardThings(<span class="number">30</span>) &#125;.await()</span><br><span class="line">  <span class="keyword">val</span> sum = deferred1 + deferred2 + deferred3</span><br><span class="line">  <span class="keyword">val</span> endTime = System.currentTimeMillis()</span><br><span class="line">  println(<span class="string">"sum = <span class="variable">$sum</span>, time = <span class="subst">$&#123;endTime - startTime&#125;</span>"</span>) <span class="comment">// sum = 600, time = 3030</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="并发进行耗时操作"><a href="#并发进行耗时操作" class="headerlink" title="并发进行耗时操作"></a>并发进行耗时操作</h3><p>因为是3个耗时1s操作并发，我们自然而然希望它们同时运行，总耗时1s而不是3s，要如何实现呢？把所有的<code>await()</code>调用写入同一个语句，编译器会优化它们，使其同时运行。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用延时操作，同时await，耗时共1s</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">exampleAsyncAwait</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">  <span class="keyword">val</span> startTime = System.currentTimeMillis()</span><br><span class="line">  <span class="keyword">val</span> deferred1 = async &#123; calculateHardThings(<span class="number">10</span>) &#125;</span><br><span class="line">  <span class="keyword">val</span> deferred2 = async &#123; calculateHardThings(<span class="number">20</span>) &#125;</span><br><span class="line">  <span class="keyword">val</span> deferred3 = async &#123; calculateHardThings(<span class="number">30</span>) &#125;</span><br><span class="line">  <span class="keyword">val</span> sum = deferred1.await() + deferred2.await() + deferred3.await()</span><br><span class="line">  <span class="keyword">val</span> endTime = System.currentTimeMillis()</span><br><span class="line">  println(<span class="string">"sum = <span class="variable">$sum</span>, time = <span class="subst">$&#123;endTime - startTime&#125;</span>"</span>) <span class="comment">// sum = 600, time = 1065</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用withContext的简化写法"><a href="#使用withContext的简化写法" class="headerlink" title="使用withContext的简化写法"></a>使用withContext的简化写法</h3><p>async/await 会运行在当前线程中，对于网络操作一般的做饭是让其在IO线程运行，对于计算密集型操作则是在CPU（Default）线程运行，使用<code>withContext</code>可以同时完成<code>async/await</code>的操作，但缺点是这三个操作只能相继运行，无法同时运行。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用延时操作</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">exampleWithContext</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">  <span class="keyword">val</span> startTime = System.currentTimeMillis()</span><br><span class="line">  <span class="keyword">val</span> deferred1 = withContext(Dispatchers.Default) &#123; calculateHardThings(<span class="number">10</span>) &#125;</span><br><span class="line">  <span class="keyword">val</span> deferred2 = withContext(Dispatchers.Default) &#123; calculateHardThings(<span class="number">20</span>) &#125;</span><br><span class="line">  <span class="keyword">val</span> deferred3 = withContext(Dispatchers.Default) &#123; calculateHardThings(<span class="number">30</span>) &#125;</span><br><span class="line">  <span class="keyword">val</span> sum = deferred1 + deferred2 + deferred3</span><br><span class="line">  <span class="keyword">val</span> endTime = System.currentTimeMillis()</span><br><span class="line">  println(<span class="string">"sum = <span class="variable">$sum</span>, time = <span class="subst">$&#123;endTime - startTime&#125;</span>"</span>) <span class="comment">// sum = 600, time = 3029</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文介绍了协程的基本用法，在阅读完本文后，你应当掌握以下知识点：</p><ul><li>声明耗时函数，以及在协程代码块里调用耗时函数</li><li>切换运行环境</li><li>等待任务完成</li><li>并行进行耗时操作，获取操作结果</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.youtube.com/watch?v=jYuK1qzFrJg" target="_blank" rel="noopener">https://www.youtube.com/watch?v=jYuK1qzFrJg</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;这是《Kotlin 协程基础课》的第1篇文章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;正因为她觉得一切都无所谓，所以生活给她什么，她便接受什么。少年时代，她觉得选择为时过早，而现在已是青年，她又觉得改变为时过晚。&lt;/p
      
    
    </summary>
    
    
      <category term="Kotlin" scheme="https://lilei.pro/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>【转】Android Studio Debug 的 9 个小技巧</title>
    <link href="https://lilei.pro/2019/11/11/android-studio-debug-skills/"/>
    <id>https://lilei.pro/2019/11/11/android-studio-debug-skills/</id>
    <published>2019-11-11T15:46:08.000Z</published>
    <updated>2019-11-11T17:09:55.597Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Pain is inevitable. Suffering is optional. 痛楚难以避免，而磨难可以选择。</p></blockquote><p>这是一篇转载的文章。</p><ul><li>作者：wanbo</li><li>链接：<a href="https://juejin.im/post/5dbf8036f265da4d4b5fe7c2" target="_blank" rel="noopener">https://juejin.im/post/5dbf8036f265da4d4b5fe7c2</a></li><li>来源：掘金</li></ul><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/191111_as_debug_skills/dev_summit_19.webp" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>周末看 Android Dev Summit ‘19 的视频的时候，看到一章关于 Android Studio Debug 的介绍，有很多日常非常有用的小技巧，学习了这些小技巧能很大程度的降低我们 Debug 的成本，快速定位问题的本质，今天就向大家介绍一下 Android Studio Debug 的 9 个小技巧。</p><p>没关注的小伙伴记得关注订阅😝，如果觉得这些文章有点意思，记得分享转发评论点赞😝！</p><h2 id="Log-过滤和折叠"><a href="#Log-过滤和折叠" class="headerlink" title="Log 过滤和折叠"></a>Log 过滤和折叠</h2><p>有时候 Logcat 中 log 的信息很长，同时还有些我们不需要的信息也打印出来，例如下图中的【时间+线程 ID】。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/191111_as_debug_skills/log_filter_0.webp" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这个时候我们可以点击 Logcat 窗口上的【设置】按钮，设置一条 Log 需要显示哪些关键信息，可设置的项有：时间、线程ID、包名、Tag name。我们可以根据自己的需要控制显示，并且下面还会有一条 Sample Log 提供设置后的预览效果，就像下图中这样。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/191111_as_debug_skills/log_filter_1.webp" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>日常开发的时候我们还会遇到另一种情况，比如根据当前 UI 的渲染情况，我们需要时刻打印 UI 的某个值，来帮助我们观察 UI，同时当到达某种条件的时候，输入一条我们得到的【结果 log】。也就是说在获得我们的【结果 log】之前会有很多没用但是又必须打印的 log，这样当我们需要查找【结果 log】的时候就会非常麻烦。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/191111_as_debug_skills/log_filter_2.webp" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>就像上图中这样，我们的【结果 log】被上下【循环打印 log】包围了，很难一下子找出来，这时候我们可以选关键字【右键】，选择【Fold Lines Like This】，如下图所示。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/191111_as_debug_skills/log_filter_3.webp" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这样我们相同关键字的 log 就会被折叠，当然也可以展开查看详细 log。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/191111_as_debug_skills/log_filter_4.webp" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="自定义断点执行条件"><a href="#自定义断点执行条件" class="headerlink" title="自定义断点执行条件"></a>自定义断点执行条件</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/191111_as_debug_skills/custom_break_0.webp" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>我们来看上面这段代码，通过字面意思我们可以得知：这是一个点击事件执行的方法，点击发生后通过 NavController 从当前 HomeFragment 跳转到 EmailFragment。然后我们在第一行打了一个断点，我们已经得知当 email 的 subject 包含 【Bonjour】关键字的时候，这段代码会发生崩溃，反之不包含则不会发生崩溃，所以我们不需要每次断点都生效。</p><p>这里我们可以右键断点，在 Condition 里输入我们的条件判断语句，当条件允许的时候，断点才生效。条件语句的代码支持 Kotlin 和 Java 两种语言的写法，如下图所示。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/191111_as_debug_skills/custom_break_1.webp" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>然后如果我们想在跳转到 EmailFragment 之后进一步去追踪问题，于是我在 EmailFragment 的 onCreate 方法打了一个断点（如下图所示），然后这里还会遇到我们之前说的问题：不符合条件的时候断点也会生效，这时候我们该怎么办呢？</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/191111_as_debug_skills/custom_break_2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>我们可以在这个断点上面，右键、点击更多。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/191111_as_debug_skills/custom_break_3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>左边选择当前断点之后，在右边点击【Disable until breakpoint hit】，选择我们之前有条件判断的断点，那么这个新的断点会在它所跟随的断点生效之后才会生效。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/191111_as_debug_skills/custom_break_4.webp" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="挂起线程"><a href="#挂起线程" class="headerlink" title="挂起线程"></a>挂起线程</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/191111_as_debug_skills/suspend.webp" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>当我们右键任意一个断点的时候，会有一个 Suspend 选项【All、Thread】，All 也就意味着当我们在一个多线程的应用中 debug 问题的时候，一旦这个断点生效，所有的线程都会被挂起，Thread 表示只挂起当前线程。所以当我们在某个后台线程中 debug 问题的时候就可以选择 Thread，这样就不会在 debug 的时候阻塞主线程的正常功能。</p><p>还有一个打开关闭断点的快捷键也分享一下：Windows 用户 Alt + Click ，Mac Option + Click 。</p><h2 id="动态打印"><a href="#动态打印" class="headerlink" title="动态打印"></a>动态打印</h2><p>详细很多人包括我之前在 debug 的时候，都会在需要 debug 的地方增加 print 输出一下信息供自己排查错误，这里提供一种快捷方便的方法，可以既不污染我们的代码，又可以随时输出任意信息。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/191111_as_debug_skills/eval_and_log.webp" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>如上图所示，在需要打印的地方增加断点，然后取消所有线程的挂起，选择【Evaluate and log】，属于我们需要打印的语句，当代码执行到断点的时候，不会暂停，而会根据我们设置的打印信息输出 log，是不是很方便？</p><h2 id="断点分组"><a href="#断点分组" class="headerlink" title="断点分组"></a>断点分组</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/191111_as_debug_skills/group.webp" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>通常遇到一个问题的时候，我们需要增加很多断点去追踪问题的原因，当问题解决之后，往往会忘记取消这些断点，导致在某次调试的时候，设备会被之前的断点所暂停，会让我们很无语。这里我们可以 debug 的时候在某个断点上：右键、更多，然后选择这个问题所有相关的断点，将它们分到同一个 Group 里面，那么这一个组的断点就可以统一开关、统一删除。</p><h2 id="断点上一步"><a href="#断点上一步" class="headerlink" title="断点上一步"></a>断点上一步</h2><p>说到这个真的很痛心，常常因为自己在 debug 的时候，由于下一步点击的太快了而错过了问题关键行，只能重新运行一次代码，重新 debug 然后自己一次次点击下一步。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/191111_as_debug_skills/drop_frame.webp" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>在运行 Android 10 的设备上，debug 界面中提供了一个叫【Drop frame】的按钮，可以供我们跳出当前方法栈，返回上一步，这样就会避免我们因为错过断点而不得不重新运行代码。</p><h2 id="观察对象"><a href="#观察对象" class="headerlink" title="观察对象"></a>观察对象</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/191111_as_debug_skills/mark_obj_0.webp" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>当我们 debug 的时候，可以从 debug 窗口中观察当前作用域中的对象以及对象的属性，有时候我们会观察在不同页面是否是同一个对象，之前我的做法很粗暴…就是找张纸，把这个对象的 ID 记下来，然后在另一个页面 debug 看 ID 是否一致😂</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/191111_as_debug_skills/mark_obj_1.webp" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这里我们可以在对象上右键、选择【Mark Object】之后会让你自定义一个 Label，然后在整个 debug 期间，相同的对象会以你设置的 Label 为 name 出现，帮助我们方便的分析是否是统一对象。</p><p>顺便提一下，在任意一段代码上，点击行号，可以从当前断点快速执行到目标行并暂停，这个我真是第一次知道，感觉之前 Android Studio 都白用了😭</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/191111_as_debug_skills/mark_obj_2.webp" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>而且在 debug 的时候我们可以选择 debug 窗口中的【Evaluate expression】按钮来动态观察对象，点击之后会弹出一个计算框，我们可以输入任意当前作用域中的对象以及属性观察。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/191111_as_debug_skills/mark_obj_3.webp" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>不得不说这个真的很方便，以前遇到这种情况我只有一种方法就是：print 😂，当然这里不仅仅是观察对象，我们可以写任意代码观察我们想要的值，就像下图这样。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/191111_as_debug_skills/mark_obj_4.webp" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="增量更新"><a href="#增量更新" class="headerlink" title="增量更新"></a>增量更新</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/191111_as_debug_skills/hot_reload.webp" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>我试了一下，这两个按钮是真的很好用啊，比重新全量运行应用真是快了不少，非常方便。</p><h2 id="错误栈分析"><a href="#错误栈分析" class="headerlink" title="错误栈分析"></a>错误栈分析</h2><p>通常我们 App 中会继承一下线上 bug 反馈的 SDK 比如 bugly，在 bugly 我们会得到崩溃的异常栈信息，类似下图这样。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/191111_as_debug_skills/analyze_stack_0.webp" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>我们可以全选复制，打开我们的 Android Studio，选择 Analyze → Analyze Stack Trace or Thread Dump，然后把异常栈信息粘贴进去，点击确定。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/191111_as_debug_skills/analyze_stack_1.webp" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Android Studio 会在控制台显示这段异常栈信息，并且与现有代码 Link 在一起，我们可以点击跳转到问题所在行。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/191111_as_debug_skills/analyze_stack_2.webp" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>好了这就是今天要分享的全部内容，关于更多详细的内容，大家可以点击【阅读原文】在油管上查看，真希望有大佬可以出一个【Android Studio 使用全攻略】，感觉自己对 AS 真的只是会用，但还有很多东西需要去学习和探索。😂</p><p>我是 wanbo 大家加油！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Pain is inevitable. Suffering is optional. 痛楚难以避免，而磨难可以选择。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是一篇转载的文章。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作者：wanbo&lt;/li&gt;
&lt;li&gt;链接
      
    
    </summary>
    
    
      <category term="Android" scheme="https://lilei.pro/tags/Android/"/>
    
      <category term="Android Studio" scheme="https://lilei.pro/tags/Android-Studio/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin域函数小结</title>
    <link href="https://lilei.pro/2019/10/28/kotlin-scope-functions/"/>
    <id>https://lilei.pro/2019/10/28/kotlin-scope-functions/</id>
    <published>2019-10-28T15:37:31.000Z</published>
    <updated>2019-10-28T15:43:35.967Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>并非意志坚强就可以无所不能，人世不是那么单纯的。老实说，我甚至觉得每天坚持跑步同意志强弱并没有太大关联。我能够坚持跑二十年，恐怕还是因为合乎我的性情，至少“不觉得那么痛苦”。人生来如此，喜欢的事自然可以坚持下去，不喜欢的事怎么也坚持不了。 ——<strong>当我谈跑步时我谈些什么</strong></p></blockquote><p>想要掌握Kotlin，域函数是不得不迈过的一道坎。</p><h1 id="所谓“域函数”"><a href="#所谓“域函数”" class="headerlink" title="所谓“域函数”"></a>所谓“域函数”</h1><p>一句话，域函数（scope functions）是为给定的对象创建一个临时的域，在这个域中执行一些操作。相比于传统的对象-函数调用写法，域函数在减少代码量的同时，还可以让编码在逻辑上看起来更加清晰，便于扩展和维护。</p><p>对比一下域函数写法与普通写法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 域函数写法</span></span><br><span class="line">Person(<span class="string">"Alice"</span>, <span class="number">20</span>, <span class="string">"Amsterdam"</span>).let &#123;</span><br><span class="line">    println(it)</span><br><span class="line">    it.moveTo(<span class="string">"London"</span>)</span><br><span class="line">    it.incrementAge()</span><br><span class="line">    println(it)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通写法</span></span><br><span class="line"><span class="keyword">val</span> alice = Person(<span class="string">"Alice"</span>, <span class="number">20</span>, <span class="string">"Amsterdam"</span>)</span><br><span class="line">println(alice)</span><br><span class="line">alice.moveTo(<span class="string">"London"</span>)</span><br><span class="line">alice.incrementAge()</span><br><span class="line">println(alice)</span><br></pre></td></tr></table></figure><p>域函数要结合lambda表达式使用。Kotlin中一共有五个域函数：<code>let</code>, <code>run</code>, <code>with</code>, <code>apply</code>, <code>also</code>。这些域函数有两个区别点。</p><ul><li>域函数中如何引用上下文对象</li><li>域函数返回值</li></ul><h1 id="区别点：上下文对象"><a href="#区别点：上下文对象" class="headerlink" title="区别点：上下文对象"></a>区别点：上下文对象</h1><p>域函数中用<code>this</code>或者<code>it</code>指代上下文对象。</p><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p><code>run</code>, <code>with</code>和<code>apply</code>在lambda表达式中用<code>this</code>指代上下文对象，就好像lambda表达式是在对象内部调用的一样，<code>this</code>是可以省略的。对于调用对象内部方法、属性的代码，应当选择使用<code>this</code>指代的域函数。如果在域内要调用其他对象的函数，不要选择<code>this</code>指代，因为容易弄混。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> adam = Person(<span class="string">"Adam"</span>).apply &#123;</span><br><span class="line">  age = <span class="number">20</span> <span class="comment">// same as this.age = 20</span></span><br><span class="line">  city = <span class="string">"Hangzhou"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="it"><a href="#it" class="headerlink" title="it"></a>it</h2><p><code>let</code>, <code>also</code>在lambda表达式中用<code>it</code>指代上下文对象，与<code>this</code>不同，在访问方法和对象时<code>it</code>是不能省略的。当上下文对象需要在域内充当函数参数时，就选用<code>it</code>类型的域函数。另一个便捷之处在于，可以为<code>it</code>指代别名。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getRandomInt</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Random.nextInt(<span class="number">100</span>).also &#123;</span><br><span class="line">        writeToLog(<span class="string">"getRandomInt() generated value <span class="variable">$it</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> i = getRandomInt()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为it指代别名</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getRandomInt</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123; value -&gt;</span><br><span class="line">    <span class="keyword">return</span> Random.nextInt(<span class="number">100</span>).also &#123;</span><br><span class="line">        writeToLog(<span class="string">"getRandomInt() generated value <span class="variable">$value</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="区别点：返回值"><a href="#区别点：返回值" class="headerlink" title="区别点：返回值"></a>区别点：返回值</h1><h2 id="Lambda表达式结果"><a href="#Lambda表达式结果" class="headerlink" title="Lambda表达式结果"></a>Lambda表达式结果</h2><p><code>let</code>, <code>run</code>和<code>with</code>返回lambda表达式的结果（最后一行），可以用这些域函数来进行赋值，也可以进行链式调用。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 赋值</span></span><br><span class="line"><span class="keyword">val</span> numbers = mutableListOf(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>)</span><br><span class="line"><span class="keyword">val</span> countEndsWithE = numbers.run &#123; </span><br><span class="line">    add(<span class="string">"four"</span>)</span><br><span class="line">    add(<span class="string">"five"</span>)</span><br><span class="line">    count &#123; it.endsWith(<span class="string">"e"</span>) &#125; <span class="comment">// 返回count数</span></span><br><span class="line">&#125;</span><br><span class="line">println(<span class="string">"There are <span class="variable">$countEndsWithE</span> elements that end with e."</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无视返回值，只是执行域函数内部操作</span></span><br><span class="line"><span class="keyword">val</span> numbers = mutableListOf(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>)</span><br><span class="line">with(numbers) &#123; <span class="comment">// with是this指代，可省略</span></span><br><span class="line">    <span class="keyword">val</span> firstItem = first()</span><br><span class="line">    <span class="keyword">val</span> lastItem = last()        </span><br><span class="line">    println(<span class="string">"First item: <span class="variable">$firstItem</span>, last item: <span class="variable">$lastItem</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="上下文对象"><a href="#上下文对象" class="headerlink" title="上下文对象"></a>上下文对象</h2><p><code>also</code>, <code>apply</code>返回上下文对象，可以继续对此进行链式调用，也可以直接返回上下文对象。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链式调用</span></span><br><span class="line"><span class="keyword">val</span> numberList = mutableListOf&lt;<span class="built_in">Double</span>&gt;()</span><br><span class="line">numberList.also &#123; println(<span class="string">"Populating the list"</span>) &#125;</span><br><span class="line">    .apply &#123; <span class="comment">// 注意apply使用this指代（省略掉）</span></span><br><span class="line">        add(<span class="number">2.71</span>)</span><br><span class="line">        add(<span class="number">3.14</span>)</span><br><span class="line">        add(<span class="number">1.0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    .also &#123; println(<span class="string">"Sorting the list"</span>) &#125;</span><br><span class="line">    .sort()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为返回值</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getRandomInt</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Random.nextInt(<span class="number">100</span>).also &#123;</span><br><span class="line">        writeToLog(<span class="string">"getRandomInt() generated value <span class="variable">$it</span>"</span>) <span class="comment">// it指代上下文对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> i = getRandomInt()</span><br></pre></td></tr></table></figure><h1 id="逐个函数讲解"><a href="#逐个函数讲解" class="headerlink" title="逐个函数讲解"></a>逐个函数讲解</h1><h2 id="let"><a href="#let" class="headerlink" title="let"></a>let</h2><p><strong>上下文对象</strong>是<code>it</code>，<strong>返回值</strong>是lambda表达式计算结果（最后一行）。</p><p><code>let</code>可以作为链式调用中的一环来使用。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链式调用</span></span><br><span class="line"><span class="keyword">val</span> numbers = mutableListOf(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>, <span class="string">"four"</span>, <span class="string">"five"</span>)</span><br><span class="line">numbers.map &#123; it.length &#125;.filter &#123; it &gt; <span class="number">3</span> &#125;.let &#123; </span><br><span class="line">    println(it)</span><br><span class="line">    <span class="comment">// and more function calls if needed</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更加精简</span></span><br><span class="line">numbers.map &#123; it.length &#125;.filter &#123; it &gt; <span class="number">3</span> &#125;.let(::println)</span><br></pre></td></tr></table></figure><p><code>let</code>经常用来在非空对象上执行一系列操作。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> str: String? = <span class="string">"Hello"</span>   </span><br><span class="line"><span class="comment">//processNonNullString(str)       // compilation error: str can be null</span></span><br><span class="line"><span class="keyword">val</span> length = str?.let &#123; </span><br><span class="line">    println(<span class="string">"let() called on <span class="variable">$it</span>"</span>)        </span><br><span class="line">    processNonNullString(it)      <span class="comment">// OK: 'it' is not null inside '?.let &#123; &#125;'</span></span><br><span class="line">    it.length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>let</code>另一个用法是为变量<code>it</code>创建别名，以增强代码可阅读性。借助于IDE，通常我们可以看到<code>it</code>指代的是什么对象，对这个用法的需求并非十分强烈。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> numbers = listOf(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>, <span class="string">"four"</span>)</span><br><span class="line"><span class="keyword">val</span> modifiedFirstItem = numbers.first().let &#123; firstItem -&gt;</span><br><span class="line">    println(<span class="string">"The first item of the list is '<span class="variable">$firstItem</span>'"</span>)</span><br><span class="line">    <span class="keyword">if</span> (firstItem.length &gt;= <span class="number">5</span>) firstItem <span class="keyword">else</span> <span class="string">"!"</span> + firstItem + <span class="string">"!"</span></span><br><span class="line">&#125;.toUpperCase()</span><br><span class="line">println(<span class="string">"First item after modifications: '<span class="variable">$modifiedFirstItem</span>'"</span>)</span><br></pre></td></tr></table></figure><h2 id="with"><a href="#with" class="headerlink" title="with"></a>with</h2><p><code>with</code>不是扩展函数，它接收<strong>上下文对象</strong>作为函数参数，在lambda表达式中用<code>this</code>指代，返回结果是lambda表达式的值。</p><p>建议在使用<code>with</code>时不要处理它的返回结果，这样<code>with</code>就可以根据字面含义简单的理解成“在这个对象上进行如下操作”。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> numbers = mutableListOf(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>)</span><br><span class="line">with(numbers) &#123;</span><br><span class="line">    println(<span class="string">"'with' is called with argument <span class="variable">$this</span>"</span>)</span><br><span class="line">    println(<span class="string">"It contains <span class="variable">$size</span> elements"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种用法是创建一个辅助对象，它的属性或者方法可以用来计算出某个值。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> numbers = mutableListOf(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>)</span><br><span class="line"><span class="keyword">val</span> firstAndLast = with(numbers) &#123; <span class="comment">// 相当于声明了一个局部函数</span></span><br><span class="line">    <span class="string">"The first element is <span class="subst">$&#123;first()&#125;</span>,"</span> +</span><br><span class="line">    <span class="string">" the last element is <span class="subst">$&#123;last()&#125;</span>"</span></span><br><span class="line">&#125;</span><br><span class="line">println(firstAndLast)</span><br></pre></td></tr></table></figure><h2 id="run"><a href="#run" class="headerlink" title="run"></a>run</h2><p>使用<code>this</code>指代上下文对象，返回结果是lambda表达式值。</p><p><code>run</code>在含义上与<code>with</code>一致，在调用方式上与<code>let</code>一致。当需要进行对象初始化、并同时要返回一个计算结果时，应当使用<code>run</code>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> service = MultiportService(<span class="string">"https://example.kotlinlang.org"</span>, <span class="number">80</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> result = service.run &#123;</span><br><span class="line">    port = <span class="number">8080</span></span><br><span class="line">    query(prepareRequest() + <span class="string">" to port <span class="variable">$port</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the same code written with let() function:</span></span><br><span class="line"><span class="keyword">val</span> letResult = service.let &#123;</span><br><span class="line">    it.port = <span class="number">8080</span></span><br><span class="line">    it.query(it.prepareRequest() + <span class="string">" to port <span class="subst">$&#123;it.port&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了在接收者对象上调用以外，<code>run</code>还可以让我们在需要一个表达式的地方传入一个代码块（这种用法略复杂）。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> hexNumberRegex = run &#123;</span><br><span class="line">    <span class="keyword">val</span> digits = <span class="string">"0-9"</span></span><br><span class="line">    <span class="keyword">val</span> hexDigits = <span class="string">"A-Fa-f"</span></span><br><span class="line">    <span class="keyword">val</span> sign = <span class="string">"+-"</span></span><br><span class="line"></span><br><span class="line">    Regex(<span class="string">"[<span class="variable">$sign</span>]?[<span class="variable">$digits</span><span class="variable">$hexDigits</span>]+"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (match <span class="keyword">in</span> hexNumberRegex.findAll(<span class="string">"+1234 -FFFF not-a-number"</span>)) &#123; <span class="comment">// findAll正则匹配</span></span><br><span class="line">    println(match.value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * output: </span></span><br><span class="line"><span class="comment"> * +1234</span></span><br><span class="line"><span class="comment"> * -FFFF</span></span><br><span class="line"><span class="comment"> * -a</span></span><br><span class="line"><span class="comment"> * be</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><p>使用<code>this</code>指代上下文对象，返回值是上下文对象本身。</p><p><code>apply</code>适用的场景是不需要返回值，且主要是操作对象成员的过程。常见的就是对象配置，“在对象上进行如下操作”。</p><p><code>apply</code>可以很容易地变成链式操作。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> adam = Person(<span class="string">"Adam"</span>).apply &#123;</span><br><span class="line">    age = <span class="number">32</span></span><br><span class="line">    city = <span class="string">"London"</span>        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="also"><a href="#also" class="headerlink" title="also"></a>also</h2><p>使用<code>it</code>指代上下文对象，返回值是上下文对象本身。</p><p><code>also</code>的使用场景是将对象作为一系列操作的参数，在这些操作中<strong>不应该对参数产生副作用</strong>，因此你可以在一个链式调用中很方便地加上<code>also</code>，或者从链式调用中把<code>also</code>摘掉，且不影响原有逻辑。</p><p>当你在代码中看到<code>also</code>时，可以将其理解为“还需要做这些事情”。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> numbers = mutableListOf(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>)</span><br><span class="line">numbers</span><br><span class="line">    .also &#123; println(<span class="string">"The list elements before adding new one: <span class="variable">$it</span>"</span>) &#125;</span><br><span class="line">    .add(<span class="string">"four"</span>)</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>用一张表格列出函数的对象引用与返回值。</p><table><thead><tr><th>Function</th><th>Object reference</th><th>Return value</th><th>Is extension function</th></tr></thead><tbody><tr><td>let</td><td>it</td><td>Lambda result</td><td>Yes</td></tr><tr><td>run</td><td>it</td><td>Lambda result</td><td>Yes</td></tr><tr><td>run</td><td>-</td><td>Lambda result</td><td>No: called without the context object</td></tr><tr><td>with</td><td>this</td><td>Lambda result</td><td>No: takes the context object as an argument</td></tr><tr><td>apply</td><td>this</td><td>Context object</td><td>Yes</td></tr><tr><td>also</td><td>it</td><td>Context object</td><td>Yes</td></tr></tbody></table><p>一个简单的函数选用指南如下，它们的应用场景有重叠的部分，使用时应当具体情况具体分析。</p><ul><li>在非空对象上调用lambda表达式：<code>let</code></li><li>在域内将表达式抽象成一个变量：<code>let</code></li><li>对象配置：<code>apply</code></li><li>对象配置并计算结果：<code>run</code></li><li>执行一系列表达式，非扩展函数：<code>run</code></li><li>附加效果：<code>also</code></li><li>将对于某个对象的函数调用组合：<code>with</code></li></ul><p>尽管作用域函数功能强大，在使用时应当谨慎，避免出错，尤其是嵌套的情况应当越少越好；当你在写链式调用时，一定要小心分辨当前的上下文对象。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://kotlinlang.org/docs/reference/scope-functions.html" target="_blank" rel="noopener">官方文档</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;并非意志坚强就可以无所不能，人世不是那么单纯的。老实说，我甚至觉得每天坚持跑步同意志强弱并没有太大关联。我能够坚持跑二十年，恐怕还是因为合乎我的性情，至少“不觉得那么痛苦”。人生来如此，喜欢的事自然可以坚持下去，不喜欢的事怎么也坚持不了。 ——&lt;s
      
    
    </summary>
    
    
      <category term="Android" scheme="https://lilei.pro/tags/Android/"/>
    
      <category term="Kotlin" scheme="https://lilei.pro/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>移动设备ID那些事</title>
    <link href="https://lilei.pro/2019/10/12/unique-device-id/"/>
    <id>https://lilei.pro/2019/10/12/unique-device-id/</id>
    <published>2019-10-11T16:09:06.000Z</published>
    <updated>2019-10-11T16:22:48.854Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么需要设备ID"><a href="#为什么需要设备ID" class="headerlink" title="为什么需要设备ID"></a>为什么需要设备ID</h2><p>“设备ID”即用于标识设备唯一身份的ID，即 Unique Device Identifier。基于以下原因，我们经常需要处理设备ID相关功能：</p><ol><li>统计需求。DAU，MAU，转化率，用户行为等统计。</li><li>业务需求。个性化推荐，日志收集，灰度发布，AB Test等业务侧需求。</li><li>风控需求。防刷单，反作弊等。</li></ol><h2 id="设备ID的特征"><a href="#设备ID的特征" class="headerlink" title="设备ID的特征"></a>设备ID的特征</h2><p>为了满足以上需求，一个良好的设备ID方案应当具有“唯一性”和“稳定性”两个特征。</p><ul><li>唯一性：系统中的任意两台设备，它们的设备ID应当不同。</li><li>稳定性：同一台设备在重启、清空应用数据、卸载应用重装、系统升级、Android 版本升级、刷机等情况下，设备ID应当保持不变。</li></ul><p>遗憾的是，Android 平台并没有稳定的API可以提供具有上面两点特征的ID。</p><h2 id="可选方案及限制"><a href="#可选方案及限制" class="headerlink" title="可选方案及限制"></a>可选方案及限制</h2><p>关于Android设备ID，常见的方案有IMEI、MAC地址、Serial、AndroidID等，下面逐一介绍它们是什么，以及为何无法承担唯一ID的职责。</p><h3 id="IMEI"><a href="#IMEI" class="headerlink" title="IMEI"></a>IMEI</h3><p>是 <strong>国际设备识别码（Imternational Mobile Equipment Identity）</strong> 的缩写，即通常所说的手机串号，用于在移动电话网络中识别每一部独立的手机等移动通信设备，共15~17位数字。在拨号键盘输入<code>*#06#</code>即可查看。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取IMEI的样例代码，需要 READ_PHONE_STATE 权限</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getIMEI</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">val</span> tm = getSystemService(Context.TELEPHONY_SERVICE) <span class="keyword">as</span> TelephonyManager</span><br><span class="line">    <span class="keyword">return</span> tm.deviceId</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在早些时候，IMEI是很多应用采取的设备ID方案，因为它读取方便，且同时具备唯一性和稳定性的特征。然而自从Android 6开始，<code>READ_PHONE_STATE</code>被列入<code>dangerous</code>的保护级别，意味着我们不仅要在<code>AndroidManifest.xml</code>文件里申请，还应当在应用到这个权限之前动态申请。尤其在中文的安卓系统上，弹窗里的文字提示是“申请电话设备信息”，很容易让人误以为这是要获取电话号码、短信内容等敏感信息。</p><p>如果说Android 6只是提高了使用IMEI作为设备ID的门槛，Android 10则是完全堵死了这条路。在Android 10的系统里，即使申请了<code>READ_PHONE_STATE</code>权限，也无法获取IMEI，会抛出<code>SecurityException</code>异常或者返回null。</p><h3 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h3><p>MAC地址（Media Access Control Address），用于标识可上网设备的唯一地址，设备有几张网卡，就会有几个MAC地址。在OSI七层模型中，MAC地址位于第二层数据链路层。看到这里你也许以为MAC地址是作为设备ID解决方案的最佳选择，实则不然，首先，MAC地址的获取方法历经多次修改，足见Google正欲收紧MAC地址权限，以后完全堵死也并非不可能。</p><p>在 (?, 6.0)，[6.0, 7.0)，[7.0, ?) 三种不同的Android版本下，有着不同的获取MAC地址方式，可以参考简书这篇文章 <a href="https://www.jianshu.com/p/16d4ff4c4cbe" target="_blank" rel="noopener">《Android 版本兼容 — Android 6.0 和 7.0后获取Mac地址》</a>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取MAC地址，适用于目前Android全版本，不保证以后继续适用（很大可能不再适用）</span></span><br><span class="line"><span class="comment">// 需要 android.permission.INTERNET 权限，为非dangerous权限，可以在AndroidManifst.xml中直接申请</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getMAC</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> enumeration = getNetworkInterfaces() ?: <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        <span class="keyword">while</span> (enumeration.hasMoreElements()) &#123;</span><br><span class="line">            <span class="keyword">val</span> netInterface = enumeration.nextElement()</span><br><span class="line">            <span class="keyword">if</span> (netInterface.name == <span class="string">"wlan0"</span>) &#123;</span><br><span class="line">                <span class="keyword">val</span> addr = netInterface.hardwareAddress</span><br><span class="line">                <span class="keyword">val</span> result = StringBuilder()</span><br><span class="line">                <span class="keyword">for</span> (b <span class="keyword">in</span> addr) &#123;</span><br><span class="line">                    result.append(String.format(<span class="string">"%02X:"</span>, b))</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (result.isNotEmpty()) &#123;</span><br><span class="line">                    result.deleteCharAt(result.length - <span class="number">1</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result.toString()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        Log.e(<span class="string">"tag"</span>, e.message, e)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h3><p>何为Serial？Serial即“设备序列号”，是设备厂商提供的设备唯一串号，唯一性由各厂商保证。拿vivo举例，它会保证自己生产的每一台设备序列号都是不同的，但是不是与OPPO的也不一样呢？这就无法保证了。一个方案是用<code>厂商ID_设备型号_序列号</code>拼接起来，作为设备ID，这样可以避免不同厂商设备具有相同Serial的问题。但是，并非所有厂商都会严格按照这个规定来做。我曾经在RK3399的开发板上做过开发，试过很多张板子，它们的Serial都是0123456789，让人哭笑不得。</p><p>更糟糕的是，Android 10又堵死了获取Serial的路，会直接抛出<code>SecurityException</code>，除非应用是系统签名且具备<code>android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE</code>权限。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取Serial，需要 READ_PHONE_STATE 权限</span></span><br><span class="line"><span class="comment">// Android 10 异常 </span></span><br><span class="line"><span class="comment">// java.lang.SecurityException: getSerial: The user 10236 does not meet the requirements to access device identifiers.</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getSerial</span><span class="params">()</span></span> = android.os.Build.getSerial()</span><br></pre></td></tr></table></figure><h3 id="AndroidID"><a href="#AndroidID" class="headerlink" title="AndroidID"></a>AndroidID</h3><p>AndroidID是SDK提供的获取ID方法，它不需要申明任何权限，具有64bit的取值范围，且唯一性也还不错。但是，它最大的硬伤在于无法满足稳定性：</p><ul><li>刷机、root、恢复出厂设置后都会变化</li><li>对安装在8.0系统的应用来说，AndroidID取决于应用签名+设备两者的组合</li><li>在8.0之前安装的应用，如果在系统升级到8.0后，卸载重装该应用，读取到的AndroidID会变化</li></ul><p>由于以上原因，在一些要求不严格的场景中，可以采用AndroidID作为设备ID，比如记录激活数、曝光数据等。但是在严格的场景中就不能用AndroidID了，如以设备ID标识用户身份，提供相应服务的场景。</p><p>读取AndroidID的样例代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取AndroidID，不需要额外申请任何权限</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getAndroidID</span><span class="params">()</span></span> = Settings.Secure.getString(contentResolver, Settings.Secure.ANDROID_ID)</span><br></pre></td></tr></table></figure><h2 id="可选方案总结"><a href="#可选方案总结" class="headerlink" title="可选方案总结"></a>可选方案总结</h2><p>用一张表格总结上述方案：</p><table><thead><tr><th>方案</th><th>概述</th><th>限制</th></tr></thead><tbody><tr><td>IMEI</td><td>具备唯一性和稳定性，过去的最佳选择</td><td>Android10堵死，无法获取</td></tr><tr><td>MAC</td><td>网卡地址，唯一且稳定</td><td>权限逐渐收紧，未来极有可能关闭</td></tr><tr><td>Serial</td><td>手机厂商提供的设备序列号</td><td>不保证唯一性，Android10堵死</td></tr><tr><td>AndroidID</td><td>Android SDK 提供，不需要申请权限，唯一性较好</td><td>不具备稳定性</td></tr></tbody></table><h2 id="设计一个新方案"><a href="#设计一个新方案" class="headerlink" title="设计一个新方案"></a>设计一个新方案</h2><p>上述四个方案里，没有哪一个是解决设备ID问题的终极武器（银弹），只有各种方法综合运用，才是解决之道。下面提出一种设备ID方案，综合使用多个硬件ID，借助服务器生成唯一虚拟设备ID（VDID），可以最大限度地保证唯一性和稳定性。</p><h3 id="稳定性：拜占庭容错"><a href="#稳定性：拜占庭容错" class="headerlink" title="稳定性：拜占庭容错"></a>稳定性：拜占庭容错</h3><p>稳定性要求当获取不到某种ID，或者某种ID发生变化时，系统能够辨识出这个设备。借助“拜占庭容错”可以解决稳定性的问题。</p><p>拜占庭容错机制源于古老 <strong>拜占庭将军（Byzantine failures）</strong> 问题。用简单的语言解释： <strong>如果系统中有n个故障节点，系统要想正确运行，必须至少要有2n+1个正常节点。</strong> 。但对于Android设备ID，我们采用弱化的拜占庭容错机制，即客户端每次上传4个ID（IMEI、MAC、Serial、AndroidID），服务器根据这4个ID生成一个随机的唯一ID即VDID。后续客户端再请求时，可以使用VDID，或者再次使用4个ID，由服务器拿这4个ID在数据库中进行查找VDID，若找到则返回，若未找到，再使用4个ID中的3个进行查找，3个不行则用2个，以此类推。</p><h3 id="获取VDID的时序图"><a href="#获取VDID的时序图" class="headerlink" title="获取VDID的时序图"></a>获取VDID的时序图</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/20191012_unique_device_id/vdid_sequence.png" alt="vdid_sequence" title="">                </div>                <div class="image-caption">vdid_sequence</div>            </figure><h3 id="唯一性：VDID的生成方式与取值范围"><a href="#唯一性：VDID的生成方式与取值范围" class="headerlink" title="唯一性：VDID的生成方式与取值范围"></a>唯一性：VDID的生成方式与取值范围</h3><p>要实现VDID的唯一性，有两种方案可以考虑：</p><h4 id="方案一：自增主键ID"><a href="#方案一：自增主键ID" class="headerlink" title="方案一：自增主键ID"></a>方案一：自增主键ID</h4><p>自增、分步自增、分段构造、Redis分布式ID等方法，可以保证唯一性。但是在传输此类ID时，应当进行hash操作，且保证hash后的ID不可碰撞。</p><p>自增ID的优点是可作为索引，检索速度快；缺点是生成规则存在被破解的风险。</p><h4 id="方案二：随机生成ID"><a href="#方案二：随机生成ID" class="headerlink" title="方案二：随机生成ID"></a>方案二：随机生成ID</h4><p>这是另一种生成唯一ID的方法，当位数足够多时，可以认为碰撞概率趋近于0。首先看一下这张表，它描述了随机数位数与发生碰撞的概率。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/20191012_unique_device_id/random_collision.png" alt="random_collision" title="">                </div>                <div class="image-caption">random_collision</div>            </figure><p>假设我们应用的活跃用户数为20,000,000，即两千万。可以看到至少要有128Bits，才能在2*10^7（两千万）的数量级有极小的碰撞概率，符合我们的业务需求。</p><p>随机ID的优点是具有隐蔽性，缺点是检索效率一般。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>本文是笔者阅读郭霖公众号推文<a href="https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650247428&amp;idx=1&amp;sn=9d52f7b3262622f9ad25af8af167fcd8&amp;chksm=8863606bbf14e97deb5ecd030ff02ee76f6d320f1c0f586034e442903d00ff79dd7fc5bb3d91&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1570535190224&amp;sharer_shareid=50472349a2a49142535b8b535dc7dac9&amp;key=042d6afab53eaf2ecfd1c244abe072a53b13e46580bd8c41a7ed57b6b5f3360221dd5c5a4ea8dc0fcde4b6632ba630de39d070bbd64a7e4f24155cec02abb5dc1e36d0ecbc6e250d6f3f87c039ad1407&amp;ascene=1&amp;uin=OTUwMTI1NjEw&amp;devicetype=Windows+10&amp;version=62060833&amp;lang=zh_CN&amp;pass_ticket=hOoinQFE6HGs3U8dFKy9YsMWbVerXZqDJCY6dO0Rh4aIO4VWSduOo5tRbTZkwcN3" target="_blank" rel="noopener">《漫谈设备唯一ID的那些秘密》</a>后的总结归纳，此处向原作者@呼啸长风致谢。然而作者原文中有一处纰漏，设备序列号（SERIAL）在Android 10上基本是无法获取的，这也会影响原作者提出的解决方案。笔者已经在Github上对此提了<a href="https://github.com/No89757/Udid/issues/1" target="_blank" rel="noopener">issue</a>。</p><p>出于对用户隐私的保护，Google一直试图收紧的设备ID的获取权限。而由于“账户”的概念在国内市场并不普遍，再加上各大OEM碎片化严重，国内的各种业务不得不依赖于设备ID进行展开。这也是开发者近年来不得不面对的问题，希望未来国内的Android生态可以更加统一，也希望Google也对此类需求提供更好的权限方案，能让开发者可以不必为此头痛。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么需要设备ID&quot;&gt;&lt;a href=&quot;#为什么需要设备ID&quot; class=&quot;headerlink&quot; title=&quot;为什么需要设备ID&quot;&gt;&lt;/a&gt;为什么需要设备ID&lt;/h2&gt;&lt;p&gt;“设备ID”即用于标识设备唯一身份的ID，即 Unique Device Ident
      
    
    </summary>
    
    
      <category term="Android" scheme="https://lilei.pro/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Flash Boys 读书笔记</title>
    <link href="https://lilei.pro/2019/10/11/flash-boys/"/>
    <id>https://lilei.pro/2019/10/11/flash-boys/</id>
    <published>2019-10-11T15:55:18.000Z</published>
    <updated>2019-10-11T15:56:49.115Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言-背景与动机"><a href="#前言-背景与动机" class="headerlink" title="前言-背景与动机"></a>前言-背景与动机</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/191011_flashboys/cover.jpg" alt="cover" title="">                </div>                <div class="image-caption">cover</div>            </figure><p>Flash Boys，中译《高频交易员》，是金融畅销书作家迈克尔刘易斯 2015 年的作品，作者之前出版过《大空头》、《说谎者的扑克牌》等华尔街领域的流行作品。在这本书中，刘易斯借助“胜山”的角色，讲解了一些 HFT 的基础知识，可以给我等小白用来入门 HFT。</p><p>书的前 2/3 值得细读，后 1/3 基本上都是给 IEX 做广告，一扫而过即可。</p><h2 id="定义：何为-HFT（高频交易）"><a href="#定义：何为-HFT（高频交易）" class="headerlink" title="定义：何为 HFT（高频交易）"></a>定义：何为 HFT（高频交易）</h2><p>短线交易是经典力学，研究对象为每个周期的成交价格，最短 6 秒。</p><p>高频交易是量子力学，6秒内可以发生上百次交易，最终成交价只是最后一笔订单的价格。</p><p>交易所保留数据的频度是秒，二市场中高频交易主体的数据频度是纳秒级，1秒=10亿纳秒。</p><p><strong>高频交易（High-Frequency Trading）</strong>是投资银行、对冲基金和专业交易公司等利用高速计算机进行程序化证券交易的投资策略的总称，主要包括以下几种策略：</p><ul><li>流动性回扣交易（Liquidity Rebate Trading）</li><li>猎物算法交易（Predatory Algorithmic Trading）</li><li>自动做市商交易（Automated Market Maker Trading, AMMs）</li><li>闪电订单（Flash Order）</li><li>暗池（Dark Pool）</li></ul><h2 id="理解：高频交易何以赚钱"><a href="#理解：高频交易何以赚钱" class="headerlink" title="理解：高频交易何以赚钱"></a>理解：高频交易何以赚钱</h2><p>假设某支股票价格在400~500元之间波动，股民老王下了一个单：当股票价格低于450元时，买入100股。当这个订单在交易所之间传递时（美国有十几家交易所，纽交所、纳斯达克是其中最耳熟能详的），需要几十毫秒的延迟时间，高频交易员就是在这几十毫秒里做文章。</p><p>当股民老王的订单从交易所A传递给交易所B时，借助于高速网络，高频交易员先于交易所B得到这个信息，即“有一个订单是当股票价格低于450元时买100股”，此时如果交易所B的股票价格低于450，比如说是440，交易员就会买入它，再转手以450元的价格履行刚才得到的订单。在这笔交易中，高频交易员获利1000元，股民老王也以预期的450元价格购入了目标股票。</p><blockquote><p>2013年年初，最大的高频交易公司之一Virtu Financial公开称，在其5年半的交易中心仅有一天没有赚到钱，那一天还是因为出现了“人为误差”。</p></blockquote><p>一个高频交易公司可以在市场上疯狂交易而不带来任何附加价值，而且可以不承担任何风险，当它买入时，它知道有确切的卖家，当它卖出时，它知道肯定有人买。在每个交易日结束时，它在任何市场都完全不持有头寸。</p><p>高频交易公司每天闭市时都是平仓的，他们作为买卖双方桥梁的时间极短，以至于根本没有人知道其存在。</p><h2 id="高频交易的分类"><a href="#高频交易的分类" class="headerlink" title="高频交易的分类"></a>高频交易的分类</h2><h3 id="电子抢先交易（electronic-frontrunning）"><a href="#电子抢先交易（electronic-frontrunning）" class="headerlink" title="电子抢先交易（electronic frontrunning）"></a>电子抢先交易（electronic frontrunning）</h3><p>在一个地方探知投资者的交易信息后，在另一个地方抢在投资者之前通过一系列订单推高或拉低价格，并从中获利</p><h3 id="回扣套利（rebate-arbitrage）"><a href="#回扣套利（rebate-arbitrage）" class="headerlink" title="回扣套利（rebate arbitrage）"></a>回扣套利（rebate arbitrage）</h3><p>交易所通常会为创造流动性的券商提供一定的交易费用回扣，高频交易者利用速度优势创造虚假流动性，骗取交易所的回扣</p><h3 id="慢市场套利（slow-market-arbitrage）"><a href="#慢市场套利（slow-market-arbitrage）" class="headerlink" title="慢市场套利（slow market arbitrage）"></a>慢市场套利（slow market arbitrage）</h3><p>高频交易者在一个交易所探知到股票价格变动之后，再利用速度优势在另一个交易所反应过来之前进行买卖操作。这可能是使用最广的</p><h2 id="疑问：赢家拿走一切"><a href="#疑问：赢家拿走一切" class="headerlink" title="疑问：赢家拿走一切"></a>疑问：赢家拿走一切</h2><p>在高频交易的战场上，是否意味着“赢家拿走一切”？如果甲的算法/线路比乙快10%，最终甲会获取所有的订单并完成交易，乙一分钱都拿不到？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言-背景与动机&quot;&gt;&lt;a href=&quot;#前言-背景与动机&quot; class=&quot;headerlink&quot; title=&quot;前言-背景与动机&quot;&gt;&lt;/a&gt;前言-背景与动机&lt;/h2&gt;&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;di
      
    
    </summary>
    
    
      <category term="高频交易" scheme="https://lilei.pro/tags/%E9%AB%98%E9%A2%91%E4%BA%A4%E6%98%93/"/>
    
  </entry>
  
  <entry>
    <title>架构学习之 master-v2</title>
    <link href="https://lilei.pro/2019/10/11/architecture-master-v2/"/>
    <id>https://lilei.pro/2019/10/11/architecture-master-v2/</id>
    <published>2019-10-11T15:50:24.000Z</published>
    <updated>2019-10-11T15:54:24.831Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Move stones, not mountains.</p></blockquote><p>Google 官方的 <a href="https://github.com/googlesamples/android-architecture" target="_blank" rel="noopener">Android Architecture Blueprints</a> 推出了 v2 版本，相比于之前的 v1 版本，v2 采取了更先进的设计思想与组件：</p><ul><li>采用 Kotlin Coroutines 处理后台操作</li><li>单一 Activity 结构，用 <a href="https://developer.android.com/guide/navigation/navigation-getting-started" target="_blank" rel="noopener">Navigation component</a> 处理Fragment 之间跳转</li><li>由 Fragment(View) 和 ViewModel 组成的 Presentation 层，即 <strong>MVVM</strong> 模式</li><li>基于 LiveData 和 DataBinding 的响应式（Reactive）UI</li><li>data 层使用一个 Repository 和两个 Datasource（本地数据、远端数据），采用直观的调用方式（非回调、非 data stream）</li><li>两个 product flavor，分别是<code>mock</code>和<code>prod</code>，对应着测试与开发环境</li><li>一系列单元测试、集成测试以及端到端测试</li></ul><p>接下来从源码角度解析 master 分支工程，看看 v2 究竟可以为我们带来什么便利。</p><hr><h2 id="程序入口"><a href="#程序入口" class="headerlink" title="程序入口"></a>程序入口</h2><p>入口在<code>TasksActivity.java</code>，注意到这是一个“SPA”，即 Single Page Application，在<code>AndroidManifest.xml</code>中只声明了这一个 Activity。<code>TasksActivity</code>实际上只是一个壳页面，只处理了 Navigation、ActionBar、NavigationDrawer 等基础功能。它在<code>onCreate</code>里进行这些初始化：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> drawerLayout: DrawerLayout</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> appBarConfiguration: AppBarConfiguration</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">    setContentView(R.layout.tasks_act)</span><br><span class="line">    setupNavigationDrawer()</span><br><span class="line">    setSupportActionBar(findViewById(R.id.toolbar))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> navController: NavController = findNavController(R.id.nav_host_fragment)</span><br><span class="line">    appBarConfiguration =</span><br><span class="line">        AppBarConfiguration.Builder(R.id.tasks_fragment_dest, R.id.statistics_fragment_dest)</span><br><span class="line">            .setDrawerLayout(drawerLayout)</span><br><span class="line">            .build()</span><br><span class="line">    setupActionBarWithNavController(navController, appBarConfiguration)</span><br><span class="line">    findViewById&lt;NavigationView&gt;(R.id.nav_view)</span><br><span class="line">        .setupWithNavController(navController)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该应用采用 Navigation component 管理页面跳转，跳转关系在<code>nav_graph.xml</code>文件中以可视化的方式呈现。我们这里不需要关心跳转组件的具体用法， 只要知道它可以启动我们要分析的<code>TasksFragment</code>就可以了。</p><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p>我习惯从数据开始分析代码走向，看一下<code>data</code>目录的结构：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">λ tree data</span><br><span class="line">data</span><br><span class="line">|-- Result.kt</span><br><span class="line">|-- Task.kt</span><br><span class="line">`-- <span class="built_in">source</span></span><br><span class="line">    |-- DefaultTasksRepository.kt</span><br><span class="line">    |-- TasksDataSource.kt</span><br><span class="line">    |-- TasksRepository.kt</span><br><span class="line">    `-- <span class="built_in">local</span></span><br><span class="line">        |-- TasksDao.kt</span><br><span class="line">        |-- TasksLocalDataSource.kt</span><br><span class="line">        `-- ToDoDatabase.kt</span><br></pre></td></tr></table></figure><h3 id="Result-kt-与-Task-kt"><a href="#Result-kt-与-Task-kt" class="headerlink" title="Result.kt 与 Task.kt"></a>Result.kt 与 Task.kt</h3><p><code>Result.kt</code>是一个数据请求的结果封装类，业务层对数据的请求均是通过 Result 对象进行封装。这个类使用到了多个 Kotlin 特性，容我在注释里一一说明。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">Result</span>&lt;<span class="type">out R</span>&gt; </span>&#123; <span class="comment">// 密封类，将继承限制在类内部；out 类型，协变，保留子类型化关系</span></span><br><span class="line">    <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Success</span>&lt;<span class="type">out T</span>&gt;</span>(<span class="keyword">val</span> <span class="keyword">data</span>: T) : Result&lt;T&gt;() <span class="comment">// data 类，协变类型T可以用作构造参数</span></span><br><span class="line">    <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Error</span></span>(<span class="keyword">val</span> exception: Exception) : Result&lt;<span class="built_in">Nothing</span>&gt;() <span class="comment">// Nothing类型，永不返回</span></span><br><span class="line">    <span class="keyword">object</span> Loading : Result&lt;<span class="built_in">Nothing</span>&gt;() <span class="comment">// object直接创建对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">when</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">is</span> Success&lt;*&gt; -&gt; <span class="string">"Success[data=<span class="variable">$data</span>]"</span> <span class="comment">// *表示不关心具体类型</span></span><br><span class="line">            <span class="keyword">is</span> Error -&gt; <span class="string">"Error[exception=<span class="variable">$exception</span>]"</span></span><br><span class="line">            Loading -&gt; <span class="string">"Loading"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * `true` if [Result] is of type [Success] &amp; holds non-null [Success.data].</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">val</span> Result&lt;*&gt;.succeeded <span class="comment">// 扩展属性，注意命名不是isSuccess（Chinglish）</span></span><br><span class="line">  <span class="keyword">get</span>() = <span class="keyword">this</span> <span class="keyword">is</span> Success &amp;&amp; <span class="keyword">data</span> != <span class="literal">null</span></span><br></pre></td></tr></table></figure><p><code>Task.kt</code>描述了任务对象，由<code>title</code>、<code>description</code>、<code>completed</code>和<code>id</code>四个字段构成，同时借助 Room 组件自动关联到名为<strong>tasks</strong>的数据表。</p><h3 id="数据接口：TasksDataSource-kt-与-TasksRepository-kt"><a href="#数据接口：TasksDataSource-kt-与-TasksRepository-kt" class="headerlink" title="数据接口：TasksDataSource.kt 与 TasksRepository.kt"></a>数据接口：TasksDataSource.kt 与 TasksRepository.kt</h3><p><code>TasksDataSource.kt</code>和<code>TasksRepository.kt</code>是两个接口类，内容十分相似：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TasksDataSource.kt</span></span><br><span class="line"><span class="comment">// Main entry point for accessing tasks data.</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">TasksDataSource</span> </span>&#123;</span><br><span class="line">    suspend <span class="function"><span class="keyword">fun</span> <span class="title">getTasks</span><span class="params">()</span></span>: Result&lt;List&lt;Task&gt;&gt;</span><br><span class="line">    suspend <span class="function"><span class="keyword">fun</span> <span class="title">getTask</span><span class="params">(taskId: <span class="type">String</span>)</span></span>: Result&lt;Task&gt;</span><br><span class="line">    suspend <span class="function"><span class="keyword">fun</span> <span class="title">saveTask</span><span class="params">(task: <span class="type">Task</span>)</span></span></span><br><span class="line">    suspend <span class="function"><span class="keyword">fun</span> <span class="title">completeTask</span><span class="params">(task: <span class="type">Task</span>)</span></span></span><br><span class="line">    suspend <span class="function"><span class="keyword">fun</span> <span class="title">completeTask</span><span class="params">(taskId: <span class="type">String</span>)</span></span></span><br><span class="line">    suspend <span class="function"><span class="keyword">fun</span> <span class="title">activateTask</span><span class="params">(task: <span class="type">Task</span>)</span></span></span><br><span class="line">    suspend <span class="function"><span class="keyword">fun</span> <span class="title">activateTask</span><span class="params">(taskId: <span class="type">String</span>)</span></span></span><br><span class="line">    suspend <span class="function"><span class="keyword">fun</span> <span class="title">clearCompletedTasks</span><span class="params">()</span></span></span><br><span class="line">    suspend <span class="function"><span class="keyword">fun</span> <span class="title">deleteAllTasks</span><span class="params">()</span></span></span><br><span class="line">    suspend <span class="function"><span class="keyword">fun</span> <span class="title">deleteTask</span><span class="params">(taskId: <span class="type">String</span>)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TasksRepository.kt</span></span><br><span class="line"><span class="comment">// Interface to the data layer.</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">TasksRepository</span> </span>&#123;</span><br><span class="line">    suspend <span class="function"><span class="keyword">fun</span> <span class="title">getTasks</span><span class="params">(forceUpdate: <span class="type">Boolean</span> = <span class="literal">false</span>)</span></span>: Result&lt;List&lt;Task&gt;&gt;</span><br><span class="line">    suspend <span class="function"><span class="keyword">fun</span> <span class="title">getTask</span><span class="params">(taskId: <span class="type">String</span>, forceUpdate: <span class="type">Boolean</span> = <span class="literal">false</span>)</span></span>: Result&lt;Task&gt;</span><br><span class="line">    suspend <span class="function"><span class="keyword">fun</span> <span class="title">saveTask</span><span class="params">(task: <span class="type">Task</span>)</span></span></span><br><span class="line">    suspend <span class="function"><span class="keyword">fun</span> <span class="title">completeTask</span><span class="params">(task: <span class="type">Task</span>)</span></span></span><br><span class="line">    suspend <span class="function"><span class="keyword">fun</span> <span class="title">completeTask</span><span class="params">(taskId: <span class="type">String</span>)</span></span></span><br><span class="line">    suspend <span class="function"><span class="keyword">fun</span> <span class="title">activateTask</span><span class="params">(task: <span class="type">Task</span>)</span></span></span><br><span class="line">    suspend <span class="function"><span class="keyword">fun</span> <span class="title">activateTask</span><span class="params">(taskId: <span class="type">String</span>)</span></span></span><br><span class="line">    suspend <span class="function"><span class="keyword">fun</span> <span class="title">clearCompletedTasks</span><span class="params">()</span></span></span><br><span class="line">    suspend <span class="function"><span class="keyword">fun</span> <span class="title">deleteAllTasks</span><span class="params">()</span></span></span><br><span class="line">    suspend <span class="function"><span class="keyword">fun</span> <span class="title">deleteTask</span><span class="params">(taskId: <span class="type">String</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到两者的方法几乎是一样的：名字和数量相同，区别仅仅在于<code>TasksRepository</code>中的个别方法多了<code>forceUpdate</code>参数。不过，这两个接口在语义上是不同的。</p><ul><li><code>TasksDatasource</code>是底层数据封装，数据可能来自网络，也可能来自于文件、数据库。</li><li><code>TasksRepository</code>是数据层对外的接口，业务代码通过该接口对数据进行增删改查。<code>forceUpdate</code>参数作用于接口实现类内部的缓存。</li><li><code>suspend</code>关键字说明它们均为 Coroutines 接口。</li></ul><p>然后我们来看下对外的接口是如何给到使用者的。<code>TodoApplication</code>类继承自<code>Application</code>，其中有一个成员变量<code>taskRepository</code>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TodoApplication.kt</span></span><br><span class="line"><span class="keyword">val</span> taskRepository: TasksRepository</span><br><span class="line">    <span class="keyword">get</span>() = ServiceLocator.provideTasksRepository(<span class="keyword">this</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment">// ServiceLocator.kt</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">provideTasksRepository</span><span class="params">(context: <span class="type">Context</span>)</span></span>: TasksRepository &#123;</span><br><span class="line">    synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> tasksRepository ?: tasksRepository ?: createTasksRepository(context)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">createTasksRepository</span><span class="params">(context: <span class="type">Context</span>)</span></span>: TasksRepository &#123;</span><br><span class="line">    <span class="keyword">return</span> DefaultTasksRepository(FakeTasksRemoteDataSource, createTaskLocalDataSource(context))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// TodoApplication.taskRepository 通过 Fragment 的扩展方法给到各个 Fragment</span></span><br><span class="line"><span class="comment">// FragmentExt.kt</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Fragment.<span class="title">getViewModelFactory</span><span class="params">()</span></span>: ViewModelFactory &#123;</span><br><span class="line">  <span class="keyword">val</span> repository = (requireContext().applicationContext <span class="keyword">as</span> TodoApplication).taskRepository</span><br><span class="line">  <span class="keyword">return</span> ViewModelFactory(repository)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="local-目录：本地数据实现"><a href="#local-目录：本地数据实现" class="headerlink" title="local 目录：本地数据实现"></a>local 目录：本地数据实现</h3><p>local 目录下是<code>TasksDatasource</code>的本地实现，与此相对的，若数据来源于网络，则还应当有一个 remote 目录。</p><ul><li><code>ToDoDatabase</code> 是数据库声明</li><li><code>TasksDao</code> 声明 tasks 表的 CRUD 操作</li><li><code>TasksLocalDataSource</code> 是<code>TasksDataSource</code>的本地实现，使用<code>Dispatchers.IO</code>作为协程上下文，调用<code>TasksDao</code>完成数据操作</li></ul><h3 id="数据层总结"><a href="#数据层总结" class="headerlink" title="数据层总结"></a>数据层总结</h3><p>相比于曾经分析过的<strong>todo-mvp</strong>和<strong>todo-mvp-clean</strong>，最直观的感受是，v2在保证数据接口语义不变的前提下，借助 Coroutines 简化了原有的回调写法，用同步的方式写异步的代码。此外，像使用 Room 做 ORM、local/remote 两套数据实现等，与之前的项目并无不同。</p><hr><h2 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h2><h3 id="背景知识：ViewModel-与-LiveData"><a href="#背景知识：ViewModel-与-LiveData" class="headerlink" title="背景知识：ViewModel 与 LiveData"></a>背景知识：ViewModel 与 LiveData</h3><p>ViewModel 与 LiveData 都是 Android Jetpack 中的架构组件，它们通常组合使用，达到将数据和视图解耦的目的。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/191011_architecture_master_v2/jetpack.png" alt="jetpack" title="">                </div>                <div class="image-caption">jetpack</div>            </figure><p><strong>ViewModel</strong></p><ul><li>避免屏幕旋转等事件发生时，保存在 Activity 中的数据被销毁并重建</li><li>异步回调时防止内存泄漏、Context 为 Null</li><li>将数据和视图解耦，防止出现 God Activities 和 God Fragments</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/191011_architecture_master_v2/viewmodel.png" alt="viewmodel" title="">                </div>                <div class="image-caption">viewmodel</div>            </figure><p><strong>LiveData</strong></p><ul><li>DataBinding 思想的一种实现，数据/视图双向绑定</li><li>与生命周期关联，页面销毁后自动将其从订阅者列表去除</li></ul><h3 id="ViewModelFactory"><a href="#ViewModelFactory" class="headerlink" title="ViewModelFactory"></a>ViewModelFactory</h3><p>ViewModel 的创建采用工厂模式进行统一管理。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ViewModelFactory.kt</span></span><br><span class="line"><span class="meta">@Suppress(<span class="meta-string">"UNCHECKED_CAST"</span>)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewModelFactory</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> tasksRepository: TasksRepository</span><br><span class="line">) : ViewModelProvider.NewInstanceFactory() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : ViewModel&gt;</span> <span class="title">create</span><span class="params">(modelClass: <span class="type">Class</span>&lt;<span class="type">T</span>&gt;)</span></span> =</span><br><span class="line">        with(modelClass) &#123;</span><br><span class="line">          <span class="keyword">when</span> &#123;</span><br><span class="line">                isAssignableFrom(StatisticsViewModel::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>) -&gt;</span></span><br><span class="line">                    StatisticsViewModel(tasksRepository)</span><br><span class="line">                isAssignableFrom(TaskDetailViewModel::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>) -&gt;</span></span><br><span class="line">                    TaskDetailViewModel(tasksRepository)</span><br><span class="line">                isAssignableFrom(AddEditTaskViewModel::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>) -&gt;</span></span><br><span class="line">                    AddEditTaskViewModel(tasksRepository)</span><br><span class="line">                isAssignableFrom(TasksViewModel::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>) -&gt;</span></span><br><span class="line">                    TasksViewModel(tasksRepository)</span><br><span class="line">                <span class="keyword">else</span> -&gt;</span><br><span class="line">                    <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"Unknown ViewModel class: <span class="subst">$&#123;modelClass.name&#125;</span>"</span>)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">as</span> T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还记得上文提到过为 Fragment 增加的扩展函数吗？在每一个页面（Fragment）里通过这个扩展函数获取到工厂类，进而获得对应 ViewModel 类的实例。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FragmentExt.kt</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Fragment.<span class="title">getViewModelFactory</span><span class="params">()</span></span>: ViewModelFactory &#123;</span><br><span class="line">  <span class="keyword">val</span> repository = (requireContext().applicationContext <span class="keyword">as</span> TodoApplication).taskRepository</span><br><span class="line">  <span class="keyword">return</span> ViewModelFactory(repository)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TasksFragment.kt</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TasksFragment</span> : <span class="type">Fragment</span></span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> viewModel <span class="keyword">by</span> viewModels&lt;TasksViewModel&gt; &#123; getViewModelFactory() &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是 ViewModel 类，它承担了与 Presenter 类似的职责，是处理业务逻辑的地方。如果需要的话，可以增加一个 Domain 层，负责提取出来的业务逻辑（Use cases），提供复用，这样就变成了 <a href="https://github.com/googlesamples/android-architecture/tree/usecases" target="_blank" rel="noopener">MVVM-Clean</a> 模式。在 master 分支上还没有 domain 层。</p><h3 id="TasksViewModel"><a href="#TasksViewModel" class="headerlink" title="TasksViewModel"></a>TasksViewModel</h3><p>ViewModel 接受一个 TasksRepository 参数，用作数据层接口。（在clean架构里，这里传入的不是Repository，而是UseCases）。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TasksViewModel</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> tasksRepository: TasksRepository</span><br><span class="line">) : ViewModel() &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后声明了一系列变量作为页面数据&amp;状态，这里采用“一个对象，两个变量”的成对写法，略显繁琐，不知道有没有更优美的处理方法。这样做的目的是把对变量的修改关闭，对外（即LiveData）仅提供读取变量的接口，只可以在 ViewModel 内部修改变量。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> _items = MutableLiveData&lt;List&lt;Task&gt;&gt;().apply &#123; value = emptyList() &#125; <span class="comment">// 以下划线开头的为私有变量，apply 和 with 的用法要分清，相当于调用 _items.setValue(emptyList()); return _items;</span></span><br><span class="line"><span class="keyword">val</span> items: LiveData&lt;List&lt;Task&gt;&gt; = _items</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> _dataLoading = MutableLiveData&lt;<span class="built_in">Boolean</span>&gt;()</span><br><span class="line"><span class="keyword">val</span> dataLoading: LiveData&lt;<span class="built_in">Boolean</span>&gt; = _dataLoading</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> _currentFilteringLabel = MutableLiveData&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="keyword">val</span> currentFilteringLabel: LiveData&lt;<span class="built_in">Int</span>&gt; = _currentFilteringLabel</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> _noTasksLabel = MutableLiveData&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="keyword">val</span> noTasksLabel: LiveData&lt;<span class="built_in">Int</span>&gt; = _noTasksLabel</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> _noTaskIconRes = MutableLiveData&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="keyword">val</span> noTaskIconRes: LiveData&lt;<span class="built_in">Int</span>&gt; = _noTaskIconRes</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> _tasksAddViewVisible = MutableLiveData&lt;<span class="built_in">Boolean</span>&gt;()</span><br><span class="line"><span class="keyword">val</span> tasksAddViewVisible: LiveData&lt;<span class="built_in">Boolean</span>&gt; = _tasksAddViewVisible</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> _snackbarText = MutableLiveData&lt;Event&lt;<span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line"><span class="keyword">val</span> snackbarText: LiveData&lt;Event&lt;<span class="built_in">Int</span>&gt;&gt; = _snackbarText</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> _currentFiltering = TasksFilterType.ALL_TASKS   <span class="comment">// Not used at the moment private val isDataLoadingError = MutableLiveData&lt;Boolean&gt;()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> _openTaskEvent = MutableLiveData&lt;Event&lt;String&gt;&gt;()</span><br><span class="line"><span class="keyword">val</span> openTaskEvent: LiveData&lt;Event&lt;String&gt;&gt; = _openTaskEvent</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> _newTaskEvent = MutableLiveData&lt;Event&lt;<span class="built_in">Unit</span>&gt;&gt;()</span><br><span class="line"><span class="keyword">val</span> newTaskEvent: LiveData&lt;Event&lt;<span class="built_in">Unit</span>&gt;&gt; = _newTaskEvent</span><br><span class="line"></span><br><span class="line"><span class="comment">// This LiveData depends on another so we can use a transformation.</span></span><br><span class="line"><span class="keyword">val</span> empty: LiveData&lt;<span class="built_in">Boolean</span>&gt; = Transformations.map(_items) &#123;</span><br><span class="line"> it.isEmpty()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以说管理上面这些数据是 ViewModel 最主要的职责了，从功能上区分，这些数据可以分成<strong>3种</strong>。</p><ol><li>业务实体如 items（任务对象列表），ViewModel 通过修改这类对象，借助于 DataBinding 更新 UI</li><li>数据状态对象如 dataLoading（是否正在加载数据）、currentFilteringLabel（当前的过滤器文字）、noTasksLabel（没有任务的文字）、snackbarText（提示栏文字），这一类对象不进行持久化存储，但是也会影响到 UI 显示</li><li>事件包装对象如 openTaskEvent（打开某个任务，在点击列表中的任务时触发）、newTaskEvent（创建一个任务，在点击+时触发），它们负责通知页面进行跳转——这部分设计得不佳，为了 DataBinding 而强行 DataBinding</li></ol><p>总之贯彻的思想是：一切变动都是数据变动，数据变动通过 DataBinding 自动投射到 UI。</p><hr><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>视图也就是<code>TasksFragment.kt</code>类，负责初始化布局，触发 ViewModel 进行首次加载。这里的 Fragment 继承自 androidx 中的 Fragment。</p><p>在<code>onCreateView</code>里初始化 DataBinding（数据）。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    inflater: <span class="type">LayoutInflater</span>, container: <span class="type">ViewGroup</span>?,</span></span></span><br><span class="line"><span class="function"><span class="params">  savedInstanceState: <span class="type">Bundle</span>?</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: View? &#123;</span><br><span class="line">    viewDataBinding = TasksFragBinding.inflate(inflater, container, <span class="literal">false</span>).apply &#123;</span><br><span class="line">    viewmodel = viewModel</span><br><span class="line">    &#125;</span><br><span class="line">  setHasOptionsMenu(<span class="literal">true</span>)</span><br><span class="line">  <span class="keyword">return</span> viewDataBinding.root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>onActivityCreated</code>里初始化 UI（视图），初始化完成后启动加载（代码最后一行）。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityCreated</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onActivityCreated(savedInstanceState)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the lifecycle owner to the lifecycle of the view</span></span><br><span class="line">    viewDataBinding.lifecycleOwner = <span class="keyword">this</span>.viewLifecycleOwner</span><br><span class="line">    setupSnackbar()</span><br><span class="line">    setupListAdapter()</span><br><span class="line">    setupRefreshLayout(viewDataBinding.refreshLayout, viewDataBinding.tasksList)</span><br><span class="line">    setupNavigation()</span><br><span class="line">    setupFab()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Always reloading data for simplicity. Real apps should only do this on first load and</span></span><br><span class="line">    <span class="comment">// when navigating back to this destination. <span class="doctag">TODO:</span> https://issuetracker.google.com/79672220</span></span><br><span class="line">    viewModel.loadTasks(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，Fragment 中还会进行设置 OnClickListener、Adapter 等操作，比较简单，不赘述。</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>v2 的项目设计时采取了 MVVM 思想，旨在解决 MVP 模式下Presenter 层过于庞大的问题。其实 MVP-Clean 模式已经对此有一些缓解。而 MVVM 做的更彻底，干脆把数据对 UI 的控制完全交给框架自动进行。这样做的好处显而易见，但也并不是没有缺点，比如一旦出了问题，如果没有掌握个中原理，调试时必定摸不清头绪。总而言之，这是一个值得学习与尝试的架构设计。</p><hr><h2 id="Bonus：usecases"><a href="#Bonus：usecases" class="headerlink" title="Bonus：usecases"></a>Bonus：usecases</h2><p><a href="https://github.com/googlesamples/android-architecture/tree/usecases" target="_blank" rel="noopener">usecases</a> 是 v2 中的一个 Stable<br> 分支（另一个是<a href="https://github.com/googlesamples/android-architecture/tree/dagger-android" target="_blank" rel="noopener">dagger-android</a>)。usecases 以解耦、抽象、单向依赖为核心设计理念，这也是 Clean 架构的核心思想。</p><ul><li>表现层只能访问到领域层/用例层，不知道数据层的存在</li><li>领域层/用例层只能访问到数据层，无法访问表现层</li><li>数据层无法访问表现层和领域层</li></ul><p>领域层（或者叫用例层），即 Domain Layer，是由多个 UseCase 组成的，每一个 UseCase 对应一个业务逻辑。以“加载单个Task”为例，可以看到 UseCase 里直接将请求转发给 TasksRepository 来处理，逻辑十分简单。</p><p>在分析具体差别之前，可以先看一遍 usecase 分支与 master 分支的 diff：<a href="https://github.com/googlesamples/android-architecture/compare/usecases#files_bucket" target="_blank" rel="noopener">https://github.com/googlesamples/android-architecture/compare/usecases#files_bucket</a></p><p><strong>GetTaskUseCase.kt</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetTaskUseCase</span></span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> tasksRepository: TasksRepository</span><br><span class="line">  ) &#123;</span><br><span class="line">    suspend <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(taskId: <span class="type">String</span>, forceUpdate: <span class="type">Boolean</span> = <span class="literal">false</span>)</span></span>: Result&lt;Task&gt; &#123;</span><br><span class="line">    wrapEspressoIdlingResource &#123;</span><br><span class="line">      <span class="keyword">return</span> tasksRepository.getTask(taskId, forceUpdate)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而获取 Tasks 列表的 Usecase 相对复杂一些，包括了原本在 TasksViewModel 中处理的过滤逻辑，从另一个角度看，这相当于减轻了 ViewModel 的负担。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetTasksUseCase</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> tasksRepository: TasksRepository</span><br><span class="line">) &#123;</span><br><span class="line">    suspend <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        forceUpdate: <span class="type">Boolean</span> = <span class="literal">false</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        currentFiltering: <span class="type">TasksFilterType</span> = ALL_TASKS</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>: Result&lt;List&lt;Task&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">        wrapEspressoIdlingResource &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> tasksResult = tasksRepository.getTasks(forceUpdate)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Filter tasks</span></span><br><span class="line">            <span class="keyword">if</span> (tasksResult <span class="keyword">is</span> Success &amp;&amp; currentFiltering != ALL_TASKS) &#123;</span><br><span class="line">                <span class="keyword">val</span> tasks = tasksResult.<span class="keyword">data</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">val</span> tasksToShow = mutableListOf&lt;Task&gt;()</span><br><span class="line">                <span class="comment">// We filter the tasks based on the requestType</span></span><br><span class="line">                <span class="keyword">for</span> (task <span class="keyword">in</span> tasks) &#123;</span><br><span class="line">                    <span class="keyword">when</span> (currentFiltering) &#123;</span><br><span class="line">                        ACTIVE_TASKS -&gt; <span class="keyword">if</span> (task.isActive) &#123;</span><br><span class="line">                            tasksToShow.add(task)</span><br><span class="line">                        &#125;</span><br><span class="line">                        COMPLETED_TASKS -&gt; <span class="keyword">if</span> (task.isCompleted) &#123;</span><br><span class="line">                            tasksToShow.add(task)</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> -&gt; NotImplementedError()</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> Success(tasksToShow)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> tasksResult</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于 ViewModel 里，将原来的 Repository 参数改为当前 ViewModel 用到的 UseCase 参数即可，所有处理数据的请求都有 UseCase 来接管。</p><p><strong>TasksViewModel.kt</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TasksViewModel</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> getTasksUseCase: GetTasksUseCase,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> clearCompletedTasksUseCase: ClearCompletedTasksUseCase,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> completeTaskUseCase: CompleteTaskUseCase,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> activateTaskUseCase: ActivateTaskUseCase</span><br><span class="line">) : ViewModel() &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Over~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Move stones, not mountains.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Google 官方的 &lt;a href=&quot;https://github.com/googlesamples/android-architecture&quot; 
      
    
    </summary>
    
    
      <category term="架构" scheme="https://lilei.pro/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>《Java 并发编程实战》勘误表 2019-08-27</title>
    <link href="https://lilei.pro/2019/08/27/jcip-errata/"/>
    <id>https://lilei.pro/2019/08/27/jcip-errata/</id>
    <published>2019-08-27T15:53:23.000Z</published>
    <updated>2019-08-27T16:05:56.759Z</updated>
    
    <content type="html"><![CDATA[<p>Java Concurrency in Practice 是一本讲解 JVM 下并发编程知识的经典作品，建议有志于资深的 Java 工程师将其纳入自己的读书计划中，相信一定会大有裨益。</p><p>在阅读这本书的过程中，我发现中文版本有很多显而易见的错误，尤其是代码里条件判断有时根本是反着来的（本应是<code>&gt;=</code>的条件，书里面却是<code>&lt;</code>）。Google 搜索之后发现在 <a href="http://jcip.net/errata.html" target="_blank" rel="noopener">http://jcip.net/errata.html</a> 有英文原版的勘误表，由于中文版本没有勘误表，故翻译在此，希望可以有所帮助。</p><p>使用之前请确认自己手中的书籍版本是否相符。</p><h1 id="本文适用的中文版本"><a href="#本文适用的中文版本" class="headerlink" title="本文适用的中文版本"></a>本文适用的中文版本</h1><ul><li>书名：《Java 并发编程实战》，Java Concurrency in Practice</li><li>作者：Brain Goetz, Tim Peierls 等</li><li>译者：童云兰 等</li><li>ISBN：978-7-111-37004-8</li><li>出版社：机械工业出版社</li><li>出版时间：2012.2 第一版，2018.9 重印</li><li>定价：69 元</li><li>豆瓣链接：<a href="https://book.douban.com/subject/10484692/" target="_blank" rel="noopener">https://book.douban.com/subject/10484692/</a></li></ul><h1 id="勘误数据来源"><a href="#勘误数据来源" class="headerlink" title="勘误数据来源"></a>勘误数据来源</h1><p><a href="http://jcip.net/errata.html" target="_blank" rel="noopener">官方勘误表</a></p><h1 id="中文版勘误表"><a href="#中文版勘误表" class="headerlink" title="中文版勘误表"></a>中文版勘误表</h1><table><thead><tr><th>页码</th><th>勘误</th></tr></thead><tbody><tr><td>p.5</td><td>程序清单 1-1 下面的第一段，<code>someVariable++</code>应为<code>value++</code></td></tr><tr><td>p.6</td><td>程序清单 1-2，<code>Value</code>应为<code>value</code></td></tr><tr><td>p.53</td><td>4.3 节上面的最后一段，<code>getLocation</code>应为<code>getLocations</code></td></tr><tr><td>p.58</td><td>程序清单 4-11，<code>SafePoint(int x, int y)</code>构造函数的函数体可以精简为<code>set(x, y)</code></td></tr><tr><td>p.62</td><td>程序清单 4-16，<code>if(contains)</code>应为<code>if(!contains)</code></td></tr><tr><td>p.75</td><td>5.3.1 第一段，<code>DiskCrawler</code>应为<code>FileCrawler</code></td></tr><tr><td>p.100</td><td>程序清单 6-7 下面第二段，<code>在 ExcutorService 关闭后提交的任务将由“拒绝执行处理器（Rejected Execution Handler）来处理</code>表述有误，<code>Rejected Execution Handler</code>是仅在<code>ThreadPoolExecutor</code>实现中提供的，并非所有的<code>ExecutorService</code>实现都具备此功能</td></tr><tr><td>p.122</td><td>第二行，<code>那么调用 close 或 wakeup 方法会使线程抛出 ClosedSelectorException</code>，只有<code>close</code>方法会抛出该异常，<code>wakeup</code>方法不会</td></tr><tr><td>p.163</td><td>程序清单 9-6，第一个<code>if(runningTask != null)</code>判断条件应为<code>(runningTask == null)</code></td></tr><tr><td>p.214</td><td>程序清单 12-9，<code>Executors.newFixedThreadPool(MAX_SIZE)</code>方法调用应该增加第二个参数<code>threadFactory</code></td></tr><tr><td>p.229</td><td>程序清单 13-3，代码倒数第三行<code>if (System.nanoTime() &lt; stopTime)</code>判断条件里的<code>&lt;</code>应为<code>&gt;=</code></td></tr></tbody></table><p>以上就是中文版《Java 并发编程实战》的勘误表，如有遗漏，欢迎通过文末留言联系我进行补充。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java Concurrency in Practice 是一本讲解 JVM 下并发编程知识的经典作品，建议有志于资深的 Java 工程师将其纳入自己的读书计划中，相信一定会大有裨益。&lt;/p&gt;
&lt;p&gt;在阅读这本书的过程中，我发现中文版本有很多显而易见的错误，尤其是代码里条件
      
    
    </summary>
    
    
      <category term="Java" scheme="https://lilei.pro/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>架构学习之 mvp-clean</title>
    <link href="https://lilei.pro/2019/08/21/architecture-todo-mvp-clean/"/>
    <id>https://lilei.pro/2019/08/21/architecture-todo-mvp-clean/</id>
    <published>2019-08-20T16:11:55.000Z</published>
    <updated>2019-08-20T16:17:18.801Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>I am the STORM!!!</p></blockquote><p>上一篇文章介绍了 MVP 模式，作为 Android 最朴实的架构，MVP 足以应对复杂度较低的业务场景，回想 2014~2015 年在 DP 做预订闪惠的日子，用的便是 MVP。</p><p>然而随着业务复杂度增加，Presenter 层的逻辑会随之变重，导致的结果便是 Presenter 类过大，动辄一两千行代码，实在是丑陋。在这种场景下，Clean 架构是一个很好的选择。</p><h2 id="关于-Clean"><a href="#关于-Clean" class="headerlink" title="关于 Clean"></a>关于 Clean</h2><h3 id="什么是-Clean"><a href="#什么是-Clean" class="headerlink" title="什么是 Clean"></a>什么是 Clean</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/190821_todo_mvp_clean/CleanArchitecture.jpg" alt="CleanArchitecture" title="">                </div>                <div class="image-caption">CleanArchitecture</div>            </figure><p>Clean 架构最初并不是为了针对 Android 平台的问题而提出，而是作为<strong>软件系统</strong>的通用架构被设计出来，如上面的同心圆所示，它的核心思想是<strong>The Dependency Rule（单向依赖原则）</strong>，即只能从外层向内层依赖，内层对外层一无所知，外层的变动不应当影响到内层。</p><p>另一个重要概念是<strong>Use Case（用例）</strong>，<strong>用例</strong>是业务逻辑的最小抽象单元，它调用数据模块的接口，向上（Presenter）提供业务逻辑操作入口。</p><h3 id="Android-Clean"><a href="#Android-Clean" class="headerlink" title="Android Clean"></a>Android Clean</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/190821_todo_mvp_clean/mvp-clean.png" alt="mvp-clean" title="">                </div>                <div class="image-caption">mvp-clean</div>            </figure><p>Android 平台在 Presenter 和 Model 之间定义了<strong>Domain Layer（域层）</strong>，用于承载<strong>Use Case</strong>，如上图所示，Use Case 的背后是业务逻辑。Domain Layer 脱胎于 MVP 的 Presenter，这样可以避免相同的业务逻辑代码出现在两个 Presenter 中的问题。</p><h4 id="Use-Cases-异步性"><a href="#Use-Cases-异步性" class="headerlink" title="Use Cases 异步性"></a>Use Cases 异步性</h4><p>鉴于 Domain Layer 是 UI 无关的，这里可以统一将 Use Case 放入工作线程运行，通过异步回调进行通信。至于更底层的数据库/网络操作，出于简化的目的，可以直接使用同步接口。</p><h4 id="不同-Layer-是否需要定义各自的-Model"><a href="#不同-Layer-是否需要定义各自的-Model" class="headerlink" title="不同 Layer 是否需要定义各自的 Model"></a>不同 Layer 是否需要定义各自的 Model</h4><p>标准的做法是在视图层（View Layer）、域层（Domain Layer）和数据层（Data/Model Layer）分别使用不同的对象，如 VO、BO、DO 等。这样带来的问题是重复性增加。如果对象是不可变的，在各层之间具有相同的属性和方法，则可以只定义一个对象，共通使用。</p><p>如果视图层对象包含 Android 相关的方法或属性，则应当为其单独定义一个类，然后使用<code>Mapper</code>在不同层之间进行对象转换。</p><h2 id="如何抽象业务场景"><a href="#如何抽象业务场景" class="headerlink" title="如何抽象业务场景"></a>如何抽象业务场景</h2><p>这里我们将 Clean 模式应用在 todo-app 上，想想还有点小激动。</p><h3 id="Use-Cases-amp-Domain-Layer"><a href="#Use-Cases-amp-Domain-Layer" class="headerlink" title="Use Cases &amp; Domain Layer"></a>Use Cases &amp; Domain Layer</h3><p>把 Use Case 的声明和运行机制拆开，是不是跟 Runnable + Executor 的机制很像？没错，这就是设计模式中的<strong>命令模式</strong>。设计模式不是彼此孤立的，一个项目里可以整体采用 Clean 架构，不同的子模块，应用不同的设计模式。设计模式是死的，人是活的。</p><p>抽象类<code>UseCase</code>即是<strong>命令</strong>，包含入参、出参、回调通知对象、运行的抽象过程（这里又出现了<strong>模版模式</strong>）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">UseCase</span>&lt;<span class="title">Q</span> <span class="keyword">extends</span> <span class="title">UseCase</span>.<span class="title">RequestValues</span>, <span class="title">P</span> <span class="keyword">extends</span> <span class="title">UseCase</span>.<span class="title">ResponseValue</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Q mRequestValues;</span><br><span class="line">  <span class="keyword">private</span> UseCaseCallback&lt;P&gt; mUseCaseCallback; <span class="comment">// 任务完成后（成功or失败）的回调</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// set and get</span></span><br><span class="line">  <span class="comment">//..</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="comment">// Executor 运行入口</span></span><br><span class="line">    executeUseCase(mRequestValues);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> voi8d <span class="title">executeUseCase</span><span class="params">(Q requestValues)</span></span>; <span class="comment">// 子类必需实体化这个方法</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RequestValues</span> </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResponseValues</span> </span>&#123;&#125; <span class="comment">// 接口约束</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UseCaseCallback</span>&lt;<span class="title">R</span>&gt; </span>&#123; <span class="comment">// 任务完成后的回调</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(R response)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后选取一个“加载全部任务”的场景为例，看它是如何实现抽象类的，以下是<code>GetTask.java</code>的部分代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetTasks</span> <span class="keyword">extends</span> <span class="title">UseCase</span>&lt;<span class="title">GetTasks</span>.<span class="title">RequestValues</span>, <span class="title">GetTasks</span>.<span class="title">ResponseValues</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> TasksRepository mTasksRepository; <span class="comment">// 更底层的数据源对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> FilterFactory mFilterFactory; <span class="comment">// 过滤器工厂类</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">GetTasks</span><span class="params">(@NonNull TaskRepository tasksRepository, @NonNull FilterFactory filterFactory)</span> </span>&#123; <span class="comment">// 构造时传入数据源对象和过滤器工厂</span></span><br><span class="line">    mTasksRepository = checkNotNull(tasksRepository, <span class="string">"tasksRepository cannot be null!"</span>);</span><br><span class="line">    mFilterFactory = checkNotNull(filterFactory, <span class="string">"filterFactory cannot be null!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">executeUseCase</span><span class="params">(<span class="keyword">final</span> RequestValues values)</span> </span>&#123; <span class="comment">// 利用泛型约束，在不同UseCase实现类里使用不同参数</span></span><br><span class="line">    <span class="keyword">if</span> (values.isForceUpdate()) &#123;</span><br><span class="line">      mTasksRepository.refreshTasks();</span><br><span class="line">    &#125;</span><br><span class="line">    mTasksRepository.getTasks(<span class="keyword">new</span> TasksDataSource.LoadTasksCallback() &#123; <span class="comment">// 调用数据源异步方法</span></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTasksLoaded</span><span class="params">(List&lt;Task&gt; tasks)</span> </span>&#123;</span><br><span class="line">        TasksFilterType currentFiltering = values.getCurrentFiltering();</span><br><span class="line">        TaskFilter taskfilter = mFilterFactory.create(currentFiltering);</span><br><span class="line"></span><br><span class="line">        List&lt;Task&gt; tasksFiltered = taskFilter.filter(tasks);</span><br><span class="line">        ResponseValue responseValue = <span class="keyword">new</span> ResponseValue(tasksFiltered);</span><br><span class="line">        getUseCaseCallback().onSuccess(responseValue);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDataNotAvailable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        getUseCallback().onError();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestValues</span> <span class="keyword">implements</span> <span class="title">UseCase</span>.<span class="title">RequestValues</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TasksFilterType mCurrentFiltering;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> mForceUpdate;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// constructor, get and set</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseValues</span> <span class="keyword">implements</span> <span class="title">UseCase</span>.<span class="title">ResponseValues</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Task&gt; mTasks;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我在上述代码的注释里增加了一些说明，此外，有几处需要额外的注意：</p><ol><li>Use Case 构造函数里需要传入底层数据源对象，这意味着不可以在 Presenter 层直接构造 Use Case，因为 Presenter 不应当跨过 Domain Layer 直接访问数据源。—— 想想如何实现？IOC，DI，Bingo！</li><li>在 Use Case 的类内部，以静态类的方式声明<code>RequestValues</code>和<code>ResponseValues</code>，代码集中，易于管理。<code>UseCase.java</code>基类中提供的空接口也利于不同的子类声明各自不同的参数类型。在模版方法<code>executeUseCase</code>里分别进行调用，化元归一。</li></ol><h3 id="Executor：任务执行机制"><a href="#Executor：任务执行机制" class="headerlink" title="Executor：任务执行机制"></a>Executor：任务执行机制</h3><p><strong>命令模式</strong>由命令与执行机制两部分组成，Java 中的<code>Executor</code>框架就是一种典型应用。虽然<code>Executor</code>只是一个简单的接口，但它却为灵活而强大的异步任务执行框架提供了基础，该框架能支持多种不同类型的任务执行策略。它提供了一种标准的方法将任务的提交过程和执行过程解耦开来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java 中的 Executor，不负责运行结果通知</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>项目里使用同样的机制作为<code>UseCase</code>的运行框架。</p><p><code>UseCaseScheduler.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UseCaseScheduler</span> </span>&#123;</span><br><span class="line">  <span class="comment">// todo-mvp-clean 中的 Executor</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable runnable)</span></span>;</span><br><span class="line">  <span class="comment">// 增加结果通知回调</span></span><br><span class="line">  &lt;V extends UseCase.ResponseValue&gt; <span class="function"><span class="keyword">void</span> <span class="title">notifyResponse</span><span class="params">(<span class="keyword">final</span> V response, <span class="keyword">final</span> UseCase.UseCaseCallback&lt;V&gt; useCaseCallback)</span></span>;</span><br><span class="line">  &lt;V extends UseCase.ResponseValue&gt; <span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">(<span class="keyword">final</span> UseCase.UseCaseCallback&lt;V&gt; useCaseCallback)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的实现类采用线程池方式实现：</p><p><code>UseCaseThreadPoolScheduler.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseCaseThreadPoolScheduler</span> <span class="keyword">implements</span> <span class="title">UseCaseScheduler</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Handler mHandler = <span class="keyword">new</span> Handler(); <span class="comment">// 将运算结果通知主线程</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> POOL_SIZE = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_POOL_SIZE = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIMEOUT = <span class="number">30</span>;</span><br><span class="line">  ThreadPoolExecutor mThreadPoolExecutor; <span class="comment">// 使用线程池提供复用</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">UseCaseThreadPoolScheduler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mThreadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(POOL_SIZE, MAX_POOL_SIZE, TIMEOUT, TimeUnit.SECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(POOL_SIZE));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">    mThreadPoolExecutor.execute(runnable); <span class="comment">// 任务提交给线程池处理</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;V extends UseCase.ResponseValue&gt; <span class="function"><span class="keyword">void</span> <span class="title">notifyResponse</span><span class="params">(<span class="keyword">final</span> V response, <span class="keyword">final</span> UseCase.UseCaseCallback&lt;V&gt; useCaseCallback)</span> </span>&#123;</span><br><span class="line">    mHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        useCaseCallback.onSuccess(response); <span class="comment">// 主线程处理结果</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;V extends UseCase.ResponseValue&gt; <span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">(<span class="keyword">final</span> UseCase.UseCaseCallback&lt;V&gt; useCaseCallback)</span> </span>&#123;</span><br><span class="line">    mHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        useCaseCallback.onError(); <span class="comment">// 主线程处理结果</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="UseCaseHandler：任务执行机制包装"><a href="#UseCaseHandler：任务执行机制包装" class="headerlink" title="UseCaseHandler：任务执行机制包装"></a>UseCaseHandler：任务执行机制包装</h3><p>上文介绍了项目里采用<code>Executor</code>作为命令的运行框架，<code>Executor</code>接收的是<code>Runnable</code>类型的任务，我们还需要一层<strong>UseCase处理器</strong>，用于将<code>UseCase</code>封装成<code>Runnable</code>，并且处理任务的返回值。<code>UseCaseHandler</code>就是负责处理<code>UseCase</code>的组件。</p><p><code>UseCaseHandler.java</code>，省略部分代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseCaseHandler</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> UseCaseHandler INSTANCE; <span class="comment">// 单例模式，饿汉</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T extends UseCase.RequestValues, R extends UseCase.ResponseValue&gt; <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> UseCase&lt;T, R&gt; useCase, T values, UseCase.UseCaseCallback&lt;R&gt; callback)</span> </span>&#123;</span><br><span class="line">    useCase.setRequestValues(values);</span><br><span class="line">    useCase.setUseCaseCallback(<span class="keyword">new</span> UiCallbackWrapper(callback, <span class="keyword">this</span>));</span><br><span class="line">    mUseCaseScheduler.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        useCase.run();</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// UI回调包装器类，将成功/失败事件交给UI线程处理</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">UiCallbackWrapper</span>&lt;<span class="title">V</span> <span class="keyword">extends</span> <span class="title">UseCase</span>.<span class="title">ResponseValue</span>&gt; <span class="keyword">implements</span> <span class="title">UseCase</span>.<span class="title">UseCaseCallback</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UseCase.UseCaseCallback&lt;V&gt; mCallback;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UseCaseHandler mUseCaseHandler;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UiCallbackWrapper</span><span class="params">(UseCase.UseCaseCallback&lt;V&gt; callback, UseCaseHandler useCaseHandler)</span> </span>&#123;</span><br><span class="line">      mCallback = callback;</span><br><span class="line">      mUseCaseHandler = useCaseHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(V response)</span> </span>&#123;</span><br><span class="line">      mUseCaseHandler.notifyResponse(response, mCallback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      mUseCaseHandler.notifyError(mCallback);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><code>UseCaseHandler</code>隐藏了任务的执行机制，对外暴露出通过<code>UseCase</code>提交命令的接口，此时 Presenter 就可以借助<code>UseCaseHandler</code>来提交各项异步任务，并且获取回调。注意到回调是在 UI 线程发生的，意味着 Presenter 可以在回调中直接操作 UI 元素。</p><h3 id="Activity：穿针引线的组织者"><a href="#Activity：穿针引线的组织者" class="headerlink" title="Activity：穿针引线的组织者"></a>Activity：穿针引线的组织者</h3><p>与 MVP 架构一样，在 MVP clean 架构中，Activity 同样担任初始化 Fragment、Presenter 的职责。Activity 类是十分简单的，80% 的逻辑都写在<code>onCreate</code>当中。</p><p><code>TaskActivity.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">  setContentView(R.layout.tasks_act);    <span class="comment">// Set up the toolbar.</span></span><br><span class="line">  <span class="comment">// 初始化 ActionBar</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 初始化 DrawerLayout</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// FragmentManager与Activity是一一对应的，所以这里通过R.id.contentFrame获取Fragment，在Activity B中也可以用R.id.contentFrame获取B当中的Fragment，不用担心重复</span></span><br><span class="line">  TasksFragment tasksFragment = (TasksFragment) getSupportFragmentManager().findFragmentById(R.id.contentFrame);</span><br><span class="line">  <span class="keyword">if</span> (tasksFragment == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Create the fragment</span></span><br><span class="line">    tasksFragment = TasksFragment.newInstance();</span><br><span class="line">    ActivityUtils.addFragmentToActivity(getSupportFragmentManager(), tasksFragment, R.id.contentFrame);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将使用到的Task用作构造参数，创建Presenter</span></span><br><span class="line">  mTasksPresenter = <span class="keyword">new</span> TasksPresenter(</span><br><span class="line">    Injection.provideUseCaseHandler(),</span><br><span class="line">    tasksFragment,</span><br><span class="line">    Injection.provideGetTasks(getApplicationContext()),</span><br><span class="line">    Injection.provideCompleteTasks(getApplicationContext()),</span><br><span class="line">    Injection.provideActivateTask(getApplicationContext()),</span><br><span class="line">    Injection.provideClearCompleteTasks(getApplicationContext())</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">// Load previously saved state, if available.</span></span><br><span class="line">  <span class="keyword">if</span> (savedInstanceState != <span class="keyword">null</span>) &#123;</span><br><span class="line">    TasksFilterType currentFiltering = (TasksFilterType) savedInstanceState.getSerializable(CURRENT_FILTERING_KEY);</span><br><span class="line">  mTasksPresenter.setFiltering(currentFiltering);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后在<code>View.onResume</code>中会调用<code>Presenter.start</code>来首次加载数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>.onResume();</span><br><span class="line">  mPresenter.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，MVP-clean 架构的设计思路就被我们分析透彻了，可以看出，相比于 MVP，clean 架构抽象出来 Domain 层，使具体的业务操作独立可复用，且减轻了 Presenter 类的负担。</p><p>还有一个好处是每一个 Use Case 都是可测试的，单元测试粒度被细化，更容易定位问题，从而针对性解决。关于测试我讲的不多，可以直接参考<a href="https://github.com/googlesamples/android-architecture/tree/todo-mvp-clean" target="_blank" rel="noopener">源码</a>进行理解。</p><h2 id="任务列表功能类图"><a href="#任务列表功能类图" class="headerlink" title="任务列表功能类图"></a>任务列表功能类图</h2><p>最后，我们将 todo app 的任务列表功能绘制成类图，加深理解。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/190821_todo_mvp_clean/mvp-clean-%E7%B1%BB%E5%9B%BE.png" alt="mvp-clean-类图" title="">                </div>                <div class="image-caption">mvp-clean-类图</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;I am the STORM!!!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上一篇文章介绍了 MVP 模式，作为 Android 最朴实的架构，MVP 足以应对复杂度较低的业务场景，回想 2014~2015 年在 DP 做预订闪惠的日子，用的便是
      
    
    </summary>
    
    
      <category term="架构" scheme="https://lilei.pro/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>架构学习之 mvp</title>
    <link href="https://lilei.pro/2019/08/21/architecture-todo-mvp/"/>
    <id>https://lilei.pro/2019/08/21/architecture-todo-mvp/</id>
    <published>2019-08-20T16:04:52.000Z</published>
    <updated>2019-08-20T16:17:44.226Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Life doesn’t give you what your want, it gives you what you DESERVE!</p></blockquote><h1 id="0x00-序言"><a href="#0x00-序言" class="headerlink" title="0x00 序言"></a>0x00 序言</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/190821_todo_mvp/aab-logov2.png" alt="Android Architecture Blueprints" title="">                </div>                <div class="image-caption">Android Architecture Blueprints</div>            </figure><p>Google 官方在 GitHub 推出的<a href="https://github.com/googlesamples/android-architecture" target="_blank" rel="noopener">Android 架构 Demo</a>项目非常值得学习，通过 TODO app 的例子，讲解各种应用架构模式如何在实现需求的基础上，达到可维护性、扩展性、可测试性的优秀设计。</p><p>本系列博客文章聚焦于以下几点：</p><ol><li>简明扼要介绍各个架构的思想与基础模型</li><li>在该架构模式下如何对 TODO App 的各个模块进行划分，以及划分的依据</li><li>取一个页面为例，作出类图，解析代码</li></ol><p><strong>Talk is cheap, show me the code.</strong></p><h1 id="0x01-业务逻辑"><a href="#0x01-业务逻辑" class="headerlink" title="0x01 业务逻辑"></a>0x01 业务逻辑</h1><p>建议 clone 代码后真机运行体验，用一张图概括如下。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/190821_todo_mvp/页面流程图.png" alt="页面流程图" title="">                </div>                <div class="image-caption">页面流程图</div>            </figure><p>Google 也给出了一个<a href="https://github.com/googlesamples/android-architecture/wiki/To-do-app-specification" target="_blank" rel="noopener">wiki 页面</a>说明 TODO app 的特性。至于为什么选择这样一个应用作为 demo，官方给出的解释如下：</p><blockquote><p>它必须足够简单，便于你很快地理解其功能；同时也要足够复杂，这样才能展现不同设计的决策以及提供测试场景。</p></blockquote><h1 id="0x02-todo-mvp"><a href="#0x02-todo-mvp" class="headerlink" title="0x02 todo-mvp"></a>0x02 todo-mvp</h1><h2 id="关于-MVP"><a href="#关于-MVP" class="headerlink" title="关于 MVP"></a>关于 MVP</h2><p>MVP 脱胎于大名鼎鼎的 MVC（Model-View-Controller）。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/190821_todo_mvp/mvc.png" alt="mvc" title="">                </div>                <div class="image-caption">mvc</div>            </figure><p>但凡做软件开发的人应该对 MVC 都不感到陌生，它的基本思想是将数据、视图、控制逻辑拆分。这三部分可以自由进行替换，比如在不改变数据接口的情况下，替换数据来源；或者是调整 UI 显示，而无需改动业务逻辑。</p><p>MVC 是一个具有历史意义的架构模式，它对天马行空、一团乱麻的软件设计进行规约，使后续对程序的修改和扩展简化，并且使重用成为可能。但是，它并不是最适合 Android 开发的架构模式。</p><h3 id="MVC-为什么不适合-Android-开发"><a href="#MVC-为什么不适合-Android-开发" class="headerlink" title="MVC 为什么不适合 Android 开发"></a>MVC 为什么不适合 Android 开发</h3><p>MVC 的核心思想是解耦，单一职责。在 Android 开发中，不使用 MVC 的主要原因是 Activity 的职责太重，往往要同时承担 View 和 Controller 的工作，这会造成 Activity 类非常庞大，UI 代码和逻辑代码交织，耦合严重。</p><h3 id="MVP-为什么适合-Android-开发"><a href="#MVP-为什么适合-Android-开发" class="headerlink" title="MVP 为什么适合 Android 开发"></a>MVP 为什么适合 Android 开发</h3><p>MVP 的架构如下图。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/190821_todo_mvp/mvp.png" alt="MVP" title="">                </div>                <div class="image-caption">MVP</div>            </figure><p>它单独抽出了 Presenter 对象，实现了业务逻辑，用于控制 View 的显示变化，以及与 Model 进行数据交互。Presenter 和 View 互相持有，Model 仅被 Presenter 持有。</p><p>在理想状态下，Presenter 和 Model 仅包含 Java 代码，不含 Android SDK 内容。MVP 架构解决了 MVC 中 Activity 职责过多的问题，将 UI 功能分配给 View 单独管理，View 的接口仅向 Presenter 开放，相比 MVC，更好地实现了职责单一、解耦的需求。</p><h2 id="如何抽象业务场景"><a href="#如何抽象业务场景" class="headerlink" title="如何抽象业务场景"></a>如何抽象业务场景</h2><h3 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h3><p>设计从数据层开始，数据层要承担什么职责呢？其实就是<strong>CRUD</strong>：</p><ul><li>保存新建的任务</li><li>查询已创建任务</li><li>更新任务状态（未完成 -&gt; 已完成）</li><li>删除任务</li></ul><p>数据的持久化方式，数据操作结果采用同步还是异步，这些问题也是设计过程中要考虑的。</p><h4 id="基本的任务对象：Task"><a href="#基本的任务对象：Task" class="headerlink" title="基本的任务对象：Task"></a>基本的任务对象：Task</h4><p>首先设计一个<code>Task.java</code>类，表示任务对象，它是一个典型的 Java Bean。在这里我们将 Task 设计成一个不可变的对象。在一个任务从“未完成”变为“完成”状态时，并不是修改原对象，而是丢弃掉原对象，再以相同<code>id</code>重新创建一个完成状态的对象。这样做的好处是逻辑简单，不可变对象线程绝对安全。缺点是当对象创建、销毁成本高的时候，会产生性能损失。在实际业务中应当酌情选择重用或者舍弃。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String mId;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String mTitle;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String mDescription;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> mCompleted;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Model-层对外暴露的接口：TasksDataSource"><a href="#Model-层对外暴露的接口：TasksDataSource" class="headerlink" title="Model 层对外暴露的接口：TasksDataSource"></a>Model 层对外暴露的接口：TasksDataSource</h4><p>本着面向接口编程的原则，隐藏数据操作具体实现代码，暴露出管理任务的接口（包含回调）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TasksDataSource</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">interface</span> <span class="title">LoadTasksCallback</span> </span>&#123; <span class="comment">// 加载复数任务回调</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onTasksLoaded</span><span class="params">(List&lt;Task&gt; tasks)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onDataNotAvailable</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">interface</span> <span class="title">GetTaskCallback</span> </span>&#123; <span class="comment">// 加载单条任务回调</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onTaskLoaded</span><span class="params">(Task task)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onDataNotAvailable</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">getTasks</span><span class="params">(@NonNull LoadTasksCallback callback)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">getTask</span><span class="params">(@NonNull String taskId, @NonNull GetTaskCallback callback)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">saveTask</span><span class="params">(@NonNull Task task)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">completeTask</span><span class="params">(@NonNull Task task)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">completeTask</span><span class="params">(@NonNull String taskId)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">activateTask</span><span class="params">(@NonNull Task task)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">activateTask</span><span class="params">(@NonNull String taskId)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clearCompletedTasks</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">refreshTasks</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">deleteAllTasks</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">deleteTask</span><span class="params">(@NonNull String taskId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口里有两处与我的编程思路有出入。首先是加载任务回调，我认为可以仅保留复数任务的接口，对于加载单条任务的需求，返回一个长度为 1 的列表就可以了。其次，在命名上，我习惯于将同步接口以<code>getXXX</code>，异步接口以<code>loadXXX</code>来声明。</p><p>有了这个接口，就可以提供给任务详情、任务列表等页面使用。接下来创建一个接口实现类，这个类对外的职责是实现数据操作接口，对内的职责是隐藏两种具体的数据操作实现（内存缓存、数据库、网络）。</p><p>数据源共有三级缓存：</p><ul><li>In-memory cache - Fast</li><li>Disk (SQLiteDb) - Slow</li><li>Network - Very slow</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TasksRepository</span> <span class="keyword">implements</span> <span class="title">TasksDataSource</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> TasksDatasource mTasksRemoteDataSource; <span class="comment">// 网络数据源</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> TasksDatasource mTasksLocalDataSource; <span class="comment">// 本地数据源</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读写数据策略可以概括为“依次读，全部写”，括号里是我补充的内容：</p><ul><li><p>In every <code>get</code>operation:</p><ul><li>Return cache if available, or</li><li>return local copy if it exists (and update cache) , or</li><li>return remote copy ( and update local copy &amp; cache)</li></ul></li><li><p>Every <code>write</code>/<code>delete</code>operation will simply:</p><ul><li>Update cache</li><li>Update local</li><li>Update remote</li></ul></li></ul><p>具体的网络数据源、本地数据库设计为常见写法，不赘述。</p><h3 id="Fragment-即是-View"><a href="#Fragment-即是-View" class="headerlink" title="Fragment 即是 View"></a>Fragment 即是 View</h3><p>处理所有 UI 变化事件，比如显示 loading、显示任务列表、显示任务详情、显示任务状态变更 SnackBar 等，值得注意的是页面跳转操作也属于 UI 变化，是在 Fragment 里面实现的。不妨思考一下为什么“跳转”不放在 Presenter 中进行？一个原因是 Presenter 与 Android SDK 无关，而跳转需要 Context 对象，违背了这一原则。比如从“任务列表”跳转到“任务详情”时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TasksFragment.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showAddTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Intent intent = <span class="keyword">new</span> Intent(getContext(), AddEditTaskActivity.class);</span><br><span class="line">  startActivityForResult(intent, AddEditTaskActivity.REQUEST_ADD_TASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>View 里面没有任何业务逻辑，主要处理以下事件：</p><ul><li>加载中、加载成功、失败页面展示</li><li>展现 Toast、SnackBar 等提示</li><li>处理按钮、菜单点击事件（通常是将其甩给 Presenter 处理）</li><li>处理页面跳转</li><li>声明 Adapter</li><li>在<code>onResume</code>时调用 Presenter 的<code>start</code>方法，启动页面</li><li>提供<code>isActive</code>方法，供 Presenter 在异步回调返回时判断页面是否存活</li></ul><p>最后一点是容易漏掉的，如果异步请求回调时页面被销毁，会导致各种难以预料的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> isAdded();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Presenter-业务逻辑载体"><a href="#Presenter-业务逻辑载体" class="headerlink" title="Presenter - 业务逻辑载体"></a>Presenter - 业务逻辑载体</h3><p>承担了业务逻辑实现的职责，有时业务逻辑过于复杂会导致 Presenter 类太大，此时要考虑拆分业务逻辑到单独的类中，就变成了<code>mvp-clean</code>架构，clean 架构中使用<code>Use Case（用例）</code>处理细分的业务逻辑。</p><p>Presenter 由 Activity 构造，并且提供方法给 Activity 以及 View（Fragment）使用。</p><h3 id="Activity-将一切粘合到一起"><a href="#Activity-将一切粘合到一起" class="headerlink" title="Activity - 将一切粘合到一起"></a>Activity - 将一切粘合到一起</h3><p>现在我们有了 Model、View、Presenter 各个部分，而 Android 应用的页面入口是 Activity 类，我们在 Activity 中创建 Fragment（View）及 Presenter，在这两者之间建立关联。同时还要处理一些必须放在 Activity 中进行的操作，比如<code>onSaveInstanceState</code>、<code>onOptionsItemSelected</code> 等等。</p><h2 id="任务列表功能实现"><a href="#任务列表功能实现" class="headerlink" title="任务列表功能实现"></a>任务列表功能实现</h2><p>用类图来表示 MVP 模式下的任务列表功能相关类：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/190821_todo_mvp/mvp类图.png" alt="mvp" title="">                </div>                <div class="image-caption">mvp</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Life doesn’t give you what your want, it gives you what you DESERVE!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;0x00-序言&quot;&gt;&lt;a href=&quot;#0x00-序言&quot; c
      
    
    </summary>
    
    
      <category term="架构" scheme="https://lilei.pro/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>ACE-PTM 第 II 部分 领导和实施</title>
    <link href="https://lilei.pro/2019/07/14/ace-cpt-part-2/"/>
    <id>https://lilei.pro/2019/07/14/ace-cpt-part-2/</id>
    <published>2019-07-14T10:16:42.000Z</published>
    <updated>2019-07-28T15:54:18.551Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第-2-章-激励和坚持原则"><a href="#第-2-章-激励和坚持原则" class="headerlink" title="第 2 章 - 激励和坚持原则"></a>第 2 章 - 激励和坚持原则</h1><p>只有约20%的美国成人同时符合有氧活动和肌肉强化指南要求。健身专业人员面临着两大挑战：<strong>让人们积极开始</strong>以及之后<strong>坚持运动计划</strong>。本章重点是提高人们在开始之后坚持计划的可能性。</p><p>激励人开始锻炼的因素不一定是使他们长期参与运动计划的因素。健康和健身行业的真正挑战是创造出适宜的计划和运动环境，使人们尽可能提高坚持计划并选择积极生活方式的可能性。</p><h2 id="了解激励"><a href="#了解激励" class="headerlink" title="了解激励"></a>了解激励</h2><p>用于评估激励的两种最常讨论方法是<strong>内在与外在激励</strong>和<strong>自我效能</strong>。</p><h3 id="内在和外在激励"><a href="#内在和外在激励" class="headerlink" title="内在和外在激励"></a>内在和外在激励</h3><p>在运动背景下，要实现内在激励，意味着一个人是因为参与本身所带来的内在愉悦和体验而从事运动活动。</p><p>与其认为需要让自己的客户受到更多的内在激励，私人教练应更努力增加参与计划所带来的愉悦感和成就感。私人教练通过鼓励客户<strong>拥有并参与计划以及教授自足性和自主性</strong>，可以帮助促进内在激励的形成。</p><h3 id="自我效能"><a href="#自我效能" class="headerlink" title="自我效能"></a>自我效能</h3><p>在运动背景下，自我效能定义为个体对自身成功参与体力活动计划的能力和信念。自我效能与激励呈正相关。</p><p>许多健身专业人员所犯的一个重大错误是安排整堂课进行评估，不要让客户感觉像在做测试，在某些情况下，甚至不要让客户知道你在收集评估信息。</p><h2 id="用于保持客户激励的策略"><a href="#用于保持客户激励的策略" class="headerlink" title="用于保持客户激励的策略"></a>用于保持客户激励的策略</h2><p>私人教练应当告知客户可能会出现回复原态并使其提前做好准备，以便他们能够在回复原态后立即重新坚持活动计划。第一步是<strong>宣教</strong>，第二步是<strong>支持</strong>。</p><h3 id="社会支持"><a href="#社会支持" class="headerlink" title="社会支持"></a>社会支持</h3><p>开发和维护运动的社会支持网络。教练应当尽量多利用团体参与和社交互动的机会，让客户感觉自己属于该计划，并且是具有共同兴趣和目标的成员所组成团队的一部分。</p><h3 id="自我肯定"><a href="#自我肯定" class="headerlink" title="自我肯定"></a>自我肯定</h3><p>教导客户进行自我肯定。</p><h3 id="自我调节"><a href="#自我调节" class="headerlink" title="自我调节"></a>自我调节</h3><p>教导客户成为有效的自律者，自我监督行为、日程、时间和优先事项。</p><h3 id="高风险情况"><a href="#高风险情况" class="headerlink" title="高风险情况"></a>高风险情况</h3><p>时间管理技能不佳、缺乏社会支持或日程繁忙的个人最有可能回复圆台。私人教练必须不断了解并观察客户是否出现受打击、沮丧或疲惫的迹象。</p><h2 id="影响运动参与和坚持度的因素"><a href="#影响运动参与和坚持度的因素" class="headerlink" title="影响运动参与和坚持度的因素"></a>影响运动参与和坚持度的因素</h2><p>体力活动的潜在决定因素可分为三类：</p><ul><li>个人特质</li><li>环境因素</li><li>体力活动因素</li></ul><h3 id="个人特质"><a href="#个人特质" class="headerlink" title="个人特质"></a>个人特质</h3><h4 id="人口统计变量"><a href="#人口统计变量" class="headerlink" title="人口统计变量"></a>人口统计变量</h4><h4 id="健康状况"><a href="#健康状况" class="headerlink" title="健康状况"></a>健康状况</h4><h4 id="过往的运动经验"><a href="#过往的运动经验" class="headerlink" title="过往的运动经验"></a>过往的运动经验</h4><h4 id="心理特质"><a href="#心理特质" class="headerlink" title="心理特质"></a>心理特质</h4><h4 id="认识、态度和信念"><a href="#认识、态度和信念" class="headerlink" title="认识、态度和信念"></a>认识、态度和信念</h4><h3 id="环境因素"><a href="#环境因素" class="headerlink" title="环境因素"></a>环境因素</h3><h4 id="设施便利性"><a href="#设施便利性" class="headerlink" title="设施便利性"></a>设施便利性</h4><h4 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h4><h4 id="社会支持-1"><a href="#社会支持-1" class="headerlink" title="社会支持"></a>社会支持</h4><h3 id="体力活动因素"><a href="#体力活动因素" class="headerlink" title="体力活动因素"></a>体力活动因素</h3><h4 id="强度"><a href="#强度" class="headerlink" title="强度"></a>强度</h4><h4 id="损伤"><a href="#损伤" class="headerlink" title="损伤"></a>损伤</h4><h2 id="反馈"><a href="#反馈" class="headerlink" title="反馈"></a>反馈</h2><ul><li>外部反馈：私人教练为客户提供的强化、纠错和鼓励。</li><li>内部反馈：客户根据自己的感觉系统（感受到、看到或听到的内容）为自己提供的相应信息。长期计划坚持度取决于客户提供自我反馈的能力。</li></ul><h2 id="领导特质"><a href="#领导特质" class="headerlink" title="领导特质"></a>领导特质</h2><p>对客户的进展表现出持续不断地关心和兴趣是贯穿私教职业生涯的一部分。私人教练使用系统性目标设定以及教授回复原态预防技巧的目的是，告诉客户他们对客户的关心远远超出这一小时课程的范围。</p><h2 id="私人教练爱建立坚持度中的作用"><a href="#私人教练爱建立坚持度中的作用" class="headerlink" title="私人教练爱建立坚持度中的作用"></a>私人教练爱建立坚持度中的作用</h2><h3 id="计划设计"><a href="#计划设计" class="headerlink" title="计划设计"></a>计划设计</h3><p>私人教练必须能够针对每个客户的偏好、时间表、经验、顾虑和约束条件（例如，钱、便利性和时间）设计计划。</p><h3 id="角色清晰度"><a href="#角色清晰度" class="headerlink" title="角色清晰度"></a>角色清晰度</h3><p>在一段关系中分歧和冲突产生的常见原因是角色模糊。</p><h3 id="目标设定"><a href="#目标设定" class="headerlink" title="目标设定"></a>目标设定</h3><p>目标设定应当遵循<em>SMART</em>原则。</p><ul><li>避免设定过多目标</li><li>避免设定负向目标</li><li>设定短期和长期目标以及过程目标和成绩目标</li><li>定期重审目标</li></ul><h3 id="合同-协议"><a href="#合同-协议" class="headerlink" title="合同/协议"></a>合同/协议</h3><p>使用行为合约和书面协议。</p><h2 id="第-2-章-习题集"><a href="#第-2-章-习题集" class="headerlink" title="第 2 章 - 习题集"></a>第 2 章 - 习题集</h2><h3 id="1-对于刚开始参加运动方案的个体而言，最重要的因素是什么？"><a href="#1-对于刚开始参加运动方案的个体而言，最重要的因素是什么？" class="headerlink" title="1. 对于刚开始参加运动方案的个体而言，最重要的因素是什么？"></a>1. 对于刚开始参加运动方案的个体而言，最重要的因素是什么？</h3><ol><li>家庭和朋友的大力支持</li><li>运动设施的便利性</li><li>与运动有关的行为改变意愿度</li><li>与私人教练联络</li></ol><p>错误选项（1），正确答案（3）。真正的动机都来源于内心。</p><h3 id="4-为了确保客户坚持参加训练，私人教练最好采用下列哪种策略？"><a href="#4-为了确保客户坚持参加训练，私人教练最好采用下列哪种策略？" class="headerlink" title="4. 为了确保客户坚持参加训练，私人教练最好采用下列哪种策略？"></a>4. 为了确保客户坚持参加训练，私人教练最好采用下列哪种策略？</h3><ol><li>为客户设计运动方案，这样客户就只训练，而不会对运动本身想太多</li><li>通过内在动机因素对客户进行激励，以提升其自我效能</li><li>鼓励客户独立安排运动方案，从而促进客户提升内在动机</li><li>主要通过指引（而非教育）建立自己的运动教学风格</li></ol><p>错误选项（2），正确答案（3）。教练不是通过“内在动机”对客户进行激励的。教练的目的是<strong>提升内在动机</strong>。</p><h3 id="9-在监督式环境中运动，最可能与运动坚持水平无关的因素是？"><a href="#9-在监督式环境中运动，最可能与运动坚持水平无关的因素是？" class="headerlink" title="9. 在监督式环境中运动，最可能与运动坚持水平无关的因素是？"></a>9. 在监督式环境中运动，最可能与运动坚持水平无关的因素是？</h3><ol><li>教育</li><li>年龄</li><li>收入</li><li>性别</li></ol><p>错误选项（3），正确答案（2）。其余几个选项都有相关。</p><h3 id="11-坚持的定义为：一种将行为赋予方向和目的的心理驱动力。"><a href="#11-坚持的定义为：一种将行为赋予方向和目的的心理驱动力。" class="headerlink" title="11. 坚持的定义为：一种将行为赋予方向和目的的心理驱动力。"></a>11. 坚持的定义为：一种将行为赋予方向和目的的心理驱动力。</h3><ol><li>正确</li><li>错误</li></ol><p>错误选项（1），正确答案（2）。<strong>坚持</strong>是积极主动地参加运动方案；<strong>激励</strong>则是心理驱动力。</p><h3 id="13-身体活动的三种主要潜在决定因素不包括哪一项？"><a href="#13-身体活动的三种主要潜在决定因素不包括哪一项？" class="headerlink" title="13. 身体活动的三种主要潜在决定因素不包括哪一项？"></a>13. 身体活动的三种主要潜在决定因素不包括哪一项？</h3><ol><li>个人特质</li><li>身体特质</li><li>环境因素</li><li>体育活动因素</li></ol><p>错误选项（1），正确答案（2）。其中1、3、4是体育活动的潜在决定因素。</p><h3 id="18-下列术语种，哪一项的定义为：相信自己有能力成功开始并坚持某种行为？"><a href="#18-下列术语种，哪一项的定义为：相信自己有能力成功开始并坚持某种行为？" class="headerlink" title="18. 下列术语种，哪一项的定义为：相信自己有能力成功开始并坚持某种行为？"></a>18. 下列术语种，哪一项的定义为：相信自己有能力成功开始并坚持某种行为？</h3><ol><li>内在激励</li><li>自我效能</li><li>外在激励</li><li>心里控制源</li></ol><p>错误选项（1），正确答案（2）。注意这是“效能”的定义。</p><hr><h1 id="第-3-章-沟通和教学技巧"><a href="#第-3-章-沟通和教学技巧" class="headerlink" title="第 3 章 - 沟通和教学技巧"></a>第 3 章 - 沟通和教学技巧</h1><h1 id="第-4-章-行为改变与健康心理学基础"><a href="#第-4-章-行为改变与健康心理学基础" class="headerlink" title="第 4 章 - 行为改变与健康心理学基础"></a>第 4 章 - 行为改变与健康心理学基础</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第-2-章-激励和坚持原则&quot;&gt;&lt;a href=&quot;#第-2-章-激励和坚持原则&quot; class=&quot;headerlink&quot; title=&quot;第 2 章 - 激励和坚持原则&quot;&gt;&lt;/a&gt;第 2 章 - 激励和坚持原则&lt;/h1&gt;&lt;p&gt;只有约20%的美国成人同时符合有氧活动和肌肉
      
    
    </summary>
    
    
      <category term="健身" scheme="https://lilei.pro/tags/%E5%81%A5%E8%BA%AB/"/>
    
      <category term="ACE-CPT" scheme="https://lilei.pro/tags/ACE-CPT/"/>
    
  </entry>
  
  <entry>
    <title>ACE-PTM 第 I 部分 简介</title>
    <link href="https://lilei.pro/2019/07/14/ace-cpt-part-1/"/>
    <id>https://lilei.pro/2019/07/14/ace-cpt-part-1/</id>
    <published>2019-07-14T09:32:41.000Z</published>
    <updated>2019-07-28T15:12:04.692Z</updated>
    
    <content type="html"><![CDATA[<h1 id="笔记前言"><a href="#笔记前言" class="headerlink" title="笔记前言"></a>笔记前言</h1><blockquote><p>作为学习 <a href="https://www.acefitness.org/" target="_blank" rel="noopener">ACE-CPT</a> 的读书笔记，这一系列将按章节分为七个部分。</p></blockquote><h2 id="第-I-部分-简介"><a href="#第-I-部分-简介" class="headerlink" title="第 I 部分 - 简介"></a>第 I 部分 - 简介</h2><p>介绍私人教练的角色定位与执业范围，哪些事情应该做，哪些事情可以做，哪些事情不能做。</p><h2 id="第-II-部分-领导和实施"><a href="#第-II-部分-领导和实施" class="headerlink" title="第 II 部分 - 领导和实施"></a>第 II 部分 - 领导和实施</h2><p>从沟通、激励会员角度给出指导意见，是贯彻执教过程始终的中心思想，帮助教练与会员建立相互信赖的关系。</p><h2 id="第-III-部分-ACE-整合式健身训练模式"><a href="#第-III-部分-ACE-整合式健身训练模式" class="headerlink" title="第 III 部分 - ACE 整合式健身训练模式"></a>第 III 部分 - ACE 整合式健身训练模式</h2><p>即 ACE-IFT 训练模式，是 ACE 独家的训练计划与模式，先评估，然后在稳定性、抗阻、心肺等多方面分别给出指导。</p><h2 id="第-IV-部分-特殊运动计划制定主题"><a href="#第-IV-部分-特殊运动计划制定主题" class="headerlink" title="第 IV 部分 - 特殊运动计划制定主题"></a>第 IV 部分 - 特殊运动计划制定主题</h2><p>讲解身心运动以及特殊人群的运动方法。</p><h2 id="第-V-部分-损伤预防和急救"><a href="#第-V-部分-损伤预防和急救" class="headerlink" title="第 V 部分 - 损伤预防和急救"></a>第 V 部分 - 损伤预防和急救</h2><p>常见损伤对运动过程的影响，以及遭遇损伤时候的紧急程序。</p><h2 id="第-VI-部分-职业和法律责任以及业务策略"><a href="#第-VI-部分-职业和法律责任以及业务策略" class="headerlink" title="第 VI 部分 - 职业和法律责任以及业务策略"></a>第 VI 部分 - 职业和法律责任以及业务策略</h2><p>私人教练职业的法律指南。</p><h2 id="第-VII-部分-补充"><a href="#第-VII-部分-补充" class="headerlink" title="第 VII 部分 - 补充"></a>第 VII 部分 - 补充</h2><p>涵盖不属于上述章节的内容。</p><hr><h1 id="第-1-章-私人教练的角色和执业范围"><a href="#第-1-章-私人教练的角色和执业范围" class="headerlink" title="第 1 章 - 私人教练的角色和执业范围"></a>第 1 章 - 私人教练的角色和执业范围</h1><h2 id="健康照护联盟"><a href="#健康照护联盟" class="headerlink" title="健康照护联盟"></a>健康照护联盟</h2><p>健康照护联盟由医疗保健专业人员组成，他们通过执照、注册和/或许可证获得认可，并提供相关服务以识别、预防和治疗疾病和病症。</p><p>团队成员构成如下：</p><ul><li>针灸师</li><li>脊椎按摩师</li><li>营养师</li><li>自然疗法医生</li><li>护士</li><li>医生</li><li>行为医师</li><li>物理治疗师</li><li>职业物理治疗师</li><li>运动教练</li></ul><h2 id="ACE-私人教练认证"><a href="#ACE-私人教练认证" class="headerlink" title="ACE 私人教练认证"></a>ACE 私人教练认证</h2><p>专业能力门槛被称为从事某种行业所需的“<strong>最低能力</strong>”。对于专业人员而言，执照可以将其与未证明自己处于同一能力水平的人区分开。通过获得 ACE 私人教练认证，专业人员证明了其在以下方面的能力：应用相关知识在各种实际情况下做出安全有效的运动计划决策，同时最大限度地减少客户风险和伤害。</p><h3 id="“执业范围”的定义"><a href="#“执业范围”的定义" class="headerlink" title="“执业范围”的定义"></a>“执业范围”的定义</h3><h3 id="ACE-认证的私人教练的执业范围"><a href="#ACE-认证的私人教练的执业范围" class="headerlink" title="ACE 认证的私人教练的执业范围"></a>ACE 认证的私人教练的执业范围</h3><p>根据 <strong>IDEA 私人健身教练的执业范围</strong> 表格，私人教练不可以做以下事情：</p><ul><li>进行诊断</li><li>开处方</li><li>为客户规定饮食或推荐具体的补充剂</li><li>治疗伤害或疾病</li><li>监督医疗转介绍客户的进展</li><li>提供康复服务</li><li>提供咨询</li><li>与患者合作</li></ul><h3 id="ACE-认证的私人教练的知识、技能和能力"><a href="#ACE-认证的私人教练的知识、技能和能力" class="headerlink" title="ACE 认证的私人教练的知识、技能和能力"></a>ACE 认证的私人教练的知识、技能和能力</h3><p>ACE 私人教练考试包括以下领域</p><ul><li>客户面谈和评估 - 31%</li><li>计划设计和执行 - 33%</li><li>进阶和调整 - 19%</li><li>专业行为、安全性和风险管理 - 17%</li></ul><h4 id="教育和经验"><a href="#教育和经验" class="headerlink" title="教育和经验"></a>教育和经验</h4><p>建议应试者流出平均三至四个月的学习时间来充分准备私人教练认证考试。</p><h3 id="执业责任和道德规范"><a href="#执业责任和道德规范" class="headerlink" title="执业责任和道德规范"></a>执业责任和道德规范</h3><p>ACE 制定了<strong>ACE 道德准则</strong>，所有 ACE 认证的专业人员和应试者都必须熟悉并遵守道德准则和专业时间和纪律程序。</p><h4 id="ACE-专业实践和纪律程序"><a href="#ACE-专业实践和纪律程序" class="headerlink" title="ACE 专业实践和纪律程序"></a>ACE 专业实践和纪律程序</h4><h4 id="执照期和续期"><a href="#执照期和续期" class="headerlink" title="执照期和续期"></a>执照期和续期</h4><p>ACE 认证有效期为<strong>两年</strong>，从获得认证之日起开始计算，于当月最后一天到期。续期则需要完成至少 20 小时的持续教育学分（2.0 CEC），并持有当前的<strong>心肺复苏（CPR）</strong>证书。如果持证人生活在北美，则必须能够正确使用<strong>自动外部除颤器（AED）</strong>。</p><p>ACE 为超过截止期限的专业人员的续期留出六个月的延长期限。</p><h4 id="客户隐私"><a href="#客户隐私" class="headerlink" title="客户隐私"></a>客户隐私</h4><h4 id="转介绍"><a href="#转介绍" class="headerlink" title="转介绍"></a>转介绍</h4><h4 id="补充剂和其他营养相关问题"><a href="#补充剂和其他营养相关问题" class="headerlink" title="补充剂和其他营养相关问题"></a>补充剂和其他营养相关问题</h4><p>补充剂<strong>不受美国食品和药物管理局（FDA）管制，因此无法保证起强度、纯度、安全性和效果。</strong>私人教练仅仅有资格向客户推荐补充剂，而没有资格推荐药物或开具药物。</p><h4 id="所提供服务超出执业范围的后果"><a href="#所提供服务超出执业范围的后果" class="headerlink" title="所提供服务超出执业范围的后果"></a>所提供服务超出执业范围的后果</h4><h2 id="由-NCCA-进行的健康照护联盟资格证书认证"><a href="#由-NCCA-进行的健康照护联盟资格证书认证" class="headerlink" title="由 NCCA 进行的健康照护联盟资格证书认证"></a>由 NCCA 进行的健康照护联盟资格证书认证</h2><h3 id="健身与健康行业的认可"><a href="#健身与健康行业的认可" class="headerlink" title="健身与健康行业的认可"></a>健身与健康行业的认可</h3><h3 id="教育界的认可"><a href="#教育界的认可" class="headerlink" title="教育界的认可"></a>教育界的认可</h3><p>ACE 教育伙伴计划提供四门独立的大学课程：</p><ul><li>私教</li><li>团体运动</li><li>健康教练</li><li>特殊人群运动课程</li></ul><h3 id="劳工部的认可"><a href="#劳工部的认可" class="headerlink" title="劳工部的认可"></a>劳工部的认可</h3><h2 id="职业发展"><a href="#职业发展" class="headerlink" title="职业发展"></a>职业发展</h2><h3 id="持续教育"><a href="#持续教育" class="headerlink" title="持续教育"></a>持续教育</h3><h4 id="高级知识"><a href="#高级知识" class="headerlink" title="高级知识"></a>高级知识</h4><h4 id="专业化"><a href="#专业化" class="headerlink" title="专业化"></a>专业化</h4><h3 id="学位"><a href="#学位" class="headerlink" title="学位"></a>学位</h3><h3 id="额外的健身执照"><a href="#额外的健身执照" class="headerlink" title="额外的健身执照"></a>额外的健身执照</h3><h3 id="健康照护联盟的新专业领域"><a href="#健康照护联盟的新专业领域" class="headerlink" title="健康照护联盟的新专业领域"></a>健康照护联盟的新专业领域</h3><hr><h1 id="第-1-章-习题集"><a href="#第-1-章-习题集" class="headerlink" title="第 1 章 - 习题集"></a>第 1 章 - 习题集</h1><h2 id="6-下列哪一项属于-ACE-认证私人教练的执业范围？"><a href="#6-下列哪一项属于-ACE-认证私人教练的执业范围？" class="headerlink" title="6. 下列哪一项属于 ACE 认证私人教练的执业范围？"></a>6. 下列哪一项属于 ACE 认证私人教练的执业范围？</h2><ol><li>帮助客户更好地了解食物分量与健康食品，从而帮助他们做出更明智的选择</li><li>为客户提供 4 周食谱与购物清单，帮助他们走上健康饮食的正轨</li><li>回顾过去 24 小时的饮食情况，帮助客户了解自己缺少哪些微量元素</li><li>就惊喜代谢率（RMR）以及热量摄入要小于 RMR 等知识对客户进行教育，帮助客户减轻体重</li></ol><p>错误选项（4），正确答案（1）。关键点在于选择权由客户持有，而非私人教练做出选择 or 决定。</p><h2 id="9-关于私人教练向客户推荐营养补充剂，下列叙述最恰当的一项是"><a href="#9-关于私人教练向客户推荐营养补充剂，下列叙述最恰当的一项是" class="headerlink" title="9. 关于私人教练向客户推荐营养补充剂，下列叙述最恰当的一项是"></a>9. 关于私人教练向客户推荐营养补充剂，下列叙述最恰当的一项是</h2><ol><li>只能向客户推荐自己已投职业责任险的补充剂</li><li>如果私人教练未持有注册营养师或医学博士学位等其他帧数，则不具有向他人推荐补充剂的合法资质</li><li>私人教练应接受专门的知识培训后才能向客户推荐营养补充剂</li><li>由于服用补充剂与其他药物可能会引起并发症，私人教练只能向客户推荐植物性补充剂</li></ol><p>错误选项（3），正确答案（2）。“专门的知识培训”不够精确。</p><h2 id="15-“执业范围”的定义不包括哪一项？"><a href="#15-“执业范围”的定义不包括哪一项？" class="headerlink" title="15. “执业范围”的定义不包括哪一项？"></a>15. “执业范围”的定义不包括哪一项？</h2><ol><li>专业健身人员在特定领域可提供的合法服务范围</li><li>在工作场所必须遵守的职业道德准则</li><li>可以供私教服务的场所</li><li>必须遵守的指南或参数标准</li></ol><p>错误选项（3），正确答案（2）。道德是道德，业务是业务。</p><h2 id="20-如果客户提到自己参加周末网球比赛后肌肉酸痛，教练给予的最恰当的回应是？"><a href="#20-如果客户提到自己参加周末网球比赛后肌肉酸痛，教练给予的最恰当的回应是？" class="headerlink" title="20. 如果客户提到自己参加周末网球比赛后肌肉酸痛，教练给予的最恰当的回应是？"></a>20. 如果客户提到自己参加周末网球比赛后肌肉酸痛，教练给予的最恰当的回应是？</h2><ol><li>推荐客户服用抗炎类非处方药</li><li>建议客户在下次比赛前服用肌酸补充剂</li><li>对深层组织进行按摩处理，帮助缓解肌肉酸痛</li><li>与客户探讨对患处进行冷敷的正确方法</li></ol><p>错误选项（3），正确答案（4）。其余选项超出执业范围。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;笔记前言&quot;&gt;&lt;a href=&quot;#笔记前言&quot; class=&quot;headerlink&quot; title=&quot;笔记前言&quot;&gt;&lt;/a&gt;笔记前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;作为学习 &lt;a href=&quot;https://www.acefitness.org/&quot; target
      
    
    </summary>
    
    
      <category term="健身" scheme="https://lilei.pro/tags/%E5%81%A5%E8%BA%AB/"/>
    
      <category term="ACE-CPT" scheme="https://lilei.pro/tags/ACE-CPT/"/>
    
  </entry>
  
</feed>
