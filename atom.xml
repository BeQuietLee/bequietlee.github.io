<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>柘个角落</title>
  <icon>https://www.gravatar.com/avatar/bd80dd1283cd0ce8323c050b40cb6f38</icon>
  <subtitle>IF YOU WANT SOMETHING, GO GET IT. PERIOD.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lilei.pro/"/>
  <updated>2020-02-28T01:06:56.692Z</updated>
  <id>https://lilei.pro/</id>
  
  <author>
    <name>Li Lei</name>
    <email>bequietlee@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>本周知识积累 2020/02 RecyclerView布局预览；Uri对象常用操作；轻松创建MainDispatcher与Deferred</title>
    <link href="https://lilei.pro/2020/02/28/weekly-2020-02-01/"/>
    <id>https://lilei.pro/2020/02/28/weekly-2020-02-01/</id>
    <published>2020-02-28T01:00:37.000Z</published>
    <updated>2020-02-28T01:06:56.692Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>In case of I don’t see you. Good afternoon, good evening and good night.</p></blockquote><h2 id="在xml预览中查看RecyclerView布局"><a href="#在xml预览中查看RecyclerView布局" class="headerlink" title="在xml预览中查看RecyclerView布局"></a>在xml预览中查看RecyclerView布局</h2><p>在功能开发的前期，我们做好布局后，希望可以在IDE的xml预览里查看效果。在使用到RecyclerView时，看到的往往是item 0、item 1、item 2这样的占位文字，如下左图所示。如果我们想查看设计好的item布局（如下右），应当如何做呢？</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/20200228_weekly/RecyclerView预览.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>可以使用<strong>tools</strong>的命名空间。</p><blockquote><p><code>tools</code> namespace enables design-time features (such as which layout to show in a fragment) or compile-time behaviors (such as which shrinking mode to apply to your XML resources) It is really powerful feature that is developing and allows you not compile code every time to see changes.</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 样例代码 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- AndroidX --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.recyclerview.widget.RecyclerView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:layoutManager</span>=<span class="string">"androidx.recyclerview.widget.GridLayoutManager"</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line">&lt;!-- support --&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">android.support.v7.widget.RecyclerView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:layoutManager</span>=<span class="string">"android.support.v7.widget.GridLayoutManager"</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line">    &lt;!-- common --&gt;</span><br><span class="line">    xmlns:android="http://schemas.android.com/apk/res/android"</span><br><span class="line">    xmlns:tools="http://schemas.android.com/tools"</span><br><span class="line">    android:layout_width="match_parent"</span><br><span class="line">    android:layout_height="match_parent"</span><br><span class="line">    tools:itemCount="5"</span><br><span class="line">    tools:listitem="@layout/item_video"</span><br><span class="line">    tools:orientation="horizontal"</span><br><span class="line">    tools:scrollbars="horizontal"</span><br><span class="line">    tools:spanCount="2" /&gt;</span><br></pre></td></tr></table></figure><p><strong>参考</strong> <a href="https://stackoverflow.com/questions/29929963/is-there-a-way-to-show-a-preview-of-a-recyclerviews-contents-in-the-android-stu" target="_blank" rel="noopener">https://stackoverflow.com/questions/29929963/is-there-a-way-to-show-a-preview-of-a-recyclerviews-contents-in-the-android-stu</a></p><h2 id="Uri对象的基本操作"><a href="#Uri对象的基本操作" class="headerlink" title="Uri对象的基本操作"></a>Uri对象的基本操作</h2><p>不属于新知识，做网络请求开发时经常会遇到，以前每次碰到时都是现查的，不知道是不是年纪大了记忆力下降的缘故 :-( 这里整理作为备忘。</p><p>Uri是不可变对象，构建出来后即不可修改。</p><p>Uri采用构建器模式进行构建。</p><p>初始化一个Uri.Builder对象：<code>Uri.parse(SAMPLE_URL).buildUpon()</code>，如下例</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> uriBuilder = Uri.parse(<span class="string">"https://www.google.com"</span>).buildUpon()</span><br></pre></td></tr></table></figure><p>进行UTF8编码：<code>encode(String s)</code></p><p>增加参数：<code>appendQueryParameter(&quot;key&quot;, &quot;value&quot;)</code></p><p>分开设置协议和主机：<code>scheme(&quot;https&quot;)</code>，<code>authority(&quot;www.google.com&quot;)</code></p><p>举例说明，如果想要构建如下的URL地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.myawesomesite.com/turtles/types?type=1&amp;sort=relevance#section-name</span><br></pre></td></tr></table></figure><p>则使用以下代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Uri.Builder builder = <span class="keyword">new</span> Uri.Builder();</span><br><span class="line">builder.scheme(<span class="string">"https"</span>)</span><br><span class="line">    .authority(<span class="string">"www.myawesomesite.com"</span>)</span><br><span class="line">    .appendPath(<span class="string">"turtles"</span>)</span><br><span class="line">    .appendPath(<span class="string">"types"</span>)</span><br><span class="line">    .appendQueryParameter(<span class="string">"type"</span>, <span class="string">"1"</span>)</span><br><span class="line">    .appendQueryParameter(<span class="string">"sort"</span>, <span class="string">"relevance"</span>)</span><br><span class="line">    .fragment(<span class="string">"section-name"</span>);</span><br><span class="line">String myUrl = builder.build().toString();</span><br></pre></td></tr></table></figure><p><strong>参考</strong></p><ul><li><a href="https://developer.android.com/reference/android/net/Uri" target="_blank" rel="noopener">https://developer.android.com/reference/android/net/Uri</a></li><li><a href="https://developer.android.com/reference/android/net/Uri.Builder" target="_blank" rel="noopener">https://developer.android.com/reference/android/net/Uri.Builder</a></li></ul><h2 id="轻松创建MainDispatcher与Deferred"><a href="#轻松创建MainDispatcher与Deferred" class="headerlink" title="轻松创建MainDispatcher与Deferred"></a>轻松创建MainDispatcher与Deferred</h2><h3 id="构建主线程调度器"><a href="#构建主线程调度器" class="headerlink" title="构建主线程调度器"></a>构建主线程调度器</h3><p>Dispatcher/调度器是协程上下文里很重要的一个元素，它决定了代码运行在哪个线程中。尤其是做Android开发时，经常需要把UI操作发送给主线程进行，像ViewModel就为我们提供了MainDispatcher。</p><p>如果当前没有MainDispatcher，需要手动创建时，要怎么方便地进行构建呢？Kotlin在<code>Handler</code>类上新增了一个扩展函数<code>asCoroutineDispatcher()</code>，用法如下</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> mainDispatcher = Handler(Looper.getMainLooper()).asCoroutineDispatcher()</span><br></pre></td></tr></table></figure><p>只要通过MainLooper就可以构建出主线程调度器了，是不是很方便。</p><h3 id="构建即时Deferred对象"><a href="#构建即时Deferred对象" class="headerlink" title="构建即时Deferred对象"></a>构建即时Deferred对象</h3><p>Deferred是一种泛型，在协程中用于表示耗时操作结果，当我们需要取值时，通过<code>Deferred.await()</code>即可。它有点类似Java中的<code>Future</code>，表示一种“进行中的操作，即将返回结果”。</p><p>构建Deferred对象有两种方法，一种是通过<code>async</code>的携程构建器，另一种是今天要介绍的方法，对于已知的值（比如 10），可以直接用<code>CompletableDeferred(10)</code>来创建一个Deferred对象，你可以直接把它用在任何需要Deferred对象的地方，取值时则会直接返回10。</p><p><strong>参考</strong> <a href="https://stackoverflow.com/questions/53273361/how-to-return-deferred-with-the-instant-results" target="_blank" rel="noopener">https://stackoverflow.com/questions/53273361/how-to-return-deferred-with-the-instant-results</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;In case of I don’t see you. Good afternoon, good evening and good night.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;在xml预览中查看RecyclerView布局&quot;&gt;
      
    
    </summary>
    
    
      <category term="Android" scheme="https://lilei.pro/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 协程基础课 03.揭开协程上下文CoroutineContext的神秘面纱</title>
    <link href="https://lilei.pro/2019/12/13/kotlin-coroutines-03/"/>
    <id>https://lilei.pro/2019/12/13/kotlin-coroutines-03/</id>
    <published>2019-12-13T14:40:28.000Z</published>
    <updated>2019-12-13T14:41:37.280Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>限定目的，能使人生变得简洁。</p></blockquote><h1 id="协程上下文是个啥？"><a href="#协程上下文是个啥？" class="headerlink" title="协程上下文是个啥？"></a>协程上下文是个啥？</h1><p>CoroutineContext，译作“协程上下文”，在协程中是非常重要的概念。你可能会比较好奇，为什么之前都没有注意到它的存在呢？因为协程框架已经为我们包装得非常好了。让我们来看一下<code>launch</code>和<code>async</code>两个函数的签名：</p><h2 id="launch"><a href="#launch" class="headerlink" title="launch"></a>launch</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">launch</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    context: <span class="type">CoroutineContext</span> = EmptyCoroutineContext,</span></span></span><br><span class="line"><span class="function"><span class="params">    start: <span class="type">CoroutineStart</span> = CoroutineStart.DEFAULT,</span></span></span><br><span class="line"><span class="function"><span class="params">    onCompletion: <span class="type">CompletionHandler</span>? = <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.()</span></span> -&gt; <span class="built_in">Unit</span></span><br><span class="line">): Job</span><br></pre></td></tr></table></figure><h2 id="async"><a href="#async" class="headerlink" title="async"></a>async</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> CoroutineScope.<span class="title">async</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    context: <span class="type">CoroutineContext</span> = EmptyCoroutineContext,</span></span></span><br><span class="line"><span class="function"><span class="params">    start: <span class="type">CoroutineStart</span> = CoroutineStart.DEFAULT,</span></span></span><br><span class="line"><span class="function"><span class="params">    onCompletion: <span class="type">CompletionHandler</span>? = <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.()</span></span> -&gt; T</span><br><span class="line">): Deferred&lt;T&gt;</span><br></pre></td></tr></table></figure><p>可以看到这两个函数的第一个参数都是<code>CoroutineContext</code>类型的。所有协程构建函数（如<code>launch</code>和<code>async</code>）都是以<code>CoroutineScope</code>的扩展函数的形式被定义的，而<code>CoroutineScope</code>接口唯一的成员就是<code>CoroutineContext</code>类型。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CoroutineScope</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The context of this scope.</span></span><br><span class="line"><span class="comment">     * Context is encapsulated by the scope and used for implementation of coroutine builders that are extensions on the scope.</span></span><br><span class="line"><span class="comment">     * Accessing this property in general code is not recommended for any purposes except accessing the [Job] instance for advanced usages.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * By convention, should contain an instance of a [job][Job] to enforce structured concurrency.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> coroutineContext: CoroutineContext</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>协程上下文是协程必备的组成部分，它管理了协程的线程绑定、生命周期、异常处理和调试功能，接下来我们分析上下文具体的结构组成。</p><h1 id="协程上下文的结构"><a href="#协程上下文的结构" class="headerlink" title="协程上下文的结构"></a>协程上下文的结构</h1><blockquote><p>It is an indexed set of Element instances. An indexed set is a mix between a set and a map. Every element in this set has a unique Key. Keys are compared by reference.</p></blockquote><p>CoroutineContext接口跟Map很类似，具有如下特点：</p><ul><li>有序Map</li><li>Key唯一</li><li>类型安全</li></ul><p>##跟Map类似，为什么不直接用Map</p><p>那么我们为什么不直接用Map来实现呢？参考下面一段代码，它用Map实现了类似CoroutineContext的功能</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typealias CoroutineContext = Map&lt;CoroutineContext.Key&lt;*&gt;, CoroutineContext.Element&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(key: <span class="type">CoroutineContext</span>.<span class="type">Key</span>&lt;*&gt;)</span></span>: CoroutineContext.Element?</span><br></pre></td></tr></table></figure><p>如果使用这种实现，我们每次调用<code>get</code>之后，必须用显式的类型转换，才能得到想要的<code>Element</code>类型。而CoroutineContext则通过泛型（CoroutineContext的Key即带有类型信息）为我们解决了类型转换的痛点：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;E : Element&gt;</span> <span class="title">get</span><span class="params">(key: <span class="type">Key</span>&lt;<span class="type">E</span>&gt;)</span></span>: E?</span><br></pre></td></tr></table></figure><h1 id="在CoroutineContext上可进行的操作"><a href="#在CoroutineContext上可进行的操作" class="headerlink" title="在CoroutineContext上可进行的操作"></a>在CoroutineContext上可进行的操作</h1><p>CoroutineContext并未实现标准的集合接口，因此无法使用<code>iterator()</code>等集合标准操作。它有独特的一套操作。</p><h2 id="“拼装”上下文对象"><a href="#“拼装”上下文对象" class="headerlink" title="“拼装”上下文对象"></a>“拼装”上下文对象</h2><p>对CoroutineContext来说，最重要的操作是<code>plus</code>，<code>plus</code>操作用于把两个CoroutineContext对象合并成一个。合并时有一个优先级规则：<code>plus</code>右侧对象的属性会覆盖左侧对象中的同名属性。</p><blockquote><p>[The plus operator] returns a context containing elements from this context and elements from other context. The elements from this context with the same key as in the other one are dropped.</p></blockquote><h2 id="Element即是CoroutineContext"><a href="#Element即是CoroutineContext" class="headerlink" title="Element即是CoroutineContext"></a>Element即是CoroutineContext</h2><p>我们知道CoroutineContext中的Value是Element，其实Element本身也是继承于CoroutineContext。这样做的好处是，当我们只有一个CoroutineContext.Element对象时，也可以把它作为一个CoroutineContext来使用，这种一般称之为<strong>singleton context</strong>。</p><h2 id="空对象"><a href="#空对象" class="headerlink" title="空对象"></a>空对象</h2><p>除了<strong>singleton context</strong>，还有一种特殊的上下文对象，<code>EmptyCoroutineContext</code>。它不含有任何Element，因此，当使用<code>plus</code>连接符连接一个<code>EmptyCoroutineContext</code>和另一个上下文对象时，总是得到与另一个上下文对象相同的对象。</p><h1 id="认识一下那些Elements"><a href="#认识一下那些Elements" class="headerlink" title="认识一下那些Elements"></a>认识一下那些Elements</h1><p>如果我们想要查看CoroutineContext里都可以包含哪些Elements，可以搜索CoroutineContext.Key接口的实现，因为CoroutineContext是一个保存类型确定元素的Map。经过搜索后，我们发现以下几个典型Element：</p><h2 id="指定执行线程：ContinuationInterceptor"><a href="#指定执行线程：ContinuationInterceptor" class="headerlink" title="指定执行线程：ContinuationInterceptor"></a>指定执行线程：ContinuationInterceptor</h2><p>用于处理协程挂载在线程上的逻辑，抽象类<strong>CoroutineDispatcher</strong>实现了该接口，一般常用的Dispatcher都会继承于<strong>CoroutineDispatcher</strong>。</p><h2 id="层级关系管理：Job"><a href="#层级关系管理：Job" class="headerlink" title="层级关系管理：Job"></a>层级关系管理：Job</h2><p>用于管理任务层级，处理任务父子关系。</p><ul><li>手动终止父Job时，其中的子Job也被终止</li><li>当所有子Job运行结束时，父Job才可以运行结束</li></ul><h2 id="处理异常：CoroutineExceptionHandler"><a href="#处理异常：CoroutineExceptionHandler" class="headerlink" title="处理异常：CoroutineExceptionHandler"></a>处理异常：CoroutineExceptionHandler</h2><p>如果你在构建协程时使用了无法传递异常的构建器，如<code>launch</code>和<code>actor</code>，当异常发生时，需要有一个异常处理器来处理它。<code>CoroutineExceptionHandler</code>就是充当这样的异常处理器。</p><h2 id="名字：CoroutineName"><a href="#名字：CoroutineName" class="headerlink" title="名字：CoroutineName"></a>名字：CoroutineName</h2><p>协程的别名，一般是用于调试，以区分多个协程。</p><p>上述Element内部都以伴生对象的形式定义了相应的Key，可以通过<code>coroutineContext[element type name]</code>的形式方便地获取到Element对象。比如<code>coroutineContext[Job]</code>会返回Job或者null（如果没有Job）。</p><h1 id="协程构建过程中的CoroutineContext"><a href="#协程构建过程中的CoroutineContext" class="headerlink" title="协程构建过程中的CoroutineContext"></a>协程构建过程中的CoroutineContext</h1><p>前面讲过<code>CoroutineScope</code>实际上是一个<code>CoroutineContext</code>的封装，当我们需要启动一个协程时，会在<code>CoroutineScope</code>的实例上调用构建函数，如<code>async</code>和<code>launch</code>。在构建函数中，一共出现了3个CoroutineContext：</p><ul><li><strong>inherited context</strong>：从<code>CoroutineScope</code>中继承得到的上下文对象</li><li><strong>context argument</strong>：构建函数中传入的第一个参数，默认为<code>EmptyCoroutineContext</code></li><li><strong>coroutine context</strong>：挂起代码块（lambda函数）运行时的上下文对象</li></ul><p>如果我们查看协程构建函数<code>async</code>和<code>launch</code>的源码，会发现它们第一行都是如下代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> newContext = newCoroutineContext(context)</span><br></pre></td></tr></table></figure><p>再进一步查看：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CoroutineContext.kt</span></span><br><span class="line"><span class="meta">@ExperimentalCoroutinesApi</span></span><br><span class="line"><span class="keyword">public</span> actual <span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">newCoroutineContext</span><span class="params">(context: <span class="type">CoroutineContext</span>)</span></span>: CoroutineContext &#123;</span><br><span class="line">    <span class="keyword">val</span> combined = coroutineContext + context</span><br><span class="line">    <span class="keyword">val</span> debug = <span class="keyword">if</span> (DEBUG) combined + CoroutineId(COROUTINE_ID.incrementAndGet()) <span class="keyword">else</span> combined</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (combined !== Dispatchers.Default &amp;&amp; combined[ContinuationInterceptor] == <span class="literal">null</span>)</span><br><span class="line">        debug + Dispatchers.Default <span class="keyword">else</span> debug</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就比较清晰了：构建器函数内部进行了一个CoroutineContext拼接操作，plus的左值是<code>CoroutineScope</code>内部的<code>CoroutineContext</code>，右值是作为构建函数参数的<code>CoroutineContext</code>。根据我们前面讲到的拼接操作，左值具有更高的优先级。</p><p>此外，抽象类<code>AbstractCoroutineScope</code>实现了<code>CoroutineScope</code>和<code>Job</code>接口，大部分CoroutineScope的实现都继承自<code>AbstractCoroutineScope</code>，意味着他们同时也是一个<code>Job</code>。可以得到：<strong>coroutine context = parent context + coroutine job</strong>。</p><h1 id="Elements默认值"><a href="#Elements默认值" class="headerlink" title="Elements默认值"></a>Elements默认值</h1><p>对于上述4个Elements，如果既没有显示指明，则会取相应的默认值：</p><ul><li>ContinuationInterceptor：默认值为<code>Dispatchers.Default</code>，基于线程池实现，线程数目=CPU数目，且最少为2支</li><li>Job：默认值为null，在这种情况下，协程是孤儿（没有父协程，无法被父协程取消，例如<code>GlobalScope</code>）</li><li>CoroutineExceptionHandler：它的情况比较复杂，当异常发生时，若没有指定<code>CoroutineExceptionHandler</code>，会使用全局的异常处理器，在全局异常处理器中调用当前线程的<code>uncaughtExceptionHandler</code>。代码如下：</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CoroutineExceptionHandlerImpl.kt</span></span><br><span class="line"><span class="keyword">internal</span> actual <span class="function"><span class="keyword">fun</span> <span class="title">handleCoroutineExceptionImpl</span><span class="params">(context: <span class="type">CoroutineContext</span>, exception: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// use additional extension handlers</span></span><br><span class="line">    <span class="keyword">for</span> (handler <span class="keyword">in</span> handlers) &#123;</span><br><span class="line">        handler.handleException(context, exception)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// use thread's handler</span></span><br><span class="line">    <span class="keyword">val</span> currentThread = Thread.currentThread()</span><br><span class="line">    currentThread.uncaughtExceptionHandler.uncaughtException(currentThread, exception)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Name：默认为“coroutine”</li></ul><p>对于上述默认值，用代码实现起来也并不复杂：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> defaultExceptionHandler = CoroutineExceptionHandler &#123; ctx, t -&gt;</span><br><span class="line">    ServiceLoader.load(</span><br><span class="line">        serviceClass, </span><br><span class="line">        serviceClass.classLoader</span><br><span class="line">    ).forEach&#123;</span><br><span class="line">        it.handleException(ctx, t)</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.currentThread().let &#123; </span><br><span class="line">        it.uncaughtExceptionHandler.uncaughtException(it, exception)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoroutineContext</span></span>(</span><br><span class="line">        <span class="keyword">val</span> continuationInterceptor: ContinuationInterceptor = </span><br><span class="line">                Dispatchers.Default,</span><br><span class="line">        <span class="keyword">val</span> parentJob: Job? = </span><br><span class="line">                <span class="literal">null</span>,</span><br><span class="line">        <span class="keyword">val</span> coroutineExceptionHandler: CoroutineExceptionHandler = </span><br><span class="line">                defaultExceptionHandler,</span><br><span class="line">        <span class="keyword">val</span> name: CoroutineName = </span><br><span class="line">                CoroutineName(<span class="string">"coroutine"</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="用例浅析"><a href="#用例浅析" class="headerlink" title="用例浅析"></a>用例浅析</h1><p>上述4个Elements中，最重要的是Dispatcher和Job两个，我们来看一些例子。</p><h2 id="Global-Scope-Context"><a href="#Global-Scope-Context" class="headerlink" title="Global Scope Context"></a>Global Scope Context</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GlobalScope.launch &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全局Scope使用全默认的4个Elements，意味着它使用<code>Dispatchers.Default</code>和为空的<code>Job</code>（无法通过父Job取消）。</p><h2 id="Fully-Qualified-Context"><a href="#Fully-Qualified-Context" class="headerlink" title="Fully Qualified Context"></a>Fully Qualified Context</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">launch(</span><br><span class="line">        Dispatchers.Main + </span><br><span class="line">                Job() + </span><br><span class="line">                CoroutineName(<span class="string">"HelloCoroutine"</span>) + </span><br><span class="line">                CoroutineExceptionHandler &#123; _, _ -&gt; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全限定Context，即全部显式指定具体值的Elements。不论你用哪一个<code>CoroutineScope</code>构建该协程，它都具有一致的表现，不会受到<code>CoroutineScoipe</code>任何影响。</p><h2 id="CoroutineScope-Context"><a href="#CoroutineScope-Context" class="headerlink" title="CoroutineScope Context"></a>CoroutineScope Context</h2><p>这里我们基于Activity生命周期实现一个CoroutineScope：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ScopedAppActivity</span>:<span class="type"></span></span></span><br><span class="line">        AppCompatActivity(),</span><br><span class="line">        CoroutineScope</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> job: Job</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> coroutineContext: CoroutineContext</span><br><span class="line">        <span class="keyword">get</span>() = job + Dispatchers.Main <span class="comment">// 注意这里使用+拼接CoroutineContext</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        job = Job()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">        job.cancel()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Dispatcher：使用<code>Dispatcher.Main</code>，以在UI线程进行绘制</li><li>Job：在<code>onCreate</code>时构建，在<code>onDestroy</code>时销毁，所有基于该CoroutineContext创建的协程，都会在Activity销毁时取消，从而避免Activity泄露的问题</li></ul><h2 id="临时指定参数"><a href="#临时指定参数" class="headerlink" title="临时指定参数"></a>临时指定参数</h2><p>前面数次提到过，CoroutineContext的参数主要有两个来源：从scope中继承+参数指定。我们可以用<code>withContext</code>便捷地指定某个参数启动子协程，例如我们想要在协程内部执行一个无法被取消的子协程：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">withContext(NonCancellable) &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="读取协程上下文参数"><a href="#读取协程上下文参数" class="headerlink" title="读取协程上下文参数"></a>读取协程上下文参数</h2><p>可以通过顶级挂起只读属性<code>coroutineContext</code>获取协程上下文参数，它位于 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/coroutine-context.html" target="_blank" rel="noopener">kotlin-stdlib / kotlin.coroutines / coroutineContext</a>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">"Running in <span class="subst">$&#123;coroutineContext[CoroutineName]&#125;</span>"</span>)</span><br></pre></td></tr></table></figure><h2 id="Nested-Context"><a href="#Nested-Context" class="headerlink" title="Nested Context"></a>Nested Context</h2><p>内嵌上下文切换是指：在协程A内部构建协程B时，B会自动继承A的Dispatcher，如果没有注意这一点，很容易发生诸如“主线程执行耗时操作”的错误。</p><p>我们可以在调用<code>async</code>时加入Dispatcher参数，以切换到工作线程。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的做法，在主线程中直接调用async，若耗时过长则阻塞UI</span></span><br><span class="line">GlobalScope.launch(Dispatchers.Main) &#123;</span><br><span class="line">    <span class="keyword">val</span> deferred = async &#123;</span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的做法，在工作线程执行协程任务</span></span><br><span class="line">GlobalScope.launch(Dispatchers.Main) &#123;</span><br><span class="line">    <span class="keyword">val</span> deferred = async(Dispatchers.Default) &#123;</span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul><li>协程上下文环境参数可以用加号<code>+</code>拼接，左值优先</li><li>上下文环境可以继承</li><li>上下文环境可以单独制定参数</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>本文的70%都翻译总结自Medium上的这篇文章，写的非常棒，建议有英文阅读能力的同学直接阅读原文</p><ul><li><a href="https://proandroiddev.com/demystifying-coroutinecontext-1ce5b68407ad" target="_blank" rel="noopener">Demystifying CoroutineContext</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;限定目的，能使人生变得简洁。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;协程上下文是个啥？&quot;&gt;&lt;a href=&quot;#协程上下文是个啥？&quot; class=&quot;headerlink&quot; title=&quot;协程上下文是个啥？&quot;&gt;&lt;/a&gt;协程上下文是个啥？&lt;
      
    
    </summary>
    
    
      <category term="Kotlin" scheme="https://lilei.pro/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 协程基础课 02.suspend函数</title>
    <link href="https://lilei.pro/2019/12/10/kotlin-coroutines-02/"/>
    <id>https://lilei.pro/2019/12/10/kotlin-coroutines-02/</id>
    <published>2019-12-10T14:41:39.000Z</published>
    <updated>2019-12-10T14:42:46.058Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是《Kotlin 协程基础课》的第2篇文章。</p></blockquote><blockquote><p>Everyone must choose one of two pains: The pain of discipline or the pain of regret. Choose WISELY.</p></blockquote><p>在上篇文章里我们学习了如何通过协程简化耗时操作的写法，其中有一个关键字<code>suspend</code>，用于在定义函数时进行声明。本篇文章将对suspend进行进一步介绍，旨在学会它的含义和用法。</p><h1 id="suspend限定词的含义"><a href="#suspend限定词的含义" class="headerlink" title="suspend限定词的含义"></a>suspend限定词的含义</h1><p><strong>suspend</strong>，翻译过来就是<strong>中断，挂起</strong>，跟<strong>public、static</strong>等关键字相同，用在函数声明前，表示这是一个“挂起函数”。</p><p>挂起函数只能在协程或另一个挂起函数中被调用，如果你在非协程中使用到了挂起函数，会看到编译器有如下报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error: Kotlin: Suspend functions are only allowed to be called from a coroutine or another suspend function</span><br></pre></td></tr></table></figure><p>前面用到的<code>delay</code>就是一个挂起函数。<strong>suspend</strong>关键字表明函数内部进行了耗时操作，可以是计算密集型的CPU任务，也可以是网络、磁盘操作密集型的IO任务。基本上可以看做“但凡用callback实现的回调函数，都能用一个相对应的挂起函数实现”。</p><p>所以我们使用<strong>suspend</strong>关键字的时机就非常明确了：当函数要进行耗时操作时，就把它声明为<code>suspend</code>。</p><h1 id="suspend做了什么事"><a href="#suspend做了什么事" class="headerlink" title="suspend做了什么事"></a>suspend做了什么事</h1><p><em>方便起见，后续用“挂起”指代“suspend”。</em></p><p>作为及物动词，“挂起”应当有一个宾语，这里“挂起”的对象是<strong>协程</strong>。接下来我们对挂起的过程中发生了什么一探究竟，记住下面这句话：</p><p><strong>“挂起”是指协程从它当前线程脱离，切换到另一个线程运行。</strong>当线程运行到<code>suspend</code>函数时，会暂时挂起这个函数及后续代码的执行。这里涉及到两个角色：线程和协程。</p><h2 id="线程的行为"><a href="#线程的行为" class="headerlink" title="线程的行为"></a>线程的行为</h2><p>当线程运行到“挂起”代码块时，会跳出当前的代码块，不再执行后续代码。接下来线程会做什么呢？</p><p>如果它是一个后台线程：</p><ul><li>要么无事可做，被系统回收</li><li>要么被调度执行别的后台任务</li></ul><p>跟Java线程池里的线程在工作结束之后的表现完全一样：<strong>回收或者再利用</strong>。</p><p>如果它是Android主线程：</p><ul><li>继续UI刷新工作</li></ul><h2 id="协程的行为"><a href="#协程的行为" class="headerlink" title="协程的行为"></a>协程的行为</h2><p>上面讲到线程运行到挂起代码块时，会暂时退出当前代码块的执行。那么，剩余的协程代码在哪里得到执行呢？答案就在挂起函数的实现中——即我们为挂起函数指定的线程。</p><p><code>withContext</code>函数可以指定协程代码的运行线程，常见的Dispatcher有Main、IO、Default。协程从挂起的地方开始，切换到这些线程之中的一个继续运行，当运行完毕时，会<strong>自动切换回原线程执行</strong>。</p><p>在协程的源码里，“自动切换回来”是通过<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines.experimental/-continuation/resume.html" target="_blank" rel="noopener">resume</a>实现的。挂起函数之所以必须在协程中调用，就是因为协程框架会自动帮我们处理这个自动切换的过程。</p><h2 id="suspend-不会真正操作挂起"><a href="#suspend-不会真正操作挂起" class="headerlink" title="suspend 不会真正操作挂起"></a>suspend 不会真正操作挂起</h2><p>并不是声明了<code>suspend</code>后，线程运行到该位置，就自动进行挂起切换的，参照下面一个例子，挂起函数仍然运行在主线程中。为什么没有切换线程？因为编译器根本不知道要往哪里切，需要我们在编码时明确告诉它，这个挂起函数要切换到哪一个线程继续运行。我们可以用<code>withContext</code>指明待切换的线程。在实现一个挂起函数时，仅仅加上<code>suspend</code>关键字是不够的，必须在函数内部直接或间接地调用协程框架自带的<code>suspend</code>函数。</p><p><code>suspend</code>只是一个提醒，它只有一个效果，就是限制函数只能在协程里调用，如果在非协程里使用了<code>suspend</code>函数，则编译不通过。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 仍然运行在Main</span></span><br><span class="line">suspend <span class="function"><span class="keyword">fun</span> <span class="title">suspendingPrint</span><span class="params">()</span></span> &#123;</span><br><span class="line">  println(<span class="string">"Thread: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">I/System.<span class="keyword">out</span>: Thread: main</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行在IO</span></span><br><span class="line">suspend <span class="function"><span class="keyword">fun</span> <span class="title">suspendingPrint</span><span class="params">()</span></span> = withContext(Dispatchers.IO) &#123;</span><br><span class="line">  println(<span class="string">"Thread: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="如何写一个suspend函数"><a href="#如何写一个suspend函数" class="headerlink" title="如何写一个suspend函数"></a>如何写一个suspend函数</h1><p>最简单的方式是：</p><ol><li>声明函数为<code>suspend</code></li><li>使用<code>withContext</code>指定目标线程，或者在函数内部调用另一个<code>suspend</code>函数</li></ol><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文介绍了协程中最常见的关键字<code>suspend</code>的含义和用法，阅读完本文后你应当掌握：</p><ul><li>挂起函数运行时的表现</li><li>什么情况下使用挂起函数</li><li>如何写一个简单的挂起函数</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://juejin.im/post/5da81352f265da5b774fc39d" target="_blank" rel="noopener">掘金-扔物线</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;这是《Kotlin 协程基础课》的第2篇文章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Everyone must choose one of two pains: The pain of discipline or t
      
    
    </summary>
    
    
      <category term="Kotlin" scheme="https://lilei.pro/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 协程基础课 01.协程的基本概念与用法</title>
    <link href="https://lilei.pro/2019/11/17/kotlin-coroutines-01/"/>
    <id>https://lilei.pro/2019/11/17/kotlin-coroutines-01/</id>
    <published>2019-11-17T00:57:40.000Z</published>
    <updated>2019-12-03T14:27:46.210Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是《Kotlin 协程基础课》的第1篇文章。</p></blockquote><blockquote><p>正因为她觉得一切都无所谓，所以生活给她什么，她便接受什么。少年时代，她觉得选择为时过早，而现在已是青年，她又觉得改变为时过晚。</p></blockquote><h1 id="系列基础课前言"><a href="#系列基础课前言" class="headerlink" title="系列基础课前言"></a>系列基础课前言</h1><p>对于Kotlin学习而言，要想从“入门”走到“精通”，协程（Coroutines）是必须迈过去的一道坎。接下来一周时间，我会在之前零散学习的基础上，总结成一系列基础课文章，作为对协程的阶段性学习小结。文章目录如下：</p><ul><li>01.协程的基本概念与用法</li><li>02.非阻塞式挂起（suspend）函数</li><li>03.理解协程的域（Scope）和调度器（Dispatcher）</li><li>04.用AAC&amp;协程优化Android架构设计</li></ul><h1 id="什么是协程"><a href="#什么是协程" class="headerlink" title="什么是协程"></a>什么是协程</h1><p>但凡学一门新知识，总是离不开5w1h。说起“协程”，很多人第一反应是2号线北新泾那家做旅游的互联网公司，不过，此“协程”非彼“携程”，协程（Coroutines）并不是一个新的概念，它的年纪要比Kotlin语言大得多。“协程 Coroutines”源自 Simula 和 Modula-2 语言，这个术语早在 1958 年就被 Melvin Edward Conway 发明并用于构建汇编程序，说明协程是一种编程思想，并不局限于特定的语言。目前很多现代语言都有协程的实现，比如Go、JavaScript、C#等。</p><p>协程作为一种编程思想，目的是简化并行代码编写，可以让我们以同步的方式写异步逻辑。对于Kotlin而言，“协程”一词是指实现了协程思想的一系列API的总称。Kotlin协程的底层实现是线程。</p><h1 id="没有协程的日子里"><a href="#没有协程的日子里" class="headerlink" title="没有协程的日子里"></a>没有协程的日子里</h1><p>由于Android是单一UI线程的框架，势必要进行很多UI线程以外的耗时操作，在协程之前，我们通常用这些技术来实现诸如网络请求、数据库读写等功能：</p><ul><li>AsyncTask：是Android原生的异步任务写法，写过的人就知道它有多难用，业务逻辑被分散在前中后三个方法里，冗长的boilerplate代码。更有甚者，一旦发生嵌套，光是一层层回调就能把人搞疯掉。</li><li>Thread：直接开线程并不是一种好的设计，只有新手才这么干。</li><li>ThreadPool or ExecutorService：这比<code>new Thread</code>好一些，但同样要处理UI、工作线程切换的问题，以及无法避免的回调。</li><li>Handler：一个工作线程的Handler用来处理耗时任务，处理完成后丢给主线程Handler，简单、直接、朴实无华。</li></ul><p>这时协程（Coroutines）来了，为我们推翻回调地狱、样板代码、内存泄漏、线程切换几座大山，Android开发者终于翻身农奴把歌唱，敢叫日月换新天。</p><h1 id="第一个协程Demo"><a href="#第一个协程Demo" class="headerlink" title="第一个协程Demo"></a>第一个协程Demo</h1><h2 id="用Thread-sleep模拟耗时操作"><a href="#用Thread-sleep模拟耗时操作" class="headerlink" title="用Thread.sleep模拟耗时操作"></a>用Thread.sleep模拟耗时操作</h2><p>在本文我们暂且不谈Android环境，在更通用的环境下展现协程的用法。首先我们模拟一个耗时操作与非耗时操作混合的场景，看下面一段代码，它在<code>main</code>函数里依次打印<code>one two three</code>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    println(<span class="string">"one"</span>)</span><br><span class="line">    println(<span class="string">"two"</span>)</span><br><span class="line">    println(<span class="string">"three"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时有另一个函数，它会耗时3s后，打印出参数在控制台。我们用直白的<code>Thread.sleep</code>来进行延时模拟。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printDelayed</span><span class="params">(msg: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    Thread.sleep(<span class="number">3000</span>)</span><br><span class="line">    println(msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后将主程序的<code>print(two)</code>改为耗时任务。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    println(<span class="string">"one"</span>)</span><br><span class="line">    printDelayed(<span class="string">"two"</span>)</span><br><span class="line">    println(<span class="string">"three"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后，输出如下，非常符合预期。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">three</span><br><span class="line">// 这里等待3s</span><br><span class="line">two</span><br></pre></td></tr></table></figure><h2 id="用delay模拟耗时操作"><a href="#用delay模拟耗时操作" class="headerlink" title="用delay模拟耗时操作"></a>用delay模拟耗时操作</h2><p>Kotlin的协程库提供了另一种延时的API，<code>delay</code>，我们把原来的<code>Thread.sleep</code>替换为<code>delay</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printDelayed</span><span class="params">(msg: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    delay(<span class="number">3000</span>L)</span><br><span class="line">    println(msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时Android Studio会在<code>delay</code>处提示错误：<em>suspend function delay should be called only from a coroutine or another suspend function</em>。翻译过来就是“delay是一个挂起函数，它只能在协程中、或者另一个挂起函数里面被调用”。我们把程序整体改写一下。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">suspend <span class="function"><span class="keyword">fun</span> <span class="title">printDelayed</span><span class="params">(msg: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    delay(<span class="number">3000</span>L)</span><br><span class="line">    println(msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">print123Blocking</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    println(<span class="string">"one"</span>)</span><br><span class="line">    printDelayed(<span class="string">"two"</span>)</span><br><span class="line">    println(<span class="string">"three"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    print123Blocking()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后发现程序的输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">// 等待3s</span><br><span class="line">two</span><br><span class="line">three</span><br></pre></td></tr></table></figure><p>为什么不是132而是123呢，要从<code>runBlocking</code>的定义说起。它会“新起一个协程运行后续代码，并且在该协程的运行过程中阻塞原线程（在demo中是主线程），直至协程运行结束”。而在协程运行时是按照代码顺序逐行运行的。所以打印出来的是123而非132。</p><h2 id="为runBlocking指定运行线程"><a href="#为runBlocking指定运行线程" class="headerlink" title="为runBlocking指定运行线程"></a>为runBlocking指定运行线程</h2><p>我们在<code>print123blocking</code>方法里打印出当前线程名。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">print123Blocking</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    println(<span class="string">"one - in thread: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">    printDelayed(<span class="string">"two - in thread: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">    println(<span class="string">"three - in thread: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">one - in thread: main @coroutine#1</span><br><span class="line">two - in thread: main @coroutine#1</span><br><span class="line">three - in thread: main @coroutine#1</span><br></pre></td></tr></table></figure><p>可见这个方法是在当前（main）线程里运行的，并且同属于<code>@coroutine#1</code>。</p><p>我们可以为<code>runBlocking</code>指定运行的线程，在协程的语言里，使用<code>Dispatcher</code>来表明这一概念。我们改写一下<code>print123Blocking</code>方法，使用<code>Dispatcher.Default</code>打印1和2。样例代码与系统输出如下，可见我们为其指定了Dispatcher的代码段运行在另一个线程里，且打印顺序仍然为123，这就是<strong>Blocking</strong>的厉害之处。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">print123Blocking</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking(Dispatchers.Default) &#123;</span><br><span class="line">        println(<span class="string">"one - in thread: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">        printDelayed(<span class="string">"two - in thread: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"three - in thread: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">one - in thread: DefaultDispatcher-worker-1 @coroutine#1</span><br><span class="line">two - in thread: DefaultDispatcher-worker-1 @coroutine#1</span><br><span class="line">// 此处等待3s</span><br><span class="line">three - in thread: main</span><br></pre></td></tr></table></figure><h2 id="如何利用协程打印出132"><a href="#如何利用协程打印出132" class="headerlink" title="如何利用协程打印出132"></a>如何利用协程打印出132</h2><h3 id="全局后台线程：GlobalScope-launch"><a href="#全局后台线程：GlobalScope-launch" class="headerlink" title="全局后台线程：GlobalScope.launch"></a>全局后台线程：GlobalScope.launch</h3><p>可以在blocking域中使用<code>GlobalScope.launch{ ... }</code>来指定后台线程运行任务，我们基于此将原有代码改造一下。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">print123Blocking</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        println(<span class="string">"one - in thread: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">        printDelayed(<span class="string">"two - in thread: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"three - in thread: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的输出是不可知的，有可能是以下两种情况，只打印3或者打印31，这是什么原因呢？因为我们是在后台全局线程中启动的“打印12任务”，后台线程是不会阻止主线程运行结束的，所以2是肯定打不出来，而1能否打印出来就看运行时线程调度情况了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// case 1</span><br><span class="line">three - in thread: main @coroutine#1</span><br><span class="line">one - in thread: DefaultDispatcher-worker-1 @coroutine#2</span><br><span class="line">// case 2</span><br><span class="line">three - in thread: main @coroutine#1</span><br></pre></td></tr></table></figure><h3 id="等待任务完成"><a href="#等待任务完成" class="headerlink" title="等待任务完成"></a>等待任务完成</h3><p>我们可以简单粗暴地使用<code>delay</code>来等待后台任务完成。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">print123Blocking</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        println(<span class="string">"one - in thread: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">        printDelayed(<span class="string">"two - in thread: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"three - in thread: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">    delay(<span class="number">4000</span>L) <span class="comment">// 因为我们知道printDelayed会延迟3秒，故这里等待4秒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">three - in thread: main @coroutine#1</span><br><span class="line">one - in thread: DefaultDispatcher-worker-1 @coroutine#2</span><br><span class="line">two - in thread: DefaultDispatcher-worker-1 @coroutine#2</span><br></pre></td></tr></table></figure><p>但是这种处理方法非常丑陋，而且这个<code>delay</code>的时长很难设置，设置长了吧，会导致无用的等待浪费时间；设置短了吧，有可能在后台线程输出之前就结束任务，有没有更优雅的写法呢？答案是有的，<code>job.join()</code>为我们提供了等待任务完成的功能，代码如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">print123Blocking</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> job = GlobalScope.launch &#123;</span><br><span class="line">        println(<span class="string">"one - in thread: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">        printDelayed(<span class="string">"two - in thread: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"three - in thread: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">    job.join()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义Dispatcher"><a href="#自定义Dispatcher" class="headerlink" title="自定义Dispatcher"></a>自定义Dispatcher</h2><p>Dispatcher为协程的运行指定了线程，常见Dispatchers如下：</p><ul><li>Dispatcher.IO：进行IO密集型操作，如数据库读写、文件读写、网络交互</li><li>Dispatcher.Default：进行CPU密集型操作，如列表排序、JSON解析、DiffUtils</li><li>Dispatcher.Main：仅存在于Android框架，调用<code>suspend</code>方法、进行UI操作、更新LiveData</li></ul><p>看到这里你可能已经理解了，Dispatcher其实就是线程的另一种表现形式，我们甚至可以自定义一个Dispatcher：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">print123Blocking</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    println(<span class="string">"one - in thread: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">    <span class="keyword">val</span> customDispatcher = Executors.newFixedThreadPool(<span class="number">2</span>).asCoroutineDispatcher()</span><br><span class="line">    launch(customDispatcher) &#123;</span><br><span class="line">        printDelayed(<span class="string">"two - in thread: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"three - in thread: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">    (customDispatcher.executor <span class="keyword">as</span> ExecutorService).shutdown() <span class="comment">// ！主动停止，否则线程会一直运行下去</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下（在play.kotlin上面总是超时不知道为啥），意味着我们完全可以高度定制Dispatcher的实现，虽然大部分时间使用默认的Dispatcher就已足够。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">one - from thread main</span><br><span class="line">three - from thread main</span><br><span class="line">two - from thread pool-1-thread-1</span><br></pre></td></tr></table></figure><h2 id="有返回值的suspend函数"><a href="#有返回值的suspend函数" class="headerlink" title="有返回值的suspend函数"></a>有返回值的suspend函数</h2><p>最后一部分内容是跟Android开发密切相关的，大部分时间我们需要通过网络、数据库进行一些读取数据耗时操作，函数会有返回值，我们模拟一个网络操作，它读取一个<code>startNum</code>参数，等待1s延时后，返回<code>startNum * 10</code>。通过 <code>async { ... }.await()</code> 可以获取耗时函数的返回值，代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟1s延时网络操作</span></span><br><span class="line">suspend <span class="function"><span class="keyword">fun</span> <span class="title">calculateHardThings</span><span class="params">(startNum: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">  delay(<span class="number">1000</span>)</span><br><span class="line">  println(<span class="string">"result: <span class="subst">$&#123;result&#125;</span>, in thread: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">  <span class="keyword">return</span> startNum * <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用延时操作，分别await，耗时共3s</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">exampleAsyncAwait</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">  <span class="keyword">val</span> startTime = System.currentTimeMillis()</span><br><span class="line">  <span class="keyword">val</span> deferred1 = async &#123; calculateHardThings(<span class="number">10</span>) &#125;.await()</span><br><span class="line">  <span class="keyword">val</span> deferred2 = async &#123; calculateHardThings(<span class="number">20</span>) &#125;.await()</span><br><span class="line">  <span class="keyword">val</span> deferred3 = async &#123; calculateHardThings(<span class="number">30</span>) &#125;.await()</span><br><span class="line">  <span class="keyword">val</span> sum = deferred1 + deferred2 + deferred3</span><br><span class="line">  <span class="keyword">val</span> endTime = System.currentTimeMillis()</span><br><span class="line">  println(<span class="string">"sum = <span class="variable">$sum</span>, time = <span class="subst">$&#123;endTime - startTime&#125;</span>"</span>) <span class="comment">// sum = 600, time = 3030</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="并发进行耗时操作"><a href="#并发进行耗时操作" class="headerlink" title="并发进行耗时操作"></a>并发进行耗时操作</h3><p>因为是3个耗时1s操作并发，我们自然而然希望它们同时运行，总耗时1s而不是3s，要如何实现呢？把所有的<code>await()</code>调用写入同一个语句，编译器会优化它们，使其同时运行。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用延时操作，同时await，耗时共1s</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">exampleAsyncAwait</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">  <span class="keyword">val</span> startTime = System.currentTimeMillis()</span><br><span class="line">  <span class="keyword">val</span> deferred1 = async &#123; calculateHardThings(<span class="number">10</span>) &#125;</span><br><span class="line">  <span class="keyword">val</span> deferred2 = async &#123; calculateHardThings(<span class="number">20</span>) &#125;</span><br><span class="line">  <span class="keyword">val</span> deferred3 = async &#123; calculateHardThings(<span class="number">30</span>) &#125;</span><br><span class="line">  <span class="keyword">val</span> sum = deferred1.await() + deferred2.await() + deferred3.await()</span><br><span class="line">  <span class="keyword">val</span> endTime = System.currentTimeMillis()</span><br><span class="line">  println(<span class="string">"sum = <span class="variable">$sum</span>, time = <span class="subst">$&#123;endTime - startTime&#125;</span>"</span>) <span class="comment">// sum = 600, time = 1065</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用withContext的简化写法"><a href="#使用withContext的简化写法" class="headerlink" title="使用withContext的简化写法"></a>使用withContext的简化写法</h3><p>async/await 会运行在当前线程中，对于网络操作一般的做饭是让其在IO线程运行，对于计算密集型操作则是在CPU（Default）线程运行，使用<code>withContext</code>可以同时完成<code>async/await</code>的操作，但缺点是这三个操作只能相继运行，无法同时运行。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用延时操作</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">exampleWithContext</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">  <span class="keyword">val</span> startTime = System.currentTimeMillis()</span><br><span class="line">  <span class="keyword">val</span> deferred1 = withContext(Dispatchers.Default) &#123; calculateHardThings(<span class="number">10</span>) &#125;</span><br><span class="line">  <span class="keyword">val</span> deferred2 = withContext(Dispatchers.Default) &#123; calculateHardThings(<span class="number">20</span>) &#125;</span><br><span class="line">  <span class="keyword">val</span> deferred3 = withContext(Dispatchers.Default) &#123; calculateHardThings(<span class="number">30</span>) &#125;</span><br><span class="line">  <span class="keyword">val</span> sum = deferred1 + deferred2 + deferred3</span><br><span class="line">  <span class="keyword">val</span> endTime = System.currentTimeMillis()</span><br><span class="line">  println(<span class="string">"sum = <span class="variable">$sum</span>, time = <span class="subst">$&#123;endTime - startTime&#125;</span>"</span>) <span class="comment">// sum = 600, time = 3029</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文介绍了协程的基本用法，在阅读完本文后，你应当掌握以下知识点：</p><ul><li>声明耗时函数，以及在协程代码块里调用耗时函数</li><li>切换运行环境</li><li>等待任务完成</li><li>并行进行耗时操作，获取操作结果</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.youtube.com/watch?v=jYuK1qzFrJg" target="_blank" rel="noopener">https://www.youtube.com/watch?v=jYuK1qzFrJg</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;这是《Kotlin 协程基础课》的第1篇文章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;正因为她觉得一切都无所谓，所以生活给她什么，她便接受什么。少年时代，她觉得选择为时过早，而现在已是青年，她又觉得改变为时过晚。&lt;/p
      
    
    </summary>
    
    
      <category term="Kotlin" scheme="https://lilei.pro/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>【转】Android Studio Debug 的 9 个小技巧</title>
    <link href="https://lilei.pro/2019/11/11/android-studio-debug-skills/"/>
    <id>https://lilei.pro/2019/11/11/android-studio-debug-skills/</id>
    <published>2019-11-11T15:46:08.000Z</published>
    <updated>2019-11-11T17:09:55.597Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Pain is inevitable. Suffering is optional. 痛楚难以避免，而磨难可以选择。</p></blockquote><p>这是一篇转载的文章。</p><ul><li>作者：wanbo</li><li>链接：<a href="https://juejin.im/post/5dbf8036f265da4d4b5fe7c2" target="_blank" rel="noopener">https://juejin.im/post/5dbf8036f265da4d4b5fe7c2</a></li><li>来源：掘金</li></ul><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/191111_as_debug_skills/dev_summit_19.webp" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>周末看 Android Dev Summit ‘19 的视频的时候，看到一章关于 Android Studio Debug 的介绍，有很多日常非常有用的小技巧，学习了这些小技巧能很大程度的降低我们 Debug 的成本，快速定位问题的本质，今天就向大家介绍一下 Android Studio Debug 的 9 个小技巧。</p><p>没关注的小伙伴记得关注订阅😝，如果觉得这些文章有点意思，记得分享转发评论点赞😝！</p><h2 id="Log-过滤和折叠"><a href="#Log-过滤和折叠" class="headerlink" title="Log 过滤和折叠"></a>Log 过滤和折叠</h2><p>有时候 Logcat 中 log 的信息很长，同时还有些我们不需要的信息也打印出来，例如下图中的【时间+线程 ID】。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/191111_as_debug_skills/log_filter_0.webp" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这个时候我们可以点击 Logcat 窗口上的【设置】按钮，设置一条 Log 需要显示哪些关键信息，可设置的项有：时间、线程ID、包名、Tag name。我们可以根据自己的需要控制显示，并且下面还会有一条 Sample Log 提供设置后的预览效果，就像下图中这样。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/191111_as_debug_skills/log_filter_1.webp" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>日常开发的时候我们还会遇到另一种情况，比如根据当前 UI 的渲染情况，我们需要时刻打印 UI 的某个值，来帮助我们观察 UI，同时当到达某种条件的时候，输入一条我们得到的【结果 log】。也就是说在获得我们的【结果 log】之前会有很多没用但是又必须打印的 log，这样当我们需要查找【结果 log】的时候就会非常麻烦。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/191111_as_debug_skills/log_filter_2.webp" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>就像上图中这样，我们的【结果 log】被上下【循环打印 log】包围了，很难一下子找出来，这时候我们可以选关键字【右键】，选择【Fold Lines Like This】，如下图所示。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/191111_as_debug_skills/log_filter_3.webp" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这样我们相同关键字的 log 就会被折叠，当然也可以展开查看详细 log。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/191111_as_debug_skills/log_filter_4.webp" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="自定义断点执行条件"><a href="#自定义断点执行条件" class="headerlink" title="自定义断点执行条件"></a>自定义断点执行条件</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/191111_as_debug_skills/custom_break_0.webp" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>我们来看上面这段代码，通过字面意思我们可以得知：这是一个点击事件执行的方法，点击发生后通过 NavController 从当前 HomeFragment 跳转到 EmailFragment。然后我们在第一行打了一个断点，我们已经得知当 email 的 subject 包含 【Bonjour】关键字的时候，这段代码会发生崩溃，反之不包含则不会发生崩溃，所以我们不需要每次断点都生效。</p><p>这里我们可以右键断点，在 Condition 里输入我们的条件判断语句，当条件允许的时候，断点才生效。条件语句的代码支持 Kotlin 和 Java 两种语言的写法，如下图所示。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/191111_as_debug_skills/custom_break_1.webp" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>然后如果我们想在跳转到 EmailFragment 之后进一步去追踪问题，于是我在 EmailFragment 的 onCreate 方法打了一个断点（如下图所示），然后这里还会遇到我们之前说的问题：不符合条件的时候断点也会生效，这时候我们该怎么办呢？</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/191111_as_debug_skills/custom_break_2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>我们可以在这个断点上面，右键、点击更多。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/191111_as_debug_skills/custom_break_3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>左边选择当前断点之后，在右边点击【Disable until breakpoint hit】，选择我们之前有条件判断的断点，那么这个新的断点会在它所跟随的断点生效之后才会生效。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/191111_as_debug_skills/custom_break_4.webp" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="挂起线程"><a href="#挂起线程" class="headerlink" title="挂起线程"></a>挂起线程</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/191111_as_debug_skills/suspend.webp" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>当我们右键任意一个断点的时候，会有一个 Suspend 选项【All、Thread】，All 也就意味着当我们在一个多线程的应用中 debug 问题的时候，一旦这个断点生效，所有的线程都会被挂起，Thread 表示只挂起当前线程。所以当我们在某个后台线程中 debug 问题的时候就可以选择 Thread，这样就不会在 debug 的时候阻塞主线程的正常功能。</p><p>还有一个打开关闭断点的快捷键也分享一下：Windows 用户 Alt + Click ，Mac Option + Click 。</p><h2 id="动态打印"><a href="#动态打印" class="headerlink" title="动态打印"></a>动态打印</h2><p>详细很多人包括我之前在 debug 的时候，都会在需要 debug 的地方增加 print 输出一下信息供自己排查错误，这里提供一种快捷方便的方法，可以既不污染我们的代码，又可以随时输出任意信息。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/191111_as_debug_skills/eval_and_log.webp" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>如上图所示，在需要打印的地方增加断点，然后取消所有线程的挂起，选择【Evaluate and log】，属于我们需要打印的语句，当代码执行到断点的时候，不会暂停，而会根据我们设置的打印信息输出 log，是不是很方便？</p><h2 id="断点分组"><a href="#断点分组" class="headerlink" title="断点分组"></a>断点分组</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/191111_as_debug_skills/group.webp" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>通常遇到一个问题的时候，我们需要增加很多断点去追踪问题的原因，当问题解决之后，往往会忘记取消这些断点，导致在某次调试的时候，设备会被之前的断点所暂停，会让我们很无语。这里我们可以 debug 的时候在某个断点上：右键、更多，然后选择这个问题所有相关的断点，将它们分到同一个 Group 里面，那么这一个组的断点就可以统一开关、统一删除。</p><h2 id="断点上一步"><a href="#断点上一步" class="headerlink" title="断点上一步"></a>断点上一步</h2><p>说到这个真的很痛心，常常因为自己在 debug 的时候，由于下一步点击的太快了而错过了问题关键行，只能重新运行一次代码，重新 debug 然后自己一次次点击下一步。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/191111_as_debug_skills/drop_frame.webp" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>在运行 Android 10 的设备上，debug 界面中提供了一个叫【Drop frame】的按钮，可以供我们跳出当前方法栈，返回上一步，这样就会避免我们因为错过断点而不得不重新运行代码。</p><h2 id="观察对象"><a href="#观察对象" class="headerlink" title="观察对象"></a>观察对象</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/191111_as_debug_skills/mark_obj_0.webp" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>当我们 debug 的时候，可以从 debug 窗口中观察当前作用域中的对象以及对象的属性，有时候我们会观察在不同页面是否是同一个对象，之前我的做法很粗暴…就是找张纸，把这个对象的 ID 记下来，然后在另一个页面 debug 看 ID 是否一致😂</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/191111_as_debug_skills/mark_obj_1.webp" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这里我们可以在对象上右键、选择【Mark Object】之后会让你自定义一个 Label，然后在整个 debug 期间，相同的对象会以你设置的 Label 为 name 出现，帮助我们方便的分析是否是统一对象。</p><p>顺便提一下，在任意一段代码上，点击行号，可以从当前断点快速执行到目标行并暂停，这个我真是第一次知道，感觉之前 Android Studio 都白用了😭</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/191111_as_debug_skills/mark_obj_2.webp" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>而且在 debug 的时候我们可以选择 debug 窗口中的【Evaluate expression】按钮来动态观察对象，点击之后会弹出一个计算框，我们可以输入任意当前作用域中的对象以及属性观察。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/191111_as_debug_skills/mark_obj_3.webp" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>不得不说这个真的很方便，以前遇到这种情况我只有一种方法就是：print 😂，当然这里不仅仅是观察对象，我们可以写任意代码观察我们想要的值，就像下图这样。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/191111_as_debug_skills/mark_obj_4.webp" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="增量更新"><a href="#增量更新" class="headerlink" title="增量更新"></a>增量更新</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/191111_as_debug_skills/hot_reload.webp" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>我试了一下，这两个按钮是真的很好用啊，比重新全量运行应用真是快了不少，非常方便。</p><h2 id="错误栈分析"><a href="#错误栈分析" class="headerlink" title="错误栈分析"></a>错误栈分析</h2><p>通常我们 App 中会继承一下线上 bug 反馈的 SDK 比如 bugly，在 bugly 我们会得到崩溃的异常栈信息，类似下图这样。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/191111_as_debug_skills/analyze_stack_0.webp" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>我们可以全选复制，打开我们的 Android Studio，选择 Analyze → Analyze Stack Trace or Thread Dump，然后把异常栈信息粘贴进去，点击确定。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/191111_as_debug_skills/analyze_stack_1.webp" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Android Studio 会在控制台显示这段异常栈信息，并且与现有代码 Link 在一起，我们可以点击跳转到问题所在行。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/191111_as_debug_skills/analyze_stack_2.webp" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>好了这就是今天要分享的全部内容，关于更多详细的内容，大家可以点击【阅读原文】在油管上查看，真希望有大佬可以出一个【Android Studio 使用全攻略】，感觉自己对 AS 真的只是会用，但还有很多东西需要去学习和探索。😂</p><p>我是 wanbo 大家加油！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Pain is inevitable. Suffering is optional. 痛楚难以避免，而磨难可以选择。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是一篇转载的文章。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作者：wanbo&lt;/li&gt;
&lt;li&gt;链接
      
    
    </summary>
    
    
      <category term="Android" scheme="https://lilei.pro/tags/Android/"/>
    
      <category term="Android Studio" scheme="https://lilei.pro/tags/Android-Studio/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin域函数小结</title>
    <link href="https://lilei.pro/2019/10/28/kotlin-scope-functions/"/>
    <id>https://lilei.pro/2019/10/28/kotlin-scope-functions/</id>
    <published>2019-10-28T15:37:31.000Z</published>
    <updated>2019-10-28T15:43:35.967Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>并非意志坚强就可以无所不能，人世不是那么单纯的。老实说，我甚至觉得每天坚持跑步同意志强弱并没有太大关联。我能够坚持跑二十年，恐怕还是因为合乎我的性情，至少“不觉得那么痛苦”。人生来如此，喜欢的事自然可以坚持下去，不喜欢的事怎么也坚持不了。 ——<strong>当我谈跑步时我谈些什么</strong></p></blockquote><p>想要掌握Kotlin，域函数是不得不迈过的一道坎。</p><h1 id="所谓“域函数”"><a href="#所谓“域函数”" class="headerlink" title="所谓“域函数”"></a>所谓“域函数”</h1><p>一句话，域函数（scope functions）是为给定的对象创建一个临时的域，在这个域中执行一些操作。相比于传统的对象-函数调用写法，域函数在减少代码量的同时，还可以让编码在逻辑上看起来更加清晰，便于扩展和维护。</p><p>对比一下域函数写法与普通写法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 域函数写法</span></span><br><span class="line">Person(<span class="string">"Alice"</span>, <span class="number">20</span>, <span class="string">"Amsterdam"</span>).let &#123;</span><br><span class="line">    println(it)</span><br><span class="line">    it.moveTo(<span class="string">"London"</span>)</span><br><span class="line">    it.incrementAge()</span><br><span class="line">    println(it)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通写法</span></span><br><span class="line"><span class="keyword">val</span> alice = Person(<span class="string">"Alice"</span>, <span class="number">20</span>, <span class="string">"Amsterdam"</span>)</span><br><span class="line">println(alice)</span><br><span class="line">alice.moveTo(<span class="string">"London"</span>)</span><br><span class="line">alice.incrementAge()</span><br><span class="line">println(alice)</span><br></pre></td></tr></table></figure><p>域函数要结合lambda表达式使用。Kotlin中一共有五个域函数：<code>let</code>, <code>run</code>, <code>with</code>, <code>apply</code>, <code>also</code>。这些域函数有两个区别点。</p><ul><li>域函数中如何引用上下文对象</li><li>域函数返回值</li></ul><h1 id="区别点：上下文对象"><a href="#区别点：上下文对象" class="headerlink" title="区别点：上下文对象"></a>区别点：上下文对象</h1><p>域函数中用<code>this</code>或者<code>it</code>指代上下文对象。</p><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p><code>run</code>, <code>with</code>和<code>apply</code>在lambda表达式中用<code>this</code>指代上下文对象，就好像lambda表达式是在对象内部调用的一样，<code>this</code>是可以省略的。对于调用对象内部方法、属性的代码，应当选择使用<code>this</code>指代的域函数。如果在域内要调用其他对象的函数，不要选择<code>this</code>指代，因为容易弄混。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> adam = Person(<span class="string">"Adam"</span>).apply &#123;</span><br><span class="line">  age = <span class="number">20</span> <span class="comment">// same as this.age = 20</span></span><br><span class="line">  city = <span class="string">"Hangzhou"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="it"><a href="#it" class="headerlink" title="it"></a>it</h2><p><code>let</code>, <code>also</code>在lambda表达式中用<code>it</code>指代上下文对象，与<code>this</code>不同，在访问方法和对象时<code>it</code>是不能省略的。当上下文对象需要在域内充当函数参数时，就选用<code>it</code>类型的域函数。另一个便捷之处在于，可以为<code>it</code>指代别名。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getRandomInt</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Random.nextInt(<span class="number">100</span>).also &#123;</span><br><span class="line">        writeToLog(<span class="string">"getRandomInt() generated value <span class="variable">$it</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> i = getRandomInt()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为it指代别名</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getRandomInt</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123; value -&gt;</span><br><span class="line">    <span class="keyword">return</span> Random.nextInt(<span class="number">100</span>).also &#123;</span><br><span class="line">        writeToLog(<span class="string">"getRandomInt() generated value <span class="variable">$value</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="区别点：返回值"><a href="#区别点：返回值" class="headerlink" title="区别点：返回值"></a>区别点：返回值</h1><h2 id="Lambda表达式结果"><a href="#Lambda表达式结果" class="headerlink" title="Lambda表达式结果"></a>Lambda表达式结果</h2><p><code>let</code>, <code>run</code>和<code>with</code>返回lambda表达式的结果（最后一行），可以用这些域函数来进行赋值，也可以进行链式调用。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 赋值</span></span><br><span class="line"><span class="keyword">val</span> numbers = mutableListOf(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>)</span><br><span class="line"><span class="keyword">val</span> countEndsWithE = numbers.run &#123; </span><br><span class="line">    add(<span class="string">"four"</span>)</span><br><span class="line">    add(<span class="string">"five"</span>)</span><br><span class="line">    count &#123; it.endsWith(<span class="string">"e"</span>) &#125; <span class="comment">// 返回count数</span></span><br><span class="line">&#125;</span><br><span class="line">println(<span class="string">"There are <span class="variable">$countEndsWithE</span> elements that end with e."</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无视返回值，只是执行域函数内部操作</span></span><br><span class="line"><span class="keyword">val</span> numbers = mutableListOf(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>)</span><br><span class="line">with(numbers) &#123; <span class="comment">// with是this指代，可省略</span></span><br><span class="line">    <span class="keyword">val</span> firstItem = first()</span><br><span class="line">    <span class="keyword">val</span> lastItem = last()        </span><br><span class="line">    println(<span class="string">"First item: <span class="variable">$firstItem</span>, last item: <span class="variable">$lastItem</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="上下文对象"><a href="#上下文对象" class="headerlink" title="上下文对象"></a>上下文对象</h2><p><code>also</code>, <code>apply</code>返回上下文对象，可以继续对此进行链式调用，也可以直接返回上下文对象。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链式调用</span></span><br><span class="line"><span class="keyword">val</span> numberList = mutableListOf&lt;<span class="built_in">Double</span>&gt;()</span><br><span class="line">numberList.also &#123; println(<span class="string">"Populating the list"</span>) &#125;</span><br><span class="line">    .apply &#123; <span class="comment">// 注意apply使用this指代（省略掉）</span></span><br><span class="line">        add(<span class="number">2.71</span>)</span><br><span class="line">        add(<span class="number">3.14</span>)</span><br><span class="line">        add(<span class="number">1.0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    .also &#123; println(<span class="string">"Sorting the list"</span>) &#125;</span><br><span class="line">    .sort()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为返回值</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getRandomInt</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Random.nextInt(<span class="number">100</span>).also &#123;</span><br><span class="line">        writeToLog(<span class="string">"getRandomInt() generated value <span class="variable">$it</span>"</span>) <span class="comment">// it指代上下文对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> i = getRandomInt()</span><br></pre></td></tr></table></figure><h1 id="逐个函数讲解"><a href="#逐个函数讲解" class="headerlink" title="逐个函数讲解"></a>逐个函数讲解</h1><h2 id="let"><a href="#let" class="headerlink" title="let"></a>let</h2><p><strong>上下文对象</strong>是<code>it</code>，<strong>返回值</strong>是lambda表达式计算结果（最后一行）。</p><p><code>let</code>可以作为链式调用中的一环来使用。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链式调用</span></span><br><span class="line"><span class="keyword">val</span> numbers = mutableListOf(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>, <span class="string">"four"</span>, <span class="string">"five"</span>)</span><br><span class="line">numbers.map &#123; it.length &#125;.filter &#123; it &gt; <span class="number">3</span> &#125;.let &#123; </span><br><span class="line">    println(it)</span><br><span class="line">    <span class="comment">// and more function calls if needed</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更加精简</span></span><br><span class="line">numbers.map &#123; it.length &#125;.filter &#123; it &gt; <span class="number">3</span> &#125;.let(::println)</span><br></pre></td></tr></table></figure><p><code>let</code>经常用来在非空对象上执行一系列操作。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> str: String? = <span class="string">"Hello"</span>   </span><br><span class="line"><span class="comment">//processNonNullString(str)       // compilation error: str can be null</span></span><br><span class="line"><span class="keyword">val</span> length = str?.let &#123; </span><br><span class="line">    println(<span class="string">"let() called on <span class="variable">$it</span>"</span>)        </span><br><span class="line">    processNonNullString(it)      <span class="comment">// OK: 'it' is not null inside '?.let &#123; &#125;'</span></span><br><span class="line">    it.length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>let</code>另一个用法是为变量<code>it</code>创建别名，以增强代码可阅读性。借助于IDE，通常我们可以看到<code>it</code>指代的是什么对象，对这个用法的需求并非十分强烈。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> numbers = listOf(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>, <span class="string">"four"</span>)</span><br><span class="line"><span class="keyword">val</span> modifiedFirstItem = numbers.first().let &#123; firstItem -&gt;</span><br><span class="line">    println(<span class="string">"The first item of the list is '<span class="variable">$firstItem</span>'"</span>)</span><br><span class="line">    <span class="keyword">if</span> (firstItem.length &gt;= <span class="number">5</span>) firstItem <span class="keyword">else</span> <span class="string">"!"</span> + firstItem + <span class="string">"!"</span></span><br><span class="line">&#125;.toUpperCase()</span><br><span class="line">println(<span class="string">"First item after modifications: '<span class="variable">$modifiedFirstItem</span>'"</span>)</span><br></pre></td></tr></table></figure><h2 id="with"><a href="#with" class="headerlink" title="with"></a>with</h2><p><code>with</code>不是扩展函数，它接收<strong>上下文对象</strong>作为函数参数，在lambda表达式中用<code>this</code>指代，返回结果是lambda表达式的值。</p><p>建议在使用<code>with</code>时不要处理它的返回结果，这样<code>with</code>就可以根据字面含义简单的理解成“在这个对象上进行如下操作”。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> numbers = mutableListOf(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>)</span><br><span class="line">with(numbers) &#123;</span><br><span class="line">    println(<span class="string">"'with' is called with argument <span class="variable">$this</span>"</span>)</span><br><span class="line">    println(<span class="string">"It contains <span class="variable">$size</span> elements"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种用法是创建一个辅助对象，它的属性或者方法可以用来计算出某个值。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> numbers = mutableListOf(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>)</span><br><span class="line"><span class="keyword">val</span> firstAndLast = with(numbers) &#123; <span class="comment">// 相当于声明了一个局部函数</span></span><br><span class="line">    <span class="string">"The first element is <span class="subst">$&#123;first()&#125;</span>,"</span> +</span><br><span class="line">    <span class="string">" the last element is <span class="subst">$&#123;last()&#125;</span>"</span></span><br><span class="line">&#125;</span><br><span class="line">println(firstAndLast)</span><br></pre></td></tr></table></figure><h2 id="run"><a href="#run" class="headerlink" title="run"></a>run</h2><p>使用<code>this</code>指代上下文对象，返回结果是lambda表达式值。</p><p><code>run</code>在含义上与<code>with</code>一致，在调用方式上与<code>let</code>一致。当需要进行对象初始化、并同时要返回一个计算结果时，应当使用<code>run</code>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> service = MultiportService(<span class="string">"https://example.kotlinlang.org"</span>, <span class="number">80</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> result = service.run &#123;</span><br><span class="line">    port = <span class="number">8080</span></span><br><span class="line">    query(prepareRequest() + <span class="string">" to port <span class="variable">$port</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the same code written with let() function:</span></span><br><span class="line"><span class="keyword">val</span> letResult = service.let &#123;</span><br><span class="line">    it.port = <span class="number">8080</span></span><br><span class="line">    it.query(it.prepareRequest() + <span class="string">" to port <span class="subst">$&#123;it.port&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了在接收者对象上调用以外，<code>run</code>还可以让我们在需要一个表达式的地方传入一个代码块（这种用法略复杂）。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> hexNumberRegex = run &#123;</span><br><span class="line">    <span class="keyword">val</span> digits = <span class="string">"0-9"</span></span><br><span class="line">    <span class="keyword">val</span> hexDigits = <span class="string">"A-Fa-f"</span></span><br><span class="line">    <span class="keyword">val</span> sign = <span class="string">"+-"</span></span><br><span class="line"></span><br><span class="line">    Regex(<span class="string">"[<span class="variable">$sign</span>]?[<span class="variable">$digits</span><span class="variable">$hexDigits</span>]+"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (match <span class="keyword">in</span> hexNumberRegex.findAll(<span class="string">"+1234 -FFFF not-a-number"</span>)) &#123; <span class="comment">// findAll正则匹配</span></span><br><span class="line">    println(match.value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * output: </span></span><br><span class="line"><span class="comment"> * +1234</span></span><br><span class="line"><span class="comment"> * -FFFF</span></span><br><span class="line"><span class="comment"> * -a</span></span><br><span class="line"><span class="comment"> * be</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><p>使用<code>this</code>指代上下文对象，返回值是上下文对象本身。</p><p><code>apply</code>适用的场景是不需要返回值，且主要是操作对象成员的过程。常见的就是对象配置，“在对象上进行如下操作”。</p><p><code>apply</code>可以很容易地变成链式操作。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> adam = Person(<span class="string">"Adam"</span>).apply &#123;</span><br><span class="line">    age = <span class="number">32</span></span><br><span class="line">    city = <span class="string">"London"</span>        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="also"><a href="#also" class="headerlink" title="also"></a>also</h2><p>使用<code>it</code>指代上下文对象，返回值是上下文对象本身。</p><p><code>also</code>的使用场景是将对象作为一系列操作的参数，在这些操作中<strong>不应该对参数产生副作用</strong>，因此你可以在一个链式调用中很方便地加上<code>also</code>，或者从链式调用中把<code>also</code>摘掉，且不影响原有逻辑。</p><p>当你在代码中看到<code>also</code>时，可以将其理解为“还需要做这些事情”。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> numbers = mutableListOf(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>)</span><br><span class="line">numbers</span><br><span class="line">    .also &#123; println(<span class="string">"The list elements before adding new one: <span class="variable">$it</span>"</span>) &#125;</span><br><span class="line">    .add(<span class="string">"four"</span>)</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>用一张表格列出函数的对象引用与返回值。</p><table><thead><tr><th>Function</th><th>Object reference</th><th>Return value</th><th>Is extension function</th></tr></thead><tbody><tr><td>let</td><td>it</td><td>Lambda result</td><td>Yes</td></tr><tr><td>run</td><td>it</td><td>Lambda result</td><td>Yes</td></tr><tr><td>run</td><td>-</td><td>Lambda result</td><td>No: called without the context object</td></tr><tr><td>with</td><td>this</td><td>Lambda result</td><td>No: takes the context object as an argument</td></tr><tr><td>apply</td><td>this</td><td>Context object</td><td>Yes</td></tr><tr><td>also</td><td>it</td><td>Context object</td><td>Yes</td></tr></tbody></table><p>一个简单的函数选用指南如下，它们的应用场景有重叠的部分，使用时应当具体情况具体分析。</p><ul><li>在非空对象上调用lambda表达式：<code>let</code></li><li>在域内将表达式抽象成一个变量：<code>let</code></li><li>对象配置：<code>apply</code></li><li>对象配置并计算结果：<code>run</code></li><li>执行一系列表达式，非扩展函数：<code>run</code></li><li>附加效果：<code>also</code></li><li>将对于某个对象的函数调用组合：<code>with</code></li></ul><p>尽管作用域函数功能强大，在使用时应当谨慎，避免出错，尤其是嵌套的情况应当越少越好；当你在写链式调用时，一定要小心分辨当前的上下文对象。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://kotlinlang.org/docs/reference/scope-functions.html" target="_blank" rel="noopener">官方文档</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;并非意志坚强就可以无所不能，人世不是那么单纯的。老实说，我甚至觉得每天坚持跑步同意志强弱并没有太大关联。我能够坚持跑二十年，恐怕还是因为合乎我的性情，至少“不觉得那么痛苦”。人生来如此，喜欢的事自然可以坚持下去，不喜欢的事怎么也坚持不了。 ——&lt;s
      
    
    </summary>
    
    
      <category term="Android" scheme="https://lilei.pro/tags/Android/"/>
    
      <category term="Kotlin" scheme="https://lilei.pro/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>移动设备ID那些事</title>
    <link href="https://lilei.pro/2019/10/12/unique-device-id/"/>
    <id>https://lilei.pro/2019/10/12/unique-device-id/</id>
    <published>2019-10-11T16:09:06.000Z</published>
    <updated>2019-10-11T16:22:48.854Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么需要设备ID"><a href="#为什么需要设备ID" class="headerlink" title="为什么需要设备ID"></a>为什么需要设备ID</h2><p>“设备ID”即用于标识设备唯一身份的ID，即 Unique Device Identifier。基于以下原因，我们经常需要处理设备ID相关功能：</p><ol><li>统计需求。DAU，MAU，转化率，用户行为等统计。</li><li>业务需求。个性化推荐，日志收集，灰度发布，AB Test等业务侧需求。</li><li>风控需求。防刷单，反作弊等。</li></ol><h2 id="设备ID的特征"><a href="#设备ID的特征" class="headerlink" title="设备ID的特征"></a>设备ID的特征</h2><p>为了满足以上需求，一个良好的设备ID方案应当具有“唯一性”和“稳定性”两个特征。</p><ul><li>唯一性：系统中的任意两台设备，它们的设备ID应当不同。</li><li>稳定性：同一台设备在重启、清空应用数据、卸载应用重装、系统升级、Android 版本升级、刷机等情况下，设备ID应当保持不变。</li></ul><p>遗憾的是，Android 平台并没有稳定的API可以提供具有上面两点特征的ID。</p><h2 id="可选方案及限制"><a href="#可选方案及限制" class="headerlink" title="可选方案及限制"></a>可选方案及限制</h2><p>关于Android设备ID，常见的方案有IMEI、MAC地址、Serial、AndroidID等，下面逐一介绍它们是什么，以及为何无法承担唯一ID的职责。</p><h3 id="IMEI"><a href="#IMEI" class="headerlink" title="IMEI"></a>IMEI</h3><p>是 <strong>国际设备识别码（Imternational Mobile Equipment Identity）</strong> 的缩写，即通常所说的手机串号，用于在移动电话网络中识别每一部独立的手机等移动通信设备，共15~17位数字。在拨号键盘输入<code>*#06#</code>即可查看。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取IMEI的样例代码，需要 READ_PHONE_STATE 权限</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getIMEI</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">val</span> tm = getSystemService(Context.TELEPHONY_SERVICE) <span class="keyword">as</span> TelephonyManager</span><br><span class="line">    <span class="keyword">return</span> tm.deviceId</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在早些时候，IMEI是很多应用采取的设备ID方案，因为它读取方便，且同时具备唯一性和稳定性的特征。然而自从Android 6开始，<code>READ_PHONE_STATE</code>被列入<code>dangerous</code>的保护级别，意味着我们不仅要在<code>AndroidManifest.xml</code>文件里申请，还应当在应用到这个权限之前动态申请。尤其在中文的安卓系统上，弹窗里的文字提示是“申请电话设备信息”，很容易让人误以为这是要获取电话号码、短信内容等敏感信息。</p><p>如果说Android 6只是提高了使用IMEI作为设备ID的门槛，Android 10则是完全堵死了这条路。在Android 10的系统里，即使申请了<code>READ_PHONE_STATE</code>权限，也无法获取IMEI，会抛出<code>SecurityException</code>异常或者返回null。</p><h3 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h3><p>MAC地址（Media Access Control Address），用于标识可上网设备的唯一地址，设备有几张网卡，就会有几个MAC地址。在OSI七层模型中，MAC地址位于第二层数据链路层。看到这里你也许以为MAC地址是作为设备ID解决方案的最佳选择，实则不然，首先，MAC地址的获取方法历经多次修改，足见Google正欲收紧MAC地址权限，以后完全堵死也并非不可能。</p><p>在 (?, 6.0)，[6.0, 7.0)，[7.0, ?) 三种不同的Android版本下，有着不同的获取MAC地址方式，可以参考简书这篇文章 <a href="https://www.jianshu.com/p/16d4ff4c4cbe" target="_blank" rel="noopener">《Android 版本兼容 — Android 6.0 和 7.0后获取Mac地址》</a>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取MAC地址，适用于目前Android全版本，不保证以后继续适用（很大可能不再适用）</span></span><br><span class="line"><span class="comment">// 需要 android.permission.INTERNET 权限，为非dangerous权限，可以在AndroidManifst.xml中直接申请</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getMAC</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> enumeration = getNetworkInterfaces() ?: <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        <span class="keyword">while</span> (enumeration.hasMoreElements()) &#123;</span><br><span class="line">            <span class="keyword">val</span> netInterface = enumeration.nextElement()</span><br><span class="line">            <span class="keyword">if</span> (netInterface.name == <span class="string">"wlan0"</span>) &#123;</span><br><span class="line">                <span class="keyword">val</span> addr = netInterface.hardwareAddress</span><br><span class="line">                <span class="keyword">val</span> result = StringBuilder()</span><br><span class="line">                <span class="keyword">for</span> (b <span class="keyword">in</span> addr) &#123;</span><br><span class="line">                    result.append(String.format(<span class="string">"%02X:"</span>, b))</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (result.isNotEmpty()) &#123;</span><br><span class="line">                    result.deleteCharAt(result.length - <span class="number">1</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result.toString()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        Log.e(<span class="string">"tag"</span>, e.message, e)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h3><p>何为Serial？Serial即“设备序列号”，是设备厂商提供的设备唯一串号，唯一性由各厂商保证。拿vivo举例，它会保证自己生产的每一台设备序列号都是不同的，但是不是与OPPO的也不一样呢？这就无法保证了。一个方案是用<code>厂商ID_设备型号_序列号</code>拼接起来，作为设备ID，这样可以避免不同厂商设备具有相同Serial的问题。但是，并非所有厂商都会严格按照这个规定来做。我曾经在RK3399的开发板上做过开发，试过很多张板子，它们的Serial都是0123456789，让人哭笑不得。</p><p>更糟糕的是，Android 10又堵死了获取Serial的路，会直接抛出<code>SecurityException</code>，除非应用是系统签名且具备<code>android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE</code>权限。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取Serial，需要 READ_PHONE_STATE 权限</span></span><br><span class="line"><span class="comment">// Android 10 异常 </span></span><br><span class="line"><span class="comment">// java.lang.SecurityException: getSerial: The user 10236 does not meet the requirements to access device identifiers.</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getSerial</span><span class="params">()</span></span> = android.os.Build.getSerial()</span><br></pre></td></tr></table></figure><h3 id="AndroidID"><a href="#AndroidID" class="headerlink" title="AndroidID"></a>AndroidID</h3><p>AndroidID是SDK提供的获取ID方法，它不需要申明任何权限，具有64bit的取值范围，且唯一性也还不错。但是，它最大的硬伤在于无法满足稳定性：</p><ul><li>刷机、root、恢复出厂设置后都会变化</li><li>对安装在8.0系统的应用来说，AndroidID取决于应用签名+设备两者的组合</li><li>在8.0之前安装的应用，如果在系统升级到8.0后，卸载重装该应用，读取到的AndroidID会变化</li></ul><p>由于以上原因，在一些要求不严格的场景中，可以采用AndroidID作为设备ID，比如记录激活数、曝光数据等。但是在严格的场景中就不能用AndroidID了，如以设备ID标识用户身份，提供相应服务的场景。</p><p>读取AndroidID的样例代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取AndroidID，不需要额外申请任何权限</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getAndroidID</span><span class="params">()</span></span> = Settings.Secure.getString(contentResolver, Settings.Secure.ANDROID_ID)</span><br></pre></td></tr></table></figure><h2 id="可选方案总结"><a href="#可选方案总结" class="headerlink" title="可选方案总结"></a>可选方案总结</h2><p>用一张表格总结上述方案：</p><table><thead><tr><th>方案</th><th>概述</th><th>限制</th></tr></thead><tbody><tr><td>IMEI</td><td>具备唯一性和稳定性，过去的最佳选择</td><td>Android10堵死，无法获取</td></tr><tr><td>MAC</td><td>网卡地址，唯一且稳定</td><td>权限逐渐收紧，未来极有可能关闭</td></tr><tr><td>Serial</td><td>手机厂商提供的设备序列号</td><td>不保证唯一性，Android10堵死</td></tr><tr><td>AndroidID</td><td>Android SDK 提供，不需要申请权限，唯一性较好</td><td>不具备稳定性</td></tr></tbody></table><h2 id="设计一个新方案"><a href="#设计一个新方案" class="headerlink" title="设计一个新方案"></a>设计一个新方案</h2><p>上述四个方案里，没有哪一个是解决设备ID问题的终极武器（银弹），只有各种方法综合运用，才是解决之道。下面提出一种设备ID方案，综合使用多个硬件ID，借助服务器生成唯一虚拟设备ID（VDID），可以最大限度地保证唯一性和稳定性。</p><h3 id="稳定性：拜占庭容错"><a href="#稳定性：拜占庭容错" class="headerlink" title="稳定性：拜占庭容错"></a>稳定性：拜占庭容错</h3><p>稳定性要求当获取不到某种ID，或者某种ID发生变化时，系统能够辨识出这个设备。借助“拜占庭容错”可以解决稳定性的问题。</p><p>拜占庭容错机制源于古老 <strong>拜占庭将军（Byzantine failures）</strong> 问题。用简单的语言解释： <strong>如果系统中有n个故障节点，系统要想正确运行，必须至少要有2n+1个正常节点。</strong> 。但对于Android设备ID，我们采用弱化的拜占庭容错机制，即客户端每次上传4个ID（IMEI、MAC、Serial、AndroidID），服务器根据这4个ID生成一个随机的唯一ID即VDID。后续客户端再请求时，可以使用VDID，或者再次使用4个ID，由服务器拿这4个ID在数据库中进行查找VDID，若找到则返回，若未找到，再使用4个ID中的3个进行查找，3个不行则用2个，以此类推。</p><h3 id="获取VDID的时序图"><a href="#获取VDID的时序图" class="headerlink" title="获取VDID的时序图"></a>获取VDID的时序图</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/20191012_unique_device_id/vdid_sequence.png" alt="vdid_sequence" title="">                </div>                <div class="image-caption">vdid_sequence</div>            </figure><h3 id="唯一性：VDID的生成方式与取值范围"><a href="#唯一性：VDID的生成方式与取值范围" class="headerlink" title="唯一性：VDID的生成方式与取值范围"></a>唯一性：VDID的生成方式与取值范围</h3><p>要实现VDID的唯一性，有两种方案可以考虑：</p><h4 id="方案一：自增主键ID"><a href="#方案一：自增主键ID" class="headerlink" title="方案一：自增主键ID"></a>方案一：自增主键ID</h4><p>自增、分步自增、分段构造、Redis分布式ID等方法，可以保证唯一性。但是在传输此类ID时，应当进行hash操作，且保证hash后的ID不可碰撞。</p><p>自增ID的优点是可作为索引，检索速度快；缺点是生成规则存在被破解的风险。</p><h4 id="方案二：随机生成ID"><a href="#方案二：随机生成ID" class="headerlink" title="方案二：随机生成ID"></a>方案二：随机生成ID</h4><p>这是另一种生成唯一ID的方法，当位数足够多时，可以认为碰撞概率趋近于0。首先看一下这张表，它描述了随机数位数与发生碰撞的概率。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/20191012_unique_device_id/random_collision.png" alt="random_collision" title="">                </div>                <div class="image-caption">random_collision</div>            </figure><p>假设我们应用的活跃用户数为20,000,000，即两千万。可以看到至少要有128Bits，才能在2*10^7（两千万）的数量级有极小的碰撞概率，符合我们的业务需求。</p><p>随机ID的优点是具有隐蔽性，缺点是检索效率一般。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>本文是笔者阅读郭霖公众号推文<a href="https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650247428&amp;idx=1&amp;sn=9d52f7b3262622f9ad25af8af167fcd8&amp;chksm=8863606bbf14e97deb5ecd030ff02ee76f6d320f1c0f586034e442903d00ff79dd7fc5bb3d91&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1570535190224&amp;sharer_shareid=50472349a2a49142535b8b535dc7dac9&amp;key=042d6afab53eaf2ecfd1c244abe072a53b13e46580bd8c41a7ed57b6b5f3360221dd5c5a4ea8dc0fcde4b6632ba630de39d070bbd64a7e4f24155cec02abb5dc1e36d0ecbc6e250d6f3f87c039ad1407&amp;ascene=1&amp;uin=OTUwMTI1NjEw&amp;devicetype=Windows+10&amp;version=62060833&amp;lang=zh_CN&amp;pass_ticket=hOoinQFE6HGs3U8dFKy9YsMWbVerXZqDJCY6dO0Rh4aIO4VWSduOo5tRbTZkwcN3" target="_blank" rel="noopener">《漫谈设备唯一ID的那些秘密》</a>后的总结归纳，此处向原作者@呼啸长风致谢。然而作者原文中有一处纰漏，设备序列号（SERIAL）在Android 10上基本是无法获取的，这也会影响原作者提出的解决方案。笔者已经在Github上对此提了<a href="https://github.com/No89757/Udid/issues/1" target="_blank" rel="noopener">issue</a>。</p><p>出于对用户隐私的保护，Google一直试图收紧的设备ID的获取权限。而由于“账户”的概念在国内市场并不普遍，再加上各大OEM碎片化严重，国内的各种业务不得不依赖于设备ID进行展开。这也是开发者近年来不得不面对的问题，希望未来国内的Android生态可以更加统一，也希望Google也对此类需求提供更好的权限方案，能让开发者可以不必为此头痛。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么需要设备ID&quot;&gt;&lt;a href=&quot;#为什么需要设备ID&quot; class=&quot;headerlink&quot; title=&quot;为什么需要设备ID&quot;&gt;&lt;/a&gt;为什么需要设备ID&lt;/h2&gt;&lt;p&gt;“设备ID”即用于标识设备唯一身份的ID，即 Unique Device Ident
      
    
    </summary>
    
    
      <category term="Android" scheme="https://lilei.pro/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Flash Boys 读书笔记</title>
    <link href="https://lilei.pro/2019/10/11/flash-boys/"/>
    <id>https://lilei.pro/2019/10/11/flash-boys/</id>
    <published>2019-10-11T15:55:18.000Z</published>
    <updated>2019-10-11T15:56:49.115Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言-背景与动机"><a href="#前言-背景与动机" class="headerlink" title="前言-背景与动机"></a>前言-背景与动机</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/191011_flashboys/cover.jpg" alt="cover" title="">                </div>                <div class="image-caption">cover</div>            </figure><p>Flash Boys，中译《高频交易员》，是金融畅销书作家迈克尔刘易斯 2015 年的作品，作者之前出版过《大空头》、《说谎者的扑克牌》等华尔街领域的流行作品。在这本书中，刘易斯借助“胜山”的角色，讲解了一些 HFT 的基础知识，可以给我等小白用来入门 HFT。</p><p>书的前 2/3 值得细读，后 1/3 基本上都是给 IEX 做广告，一扫而过即可。</p><h2 id="定义：何为-HFT（高频交易）"><a href="#定义：何为-HFT（高频交易）" class="headerlink" title="定义：何为 HFT（高频交易）"></a>定义：何为 HFT（高频交易）</h2><p>短线交易是经典力学，研究对象为每个周期的成交价格，最短 6 秒。</p><p>高频交易是量子力学，6秒内可以发生上百次交易，最终成交价只是最后一笔订单的价格。</p><p>交易所保留数据的频度是秒，二市场中高频交易主体的数据频度是纳秒级，1秒=10亿纳秒。</p><p><strong>高频交易（High-Frequency Trading）</strong>是投资银行、对冲基金和专业交易公司等利用高速计算机进行程序化证券交易的投资策略的总称，主要包括以下几种策略：</p><ul><li>流动性回扣交易（Liquidity Rebate Trading）</li><li>猎物算法交易（Predatory Algorithmic Trading）</li><li>自动做市商交易（Automated Market Maker Trading, AMMs）</li><li>闪电订单（Flash Order）</li><li>暗池（Dark Pool）</li></ul><h2 id="理解：高频交易何以赚钱"><a href="#理解：高频交易何以赚钱" class="headerlink" title="理解：高频交易何以赚钱"></a>理解：高频交易何以赚钱</h2><p>假设某支股票价格在400~500元之间波动，股民老王下了一个单：当股票价格低于450元时，买入100股。当这个订单在交易所之间传递时（美国有十几家交易所，纽交所、纳斯达克是其中最耳熟能详的），需要几十毫秒的延迟时间，高频交易员就是在这几十毫秒里做文章。</p><p>当股民老王的订单从交易所A传递给交易所B时，借助于高速网络，高频交易员先于交易所B得到这个信息，即“有一个订单是当股票价格低于450元时买100股”，此时如果交易所B的股票价格低于450，比如说是440，交易员就会买入它，再转手以450元的价格履行刚才得到的订单。在这笔交易中，高频交易员获利1000元，股民老王也以预期的450元价格购入了目标股票。</p><blockquote><p>2013年年初，最大的高频交易公司之一Virtu Financial公开称，在其5年半的交易中心仅有一天没有赚到钱，那一天还是因为出现了“人为误差”。</p></blockquote><p>一个高频交易公司可以在市场上疯狂交易而不带来任何附加价值，而且可以不承担任何风险，当它买入时，它知道有确切的卖家，当它卖出时，它知道肯定有人买。在每个交易日结束时，它在任何市场都完全不持有头寸。</p><p>高频交易公司每天闭市时都是平仓的，他们作为买卖双方桥梁的时间极短，以至于根本没有人知道其存在。</p><h2 id="高频交易的分类"><a href="#高频交易的分类" class="headerlink" title="高频交易的分类"></a>高频交易的分类</h2><h3 id="电子抢先交易（electronic-frontrunning）"><a href="#电子抢先交易（electronic-frontrunning）" class="headerlink" title="电子抢先交易（electronic frontrunning）"></a>电子抢先交易（electronic frontrunning）</h3><p>在一个地方探知投资者的交易信息后，在另一个地方抢在投资者之前通过一系列订单推高或拉低价格，并从中获利</p><h3 id="回扣套利（rebate-arbitrage）"><a href="#回扣套利（rebate-arbitrage）" class="headerlink" title="回扣套利（rebate arbitrage）"></a>回扣套利（rebate arbitrage）</h3><p>交易所通常会为创造流动性的券商提供一定的交易费用回扣，高频交易者利用速度优势创造虚假流动性，骗取交易所的回扣</p><h3 id="慢市场套利（slow-market-arbitrage）"><a href="#慢市场套利（slow-market-arbitrage）" class="headerlink" title="慢市场套利（slow market arbitrage）"></a>慢市场套利（slow market arbitrage）</h3><p>高频交易者在一个交易所探知到股票价格变动之后，再利用速度优势在另一个交易所反应过来之前进行买卖操作。这可能是使用最广的</p><h2 id="疑问：赢家拿走一切"><a href="#疑问：赢家拿走一切" class="headerlink" title="疑问：赢家拿走一切"></a>疑问：赢家拿走一切</h2><p>在高频交易的战场上，是否意味着“赢家拿走一切”？如果甲的算法/线路比乙快10%，最终甲会获取所有的订单并完成交易，乙一分钱都拿不到？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言-背景与动机&quot;&gt;&lt;a href=&quot;#前言-背景与动机&quot; class=&quot;headerlink&quot; title=&quot;前言-背景与动机&quot;&gt;&lt;/a&gt;前言-背景与动机&lt;/h2&gt;&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;di
      
    
    </summary>
    
    
      <category term="高频交易" scheme="https://lilei.pro/tags/%E9%AB%98%E9%A2%91%E4%BA%A4%E6%98%93/"/>
    
  </entry>
  
  <entry>
    <title>架构学习之 master-v2</title>
    <link href="https://lilei.pro/2019/10/11/architecture-master-v2/"/>
    <id>https://lilei.pro/2019/10/11/architecture-master-v2/</id>
    <published>2019-10-11T15:50:24.000Z</published>
    <updated>2019-10-11T15:54:24.831Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Move stones, not mountains.</p></blockquote><p>Google 官方的 <a href="https://github.com/googlesamples/android-architecture" target="_blank" rel="noopener">Android Architecture Blueprints</a> 推出了 v2 版本，相比于之前的 v1 版本，v2 采取了更先进的设计思想与组件：</p><ul><li>采用 Kotlin Coroutines 处理后台操作</li><li>单一 Activity 结构，用 <a href="https://developer.android.com/guide/navigation/navigation-getting-started" target="_blank" rel="noopener">Navigation component</a> 处理Fragment 之间跳转</li><li>由 Fragment(View) 和 ViewModel 组成的 Presentation 层，即 <strong>MVVM</strong> 模式</li><li>基于 LiveData 和 DataBinding 的响应式（Reactive）UI</li><li>data 层使用一个 Repository 和两个 Datasource（本地数据、远端数据），采用直观的调用方式（非回调、非 data stream）</li><li>两个 product flavor，分别是<code>mock</code>和<code>prod</code>，对应着测试与开发环境</li><li>一系列单元测试、集成测试以及端到端测试</li></ul><p>接下来从源码角度解析 master 分支工程，看看 v2 究竟可以为我们带来什么便利。</p><hr><h2 id="程序入口"><a href="#程序入口" class="headerlink" title="程序入口"></a>程序入口</h2><p>入口在<code>TasksActivity.java</code>，注意到这是一个“SPA”，即 Single Page Application，在<code>AndroidManifest.xml</code>中只声明了这一个 Activity。<code>TasksActivity</code>实际上只是一个壳页面，只处理了 Navigation、ActionBar、NavigationDrawer 等基础功能。它在<code>onCreate</code>里进行这些初始化：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> drawerLayout: DrawerLayout</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> appBarConfiguration: AppBarConfiguration</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">    setContentView(R.layout.tasks_act)</span><br><span class="line">    setupNavigationDrawer()</span><br><span class="line">    setSupportActionBar(findViewById(R.id.toolbar))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> navController: NavController = findNavController(R.id.nav_host_fragment)</span><br><span class="line">    appBarConfiguration =</span><br><span class="line">        AppBarConfiguration.Builder(R.id.tasks_fragment_dest, R.id.statistics_fragment_dest)</span><br><span class="line">            .setDrawerLayout(drawerLayout)</span><br><span class="line">            .build()</span><br><span class="line">    setupActionBarWithNavController(navController, appBarConfiguration)</span><br><span class="line">    findViewById&lt;NavigationView&gt;(R.id.nav_view)</span><br><span class="line">        .setupWithNavController(navController)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该应用采用 Navigation component 管理页面跳转，跳转关系在<code>nav_graph.xml</code>文件中以可视化的方式呈现。我们这里不需要关心跳转组件的具体用法， 只要知道它可以启动我们要分析的<code>TasksFragment</code>就可以了。</p><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p>我习惯从数据开始分析代码走向，看一下<code>data</code>目录的结构：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">λ tree data</span><br><span class="line">data</span><br><span class="line">|-- Result.kt</span><br><span class="line">|-- Task.kt</span><br><span class="line">`-- <span class="built_in">source</span></span><br><span class="line">    |-- DefaultTasksRepository.kt</span><br><span class="line">    |-- TasksDataSource.kt</span><br><span class="line">    |-- TasksRepository.kt</span><br><span class="line">    `-- <span class="built_in">local</span></span><br><span class="line">        |-- TasksDao.kt</span><br><span class="line">        |-- TasksLocalDataSource.kt</span><br><span class="line">        `-- ToDoDatabase.kt</span><br></pre></td></tr></table></figure><h3 id="Result-kt-与-Task-kt"><a href="#Result-kt-与-Task-kt" class="headerlink" title="Result.kt 与 Task.kt"></a>Result.kt 与 Task.kt</h3><p><code>Result.kt</code>是一个数据请求的结果封装类，业务层对数据的请求均是通过 Result 对象进行封装。这个类使用到了多个 Kotlin 特性，容我在注释里一一说明。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">Result</span>&lt;<span class="type">out R</span>&gt; </span>&#123; <span class="comment">// 密封类，将继承限制在类内部；out 类型，协变，保留子类型化关系</span></span><br><span class="line">    <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Success</span>&lt;<span class="type">out T</span>&gt;</span>(<span class="keyword">val</span> <span class="keyword">data</span>: T) : Result&lt;T&gt;() <span class="comment">// data 类，协变类型T可以用作构造参数</span></span><br><span class="line">    <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Error</span></span>(<span class="keyword">val</span> exception: Exception) : Result&lt;<span class="built_in">Nothing</span>&gt;() <span class="comment">// Nothing类型，永不返回</span></span><br><span class="line">    <span class="keyword">object</span> Loading : Result&lt;<span class="built_in">Nothing</span>&gt;() <span class="comment">// object直接创建对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">when</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">is</span> Success&lt;*&gt; -&gt; <span class="string">"Success[data=<span class="variable">$data</span>]"</span> <span class="comment">// *表示不关心具体类型</span></span><br><span class="line">            <span class="keyword">is</span> Error -&gt; <span class="string">"Error[exception=<span class="variable">$exception</span>]"</span></span><br><span class="line">            Loading -&gt; <span class="string">"Loading"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * `true` if [Result] is of type [Success] &amp; holds non-null [Success.data].</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">val</span> Result&lt;*&gt;.succeeded <span class="comment">// 扩展属性，注意命名不是isSuccess（Chinglish）</span></span><br><span class="line">  <span class="keyword">get</span>() = <span class="keyword">this</span> <span class="keyword">is</span> Success &amp;&amp; <span class="keyword">data</span> != <span class="literal">null</span></span><br></pre></td></tr></table></figure><p><code>Task.kt</code>描述了任务对象，由<code>title</code>、<code>description</code>、<code>completed</code>和<code>id</code>四个字段构成，同时借助 Room 组件自动关联到名为<strong>tasks</strong>的数据表。</p><h3 id="数据接口：TasksDataSource-kt-与-TasksRepository-kt"><a href="#数据接口：TasksDataSource-kt-与-TasksRepository-kt" class="headerlink" title="数据接口：TasksDataSource.kt 与 TasksRepository.kt"></a>数据接口：TasksDataSource.kt 与 TasksRepository.kt</h3><p><code>TasksDataSource.kt</code>和<code>TasksRepository.kt</code>是两个接口类，内容十分相似：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TasksDataSource.kt</span></span><br><span class="line"><span class="comment">// Main entry point for accessing tasks data.</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">TasksDataSource</span> </span>&#123;</span><br><span class="line">    suspend <span class="function"><span class="keyword">fun</span> <span class="title">getTasks</span><span class="params">()</span></span>: Result&lt;List&lt;Task&gt;&gt;</span><br><span class="line">    suspend <span class="function"><span class="keyword">fun</span> <span class="title">getTask</span><span class="params">(taskId: <span class="type">String</span>)</span></span>: Result&lt;Task&gt;</span><br><span class="line">    suspend <span class="function"><span class="keyword">fun</span> <span class="title">saveTask</span><span class="params">(task: <span class="type">Task</span>)</span></span></span><br><span class="line">    suspend <span class="function"><span class="keyword">fun</span> <span class="title">completeTask</span><span class="params">(task: <span class="type">Task</span>)</span></span></span><br><span class="line">    suspend <span class="function"><span class="keyword">fun</span> <span class="title">completeTask</span><span class="params">(taskId: <span class="type">String</span>)</span></span></span><br><span class="line">    suspend <span class="function"><span class="keyword">fun</span> <span class="title">activateTask</span><span class="params">(task: <span class="type">Task</span>)</span></span></span><br><span class="line">    suspend <span class="function"><span class="keyword">fun</span> <span class="title">activateTask</span><span class="params">(taskId: <span class="type">String</span>)</span></span></span><br><span class="line">    suspend <span class="function"><span class="keyword">fun</span> <span class="title">clearCompletedTasks</span><span class="params">()</span></span></span><br><span class="line">    suspend <span class="function"><span class="keyword">fun</span> <span class="title">deleteAllTasks</span><span class="params">()</span></span></span><br><span class="line">    suspend <span class="function"><span class="keyword">fun</span> <span class="title">deleteTask</span><span class="params">(taskId: <span class="type">String</span>)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TasksRepository.kt</span></span><br><span class="line"><span class="comment">// Interface to the data layer.</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">TasksRepository</span> </span>&#123;</span><br><span class="line">    suspend <span class="function"><span class="keyword">fun</span> <span class="title">getTasks</span><span class="params">(forceUpdate: <span class="type">Boolean</span> = <span class="literal">false</span>)</span></span>: Result&lt;List&lt;Task&gt;&gt;</span><br><span class="line">    suspend <span class="function"><span class="keyword">fun</span> <span class="title">getTask</span><span class="params">(taskId: <span class="type">String</span>, forceUpdate: <span class="type">Boolean</span> = <span class="literal">false</span>)</span></span>: Result&lt;Task&gt;</span><br><span class="line">    suspend <span class="function"><span class="keyword">fun</span> <span class="title">saveTask</span><span class="params">(task: <span class="type">Task</span>)</span></span></span><br><span class="line">    suspend <span class="function"><span class="keyword">fun</span> <span class="title">completeTask</span><span class="params">(task: <span class="type">Task</span>)</span></span></span><br><span class="line">    suspend <span class="function"><span class="keyword">fun</span> <span class="title">completeTask</span><span class="params">(taskId: <span class="type">String</span>)</span></span></span><br><span class="line">    suspend <span class="function"><span class="keyword">fun</span> <span class="title">activateTask</span><span class="params">(task: <span class="type">Task</span>)</span></span></span><br><span class="line">    suspend <span class="function"><span class="keyword">fun</span> <span class="title">activateTask</span><span class="params">(taskId: <span class="type">String</span>)</span></span></span><br><span class="line">    suspend <span class="function"><span class="keyword">fun</span> <span class="title">clearCompletedTasks</span><span class="params">()</span></span></span><br><span class="line">    suspend <span class="function"><span class="keyword">fun</span> <span class="title">deleteAllTasks</span><span class="params">()</span></span></span><br><span class="line">    suspend <span class="function"><span class="keyword">fun</span> <span class="title">deleteTask</span><span class="params">(taskId: <span class="type">String</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到两者的方法几乎是一样的：名字和数量相同，区别仅仅在于<code>TasksRepository</code>中的个别方法多了<code>forceUpdate</code>参数。不过，这两个接口在语义上是不同的。</p><ul><li><code>TasksDatasource</code>是底层数据封装，数据可能来自网络，也可能来自于文件、数据库。</li><li><code>TasksRepository</code>是数据层对外的接口，业务代码通过该接口对数据进行增删改查。<code>forceUpdate</code>参数作用于接口实现类内部的缓存。</li><li><code>suspend</code>关键字说明它们均为 Coroutines 接口。</li></ul><p>然后我们来看下对外的接口是如何给到使用者的。<code>TodoApplication</code>类继承自<code>Application</code>，其中有一个成员变量<code>taskRepository</code>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TodoApplication.kt</span></span><br><span class="line"><span class="keyword">val</span> taskRepository: TasksRepository</span><br><span class="line">    <span class="keyword">get</span>() = ServiceLocator.provideTasksRepository(<span class="keyword">this</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment">// ServiceLocator.kt</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">provideTasksRepository</span><span class="params">(context: <span class="type">Context</span>)</span></span>: TasksRepository &#123;</span><br><span class="line">    synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> tasksRepository ?: tasksRepository ?: createTasksRepository(context)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">createTasksRepository</span><span class="params">(context: <span class="type">Context</span>)</span></span>: TasksRepository &#123;</span><br><span class="line">    <span class="keyword">return</span> DefaultTasksRepository(FakeTasksRemoteDataSource, createTaskLocalDataSource(context))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// TodoApplication.taskRepository 通过 Fragment 的扩展方法给到各个 Fragment</span></span><br><span class="line"><span class="comment">// FragmentExt.kt</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Fragment.<span class="title">getViewModelFactory</span><span class="params">()</span></span>: ViewModelFactory &#123;</span><br><span class="line">  <span class="keyword">val</span> repository = (requireContext().applicationContext <span class="keyword">as</span> TodoApplication).taskRepository</span><br><span class="line">  <span class="keyword">return</span> ViewModelFactory(repository)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="local-目录：本地数据实现"><a href="#local-目录：本地数据实现" class="headerlink" title="local 目录：本地数据实现"></a>local 目录：本地数据实现</h3><p>local 目录下是<code>TasksDatasource</code>的本地实现，与此相对的，若数据来源于网络，则还应当有一个 remote 目录。</p><ul><li><code>ToDoDatabase</code> 是数据库声明</li><li><code>TasksDao</code> 声明 tasks 表的 CRUD 操作</li><li><code>TasksLocalDataSource</code> 是<code>TasksDataSource</code>的本地实现，使用<code>Dispatchers.IO</code>作为协程上下文，调用<code>TasksDao</code>完成数据操作</li></ul><h3 id="数据层总结"><a href="#数据层总结" class="headerlink" title="数据层总结"></a>数据层总结</h3><p>相比于曾经分析过的<strong>todo-mvp</strong>和<strong>todo-mvp-clean</strong>，最直观的感受是，v2在保证数据接口语义不变的前提下，借助 Coroutines 简化了原有的回调写法，用同步的方式写异步的代码。此外，像使用 Room 做 ORM、local/remote 两套数据实现等，与之前的项目并无不同。</p><hr><h2 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h2><h3 id="背景知识：ViewModel-与-LiveData"><a href="#背景知识：ViewModel-与-LiveData" class="headerlink" title="背景知识：ViewModel 与 LiveData"></a>背景知识：ViewModel 与 LiveData</h3><p>ViewModel 与 LiveData 都是 Android Jetpack 中的架构组件，它们通常组合使用，达到将数据和视图解耦的目的。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/191011_architecture_master_v2/jetpack.png" alt="jetpack" title="">                </div>                <div class="image-caption">jetpack</div>            </figure><p><strong>ViewModel</strong></p><ul><li>避免屏幕旋转等事件发生时，保存在 Activity 中的数据被销毁并重建</li><li>异步回调时防止内存泄漏、Context 为 Null</li><li>将数据和视图解耦，防止出现 God Activities 和 God Fragments</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/191011_architecture_master_v2/viewmodel.png" alt="viewmodel" title="">                </div>                <div class="image-caption">viewmodel</div>            </figure><p><strong>LiveData</strong></p><ul><li>DataBinding 思想的一种实现，数据/视图双向绑定</li><li>与生命周期关联，页面销毁后自动将其从订阅者列表去除</li></ul><h3 id="ViewModelFactory"><a href="#ViewModelFactory" class="headerlink" title="ViewModelFactory"></a>ViewModelFactory</h3><p>ViewModel 的创建采用工厂模式进行统一管理。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ViewModelFactory.kt</span></span><br><span class="line"><span class="meta">@Suppress(<span class="meta-string">"UNCHECKED_CAST"</span>)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewModelFactory</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> tasksRepository: TasksRepository</span><br><span class="line">) : ViewModelProvider.NewInstanceFactory() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : ViewModel&gt;</span> <span class="title">create</span><span class="params">(modelClass: <span class="type">Class</span>&lt;<span class="type">T</span>&gt;)</span></span> =</span><br><span class="line">        with(modelClass) &#123;</span><br><span class="line">          <span class="keyword">when</span> &#123;</span><br><span class="line">                isAssignableFrom(StatisticsViewModel::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>) -&gt;</span></span><br><span class="line">                    StatisticsViewModel(tasksRepository)</span><br><span class="line">                isAssignableFrom(TaskDetailViewModel::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>) -&gt;</span></span><br><span class="line">                    TaskDetailViewModel(tasksRepository)</span><br><span class="line">                isAssignableFrom(AddEditTaskViewModel::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>) -&gt;</span></span><br><span class="line">                    AddEditTaskViewModel(tasksRepository)</span><br><span class="line">                isAssignableFrom(TasksViewModel::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>) -&gt;</span></span><br><span class="line">                    TasksViewModel(tasksRepository)</span><br><span class="line">                <span class="keyword">else</span> -&gt;</span><br><span class="line">                    <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"Unknown ViewModel class: <span class="subst">$&#123;modelClass.name&#125;</span>"</span>)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">as</span> T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还记得上文提到过为 Fragment 增加的扩展函数吗？在每一个页面（Fragment）里通过这个扩展函数获取到工厂类，进而获得对应 ViewModel 类的实例。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FragmentExt.kt</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Fragment.<span class="title">getViewModelFactory</span><span class="params">()</span></span>: ViewModelFactory &#123;</span><br><span class="line">  <span class="keyword">val</span> repository = (requireContext().applicationContext <span class="keyword">as</span> TodoApplication).taskRepository</span><br><span class="line">  <span class="keyword">return</span> ViewModelFactory(repository)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TasksFragment.kt</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TasksFragment</span> : <span class="type">Fragment</span></span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> viewModel <span class="keyword">by</span> viewModels&lt;TasksViewModel&gt; &#123; getViewModelFactory() &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是 ViewModel 类，它承担了与 Presenter 类似的职责，是处理业务逻辑的地方。如果需要的话，可以增加一个 Domain 层，负责提取出来的业务逻辑（Use cases），提供复用，这样就变成了 <a href="https://github.com/googlesamples/android-architecture/tree/usecases" target="_blank" rel="noopener">MVVM-Clean</a> 模式。在 master 分支上还没有 domain 层。</p><h3 id="TasksViewModel"><a href="#TasksViewModel" class="headerlink" title="TasksViewModel"></a>TasksViewModel</h3><p>ViewModel 接受一个 TasksRepository 参数，用作数据层接口。（在clean架构里，这里传入的不是Repository，而是UseCases）。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TasksViewModel</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> tasksRepository: TasksRepository</span><br><span class="line">) : ViewModel() &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后声明了一系列变量作为页面数据&amp;状态，这里采用“一个对象，两个变量”的成对写法，略显繁琐，不知道有没有更优美的处理方法。这样做的目的是把对变量的修改关闭，对外（即LiveData）仅提供读取变量的接口，只可以在 ViewModel 内部修改变量。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> _items = MutableLiveData&lt;List&lt;Task&gt;&gt;().apply &#123; value = emptyList() &#125; <span class="comment">// 以下划线开头的为私有变量，apply 和 with 的用法要分清，相当于调用 _items.setValue(emptyList()); return _items;</span></span><br><span class="line"><span class="keyword">val</span> items: LiveData&lt;List&lt;Task&gt;&gt; = _items</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> _dataLoading = MutableLiveData&lt;<span class="built_in">Boolean</span>&gt;()</span><br><span class="line"><span class="keyword">val</span> dataLoading: LiveData&lt;<span class="built_in">Boolean</span>&gt; = _dataLoading</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> _currentFilteringLabel = MutableLiveData&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="keyword">val</span> currentFilteringLabel: LiveData&lt;<span class="built_in">Int</span>&gt; = _currentFilteringLabel</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> _noTasksLabel = MutableLiveData&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="keyword">val</span> noTasksLabel: LiveData&lt;<span class="built_in">Int</span>&gt; = _noTasksLabel</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> _noTaskIconRes = MutableLiveData&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="keyword">val</span> noTaskIconRes: LiveData&lt;<span class="built_in">Int</span>&gt; = _noTaskIconRes</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> _tasksAddViewVisible = MutableLiveData&lt;<span class="built_in">Boolean</span>&gt;()</span><br><span class="line"><span class="keyword">val</span> tasksAddViewVisible: LiveData&lt;<span class="built_in">Boolean</span>&gt; = _tasksAddViewVisible</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> _snackbarText = MutableLiveData&lt;Event&lt;<span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line"><span class="keyword">val</span> snackbarText: LiveData&lt;Event&lt;<span class="built_in">Int</span>&gt;&gt; = _snackbarText</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> _currentFiltering = TasksFilterType.ALL_TASKS   <span class="comment">// Not used at the moment private val isDataLoadingError = MutableLiveData&lt;Boolean&gt;()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> _openTaskEvent = MutableLiveData&lt;Event&lt;String&gt;&gt;()</span><br><span class="line"><span class="keyword">val</span> openTaskEvent: LiveData&lt;Event&lt;String&gt;&gt; = _openTaskEvent</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> _newTaskEvent = MutableLiveData&lt;Event&lt;<span class="built_in">Unit</span>&gt;&gt;()</span><br><span class="line"><span class="keyword">val</span> newTaskEvent: LiveData&lt;Event&lt;<span class="built_in">Unit</span>&gt;&gt; = _newTaskEvent</span><br><span class="line"></span><br><span class="line"><span class="comment">// This LiveData depends on another so we can use a transformation.</span></span><br><span class="line"><span class="keyword">val</span> empty: LiveData&lt;<span class="built_in">Boolean</span>&gt; = Transformations.map(_items) &#123;</span><br><span class="line"> it.isEmpty()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以说管理上面这些数据是 ViewModel 最主要的职责了，从功能上区分，这些数据可以分成<strong>3种</strong>。</p><ol><li>业务实体如 items（任务对象列表），ViewModel 通过修改这类对象，借助于 DataBinding 更新 UI</li><li>数据状态对象如 dataLoading（是否正在加载数据）、currentFilteringLabel（当前的过滤器文字）、noTasksLabel（没有任务的文字）、snackbarText（提示栏文字），这一类对象不进行持久化存储，但是也会影响到 UI 显示</li><li>事件包装对象如 openTaskEvent（打开某个任务，在点击列表中的任务时触发）、newTaskEvent（创建一个任务，在点击+时触发），它们负责通知页面进行跳转——这部分设计得不佳，为了 DataBinding 而强行 DataBinding</li></ol><p>总之贯彻的思想是：一切变动都是数据变动，数据变动通过 DataBinding 自动投射到 UI。</p><hr><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>视图也就是<code>TasksFragment.kt</code>类，负责初始化布局，触发 ViewModel 进行首次加载。这里的 Fragment 继承自 androidx 中的 Fragment。</p><p>在<code>onCreateView</code>里初始化 DataBinding（数据）。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    inflater: <span class="type">LayoutInflater</span>, container: <span class="type">ViewGroup</span>?,</span></span></span><br><span class="line"><span class="function"><span class="params">  savedInstanceState: <span class="type">Bundle</span>?</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: View? &#123;</span><br><span class="line">    viewDataBinding = TasksFragBinding.inflate(inflater, container, <span class="literal">false</span>).apply &#123;</span><br><span class="line">    viewmodel = viewModel</span><br><span class="line">    &#125;</span><br><span class="line">  setHasOptionsMenu(<span class="literal">true</span>)</span><br><span class="line">  <span class="keyword">return</span> viewDataBinding.root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>onActivityCreated</code>里初始化 UI（视图），初始化完成后启动加载（代码最后一行）。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityCreated</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onActivityCreated(savedInstanceState)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the lifecycle owner to the lifecycle of the view</span></span><br><span class="line">    viewDataBinding.lifecycleOwner = <span class="keyword">this</span>.viewLifecycleOwner</span><br><span class="line">    setupSnackbar()</span><br><span class="line">    setupListAdapter()</span><br><span class="line">    setupRefreshLayout(viewDataBinding.refreshLayout, viewDataBinding.tasksList)</span><br><span class="line">    setupNavigation()</span><br><span class="line">    setupFab()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Always reloading data for simplicity. Real apps should only do this on first load and</span></span><br><span class="line">    <span class="comment">// when navigating back to this destination. <span class="doctag">TODO:</span> https://issuetracker.google.com/79672220</span></span><br><span class="line">    viewModel.loadTasks(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，Fragment 中还会进行设置 OnClickListener、Adapter 等操作，比较简单，不赘述。</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>v2 的项目设计时采取了 MVVM 思想，旨在解决 MVP 模式下Presenter 层过于庞大的问题。其实 MVP-Clean 模式已经对此有一些缓解。而 MVVM 做的更彻底，干脆把数据对 UI 的控制完全交给框架自动进行。这样做的好处显而易见，但也并不是没有缺点，比如一旦出了问题，如果没有掌握个中原理，调试时必定摸不清头绪。总而言之，这是一个值得学习与尝试的架构设计。</p><hr><h2 id="Bonus：usecases"><a href="#Bonus：usecases" class="headerlink" title="Bonus：usecases"></a>Bonus：usecases</h2><p><a href="https://github.com/googlesamples/android-architecture/tree/usecases" target="_blank" rel="noopener">usecases</a> 是 v2 中的一个 Stable<br> 分支（另一个是<a href="https://github.com/googlesamples/android-architecture/tree/dagger-android" target="_blank" rel="noopener">dagger-android</a>)。usecases 以解耦、抽象、单向依赖为核心设计理念，这也是 Clean 架构的核心思想。</p><ul><li>表现层只能访问到领域层/用例层，不知道数据层的存在</li><li>领域层/用例层只能访问到数据层，无法访问表现层</li><li>数据层无法访问表现层和领域层</li></ul><p>领域层（或者叫用例层），即 Domain Layer，是由多个 UseCase 组成的，每一个 UseCase 对应一个业务逻辑。以“加载单个Task”为例，可以看到 UseCase 里直接将请求转发给 TasksRepository 来处理，逻辑十分简单。</p><p>在分析具体差别之前，可以先看一遍 usecase 分支与 master 分支的 diff：<a href="https://github.com/googlesamples/android-architecture/compare/usecases#files_bucket" target="_blank" rel="noopener">https://github.com/googlesamples/android-architecture/compare/usecases#files_bucket</a></p><p><strong>GetTaskUseCase.kt</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetTaskUseCase</span></span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> tasksRepository: TasksRepository</span><br><span class="line">  ) &#123;</span><br><span class="line">    suspend <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(taskId: <span class="type">String</span>, forceUpdate: <span class="type">Boolean</span> = <span class="literal">false</span>)</span></span>: Result&lt;Task&gt; &#123;</span><br><span class="line">    wrapEspressoIdlingResource &#123;</span><br><span class="line">      <span class="keyword">return</span> tasksRepository.getTask(taskId, forceUpdate)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而获取 Tasks 列表的 Usecase 相对复杂一些，包括了原本在 TasksViewModel 中处理的过滤逻辑，从另一个角度看，这相当于减轻了 ViewModel 的负担。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetTasksUseCase</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> tasksRepository: TasksRepository</span><br><span class="line">) &#123;</span><br><span class="line">    suspend <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        forceUpdate: <span class="type">Boolean</span> = <span class="literal">false</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        currentFiltering: <span class="type">TasksFilterType</span> = ALL_TASKS</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>: Result&lt;List&lt;Task&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">        wrapEspressoIdlingResource &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> tasksResult = tasksRepository.getTasks(forceUpdate)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Filter tasks</span></span><br><span class="line">            <span class="keyword">if</span> (tasksResult <span class="keyword">is</span> Success &amp;&amp; currentFiltering != ALL_TASKS) &#123;</span><br><span class="line">                <span class="keyword">val</span> tasks = tasksResult.<span class="keyword">data</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">val</span> tasksToShow = mutableListOf&lt;Task&gt;()</span><br><span class="line">                <span class="comment">// We filter the tasks based on the requestType</span></span><br><span class="line">                <span class="keyword">for</span> (task <span class="keyword">in</span> tasks) &#123;</span><br><span class="line">                    <span class="keyword">when</span> (currentFiltering) &#123;</span><br><span class="line">                        ACTIVE_TASKS -&gt; <span class="keyword">if</span> (task.isActive) &#123;</span><br><span class="line">                            tasksToShow.add(task)</span><br><span class="line">                        &#125;</span><br><span class="line">                        COMPLETED_TASKS -&gt; <span class="keyword">if</span> (task.isCompleted) &#123;</span><br><span class="line">                            tasksToShow.add(task)</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> -&gt; NotImplementedError()</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> Success(tasksToShow)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> tasksResult</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于 ViewModel 里，将原来的 Repository 参数改为当前 ViewModel 用到的 UseCase 参数即可，所有处理数据的请求都有 UseCase 来接管。</p><p><strong>TasksViewModel.kt</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TasksViewModel</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> getTasksUseCase: GetTasksUseCase,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> clearCompletedTasksUseCase: ClearCompletedTasksUseCase,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> completeTaskUseCase: CompleteTaskUseCase,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> activateTaskUseCase: ActivateTaskUseCase</span><br><span class="line">) : ViewModel() &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Over~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Move stones, not mountains.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Google 官方的 &lt;a href=&quot;https://github.com/googlesamples/android-architecture&quot; 
      
    
    </summary>
    
    
      <category term="架构" scheme="https://lilei.pro/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>《Java 并发编程实战》勘误表 2019-08-27</title>
    <link href="https://lilei.pro/2019/08/27/jcip-errata/"/>
    <id>https://lilei.pro/2019/08/27/jcip-errata/</id>
    <published>2019-08-27T15:53:23.000Z</published>
    <updated>2019-08-27T16:05:56.759Z</updated>
    
    <content type="html"><![CDATA[<p>Java Concurrency in Practice 是一本讲解 JVM 下并发编程知识的经典作品，建议有志于资深的 Java 工程师将其纳入自己的读书计划中，相信一定会大有裨益。</p><p>在阅读这本书的过程中，我发现中文版本有很多显而易见的错误，尤其是代码里条件判断有时根本是反着来的（本应是<code>&gt;=</code>的条件，书里面却是<code>&lt;</code>）。Google 搜索之后发现在 <a href="http://jcip.net/errata.html" target="_blank" rel="noopener">http://jcip.net/errata.html</a> 有英文原版的勘误表，由于中文版本没有勘误表，故翻译在此，希望可以有所帮助。</p><p>使用之前请确认自己手中的书籍版本是否相符。</p><h1 id="本文适用的中文版本"><a href="#本文适用的中文版本" class="headerlink" title="本文适用的中文版本"></a>本文适用的中文版本</h1><ul><li>书名：《Java 并发编程实战》，Java Concurrency in Practice</li><li>作者：Brain Goetz, Tim Peierls 等</li><li>译者：童云兰 等</li><li>ISBN：978-7-111-37004-8</li><li>出版社：机械工业出版社</li><li>出版时间：2012.2 第一版，2018.9 重印</li><li>定价：69 元</li><li>豆瓣链接：<a href="https://book.douban.com/subject/10484692/" target="_blank" rel="noopener">https://book.douban.com/subject/10484692/</a></li></ul><h1 id="勘误数据来源"><a href="#勘误数据来源" class="headerlink" title="勘误数据来源"></a>勘误数据来源</h1><p><a href="http://jcip.net/errata.html" target="_blank" rel="noopener">官方勘误表</a></p><h1 id="中文版勘误表"><a href="#中文版勘误表" class="headerlink" title="中文版勘误表"></a>中文版勘误表</h1><table><thead><tr><th>页码</th><th>勘误</th></tr></thead><tbody><tr><td>p.5</td><td>程序清单 1-1 下面的第一段，<code>someVariable++</code>应为<code>value++</code></td></tr><tr><td>p.6</td><td>程序清单 1-2，<code>Value</code>应为<code>value</code></td></tr><tr><td>p.53</td><td>4.3 节上面的最后一段，<code>getLocation</code>应为<code>getLocations</code></td></tr><tr><td>p.58</td><td>程序清单 4-11，<code>SafePoint(int x, int y)</code>构造函数的函数体可以精简为<code>set(x, y)</code></td></tr><tr><td>p.62</td><td>程序清单 4-16，<code>if(contains)</code>应为<code>if(!contains)</code></td></tr><tr><td>p.75</td><td>5.3.1 第一段，<code>DiskCrawler</code>应为<code>FileCrawler</code></td></tr><tr><td>p.100</td><td>程序清单 6-7 下面第二段，<code>在 ExcutorService 关闭后提交的任务将由“拒绝执行处理器（Rejected Execution Handler）来处理</code>表述有误，<code>Rejected Execution Handler</code>是仅在<code>ThreadPoolExecutor</code>实现中提供的，并非所有的<code>ExecutorService</code>实现都具备此功能</td></tr><tr><td>p.122</td><td>第二行，<code>那么调用 close 或 wakeup 方法会使线程抛出 ClosedSelectorException</code>，只有<code>close</code>方法会抛出该异常，<code>wakeup</code>方法不会</td></tr><tr><td>p.163</td><td>程序清单 9-6，第一个<code>if(runningTask != null)</code>判断条件应为<code>(runningTask == null)</code></td></tr><tr><td>p.214</td><td>程序清单 12-9，<code>Executors.newFixedThreadPool(MAX_SIZE)</code>方法调用应该增加第二个参数<code>threadFactory</code></td></tr><tr><td>p.229</td><td>程序清单 13-3，代码倒数第三行<code>if (System.nanoTime() &lt; stopTime)</code>判断条件里的<code>&lt;</code>应为<code>&gt;=</code></td></tr></tbody></table><p>以上就是中文版《Java 并发编程实战》的勘误表，如有遗漏，欢迎通过文末留言联系我进行补充。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java Concurrency in Practice 是一本讲解 JVM 下并发编程知识的经典作品，建议有志于资深的 Java 工程师将其纳入自己的读书计划中，相信一定会大有裨益。&lt;/p&gt;
&lt;p&gt;在阅读这本书的过程中，我发现中文版本有很多显而易见的错误，尤其是代码里条件
      
    
    </summary>
    
    
      <category term="Java" scheme="https://lilei.pro/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>架构学习之 mvp-clean</title>
    <link href="https://lilei.pro/2019/08/21/architecture-todo-mvp-clean/"/>
    <id>https://lilei.pro/2019/08/21/architecture-todo-mvp-clean/</id>
    <published>2019-08-20T16:11:55.000Z</published>
    <updated>2019-08-20T16:17:18.801Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>I am the STORM!!!</p></blockquote><p>上一篇文章介绍了 MVP 模式，作为 Android 最朴实的架构，MVP 足以应对复杂度较低的业务场景，回想 2014~2015 年在 DP 做预订闪惠的日子，用的便是 MVP。</p><p>然而随着业务复杂度增加，Presenter 层的逻辑会随之变重，导致的结果便是 Presenter 类过大，动辄一两千行代码，实在是丑陋。在这种场景下，Clean 架构是一个很好的选择。</p><h2 id="关于-Clean"><a href="#关于-Clean" class="headerlink" title="关于 Clean"></a>关于 Clean</h2><h3 id="什么是-Clean"><a href="#什么是-Clean" class="headerlink" title="什么是 Clean"></a>什么是 Clean</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/190821_todo_mvp_clean/CleanArchitecture.jpg" alt="CleanArchitecture" title="">                </div>                <div class="image-caption">CleanArchitecture</div>            </figure><p>Clean 架构最初并不是为了针对 Android 平台的问题而提出，而是作为<strong>软件系统</strong>的通用架构被设计出来，如上面的同心圆所示，它的核心思想是<strong>The Dependency Rule（单向依赖原则）</strong>，即只能从外层向内层依赖，内层对外层一无所知，外层的变动不应当影响到内层。</p><p>另一个重要概念是<strong>Use Case（用例）</strong>，<strong>用例</strong>是业务逻辑的最小抽象单元，它调用数据模块的接口，向上（Presenter）提供业务逻辑操作入口。</p><h3 id="Android-Clean"><a href="#Android-Clean" class="headerlink" title="Android Clean"></a>Android Clean</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/190821_todo_mvp_clean/mvp-clean.png" alt="mvp-clean" title="">                </div>                <div class="image-caption">mvp-clean</div>            </figure><p>Android 平台在 Presenter 和 Model 之间定义了<strong>Domain Layer（域层）</strong>，用于承载<strong>Use Case</strong>，如上图所示，Use Case 的背后是业务逻辑。Domain Layer 脱胎于 MVP 的 Presenter，这样可以避免相同的业务逻辑代码出现在两个 Presenter 中的问题。</p><h4 id="Use-Cases-异步性"><a href="#Use-Cases-异步性" class="headerlink" title="Use Cases 异步性"></a>Use Cases 异步性</h4><p>鉴于 Domain Layer 是 UI 无关的，这里可以统一将 Use Case 放入工作线程运行，通过异步回调进行通信。至于更底层的数据库/网络操作，出于简化的目的，可以直接使用同步接口。</p><h4 id="不同-Layer-是否需要定义各自的-Model"><a href="#不同-Layer-是否需要定义各自的-Model" class="headerlink" title="不同 Layer 是否需要定义各自的 Model"></a>不同 Layer 是否需要定义各自的 Model</h4><p>标准的做法是在视图层（View Layer）、域层（Domain Layer）和数据层（Data/Model Layer）分别使用不同的对象，如 VO、BO、DO 等。这样带来的问题是重复性增加。如果对象是不可变的，在各层之间具有相同的属性和方法，则可以只定义一个对象，共通使用。</p><p>如果视图层对象包含 Android 相关的方法或属性，则应当为其单独定义一个类，然后使用<code>Mapper</code>在不同层之间进行对象转换。</p><h2 id="如何抽象业务场景"><a href="#如何抽象业务场景" class="headerlink" title="如何抽象业务场景"></a>如何抽象业务场景</h2><p>这里我们将 Clean 模式应用在 todo-app 上，想想还有点小激动。</p><h3 id="Use-Cases-amp-Domain-Layer"><a href="#Use-Cases-amp-Domain-Layer" class="headerlink" title="Use Cases &amp; Domain Layer"></a>Use Cases &amp; Domain Layer</h3><p>把 Use Case 的声明和运行机制拆开，是不是跟 Runnable + Executor 的机制很像？没错，这就是设计模式中的<strong>命令模式</strong>。设计模式不是彼此孤立的，一个项目里可以整体采用 Clean 架构，不同的子模块，应用不同的设计模式。设计模式是死的，人是活的。</p><p>抽象类<code>UseCase</code>即是<strong>命令</strong>，包含入参、出参、回调通知对象、运行的抽象过程（这里又出现了<strong>模版模式</strong>）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">UseCase</span>&lt;<span class="title">Q</span> <span class="keyword">extends</span> <span class="title">UseCase</span>.<span class="title">RequestValues</span>, <span class="title">P</span> <span class="keyword">extends</span> <span class="title">UseCase</span>.<span class="title">ResponseValue</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Q mRequestValues;</span><br><span class="line">  <span class="keyword">private</span> UseCaseCallback&lt;P&gt; mUseCaseCallback; <span class="comment">// 任务完成后（成功or失败）的回调</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// set and get</span></span><br><span class="line">  <span class="comment">//..</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="comment">// Executor 运行入口</span></span><br><span class="line">    executeUseCase(mRequestValues);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> voi8d <span class="title">executeUseCase</span><span class="params">(Q requestValues)</span></span>; <span class="comment">// 子类必需实体化这个方法</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RequestValues</span> </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResponseValues</span> </span>&#123;&#125; <span class="comment">// 接口约束</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UseCaseCallback</span>&lt;<span class="title">R</span>&gt; </span>&#123; <span class="comment">// 任务完成后的回调</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(R response)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后选取一个“加载全部任务”的场景为例，看它是如何实现抽象类的，以下是<code>GetTask.java</code>的部分代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetTasks</span> <span class="keyword">extends</span> <span class="title">UseCase</span>&lt;<span class="title">GetTasks</span>.<span class="title">RequestValues</span>, <span class="title">GetTasks</span>.<span class="title">ResponseValues</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> TasksRepository mTasksRepository; <span class="comment">// 更底层的数据源对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> FilterFactory mFilterFactory; <span class="comment">// 过滤器工厂类</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">GetTasks</span><span class="params">(@NonNull TaskRepository tasksRepository, @NonNull FilterFactory filterFactory)</span> </span>&#123; <span class="comment">// 构造时传入数据源对象和过滤器工厂</span></span><br><span class="line">    mTasksRepository = checkNotNull(tasksRepository, <span class="string">"tasksRepository cannot be null!"</span>);</span><br><span class="line">    mFilterFactory = checkNotNull(filterFactory, <span class="string">"filterFactory cannot be null!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">executeUseCase</span><span class="params">(<span class="keyword">final</span> RequestValues values)</span> </span>&#123; <span class="comment">// 利用泛型约束，在不同UseCase实现类里使用不同参数</span></span><br><span class="line">    <span class="keyword">if</span> (values.isForceUpdate()) &#123;</span><br><span class="line">      mTasksRepository.refreshTasks();</span><br><span class="line">    &#125;</span><br><span class="line">    mTasksRepository.getTasks(<span class="keyword">new</span> TasksDataSource.LoadTasksCallback() &#123; <span class="comment">// 调用数据源异步方法</span></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTasksLoaded</span><span class="params">(List&lt;Task&gt; tasks)</span> </span>&#123;</span><br><span class="line">        TasksFilterType currentFiltering = values.getCurrentFiltering();</span><br><span class="line">        TaskFilter taskfilter = mFilterFactory.create(currentFiltering);</span><br><span class="line"></span><br><span class="line">        List&lt;Task&gt; tasksFiltered = taskFilter.filter(tasks);</span><br><span class="line">        ResponseValue responseValue = <span class="keyword">new</span> ResponseValue(tasksFiltered);</span><br><span class="line">        getUseCaseCallback().onSuccess(responseValue);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDataNotAvailable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        getUseCallback().onError();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestValues</span> <span class="keyword">implements</span> <span class="title">UseCase</span>.<span class="title">RequestValues</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TasksFilterType mCurrentFiltering;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> mForceUpdate;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// constructor, get and set</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseValues</span> <span class="keyword">implements</span> <span class="title">UseCase</span>.<span class="title">ResponseValues</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Task&gt; mTasks;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我在上述代码的注释里增加了一些说明，此外，有几处需要额外的注意：</p><ol><li>Use Case 构造函数里需要传入底层数据源对象，这意味着不可以在 Presenter 层直接构造 Use Case，因为 Presenter 不应当跨过 Domain Layer 直接访问数据源。—— 想想如何实现？IOC，DI，Bingo！</li><li>在 Use Case 的类内部，以静态类的方式声明<code>RequestValues</code>和<code>ResponseValues</code>，代码集中，易于管理。<code>UseCase.java</code>基类中提供的空接口也利于不同的子类声明各自不同的参数类型。在模版方法<code>executeUseCase</code>里分别进行调用，化元归一。</li></ol><h3 id="Executor：任务执行机制"><a href="#Executor：任务执行机制" class="headerlink" title="Executor：任务执行机制"></a>Executor：任务执行机制</h3><p><strong>命令模式</strong>由命令与执行机制两部分组成，Java 中的<code>Executor</code>框架就是一种典型应用。虽然<code>Executor</code>只是一个简单的接口，但它却为灵活而强大的异步任务执行框架提供了基础，该框架能支持多种不同类型的任务执行策略。它提供了一种标准的方法将任务的提交过程和执行过程解耦开来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java 中的 Executor，不负责运行结果通知</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>项目里使用同样的机制作为<code>UseCase</code>的运行框架。</p><p><code>UseCaseScheduler.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UseCaseScheduler</span> </span>&#123;</span><br><span class="line">  <span class="comment">// todo-mvp-clean 中的 Executor</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable runnable)</span></span>;</span><br><span class="line">  <span class="comment">// 增加结果通知回调</span></span><br><span class="line">  &lt;V extends UseCase.ResponseValue&gt; <span class="function"><span class="keyword">void</span> <span class="title">notifyResponse</span><span class="params">(<span class="keyword">final</span> V response, <span class="keyword">final</span> UseCase.UseCaseCallback&lt;V&gt; useCaseCallback)</span></span>;</span><br><span class="line">  &lt;V extends UseCase.ResponseValue&gt; <span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">(<span class="keyword">final</span> UseCase.UseCaseCallback&lt;V&gt; useCaseCallback)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的实现类采用线程池方式实现：</p><p><code>UseCaseThreadPoolScheduler.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseCaseThreadPoolScheduler</span> <span class="keyword">implements</span> <span class="title">UseCaseScheduler</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Handler mHandler = <span class="keyword">new</span> Handler(); <span class="comment">// 将运算结果通知主线程</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> POOL_SIZE = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_POOL_SIZE = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIMEOUT = <span class="number">30</span>;</span><br><span class="line">  ThreadPoolExecutor mThreadPoolExecutor; <span class="comment">// 使用线程池提供复用</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">UseCaseThreadPoolScheduler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mThreadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(POOL_SIZE, MAX_POOL_SIZE, TIMEOUT, TimeUnit.SECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(POOL_SIZE));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">    mThreadPoolExecutor.execute(runnable); <span class="comment">// 任务提交给线程池处理</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;V extends UseCase.ResponseValue&gt; <span class="function"><span class="keyword">void</span> <span class="title">notifyResponse</span><span class="params">(<span class="keyword">final</span> V response, <span class="keyword">final</span> UseCase.UseCaseCallback&lt;V&gt; useCaseCallback)</span> </span>&#123;</span><br><span class="line">    mHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        useCaseCallback.onSuccess(response); <span class="comment">// 主线程处理结果</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;V extends UseCase.ResponseValue&gt; <span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">(<span class="keyword">final</span> UseCase.UseCaseCallback&lt;V&gt; useCaseCallback)</span> </span>&#123;</span><br><span class="line">    mHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        useCaseCallback.onError(); <span class="comment">// 主线程处理结果</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="UseCaseHandler：任务执行机制包装"><a href="#UseCaseHandler：任务执行机制包装" class="headerlink" title="UseCaseHandler：任务执行机制包装"></a>UseCaseHandler：任务执行机制包装</h3><p>上文介绍了项目里采用<code>Executor</code>作为命令的运行框架，<code>Executor</code>接收的是<code>Runnable</code>类型的任务，我们还需要一层<strong>UseCase处理器</strong>，用于将<code>UseCase</code>封装成<code>Runnable</code>，并且处理任务的返回值。<code>UseCaseHandler</code>就是负责处理<code>UseCase</code>的组件。</p><p><code>UseCaseHandler.java</code>，省略部分代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseCaseHandler</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> UseCaseHandler INSTANCE; <span class="comment">// 单例模式，饿汉</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T extends UseCase.RequestValues, R extends UseCase.ResponseValue&gt; <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> UseCase&lt;T, R&gt; useCase, T values, UseCase.UseCaseCallback&lt;R&gt; callback)</span> </span>&#123;</span><br><span class="line">    useCase.setRequestValues(values);</span><br><span class="line">    useCase.setUseCaseCallback(<span class="keyword">new</span> UiCallbackWrapper(callback, <span class="keyword">this</span>));</span><br><span class="line">    mUseCaseScheduler.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        useCase.run();</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// UI回调包装器类，将成功/失败事件交给UI线程处理</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">UiCallbackWrapper</span>&lt;<span class="title">V</span> <span class="keyword">extends</span> <span class="title">UseCase</span>.<span class="title">ResponseValue</span>&gt; <span class="keyword">implements</span> <span class="title">UseCase</span>.<span class="title">UseCaseCallback</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UseCase.UseCaseCallback&lt;V&gt; mCallback;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UseCaseHandler mUseCaseHandler;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UiCallbackWrapper</span><span class="params">(UseCase.UseCaseCallback&lt;V&gt; callback, UseCaseHandler useCaseHandler)</span> </span>&#123;</span><br><span class="line">      mCallback = callback;</span><br><span class="line">      mUseCaseHandler = useCaseHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(V response)</span> </span>&#123;</span><br><span class="line">      mUseCaseHandler.notifyResponse(response, mCallback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      mUseCaseHandler.notifyError(mCallback);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><code>UseCaseHandler</code>隐藏了任务的执行机制，对外暴露出通过<code>UseCase</code>提交命令的接口，此时 Presenter 就可以借助<code>UseCaseHandler</code>来提交各项异步任务，并且获取回调。注意到回调是在 UI 线程发生的，意味着 Presenter 可以在回调中直接操作 UI 元素。</p><h3 id="Activity：穿针引线的组织者"><a href="#Activity：穿针引线的组织者" class="headerlink" title="Activity：穿针引线的组织者"></a>Activity：穿针引线的组织者</h3><p>与 MVP 架构一样，在 MVP clean 架构中，Activity 同样担任初始化 Fragment、Presenter 的职责。Activity 类是十分简单的，80% 的逻辑都写在<code>onCreate</code>当中。</p><p><code>TaskActivity.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">  setContentView(R.layout.tasks_act);    <span class="comment">// Set up the toolbar.</span></span><br><span class="line">  <span class="comment">// 初始化 ActionBar</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 初始化 DrawerLayout</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// FragmentManager与Activity是一一对应的，所以这里通过R.id.contentFrame获取Fragment，在Activity B中也可以用R.id.contentFrame获取B当中的Fragment，不用担心重复</span></span><br><span class="line">  TasksFragment tasksFragment = (TasksFragment) getSupportFragmentManager().findFragmentById(R.id.contentFrame);</span><br><span class="line">  <span class="keyword">if</span> (tasksFragment == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Create the fragment</span></span><br><span class="line">    tasksFragment = TasksFragment.newInstance();</span><br><span class="line">    ActivityUtils.addFragmentToActivity(getSupportFragmentManager(), tasksFragment, R.id.contentFrame);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将使用到的Task用作构造参数，创建Presenter</span></span><br><span class="line">  mTasksPresenter = <span class="keyword">new</span> TasksPresenter(</span><br><span class="line">    Injection.provideUseCaseHandler(),</span><br><span class="line">    tasksFragment,</span><br><span class="line">    Injection.provideGetTasks(getApplicationContext()),</span><br><span class="line">    Injection.provideCompleteTasks(getApplicationContext()),</span><br><span class="line">    Injection.provideActivateTask(getApplicationContext()),</span><br><span class="line">    Injection.provideClearCompleteTasks(getApplicationContext())</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">// Load previously saved state, if available.</span></span><br><span class="line">  <span class="keyword">if</span> (savedInstanceState != <span class="keyword">null</span>) &#123;</span><br><span class="line">    TasksFilterType currentFiltering = (TasksFilterType) savedInstanceState.getSerializable(CURRENT_FILTERING_KEY);</span><br><span class="line">  mTasksPresenter.setFiltering(currentFiltering);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后在<code>View.onResume</code>中会调用<code>Presenter.start</code>来首次加载数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>.onResume();</span><br><span class="line">  mPresenter.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，MVP-clean 架构的设计思路就被我们分析透彻了，可以看出，相比于 MVP，clean 架构抽象出来 Domain 层，使具体的业务操作独立可复用，且减轻了 Presenter 类的负担。</p><p>还有一个好处是每一个 Use Case 都是可测试的，单元测试粒度被细化，更容易定位问题，从而针对性解决。关于测试我讲的不多，可以直接参考<a href="https://github.com/googlesamples/android-architecture/tree/todo-mvp-clean" target="_blank" rel="noopener">源码</a>进行理解。</p><h2 id="任务列表功能类图"><a href="#任务列表功能类图" class="headerlink" title="任务列表功能类图"></a>任务列表功能类图</h2><p>最后，我们将 todo app 的任务列表功能绘制成类图，加深理解。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/190821_todo_mvp_clean/mvp-clean-%E7%B1%BB%E5%9B%BE.png" alt="mvp-clean-类图" title="">                </div>                <div class="image-caption">mvp-clean-类图</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;I am the STORM!!!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上一篇文章介绍了 MVP 模式，作为 Android 最朴实的架构，MVP 足以应对复杂度较低的业务场景，回想 2014~2015 年在 DP 做预订闪惠的日子，用的便是
      
    
    </summary>
    
    
      <category term="架构" scheme="https://lilei.pro/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>架构学习之 mvp</title>
    <link href="https://lilei.pro/2019/08/21/architecture-todo-mvp/"/>
    <id>https://lilei.pro/2019/08/21/architecture-todo-mvp/</id>
    <published>2019-08-20T16:04:52.000Z</published>
    <updated>2019-08-20T16:17:44.226Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Life doesn’t give you what your want, it gives you what you DESERVE!</p></blockquote><h1 id="0x00-序言"><a href="#0x00-序言" class="headerlink" title="0x00 序言"></a>0x00 序言</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/190821_todo_mvp/aab-logov2.png" alt="Android Architecture Blueprints" title="">                </div>                <div class="image-caption">Android Architecture Blueprints</div>            </figure><p>Google 官方在 GitHub 推出的<a href="https://github.com/googlesamples/android-architecture" target="_blank" rel="noopener">Android 架构 Demo</a>项目非常值得学习，通过 TODO app 的例子，讲解各种应用架构模式如何在实现需求的基础上，达到可维护性、扩展性、可测试性的优秀设计。</p><p>本系列博客文章聚焦于以下几点：</p><ol><li>简明扼要介绍各个架构的思想与基础模型</li><li>在该架构模式下如何对 TODO App 的各个模块进行划分，以及划分的依据</li><li>取一个页面为例，作出类图，解析代码</li></ol><p><strong>Talk is cheap, show me the code.</strong></p><h1 id="0x01-业务逻辑"><a href="#0x01-业务逻辑" class="headerlink" title="0x01 业务逻辑"></a>0x01 业务逻辑</h1><p>建议 clone 代码后真机运行体验，用一张图概括如下。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/190821_todo_mvp/页面流程图.png" alt="页面流程图" title="">                </div>                <div class="image-caption">页面流程图</div>            </figure><p>Google 也给出了一个<a href="https://github.com/googlesamples/android-architecture/wiki/To-do-app-specification" target="_blank" rel="noopener">wiki 页面</a>说明 TODO app 的特性。至于为什么选择这样一个应用作为 demo，官方给出的解释如下：</p><blockquote><p>它必须足够简单，便于你很快地理解其功能；同时也要足够复杂，这样才能展现不同设计的决策以及提供测试场景。</p></blockquote><h1 id="0x02-todo-mvp"><a href="#0x02-todo-mvp" class="headerlink" title="0x02 todo-mvp"></a>0x02 todo-mvp</h1><h2 id="关于-MVP"><a href="#关于-MVP" class="headerlink" title="关于 MVP"></a>关于 MVP</h2><p>MVP 脱胎于大名鼎鼎的 MVC（Model-View-Controller）。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/190821_todo_mvp/mvc.png" alt="mvc" title="">                </div>                <div class="image-caption">mvc</div>            </figure><p>但凡做软件开发的人应该对 MVC 都不感到陌生，它的基本思想是将数据、视图、控制逻辑拆分。这三部分可以自由进行替换，比如在不改变数据接口的情况下，替换数据来源；或者是调整 UI 显示，而无需改动业务逻辑。</p><p>MVC 是一个具有历史意义的架构模式，它对天马行空、一团乱麻的软件设计进行规约，使后续对程序的修改和扩展简化，并且使重用成为可能。但是，它并不是最适合 Android 开发的架构模式。</p><h3 id="MVC-为什么不适合-Android-开发"><a href="#MVC-为什么不适合-Android-开发" class="headerlink" title="MVC 为什么不适合 Android 开发"></a>MVC 为什么不适合 Android 开发</h3><p>MVC 的核心思想是解耦，单一职责。在 Android 开发中，不使用 MVC 的主要原因是 Activity 的职责太重，往往要同时承担 View 和 Controller 的工作，这会造成 Activity 类非常庞大，UI 代码和逻辑代码交织，耦合严重。</p><h3 id="MVP-为什么适合-Android-开发"><a href="#MVP-为什么适合-Android-开发" class="headerlink" title="MVP 为什么适合 Android 开发"></a>MVP 为什么适合 Android 开发</h3><p>MVP 的架构如下图。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/190821_todo_mvp/mvp.png" alt="MVP" title="">                </div>                <div class="image-caption">MVP</div>            </figure><p>它单独抽出了 Presenter 对象，实现了业务逻辑，用于控制 View 的显示变化，以及与 Model 进行数据交互。Presenter 和 View 互相持有，Model 仅被 Presenter 持有。</p><p>在理想状态下，Presenter 和 Model 仅包含 Java 代码，不含 Android SDK 内容。MVP 架构解决了 MVC 中 Activity 职责过多的问题，将 UI 功能分配给 View 单独管理，View 的接口仅向 Presenter 开放，相比 MVC，更好地实现了职责单一、解耦的需求。</p><h2 id="如何抽象业务场景"><a href="#如何抽象业务场景" class="headerlink" title="如何抽象业务场景"></a>如何抽象业务场景</h2><h3 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h3><p>设计从数据层开始，数据层要承担什么职责呢？其实就是<strong>CRUD</strong>：</p><ul><li>保存新建的任务</li><li>查询已创建任务</li><li>更新任务状态（未完成 -&gt; 已完成）</li><li>删除任务</li></ul><p>数据的持久化方式，数据操作结果采用同步还是异步，这些问题也是设计过程中要考虑的。</p><h4 id="基本的任务对象：Task"><a href="#基本的任务对象：Task" class="headerlink" title="基本的任务对象：Task"></a>基本的任务对象：Task</h4><p>首先设计一个<code>Task.java</code>类，表示任务对象，它是一个典型的 Java Bean。在这里我们将 Task 设计成一个不可变的对象。在一个任务从“未完成”变为“完成”状态时，并不是修改原对象，而是丢弃掉原对象，再以相同<code>id</code>重新创建一个完成状态的对象。这样做的好处是逻辑简单，不可变对象线程绝对安全。缺点是当对象创建、销毁成本高的时候，会产生性能损失。在实际业务中应当酌情选择重用或者舍弃。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String mId;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String mTitle;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String mDescription;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> mCompleted;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Model-层对外暴露的接口：TasksDataSource"><a href="#Model-层对外暴露的接口：TasksDataSource" class="headerlink" title="Model 层对外暴露的接口：TasksDataSource"></a>Model 层对外暴露的接口：TasksDataSource</h4><p>本着面向接口编程的原则，隐藏数据操作具体实现代码，暴露出管理任务的接口（包含回调）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TasksDataSource</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">interface</span> <span class="title">LoadTasksCallback</span> </span>&#123; <span class="comment">// 加载复数任务回调</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onTasksLoaded</span><span class="params">(List&lt;Task&gt; tasks)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onDataNotAvailable</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">interface</span> <span class="title">GetTaskCallback</span> </span>&#123; <span class="comment">// 加载单条任务回调</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onTaskLoaded</span><span class="params">(Task task)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onDataNotAvailable</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">getTasks</span><span class="params">(@NonNull LoadTasksCallback callback)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">getTask</span><span class="params">(@NonNull String taskId, @NonNull GetTaskCallback callback)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">saveTask</span><span class="params">(@NonNull Task task)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">completeTask</span><span class="params">(@NonNull Task task)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">completeTask</span><span class="params">(@NonNull String taskId)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">activateTask</span><span class="params">(@NonNull Task task)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">activateTask</span><span class="params">(@NonNull String taskId)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clearCompletedTasks</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">refreshTasks</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">deleteAllTasks</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">deleteTask</span><span class="params">(@NonNull String taskId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口里有两处与我的编程思路有出入。首先是加载任务回调，我认为可以仅保留复数任务的接口，对于加载单条任务的需求，返回一个长度为 1 的列表就可以了。其次，在命名上，我习惯于将同步接口以<code>getXXX</code>，异步接口以<code>loadXXX</code>来声明。</p><p>有了这个接口，就可以提供给任务详情、任务列表等页面使用。接下来创建一个接口实现类，这个类对外的职责是实现数据操作接口，对内的职责是隐藏两种具体的数据操作实现（内存缓存、数据库、网络）。</p><p>数据源共有三级缓存：</p><ul><li>In-memory cache - Fast</li><li>Disk (SQLiteDb) - Slow</li><li>Network - Very slow</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TasksRepository</span> <span class="keyword">implements</span> <span class="title">TasksDataSource</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> TasksDatasource mTasksRemoteDataSource; <span class="comment">// 网络数据源</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> TasksDatasource mTasksLocalDataSource; <span class="comment">// 本地数据源</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读写数据策略可以概括为“依次读，全部写”，括号里是我补充的内容：</p><ul><li><p>In every <code>get</code>operation:</p><ul><li>Return cache if available, or</li><li>return local copy if it exists (and update cache) , or</li><li>return remote copy ( and update local copy &amp; cache)</li></ul></li><li><p>Every <code>write</code>/<code>delete</code>operation will simply:</p><ul><li>Update cache</li><li>Update local</li><li>Update remote</li></ul></li></ul><p>具体的网络数据源、本地数据库设计为常见写法，不赘述。</p><h3 id="Fragment-即是-View"><a href="#Fragment-即是-View" class="headerlink" title="Fragment 即是 View"></a>Fragment 即是 View</h3><p>处理所有 UI 变化事件，比如显示 loading、显示任务列表、显示任务详情、显示任务状态变更 SnackBar 等，值得注意的是页面跳转操作也属于 UI 变化，是在 Fragment 里面实现的。不妨思考一下为什么“跳转”不放在 Presenter 中进行？一个原因是 Presenter 与 Android SDK 无关，而跳转需要 Context 对象，违背了这一原则。比如从“任务列表”跳转到“任务详情”时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TasksFragment.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showAddTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Intent intent = <span class="keyword">new</span> Intent(getContext(), AddEditTaskActivity.class);</span><br><span class="line">  startActivityForResult(intent, AddEditTaskActivity.REQUEST_ADD_TASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>View 里面没有任何业务逻辑，主要处理以下事件：</p><ul><li>加载中、加载成功、失败页面展示</li><li>展现 Toast、SnackBar 等提示</li><li>处理按钮、菜单点击事件（通常是将其甩给 Presenter 处理）</li><li>处理页面跳转</li><li>声明 Adapter</li><li>在<code>onResume</code>时调用 Presenter 的<code>start</code>方法，启动页面</li><li>提供<code>isActive</code>方法，供 Presenter 在异步回调返回时判断页面是否存活</li></ul><p>最后一点是容易漏掉的，如果异步请求回调时页面被销毁，会导致各种难以预料的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> isAdded();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Presenter-业务逻辑载体"><a href="#Presenter-业务逻辑载体" class="headerlink" title="Presenter - 业务逻辑载体"></a>Presenter - 业务逻辑载体</h3><p>承担了业务逻辑实现的职责，有时业务逻辑过于复杂会导致 Presenter 类太大，此时要考虑拆分业务逻辑到单独的类中，就变成了<code>mvp-clean</code>架构，clean 架构中使用<code>Use Case（用例）</code>处理细分的业务逻辑。</p><p>Presenter 由 Activity 构造，并且提供方法给 Activity 以及 View（Fragment）使用。</p><h3 id="Activity-将一切粘合到一起"><a href="#Activity-将一切粘合到一起" class="headerlink" title="Activity - 将一切粘合到一起"></a>Activity - 将一切粘合到一起</h3><p>现在我们有了 Model、View、Presenter 各个部分，而 Android 应用的页面入口是 Activity 类，我们在 Activity 中创建 Fragment（View）及 Presenter，在这两者之间建立关联。同时还要处理一些必须放在 Activity 中进行的操作，比如<code>onSaveInstanceState</code>、<code>onOptionsItemSelected</code> 等等。</p><h2 id="任务列表功能实现"><a href="#任务列表功能实现" class="headerlink" title="任务列表功能实现"></a>任务列表功能实现</h2><p>用类图来表示 MVP 模式下的任务列表功能相关类：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/190821_todo_mvp/mvp类图.png" alt="mvp" title="">                </div>                <div class="image-caption">mvp</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Life doesn’t give you what your want, it gives you what you DESERVE!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;0x00-序言&quot;&gt;&lt;a href=&quot;#0x00-序言&quot; c
      
    
    </summary>
    
    
      <category term="架构" scheme="https://lilei.pro/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>ACE-PTM 第 II 部分 领导和实施</title>
    <link href="https://lilei.pro/2019/07/14/ace-cpt-part-2/"/>
    <id>https://lilei.pro/2019/07/14/ace-cpt-part-2/</id>
    <published>2019-07-14T10:16:42.000Z</published>
    <updated>2019-07-28T15:54:18.551Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第-2-章-激励和坚持原则"><a href="#第-2-章-激励和坚持原则" class="headerlink" title="第 2 章 - 激励和坚持原则"></a>第 2 章 - 激励和坚持原则</h1><p>只有约20%的美国成人同时符合有氧活动和肌肉强化指南要求。健身专业人员面临着两大挑战：<strong>让人们积极开始</strong>以及之后<strong>坚持运动计划</strong>。本章重点是提高人们在开始之后坚持计划的可能性。</p><p>激励人开始锻炼的因素不一定是使他们长期参与运动计划的因素。健康和健身行业的真正挑战是创造出适宜的计划和运动环境，使人们尽可能提高坚持计划并选择积极生活方式的可能性。</p><h2 id="了解激励"><a href="#了解激励" class="headerlink" title="了解激励"></a>了解激励</h2><p>用于评估激励的两种最常讨论方法是<strong>内在与外在激励</strong>和<strong>自我效能</strong>。</p><h3 id="内在和外在激励"><a href="#内在和外在激励" class="headerlink" title="内在和外在激励"></a>内在和外在激励</h3><p>在运动背景下，要实现内在激励，意味着一个人是因为参与本身所带来的内在愉悦和体验而从事运动活动。</p><p>与其认为需要让自己的客户受到更多的内在激励，私人教练应更努力增加参与计划所带来的愉悦感和成就感。私人教练通过鼓励客户<strong>拥有并参与计划以及教授自足性和自主性</strong>，可以帮助促进内在激励的形成。</p><h3 id="自我效能"><a href="#自我效能" class="headerlink" title="自我效能"></a>自我效能</h3><p>在运动背景下，自我效能定义为个体对自身成功参与体力活动计划的能力和信念。自我效能与激励呈正相关。</p><p>许多健身专业人员所犯的一个重大错误是安排整堂课进行评估，不要让客户感觉像在做测试，在某些情况下，甚至不要让客户知道你在收集评估信息。</p><h2 id="用于保持客户激励的策略"><a href="#用于保持客户激励的策略" class="headerlink" title="用于保持客户激励的策略"></a>用于保持客户激励的策略</h2><p>私人教练应当告知客户可能会出现回复原态并使其提前做好准备，以便他们能够在回复原态后立即重新坚持活动计划。第一步是<strong>宣教</strong>，第二步是<strong>支持</strong>。</p><h3 id="社会支持"><a href="#社会支持" class="headerlink" title="社会支持"></a>社会支持</h3><p>开发和维护运动的社会支持网络。教练应当尽量多利用团体参与和社交互动的机会，让客户感觉自己属于该计划，并且是具有共同兴趣和目标的成员所组成团队的一部分。</p><h3 id="自我肯定"><a href="#自我肯定" class="headerlink" title="自我肯定"></a>自我肯定</h3><p>教导客户进行自我肯定。</p><h3 id="自我调节"><a href="#自我调节" class="headerlink" title="自我调节"></a>自我调节</h3><p>教导客户成为有效的自律者，自我监督行为、日程、时间和优先事项。</p><h3 id="高风险情况"><a href="#高风险情况" class="headerlink" title="高风险情况"></a>高风险情况</h3><p>时间管理技能不佳、缺乏社会支持或日程繁忙的个人最有可能回复圆台。私人教练必须不断了解并观察客户是否出现受打击、沮丧或疲惫的迹象。</p><h2 id="影响运动参与和坚持度的因素"><a href="#影响运动参与和坚持度的因素" class="headerlink" title="影响运动参与和坚持度的因素"></a>影响运动参与和坚持度的因素</h2><p>体力活动的潜在决定因素可分为三类：</p><ul><li>个人特质</li><li>环境因素</li><li>体力活动因素</li></ul><h3 id="个人特质"><a href="#个人特质" class="headerlink" title="个人特质"></a>个人特质</h3><h4 id="人口统计变量"><a href="#人口统计变量" class="headerlink" title="人口统计变量"></a>人口统计变量</h4><h4 id="健康状况"><a href="#健康状况" class="headerlink" title="健康状况"></a>健康状况</h4><h4 id="过往的运动经验"><a href="#过往的运动经验" class="headerlink" title="过往的运动经验"></a>过往的运动经验</h4><h4 id="心理特质"><a href="#心理特质" class="headerlink" title="心理特质"></a>心理特质</h4><h4 id="认识、态度和信念"><a href="#认识、态度和信念" class="headerlink" title="认识、态度和信念"></a>认识、态度和信念</h4><h3 id="环境因素"><a href="#环境因素" class="headerlink" title="环境因素"></a>环境因素</h3><h4 id="设施便利性"><a href="#设施便利性" class="headerlink" title="设施便利性"></a>设施便利性</h4><h4 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h4><h4 id="社会支持-1"><a href="#社会支持-1" class="headerlink" title="社会支持"></a>社会支持</h4><h3 id="体力活动因素"><a href="#体力活动因素" class="headerlink" title="体力活动因素"></a>体力活动因素</h3><h4 id="强度"><a href="#强度" class="headerlink" title="强度"></a>强度</h4><h4 id="损伤"><a href="#损伤" class="headerlink" title="损伤"></a>损伤</h4><h2 id="反馈"><a href="#反馈" class="headerlink" title="反馈"></a>反馈</h2><ul><li>外部反馈：私人教练为客户提供的强化、纠错和鼓励。</li><li>内部反馈：客户根据自己的感觉系统（感受到、看到或听到的内容）为自己提供的相应信息。长期计划坚持度取决于客户提供自我反馈的能力。</li></ul><h2 id="领导特质"><a href="#领导特质" class="headerlink" title="领导特质"></a>领导特质</h2><p>对客户的进展表现出持续不断地关心和兴趣是贯穿私教职业生涯的一部分。私人教练使用系统性目标设定以及教授回复原态预防技巧的目的是，告诉客户他们对客户的关心远远超出这一小时课程的范围。</p><h2 id="私人教练爱建立坚持度中的作用"><a href="#私人教练爱建立坚持度中的作用" class="headerlink" title="私人教练爱建立坚持度中的作用"></a>私人教练爱建立坚持度中的作用</h2><h3 id="计划设计"><a href="#计划设计" class="headerlink" title="计划设计"></a>计划设计</h3><p>私人教练必须能够针对每个客户的偏好、时间表、经验、顾虑和约束条件（例如，钱、便利性和时间）设计计划。</p><h3 id="角色清晰度"><a href="#角色清晰度" class="headerlink" title="角色清晰度"></a>角色清晰度</h3><p>在一段关系中分歧和冲突产生的常见原因是角色模糊。</p><h3 id="目标设定"><a href="#目标设定" class="headerlink" title="目标设定"></a>目标设定</h3><p>目标设定应当遵循<em>SMART</em>原则。</p><ul><li>避免设定过多目标</li><li>避免设定负向目标</li><li>设定短期和长期目标以及过程目标和成绩目标</li><li>定期重审目标</li></ul><h3 id="合同-协议"><a href="#合同-协议" class="headerlink" title="合同/协议"></a>合同/协议</h3><p>使用行为合约和书面协议。</p><h2 id="第-2-章-习题集"><a href="#第-2-章-习题集" class="headerlink" title="第 2 章 - 习题集"></a>第 2 章 - 习题集</h2><h3 id="1-对于刚开始参加运动方案的个体而言，最重要的因素是什么？"><a href="#1-对于刚开始参加运动方案的个体而言，最重要的因素是什么？" class="headerlink" title="1. 对于刚开始参加运动方案的个体而言，最重要的因素是什么？"></a>1. 对于刚开始参加运动方案的个体而言，最重要的因素是什么？</h3><ol><li>家庭和朋友的大力支持</li><li>运动设施的便利性</li><li>与运动有关的行为改变意愿度</li><li>与私人教练联络</li></ol><p>错误选项（1），正确答案（3）。真正的动机都来源于内心。</p><h3 id="4-为了确保客户坚持参加训练，私人教练最好采用下列哪种策略？"><a href="#4-为了确保客户坚持参加训练，私人教练最好采用下列哪种策略？" class="headerlink" title="4. 为了确保客户坚持参加训练，私人教练最好采用下列哪种策略？"></a>4. 为了确保客户坚持参加训练，私人教练最好采用下列哪种策略？</h3><ol><li>为客户设计运动方案，这样客户就只训练，而不会对运动本身想太多</li><li>通过内在动机因素对客户进行激励，以提升其自我效能</li><li>鼓励客户独立安排运动方案，从而促进客户提升内在动机</li><li>主要通过指引（而非教育）建立自己的运动教学风格</li></ol><p>错误选项（2），正确答案（3）。教练不是通过“内在动机”对客户进行激励的。教练的目的是<strong>提升内在动机</strong>。</p><h3 id="9-在监督式环境中运动，最可能与运动坚持水平无关的因素是？"><a href="#9-在监督式环境中运动，最可能与运动坚持水平无关的因素是？" class="headerlink" title="9. 在监督式环境中运动，最可能与运动坚持水平无关的因素是？"></a>9. 在监督式环境中运动，最可能与运动坚持水平无关的因素是？</h3><ol><li>教育</li><li>年龄</li><li>收入</li><li>性别</li></ol><p>错误选项（3），正确答案（2）。其余几个选项都有相关。</p><h3 id="11-坚持的定义为：一种将行为赋予方向和目的的心理驱动力。"><a href="#11-坚持的定义为：一种将行为赋予方向和目的的心理驱动力。" class="headerlink" title="11. 坚持的定义为：一种将行为赋予方向和目的的心理驱动力。"></a>11. 坚持的定义为：一种将行为赋予方向和目的的心理驱动力。</h3><ol><li>正确</li><li>错误</li></ol><p>错误选项（1），正确答案（2）。<strong>坚持</strong>是积极主动地参加运动方案；<strong>激励</strong>则是心理驱动力。</p><h3 id="13-身体活动的三种主要潜在决定因素不包括哪一项？"><a href="#13-身体活动的三种主要潜在决定因素不包括哪一项？" class="headerlink" title="13. 身体活动的三种主要潜在决定因素不包括哪一项？"></a>13. 身体活动的三种主要潜在决定因素不包括哪一项？</h3><ol><li>个人特质</li><li>身体特质</li><li>环境因素</li><li>体育活动因素</li></ol><p>错误选项（1），正确答案（2）。其中1、3、4是体育活动的潜在决定因素。</p><h3 id="18-下列术语种，哪一项的定义为：相信自己有能力成功开始并坚持某种行为？"><a href="#18-下列术语种，哪一项的定义为：相信自己有能力成功开始并坚持某种行为？" class="headerlink" title="18. 下列术语种，哪一项的定义为：相信自己有能力成功开始并坚持某种行为？"></a>18. 下列术语种，哪一项的定义为：相信自己有能力成功开始并坚持某种行为？</h3><ol><li>内在激励</li><li>自我效能</li><li>外在激励</li><li>心里控制源</li></ol><p>错误选项（1），正确答案（2）。注意这是“效能”的定义。</p><hr><h1 id="第-3-章-沟通和教学技巧"><a href="#第-3-章-沟通和教学技巧" class="headerlink" title="第 3 章 - 沟通和教学技巧"></a>第 3 章 - 沟通和教学技巧</h1><h1 id="第-4-章-行为改变与健康心理学基础"><a href="#第-4-章-行为改变与健康心理学基础" class="headerlink" title="第 4 章 - 行为改变与健康心理学基础"></a>第 4 章 - 行为改变与健康心理学基础</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第-2-章-激励和坚持原则&quot;&gt;&lt;a href=&quot;#第-2-章-激励和坚持原则&quot; class=&quot;headerlink&quot; title=&quot;第 2 章 - 激励和坚持原则&quot;&gt;&lt;/a&gt;第 2 章 - 激励和坚持原则&lt;/h1&gt;&lt;p&gt;只有约20%的美国成人同时符合有氧活动和肌肉
      
    
    </summary>
    
    
      <category term="健身" scheme="https://lilei.pro/tags/%E5%81%A5%E8%BA%AB/"/>
    
      <category term="ACE-CPT" scheme="https://lilei.pro/tags/ACE-CPT/"/>
    
  </entry>
  
  <entry>
    <title>ACE-PTM 第 I 部分 简介</title>
    <link href="https://lilei.pro/2019/07/14/ace-cpt-part-1/"/>
    <id>https://lilei.pro/2019/07/14/ace-cpt-part-1/</id>
    <published>2019-07-14T09:32:41.000Z</published>
    <updated>2019-07-28T15:12:04.692Z</updated>
    
    <content type="html"><![CDATA[<h1 id="笔记前言"><a href="#笔记前言" class="headerlink" title="笔记前言"></a>笔记前言</h1><blockquote><p>作为学习 <a href="https://www.acefitness.org/" target="_blank" rel="noopener">ACE-CPT</a> 的读书笔记，这一系列将按章节分为七个部分。</p></blockquote><h2 id="第-I-部分-简介"><a href="#第-I-部分-简介" class="headerlink" title="第 I 部分 - 简介"></a>第 I 部分 - 简介</h2><p>介绍私人教练的角色定位与执业范围，哪些事情应该做，哪些事情可以做，哪些事情不能做。</p><h2 id="第-II-部分-领导和实施"><a href="#第-II-部分-领导和实施" class="headerlink" title="第 II 部分 - 领导和实施"></a>第 II 部分 - 领导和实施</h2><p>从沟通、激励会员角度给出指导意见，是贯彻执教过程始终的中心思想，帮助教练与会员建立相互信赖的关系。</p><h2 id="第-III-部分-ACE-整合式健身训练模式"><a href="#第-III-部分-ACE-整合式健身训练模式" class="headerlink" title="第 III 部分 - ACE 整合式健身训练模式"></a>第 III 部分 - ACE 整合式健身训练模式</h2><p>即 ACE-IFT 训练模式，是 ACE 独家的训练计划与模式，先评估，然后在稳定性、抗阻、心肺等多方面分别给出指导。</p><h2 id="第-IV-部分-特殊运动计划制定主题"><a href="#第-IV-部分-特殊运动计划制定主题" class="headerlink" title="第 IV 部分 - 特殊运动计划制定主题"></a>第 IV 部分 - 特殊运动计划制定主题</h2><p>讲解身心运动以及特殊人群的运动方法。</p><h2 id="第-V-部分-损伤预防和急救"><a href="#第-V-部分-损伤预防和急救" class="headerlink" title="第 V 部分 - 损伤预防和急救"></a>第 V 部分 - 损伤预防和急救</h2><p>常见损伤对运动过程的影响，以及遭遇损伤时候的紧急程序。</p><h2 id="第-VI-部分-职业和法律责任以及业务策略"><a href="#第-VI-部分-职业和法律责任以及业务策略" class="headerlink" title="第 VI 部分 - 职业和法律责任以及业务策略"></a>第 VI 部分 - 职业和法律责任以及业务策略</h2><p>私人教练职业的法律指南。</p><h2 id="第-VII-部分-补充"><a href="#第-VII-部分-补充" class="headerlink" title="第 VII 部分 - 补充"></a>第 VII 部分 - 补充</h2><p>涵盖不属于上述章节的内容。</p><hr><h1 id="第-1-章-私人教练的角色和执业范围"><a href="#第-1-章-私人教练的角色和执业范围" class="headerlink" title="第 1 章 - 私人教练的角色和执业范围"></a>第 1 章 - 私人教练的角色和执业范围</h1><h2 id="健康照护联盟"><a href="#健康照护联盟" class="headerlink" title="健康照护联盟"></a>健康照护联盟</h2><p>健康照护联盟由医疗保健专业人员组成，他们通过执照、注册和/或许可证获得认可，并提供相关服务以识别、预防和治疗疾病和病症。</p><p>团队成员构成如下：</p><ul><li>针灸师</li><li>脊椎按摩师</li><li>营养师</li><li>自然疗法医生</li><li>护士</li><li>医生</li><li>行为医师</li><li>物理治疗师</li><li>职业物理治疗师</li><li>运动教练</li></ul><h2 id="ACE-私人教练认证"><a href="#ACE-私人教练认证" class="headerlink" title="ACE 私人教练认证"></a>ACE 私人教练认证</h2><p>专业能力门槛被称为从事某种行业所需的“<strong>最低能力</strong>”。对于专业人员而言，执照可以将其与未证明自己处于同一能力水平的人区分开。通过获得 ACE 私人教练认证，专业人员证明了其在以下方面的能力：应用相关知识在各种实际情况下做出安全有效的运动计划决策，同时最大限度地减少客户风险和伤害。</p><h3 id="“执业范围”的定义"><a href="#“执业范围”的定义" class="headerlink" title="“执业范围”的定义"></a>“执业范围”的定义</h3><h3 id="ACE-认证的私人教练的执业范围"><a href="#ACE-认证的私人教练的执业范围" class="headerlink" title="ACE 认证的私人教练的执业范围"></a>ACE 认证的私人教练的执业范围</h3><p>根据 <strong>IDEA 私人健身教练的执业范围</strong> 表格，私人教练不可以做以下事情：</p><ul><li>进行诊断</li><li>开处方</li><li>为客户规定饮食或推荐具体的补充剂</li><li>治疗伤害或疾病</li><li>监督医疗转介绍客户的进展</li><li>提供康复服务</li><li>提供咨询</li><li>与患者合作</li></ul><h3 id="ACE-认证的私人教练的知识、技能和能力"><a href="#ACE-认证的私人教练的知识、技能和能力" class="headerlink" title="ACE 认证的私人教练的知识、技能和能力"></a>ACE 认证的私人教练的知识、技能和能力</h3><p>ACE 私人教练考试包括以下领域</p><ul><li>客户面谈和评估 - 31%</li><li>计划设计和执行 - 33%</li><li>进阶和调整 - 19%</li><li>专业行为、安全性和风险管理 - 17%</li></ul><h4 id="教育和经验"><a href="#教育和经验" class="headerlink" title="教育和经验"></a>教育和经验</h4><p>建议应试者流出平均三至四个月的学习时间来充分准备私人教练认证考试。</p><h3 id="执业责任和道德规范"><a href="#执业责任和道德规范" class="headerlink" title="执业责任和道德规范"></a>执业责任和道德规范</h3><p>ACE 制定了<strong>ACE 道德准则</strong>，所有 ACE 认证的专业人员和应试者都必须熟悉并遵守道德准则和专业时间和纪律程序。</p><h4 id="ACE-专业实践和纪律程序"><a href="#ACE-专业实践和纪律程序" class="headerlink" title="ACE 专业实践和纪律程序"></a>ACE 专业实践和纪律程序</h4><h4 id="执照期和续期"><a href="#执照期和续期" class="headerlink" title="执照期和续期"></a>执照期和续期</h4><p>ACE 认证有效期为<strong>两年</strong>，从获得认证之日起开始计算，于当月最后一天到期。续期则需要完成至少 20 小时的持续教育学分（2.0 CEC），并持有当前的<strong>心肺复苏（CPR）</strong>证书。如果持证人生活在北美，则必须能够正确使用<strong>自动外部除颤器（AED）</strong>。</p><p>ACE 为超过截止期限的专业人员的续期留出六个月的延长期限。</p><h4 id="客户隐私"><a href="#客户隐私" class="headerlink" title="客户隐私"></a>客户隐私</h4><h4 id="转介绍"><a href="#转介绍" class="headerlink" title="转介绍"></a>转介绍</h4><h4 id="补充剂和其他营养相关问题"><a href="#补充剂和其他营养相关问题" class="headerlink" title="补充剂和其他营养相关问题"></a>补充剂和其他营养相关问题</h4><p>补充剂<strong>不受美国食品和药物管理局（FDA）管制，因此无法保证起强度、纯度、安全性和效果。</strong>私人教练仅仅有资格向客户推荐补充剂，而没有资格推荐药物或开具药物。</p><h4 id="所提供服务超出执业范围的后果"><a href="#所提供服务超出执业范围的后果" class="headerlink" title="所提供服务超出执业范围的后果"></a>所提供服务超出执业范围的后果</h4><h2 id="由-NCCA-进行的健康照护联盟资格证书认证"><a href="#由-NCCA-进行的健康照护联盟资格证书认证" class="headerlink" title="由 NCCA 进行的健康照护联盟资格证书认证"></a>由 NCCA 进行的健康照护联盟资格证书认证</h2><h3 id="健身与健康行业的认可"><a href="#健身与健康行业的认可" class="headerlink" title="健身与健康行业的认可"></a>健身与健康行业的认可</h3><h3 id="教育界的认可"><a href="#教育界的认可" class="headerlink" title="教育界的认可"></a>教育界的认可</h3><p>ACE 教育伙伴计划提供四门独立的大学课程：</p><ul><li>私教</li><li>团体运动</li><li>健康教练</li><li>特殊人群运动课程</li></ul><h3 id="劳工部的认可"><a href="#劳工部的认可" class="headerlink" title="劳工部的认可"></a>劳工部的认可</h3><h2 id="职业发展"><a href="#职业发展" class="headerlink" title="职业发展"></a>职业发展</h2><h3 id="持续教育"><a href="#持续教育" class="headerlink" title="持续教育"></a>持续教育</h3><h4 id="高级知识"><a href="#高级知识" class="headerlink" title="高级知识"></a>高级知识</h4><h4 id="专业化"><a href="#专业化" class="headerlink" title="专业化"></a>专业化</h4><h3 id="学位"><a href="#学位" class="headerlink" title="学位"></a>学位</h3><h3 id="额外的健身执照"><a href="#额外的健身执照" class="headerlink" title="额外的健身执照"></a>额外的健身执照</h3><h3 id="健康照护联盟的新专业领域"><a href="#健康照护联盟的新专业领域" class="headerlink" title="健康照护联盟的新专业领域"></a>健康照护联盟的新专业领域</h3><hr><h1 id="第-1-章-习题集"><a href="#第-1-章-习题集" class="headerlink" title="第 1 章 - 习题集"></a>第 1 章 - 习题集</h1><h2 id="6-下列哪一项属于-ACE-认证私人教练的执业范围？"><a href="#6-下列哪一项属于-ACE-认证私人教练的执业范围？" class="headerlink" title="6. 下列哪一项属于 ACE 认证私人教练的执业范围？"></a>6. 下列哪一项属于 ACE 认证私人教练的执业范围？</h2><ol><li>帮助客户更好地了解食物分量与健康食品，从而帮助他们做出更明智的选择</li><li>为客户提供 4 周食谱与购物清单，帮助他们走上健康饮食的正轨</li><li>回顾过去 24 小时的饮食情况，帮助客户了解自己缺少哪些微量元素</li><li>就惊喜代谢率（RMR）以及热量摄入要小于 RMR 等知识对客户进行教育，帮助客户减轻体重</li></ol><p>错误选项（4），正确答案（1）。关键点在于选择权由客户持有，而非私人教练做出选择 or 决定。</p><h2 id="9-关于私人教练向客户推荐营养补充剂，下列叙述最恰当的一项是"><a href="#9-关于私人教练向客户推荐营养补充剂，下列叙述最恰当的一项是" class="headerlink" title="9. 关于私人教练向客户推荐营养补充剂，下列叙述最恰当的一项是"></a>9. 关于私人教练向客户推荐营养补充剂，下列叙述最恰当的一项是</h2><ol><li>只能向客户推荐自己已投职业责任险的补充剂</li><li>如果私人教练未持有注册营养师或医学博士学位等其他帧数，则不具有向他人推荐补充剂的合法资质</li><li>私人教练应接受专门的知识培训后才能向客户推荐营养补充剂</li><li>由于服用补充剂与其他药物可能会引起并发症，私人教练只能向客户推荐植物性补充剂</li></ol><p>错误选项（3），正确答案（2）。“专门的知识培训”不够精确。</p><h2 id="15-“执业范围”的定义不包括哪一项？"><a href="#15-“执业范围”的定义不包括哪一项？" class="headerlink" title="15. “执业范围”的定义不包括哪一项？"></a>15. “执业范围”的定义不包括哪一项？</h2><ol><li>专业健身人员在特定领域可提供的合法服务范围</li><li>在工作场所必须遵守的职业道德准则</li><li>可以供私教服务的场所</li><li>必须遵守的指南或参数标准</li></ol><p>错误选项（3），正确答案（2）。道德是道德，业务是业务。</p><h2 id="20-如果客户提到自己参加周末网球比赛后肌肉酸痛，教练给予的最恰当的回应是？"><a href="#20-如果客户提到自己参加周末网球比赛后肌肉酸痛，教练给予的最恰当的回应是？" class="headerlink" title="20. 如果客户提到自己参加周末网球比赛后肌肉酸痛，教练给予的最恰当的回应是？"></a>20. 如果客户提到自己参加周末网球比赛后肌肉酸痛，教练给予的最恰当的回应是？</h2><ol><li>推荐客户服用抗炎类非处方药</li><li>建议客户在下次比赛前服用肌酸补充剂</li><li>对深层组织进行按摩处理，帮助缓解肌肉酸痛</li><li>与客户探讨对患处进行冷敷的正确方法</li></ol><p>错误选项（3），正确答案（4）。其余选项超出执业范围。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;笔记前言&quot;&gt;&lt;a href=&quot;#笔记前言&quot; class=&quot;headerlink&quot; title=&quot;笔记前言&quot;&gt;&lt;/a&gt;笔记前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;作为学习 &lt;a href=&quot;https://www.acefitness.org/&quot; target
      
    
    </summary>
    
    
      <category term="健身" scheme="https://lilei.pro/tags/%E5%81%A5%E8%BA%AB/"/>
    
      <category term="ACE-CPT" scheme="https://lilei.pro/tags/ACE-CPT/"/>
    
  </entry>
  
  <entry>
    <title>ACE-CPT 考试信息汇总</title>
    <link href="https://lilei.pro/2019/07/14/ace-cpt-qualification/"/>
    <id>https://lilei.pro/2019/07/14/ace-cpt-qualification/</id>
    <published>2019-07-14T09:27:29.000Z</published>
    <updated>2019-07-14T09:31:24.837Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/64605617" target="_blank" rel="noopener">国内自考ACE-CPT心得（一）考试流程</a></p><p><a href="https://zhuanlan.zhihu.com/p/67532892" target="_blank" rel="noopener">国内自考ACE-CPT心得（二）读者问答</a></p><p><a href="https://www.zhihu.com/question/54711544" target="_blank" rel="noopener">教材哪里买</a></p><h2 id="四大认证"><a href="#四大认证" class="headerlink" title="四大认证"></a>四大认证</h2><ul><li>ACSM</li><li>NSCA</li><li>ACE</li><li>NASM</li></ul><h2 id="教材"><a href="#教材" class="headerlink" title="教材"></a>教材</h2><p>1000页教材，需要100h学习时间。</p><ul><li>官网英文版</li><li>官网翻译版</li><li>培训机构翻译版</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/190714_acecpt/教材.jpg" alt="教材" title="">                </div>                <div class="image-caption">教材</div>            </figure><ol><li>Personal Trainer Manual —— 主要教材，80%考题来源于此</li><li>Essential of Exercise Science —— 辅助材料，解剖、营养、生理等</li><li>Study Companion —— 课后习题</li><li>宣传手册 —— 没用</li></ol><p>官网有在线模拟题。</p><p>考题分布。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/190714_acecpt/考题分布.jpg" alt="考题分布" title="">                </div>                <div class="image-caption">考题分布</div>            </figure><h2 id="考试"><a href="#考试" class="headerlink" title="考试"></a>考试</h2><p>携带身份证、驾照、护照、CPR证。</p><p>3小时，150道单选题，125题计入总分。每道题都有英文原文和中文翻译。开考前会提供纸笔。</p><p>电脑上有工具：</p><ul><li>题目标记</li><li>未答题数量</li><li>计算器</li></ul><p>考试提交后立马出分数。总分800分，超过500分及格。</p><h2 id="报名"><a href="#报名" class="headerlink" title="报名"></a>报名</h2><p>官网报名。399刀。</p><p>提前一个月申请考场。</p><p>急救培训：CPR or AED，在当地红十字会报名，一周末拿证。</p><h2 id="继续教育"><a href="#继续教育" class="headerlink" title="继续教育"></a>继续教育</h2><p>两年内 2.0 学分 + CPR</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/64605617&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;国内自考ACE-CPT心得（一）考试流程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.
      
    
    </summary>
    
    
      <category term="健身" scheme="https://lilei.pro/tags/%E5%81%A5%E8%BA%AB/"/>
    
      <category term="ACE-CPT" scheme="https://lilei.pro/tags/ACE-CPT/"/>
    
  </entry>
  
  <entry>
    <title>《高效能人士的七个习惯》第二部分 习惯三 要事第一</title>
    <link href="https://lilei.pro/2019/04/07/Seven-Habbits-4/"/>
    <id>https://lilei.pro/2019/04/07/Seven-Habbits-4/</id>
    <published>2019-04-07T03:00:29.000Z</published>
    <updated>2019-06-08T08:46:02.557Z</updated>
    
    <content type="html"><![CDATA[<h1 id="回答两个问题"><a href="#回答两个问题" class="headerlink" title="回答两个问题"></a>回答两个问题</h1><ul><li>在你目前的生活中，有哪些事情能够彻底改观你的个人生活，但是你一直没有去做？</li><li>在你目前的生活中，有哪些事情能够彻底改观你的工作局面，但是你一直没有去做？</li></ul><p>习惯三是习惯一、二的具体实践。习惯一告诉你，你是创造者，你掌控自己的人生，其基础是人类特有的四大天赋：想象力、良知、独立意志、自我意识。</p><p>习惯二是关于第一次的创造或者智力上的创造的习惯，其原则基础是<strong>想象力</strong>和<strong>良知</strong>这两大天赋。</p><p>习惯三是关于第二次的创造或者体力上的创造的习惯，是对前面两个习惯的实施、执行和自然表现。</p><p>左脑进行管理，右脑进行领导。</p><p>有效的管理指的就是要事第一，先做最重要的事情。领导者首先要决定的，就是哪些事情是重要的；而作为管理者，就是要将这些重要的事务优先安排。自我管理的实质就是自律和条理，是对计划的实施。</p><p>《成功的普遍共性》一文的作者格雷（E.M.Gray）说：“<strong>成功者能为失败者所不能为，纵使并非心甘情愿，但为了理想与目标，仍可以凭毅力克服心理障碍。</strong>”</p><h1 id="四代时间管理理论的演进"><a href="#四代时间管理理论的演进" class="headerlink" title="四代时间管理理论的演进"></a>四代时间管理理论的演进</h1><p>如何分辨轻重缓急与培养组织能力，是时间管理的精髓。</p><ol><li>第一代理论着重利用便条与备忘录，在忙碌中调配时间与精力</li><li>第二代理论强调行事历与日程表，反映出时间管理已经注意到规划未来的重要。</li><li>第三代是讲求优先顺序的概念，依据轻重缓急设定短中长期目标。</li><li>第四代理论从根本否定“时间管理”，主张关键在于“个人管理”，重心应当放在维持产出与产能平衡上。</li></ol><h1 id="别让琐务牵着鼻子走"><a href="#别让琐务牵着鼻子走" class="headerlink" title="别让琐务牵着鼻子走"></a>别让琐务牵着鼻子走</h1><p>第四代时间管理理论从重要性和紧急程度两个维度对事务进行划分。重要性与目标有关，凡有价值、有利于实现个人目标的就是要事。紧急程度与时间紧迫性有关，紧迫之事通常都显而易见，推诿不得。</p><h2 id="第一类事务，重要且紧急"><a href="#第一类事务，重要且紧急" class="headerlink" title="第一类事务，重要且紧急"></a>第一类事务，重要且紧急</h2><p>在矩阵中，第一类事务通常既紧迫又重要，需要立即处理，通常被称为“危机”或者“问题”。如果你过分注重第一类事务，它们的范围会变得越来越大，最终占据你全部的时间和精力。</p><p>大部分时间精力都用于处理危机的人（第一类事务）</p><ul><li>压力大</li><li>精疲力尽</li><li>被危机牵着鼻子走</li><li>忙于收拾残局</li></ul><h2 id="第三类事务，紧急不重要"><a href="#第三类事务，紧急不重要" class="headerlink" title="第三类事务，紧急不重要"></a>第三类事务，紧急不重要</h2><p>这些人将时间致力于紧急不重要的第三类事务，却自以为在处理第一类事务。殊不知紧迫之事往往是别人的优先，对别人很重要，对自己却不然。</p><ul><li>急功近利</li><li>被危机牵着鼻子走</li><li>被视为巧言令色</li><li>轻视目标和计划</li><li>认为自己是受害者，缺乏自制力</li><li>人际关系肤浅，甚至破裂</li></ul><h2 id="第四类事务，既不重要也不紧急"><a href="#第四类事务，既不重要也不紧急" class="headerlink" title="第四类事务，既不重要也不紧急"></a>第四类事务，既不重要也不紧急</h2><p>有些不负责任的人，将时间都花在第三和第四类事务上</p><ul><li>完全不负责任</li><li>被炒鱿鱼</li><li>基本生活都需要依赖他人或社会机构</li></ul><h2 id="第二类事务，重要不紧急"><a href="#第二类事务，重要不紧急" class="headerlink" title="第二类事务，重要不紧急"></a>第二类事务，重要不紧急</h2><p>包括建立人际关系、撰写使命宣言、规划长期目标、防患于未然等等。高效能人士避免陷入第三和第四类事务，通过花费更多时间在第二类事务来减少第一类事务的数量。</p><ul><li>愿景，远见</li><li>平衡</li><li>自律</li><li>自制</li><li>很少发生危机</li></ul><h1 id="勇敢说“不”"><a href="#勇敢说“不”" class="headerlink" title="勇敢说“不”"></a>勇敢说“不”</h1><p>若要集中精力于当急的要务，就得排除次要事务的牵绊，此时需要有说“不”的勇气。</p><blockquote><p>我曾聘用一位极有才华又独立自主的专员，有一天有件急事想拜托他。他说：“你要我做什么都可以，不过请先了解目前的状况。”他指着墙壁上的工作计划表，显示超过 20 个计划正在进行，这是我俩早已谈妥的。然后他说：“这件急事至少占去几天时间，你希望我放下或取消哪个计划来空出时间？”</p></blockquote><p>很多人坦陈自己“缺乏自制力”，实际上，这是“确认目标”的功夫还不到家，而且不能由衷接收“事有轻重缓急”的观念，自然容易半途而废。</p><h1 id="集大成的时间管理理论"><a href="#集大成的时间管理理论" class="headerlink" title="集大成的时间管理理论"></a>集大成的时间管理理论</h1><p>第一代的时间管理理论丝毫没有“优先”的概念。固然做完备忘录上的一件事，会带给人成就感，可是这种成就不一定符合人生大目标。因此，所完成的只是必要而非重要的事。</p><p>然而好此道者不在少数，因为阻力最小，痛苦与压力也最少。</p><p>更何况，根据外在要求与规律行事，容易推卸责任。这类人缺乏效率，缺乏自制力与自尊。</p><p>第四代理论强调以原则为重心，配合个人对使命的认知，兼顾重要性与急迫性；强调产出与产能齐头并进，着重第二类事务的完成。</p><h1 id="管理方法六标准"><a href="#管理方法六标准" class="headerlink" title="管理方法六标准"></a>管理方法六标准</h1><ol><li>和谐一致。</li><li>平衡功能。</li><li>围绕中心理想的管理方法。</li><li>以人为本。</li><li>灵活变通。</li><li>便于携带的管理工具。</li></ol><h1 id="个人管理四步骤"><a href="#个人管理四步骤" class="headerlink" title="个人管理四步骤"></a>个人管理四步骤</h1><h2 id="第一步-确认角色"><a href="#第一步-确认角色" class="headerlink" title="第一步 确认角色"></a>第一步 确认角色</h2><p>写出你自己的关键角色，在家庭中、工作中乃至教会和社区事务中的角色。列举自己想要持续投入时间和精力去做的一些事情。</p><h2 id="第二步-选定周目标"><a href="#第二步-选定周目标" class="headerlink" title="第二步 选定周目标"></a>第二步 选定周目标</h2><p>思考下一个周计划中每一个任务栏下你最想做的一两件要事，作为你选定的目标。这些目标中一定要有几个<strong>第二类事务</strong>，根据自己的感觉判断每个角色中哪些事情是比较重要的，并为每个角色确立一个或两个目标。</p><h2 id="第三步-安排进度"><a href="#第三步-安排进度" class="headerlink" title="第三步 安排进度"></a>第三步 安排进度</h2><p>为每一项目标安排具体的实施时间。有些目标需要在工作日完成，有些目标需要在周末完成。确保自己有充分的自由和灵活性以应付突发事件，让你享受到自发的乐趣。你会感觉很踏实，因为你知道自己已经安排好了一周的要务，照顾到了工作生活中的每一个重要领域。</p><h2 id="第四部-每日调整"><a href="#第四部-每日调整" class="headerlink" title="第四部 每日调整"></a>第四部 每日调整</h2><p>根据突发事件、人际关系的意外发展及崭新机会对每天的要务安排进行适当调整。</p><p>在每天早晨审视自己一天的日程安排。</p><h1 id="付诸实践"><a href="#付诸实践" class="headerlink" title="付诸实践"></a>付诸实践</h1><p>诚心正意，对人不可讲效率，效率是对事而言的，对人应当讲<strong>效用</strong>。第四代个人管理理论的特点在于承认人比事更重要。</p><h1 id="第四代时间管理方法的优点"><a href="#第四代时间管理方法的优点" class="headerlink" title="第四代时间管理方法的优点"></a>第四代时间管理方法的优点</h1><p>第四代时间管理方法比前三代更加先进，这种先进体现在五个方面</p><ol><li>以原则为基础，切实地创造出一个核心模式，让你能够在一个更大的范围内分配自己的时间，看清楚什么是真正重要和有效的。</li><li>接受你内心良知的指导，让你有机会更好地安排自己的生活，并且最大限度地同你的价值观保持一致。同时给你自由和变通，让你在牺牲既定日程安排，服从更重要的价值观的时候心平气和，毫不内疚。</li><li>这种方法确认了你的个人使命，包括价值观和长期目标。</li><li>这种方法帮助你明确自己的角色，平衡自己生活中的各个方面。每个星期为每个关键角色确立要达到的目标，并作出具体的日程安排。</li><li>以一个星期为单位计划生活，不必局限于短暂的一天时间。通过审视自己的主要角色而让自己保持清醒，经常想到自己内心深处的价值观。</li></ol><p>有一条主线贯穿这五个方面，那就是将人际关系和效果放在第一位，将时间放在第二位。</p><h1 id="高效能的秘诀——授权"><a href="#高效能的秘诀——授权" class="headerlink" title="高效能的秘诀——授权"></a>高效能的秘诀——授权</h1><p>把责任分配给其他成熟老练的员工，才有余力从事更高层次的活动。授权是事必躬亲与管理之间的最大分野，事必躬亲者凡事不假外求。反之，管理者注重建立制度，然后汇集群力共同完成工作。</p><p>授权可以划分为两种类型：<strong>指令型授权</strong>和<strong>责任型授权</strong>。</p><h2 id="指令型授权"><a href="#指令型授权" class="headerlink" title="指令型授权"></a>指令型授权</h2><p>指令型授权关注重点是<strong>方法</strong>，管理者自己为最后的结果负责。</p><h2 id="责任型授权"><a href="#责任型授权" class="headerlink" title="责任型授权"></a>责任型授权</h2><p>责任型授权的关注重点是<strong>最终结果</strong>，它给人们自由，允许自行选择做事的具体方法，并为最终的结果负责。起初，这种授权方式费时费力，但却十分值得。通过责任型授权，可以将杠杆的支点向右移动，提高杠杆的作用。</p><p>责任型授权要求双方就以下<strong>五个方面</strong>达成清晰、坦诚的共识，并作出承诺。</p><ol><li>预期结果。双方都要明确并且完全理解最终想要的结果。要以“结果”而不是以“方法”为中心。要有具体的日程，明确截止期限。</li><li>指导方针。确认适用的评估标准，避免成为指令型授权。但是一定要有明确的限制性规定。</li><li>可用资源。告诉他们可以使用哪些人力、财务、技术或者组织资源来取得缩预期的成果。</li><li>责任归属。制定业绩标准，并用这些标准来评估他们的成果。制定具体的时间表，说明何时提交业绩报告，何时进行评估。</li><li>明确奖惩。明确地告诉他们评估可能导致的结果，好的和不好的后果都要告诉他们。</li></ol><p>信任是促使人进步的最大动力，因为信任能够让人表现出自己最好的一面。</p><p>授权的大原则不变，权限却因人而异。对不够成熟的人，目标不必订得太高，指示要详尽，并且充分提供资源；监督考核则较频繁，奖惩也更直接。对成熟的人，可分配挑战性高的任务，精简指示，减少监督考核的次数，考评标准则较为抽象。</p><h1 id="付诸行动"><a href="#付诸行动" class="headerlink" title="付诸行动"></a>付诸行动</h1><ol><li>找出一项平时被你忽略的第二类事务。</li><li>画出一个时间管理矩阵，按照百分比将你的时间分配给每一类事务。然后以十五分钟为计时单位连续记录自己三天的活动状况。对照一下自己的计划，看是否有很大的出入。</li><li>将你认为可以授权给他人作的事情列在一张纸上，然后列出你认为可以做这些工作的人选或者通过培训可以胜任的工作人选。思考一下应该如何开始授权程序或者开展培训工作。</li><li>计划你的下周活动，你的计划应当能够体现你的人生目标和主导价值观。并在星期结束的时候进行总结。</li><li>承诺以后每周都制定一个周计划，并规定一个具体的时间专门做这件事情。</li><li>将目前使用的时间管理工具升级为第四代时间管理工具。</li><li>阅读附录二——高效能人士的一天。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;回答两个问题&quot;&gt;&lt;a href=&quot;#回答两个问题&quot; class=&quot;headerlink&quot; title=&quot;回答两个问题&quot;&gt;&lt;/a&gt;回答两个问题&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;在你目前的生活中，有哪些事情能够彻底改观你的个人生活，但是你一直没有去做？&lt;/li&gt;
&lt;li&gt;在
      
    
    </summary>
    
    
      <category term="高效能人士的七个习惯" scheme="https://lilei.pro/tags/%E9%AB%98%E6%95%88%E8%83%BD%E4%BA%BA%E5%A3%AB%E7%9A%84%E4%B8%83%E4%B8%AA%E4%B9%A0%E6%83%AF/"/>
    
  </entry>
  
  <entry>
    <title>《高效能人士的七个习惯》第三部分 公众领域的成功</title>
    <link href="https://lilei.pro/2019/04/07/Seven-Habbits-5/"/>
    <id>https://lilei.pro/2019/04/07/Seven-Habbits-5/</id>
    <published>2019-04-07T03:00:29.000Z</published>
    <updated>2019-06-08T08:41:53.526Z</updated>
    
    <content type="html"><![CDATA[<ul><li>习惯一：积极主动</li><li>习惯二：以终为始</li><li>习惯三：要事第一</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;习惯一：积极主动&lt;/li&gt;
&lt;li&gt;习惯二：以终为始&lt;/li&gt;
&lt;li&gt;习惯三：要事第一&lt;/li&gt;
&lt;/ul&gt;

      
    
    </summary>
    
    
      <category term="高效能人士的七个习惯" scheme="https://lilei.pro/tags/%E9%AB%98%E6%95%88%E8%83%BD%E4%BA%BA%E5%A3%AB%E7%9A%84%E4%B8%83%E4%B8%AA%E4%B9%A0%E6%83%AF/"/>
    
  </entry>
  
  <entry>
    <title>《高效能人士的七个习惯》第四部分 再论由内而外造就自己</title>
    <link href="https://lilei.pro/2019/04/07/Seven-Habbits-11/"/>
    <id>https://lilei.pro/2019/04/07/Seven-Habbits-11/</id>
    <published>2019-04-07T03:00:29.000Z</published>
    <updated>2019-06-08T08:51:39.699Z</updated>
    
    <content type="html"><![CDATA[<h1 id="利用刺激与回应之间的距离"><a href="#利用刺激与回应之间的距离" class="headerlink" title="利用刺激与回应之间的距离"></a>利用刺激与回应之间的距离</h1><p>上帝行事由内而外，尘世行事由外而内；尘世让世人摆脱贫穷，耶稣则先让世人摆脱内心的贫穷，然后由他们自己摆脱贫穷；尘世通过改变环境来造就人，耶稣则通过改变人来造就环境：尘世塑造人的行为，而耶稣改变人的本质。</p><p>刺激与回应之间存在一段距离，成长和幸福的关键就在于我们如何利用这段距离。</p><p>我们用新颖而有趣的方式利用刺激与回应之间的那段距离，思考自己如何变成了今天的自己以及这些过程如何决定了我们的世界观。</p><p>从一开始，我们就极力互相支持、鼓励和体谅，这让我们能够更进一步地探索彼此的内心世界，而我们之间的关系也得到滋养。</p><p>我们逐渐有了两项心照不宣的基本规则。一是“不要刨根问底”：无论哪个人露出了内心最脆弱的一面，另一人都不得追根究底，而是要尽力体谅对方，否则就显得太过咄咄逼人、霸道和刻板。二是在话题过于尖锐或痛苦的时候，我们就要及时打住，晚些时候或者等到第二天再说，直到当事人愿意再次开口。</p><p>我们发现，看似琐碎的小事，往往也源自铭心刻骨的情感经历，如果只看表面，而没有挖掘深层的敏感问题，无异于在践踏对方心中的圣土。</p><p>爱情保鲜的秘诀就是交谈，特别是讨论彼此的感受。</p><h1 id="代际传承"><a href="#代际传承" class="headerlink" title="代际传承"></a>代际传承</h1><p>我们的行为模式会对子女的生活产生难以置信的影响，就好像我们的父母影响了我们一样。他们不仅让我们了解了自己是什么样子的人，而且让我们知道自己通过努力可以成为什么样的人。</p><p>一个关系紧密、几代同堂的大家庭往往有一种超常的力量，能帮人们确认自我。让孩子们在这样的“部落”中找到自己的位置，时时感到被关怀。几代同堂的和睦家庭可能蕴含着最富有成效，回报最高，最令人满意的相互依赖关系，许多人都能感觉到这种关系的重要性。</p><h1 id="成为转型者"><a href="#成为转型者" class="headerlink" title="成为转型者"></a>成为转型者</h1><p>在你的家族中已经延续数代的趋势可以在你这里画一个句号。你是一个转型者，连接着过去和未来，你自身的变化可以影响到后世的许多人。</p><p>真正的变革是由内向外实现的，只是利用性格魅力的技巧，在态度和行为方面做些表面功夫根本不行，一定要从根本上改变那些决定了我们的人格和世界观的思想构造和行为模式才行。</p><p>再次引用艾默生（Emerson）的名言：“在我们的不懈努力下，事情变得可以迎刃而解，这并不是因为任务的性质发生了变化，而是因为我们的能力增强了。”</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;利用刺激与回应之间的距离&quot;&gt;&lt;a href=&quot;#利用刺激与回应之间的距离&quot; class=&quot;headerlink&quot; title=&quot;利用刺激与回应之间的距离&quot;&gt;&lt;/a&gt;利用刺激与回应之间的距离&lt;/h1&gt;&lt;p&gt;上帝行事由内而外，尘世行事由外而内；尘世让世人摆脱贫穷，耶稣
      
    
    </summary>
    
    
      <category term="高效能人士的七个习惯" scheme="https://lilei.pro/tags/%E9%AB%98%E6%95%88%E8%83%BD%E4%BA%BA%E5%A3%AB%E7%9A%84%E4%B8%83%E4%B8%AA%E4%B9%A0%E6%83%AF/"/>
    
  </entry>
  
  <entry>
    <title>《高效能人士的七个习惯》第四部分 自我提升和完善</title>
    <link href="https://lilei.pro/2019/04/07/Seven-Habbits-9/"/>
    <id>https://lilei.pro/2019/04/07/Seven-Habbits-9/</id>
    <published>2019-04-07T03:00:29.000Z</published>
    <updated>2019-06-08T08:49:30.912Z</updated>
    
    <content type="html"><![CDATA[<ul><li>习惯七：不断更新</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;习惯七：不断更新&lt;/li&gt;
&lt;/ul&gt;

      
    
    </summary>
    
    
      <category term="高效能人士的七个习惯" scheme="https://lilei.pro/tags/%E9%AB%98%E6%95%88%E8%83%BD%E4%BA%BA%E5%A3%AB%E7%9A%84%E4%B8%83%E4%B8%AA%E4%B9%A0%E6%83%AF/"/>
    
  </entry>
  
  <entry>
    <title>《高效能人士的七个习惯》第四部分 习惯七 不断更新——平衡的自我更新的原则</title>
    <link href="https://lilei.pro/2019/04/07/Seven-Habbits-10/"/>
    <id>https://lilei.pro/2019/04/07/Seven-Habbits-10/</id>
    <published>2019-04-07T03:00:29.000Z</published>
    <updated>2019-06-08T08:50:16.213Z</updated>
    
    <content type="html"><![CDATA[<p>人生最值得的投资就是锻炼自己，因为生活与服务人群都得靠自己，这是最真贵的工具。</p><p>工作本身并不能带来经济上的安全感，具备良好的思考、学习、创造与适应能力，才能立于不败之地。拥有财富，并不代表经济独立，拥有创造财富的能力才真正可靠。</p><h1 id="自我提升和完善的四个层面"><a href="#自我提升和完善的四个层面" class="headerlink" title="自我提升和完善的四个层面"></a>自我提升和完善的四个层面</h1><p>习惯七就是个人产能。它保护并优化你所拥有的最重要的资产——你自己。它从四个层面更新你的天性，那就是：身体、精神、智力、社会/情感。</p><h2 id="身体层面"><a href="#身体层面" class="headerlink" title="身体层面"></a>身体层面</h2><p>身体层面指有效呵护我们的身体——健康饮食，充足休息以及定期锻炼。</p><p>锻炼属于第二类事务，但是由于不具紧迫性，所以很少人能坚持不懈，结果终有一天我们会发现自己陷入了第一类事务，不得不面对健康问题和危机，而原因正是之前对锻炼的忽视。</p><p>锻炼的所有好处几乎都产生于最后阶段。我想增强力量，就必须等到肌肉纤维撕裂，神经纤维感到疼痛才行，因为这时候自然机制才会予以过度补偿，纤维在 48 小时后会变得更加坚韧。</p><p>情感“肌肉”（比如耐心）也是一样。当对耐心的磨练超越过去的记录时，情感纤维就会断裂，自然机制就会予以过度补偿，下一次纤维就会更加坚韧。</p><p>刚开始时也许你并不喜欢锻炼，甚至还很厌恶，但是一定要积极一点，坚持下去。在你执行慢跑计划期间，即使清晨有雨，也不能放弃。而是要想太好了！下雨了！我可以在锻炼身体的同时磨练意志。</p><h2 id="精神层面"><a href="#精神层面" class="headerlink" title="精神层面"></a>精神层面</h2><p>精神层面的更新为你指引人生的方向，与习惯二密切相关。</p><p>有些人是通过欣赏优秀的文学或音乐作品来实现精神层面的更新，还有些人是通过与自然交流来达到同样目的。我的做法是每天认真阅读和思考《圣经》。</p><p>大自然会赐福给哪些沉浸在自然中的人。当你远离城市的喧嚣与混乱，尽情享受过大自然的和谐与韵律，再回到城市时会感到耳目一新，在一段时间内，没有什么能够干扰你或让你惊慌失措，直到外界的喧嚣混乱再次侵蚀到你内心的静谧和安详。</p><p>个人的使命宣言至关重要。一旦深刻理解了生活的中心和目标，我们就可以不断反思，持之以恒，在更新精神层面的过程中，就可以抱着坚定的信念，构想并实践每一天的活动。</p><p>仔细聆听，设法回头，检讨动机，把忧愁埋进沙子里。</p><h2 id="智力层面"><a href="#智力层面" class="headerlink" title="智力层面"></a>智力层面</h2><p>我们大多数人的智力发育和学习习惯都源自正规教育。但是，一旦脱离了学校的训导，许多人的头脑就会退化：不再认真读书，不再探索身外的新世界，不再用心思考，也不再写作，至少是不再重视写作，不再把它当作考验我们准确、扼要表达自己的能力的方式。相反，我们把时间花在了看电视（或者是网上冲浪）中。</p><p>电视的确让生活变得丰富多彩，但是，还有很多电视节目完全是在浪费我们的时间和头脑。</p><p>养成定期阅读优秀文学作品的习惯是拓展思维的最佳方式。可以从每个月读一本书开始，然后每两周读一本书，接着是每周读一本书。</p><p>磨砺心志的另一种有效方式是写作。如果能够在写信的时候与他人深入交流思想、感受和理念，而不是肤浅地停留在事物表面，也有助于我们提高思考、推理和获取他人理解的能力。</p><h2 id="社会-情感层面"><a href="#社会-情感层面" class="headerlink" title="社会/情感层面"></a>社会/情感层面</h2><p>社会/情感层面的更新并不像其它层面的更新那样需要花费大量的时间，我们可以在与他人的日常交往中完成这项工作，但练习还是必要的。习惯四、五、六是你在练习当中需要时时关注的地方，这些习惯成功的关键不是智力问题，而是情感问题，与我们个人的安全感密切相关。</p><h1 id="改变他人"><a href="#改变他人" class="headerlink" title="改变他人"></a>改变他人</h1><p>后来，当她又要恢复到旧有的行为模式时，生命垂危的骑士把她叫到病床前，唱起了那曲动人的《无法实现的梦》（The Impossible Dream）。他凝视她的双眼，轻声说：“永远不要忘记，你是杜尔西内娅”。</p><p>我们可以选择清晰而真实地反映出他人的形象，肯定他们的积极性和责任心，帮助他们改变行为模式，成为讲原则，懂判断，独立自主，有价值的个体。知足心态让我们意识到，反映他人的正面形象并不会贬低我们自己，而会使我们更强大，因为它增加了我们与其他积极主动者有效交往的机会。</p><p>歌德（Goethe）说：“以一个人的现有表现期许之，他不会有所长进。以他的潜能和应有成就期许之，他定能不负所望。”</p><h1 id="平衡更新"><a href="#平衡更新" class="headerlink" title="平衡更新"></a>平衡更新</h1><p>自我提升和完善的过程必须包括天性中的所有四个层面：身体、精神、智力、社会/情感。</p><p>企业力争上游的道理也是这样。谋利固然是企业经营的基本目的，但并非企业存在的唯一目的。犹如生命少不了食物，但人绝非为吃而活。</p><h1 id="更新中的统合综效"><a href="#更新中的统合综效" class="headerlink" title="更新中的统合综效"></a>更新中的统合综效</h1><p>人生的四个层面休戚相关：身体健全有助于心智发展，精神提升有益于人际关系的圆满。因此，平衡才能产生最佳的整体效果。</p><p>身体层面的自我更新等同于强化个人愿景（习惯一）。它帮助我们增强积极性、自我意识和独立意志，让我们知道自己是自由的，不需要被动地承受他人的行为后果，这也许是锻炼身体的最大好处。</p><p>精神层面的更新等同于强化自我领导（习惯二）。它帮助我们更好地按照想象和良知（而不只是回忆）行事，深入理解个人思维和价值观，确定核心的正确原则，明确自己在生活中的独特使命，改变思维和行为模式，以及坚持正确原则并利用个人的资源优势。</p><p>精神层面的更新让个人的生活变得更加丰富。</p><p>智力层面的更新等同于强化自我管理（习惯三）。它帮助你在做计划的时候确定第二类事务的重要活动，优先能够有效利用时间和精力的目标与活动，然后围绕这些组织并展开活动。不断接受教育帮助你巩固知识基础，增加选择范围。稳定的经济基础并非来自于工作，而是来自于<strong>个人的产能</strong>（思考、学习、创造、调整）。<strong>真正的经济独立指的不是家财万贯，而是拥有创造财富的能力</strong>，这是内在的。</p><p>“每天的个人领域的成功”（每天至少用一个小时实现身体、精神和智力层面的更新）是培养七个习惯的关键，完全在个人的影响圈范围内。</p><h1 id="螺旋式上升"><a href="#螺旋式上升" class="headerlink" title="螺旋式上升"></a>螺旋式上升</h1><p>良知是人类独特的天赋，帮助我们判断自己是否背离了正确的原则，然后引导我们向这些原则靠拢。</p><p>垃圾食品和缺乏锻炼会毁掉运动员的健康。同样，淫秽、粗俗或色情的东西会使我们的灵魂陷入黑暗之中，削弱我们的判断能力，不再关心是非对错（自然而神圣的良知），只在乎自己是否会被揭发“社会良知”。</p><p>哈马舍尔德（Dag Hammarskjold，前联合国秘书长）说过：把玩内心兽性的人，早晚会变成真正的野兽；整天弄虚作假的人，终将失去获得真理的权利；暴虐成性的人，头脑的判断力会日益减退。如果真的要保持花园整洁，就不能让杂草有立足之地。</p><p>要实现这个良性循环，就必须学习、坚持、实践，并沿着螺旋式上升的路线不断提高实践的层次。如果以为做到一项就已足够，完全是在自欺欺人。</p><h1 id="付诸行动"><a href="#付诸行动" class="headerlink" title="付诸行动"></a>付诸行动</h1><ol><li>写出有助于保持良好的身体状态，符合你的生活方式，能让你从中得到乐趣的活动清单。</li><li>挑选其中一项活动，把它列为你下周的个人活动的目标。</li><li>到一周结束时，评估自己的表现，如果没有实现目标，就思考一下原因，是因为你更看重一种更高尚的价值观，还是因为你未能遵循自己的价值观行事。</li><li>列出在精神和智力层面自我提升和完善的活动清单，在社会、情感层面希望改善的人际关系以及能依靠公众成功来提高效能的具体领域。在每个层面中挑选一项活动，列为本周目标，付诸实施并加以评估。</li><li>坚持每周写下所有四个层面的具体“磨刀”行动，付诸实施并评估自己的表现和效果。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;人生最值得的投资就是锻炼自己，因为生活与服务人群都得靠自己，这是最真贵的工具。&lt;/p&gt;
&lt;p&gt;工作本身并不能带来经济上的安全感，具备良好的思考、学习、创造与适应能力，才能立于不败之地。拥有财富，并不代表经济独立，拥有创造财富的能力才真正可靠。&lt;/p&gt;
&lt;h1 id=&quot;自我提
      
    
    </summary>
    
    
      <category term="高效能人士的七个习惯" scheme="https://lilei.pro/tags/%E9%AB%98%E6%95%88%E8%83%BD%E4%BA%BA%E5%A3%AB%E7%9A%84%E4%B8%83%E4%B8%AA%E4%B9%A0%E6%83%AF/"/>
    
  </entry>
  
</feed>
